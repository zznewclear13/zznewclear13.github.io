<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>屏幕空间反射 | ZZNEWCLEAR13</title>
<meta name=keywords content="Screen Space Reflection,Screen Space"><meta name=description content="目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/screen-space-reflection/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/screen-space-reflection/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="屏幕空间反射"><meta property="og:description" content="目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/screen-space-reflection/"><meta property="og:image" content="https://zznewclear13.github.io/posts/screen-space-reflection/posts/images/ScreenSpaceReflection_64.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-09T17:00:00+08:00"><meta property="article:modified_time" content="2024-03-09T17:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/screen-space-reflection/posts/images/ScreenSpaceReflection_64.png"><meta name=twitter:title content="屏幕空间反射"><meta name=twitter:description content="目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"屏幕空间反射","item":"https://zznewclear13.github.io/posts/screen-space-reflection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"屏幕空间反射","name":"屏幕空间反射","description":"目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色.","keywords":["Screen Space Reflection","Screen Space"],"articleBody":"屏幕空间反射 屏幕空间反射也是一个老生常谈的效果了，但正如本博客的宗旨，要从千篇一律中脱颖而出，这篇文章也将介绍与众不同的，至少我在网上没有见到过的计算屏幕空间反射的方法。\n网上有很多很多的屏幕空间反射的教程，绝大部分的流程是这样的：计算世界空间的反射方向，使用一个大部分情况下是统一的步长在世界空间中步进，对于每一次步进，计算标准化设备空间的坐标，将当前的深度和深度图进行比较，如果在深度图之后，认为发生了交叉，采样当前点的颜色值并返回。这种方法能看到很多很多看上去非常完美的反射效果，但几乎没有人会提及所需要的步进次数，因为它往往高得惊人，关于这点我们后续还会谈到。而且对于不同远近的物体，想要达到比较好反射效果，其需要的步长往往是不同的，也很少有人去做这方面的思考。稍好一些的会考虑在交叉之后做几次二分法查找，这样能够让一段一段的反射后的颜色带上下颠倒，使画面看上去更加连贯，后面也能看到对比。还有一些会考虑在计算标准化设备空间的坐标后，根据坐标和[-1, 1]之间的大小关系，提前结束步进或是对反射的颜色和环境反射进行插值。目前看来最好的步进方法，是预先计算Hierarchical ZBuffer，通过对更高LOD步进的方法，使用更少的步进次数达到同样的步进效果，但是Hierarchical ZBuffer并不是一个所有项目都能有的特性。\n网上能找到的最有用的教程，是Morgan McGuire写的Screen Space Ray Tracing。在他的这篇文章中也提到了为什么在世界空间中步进是不好的，因为世界空间步进的位置在经过透视变换后，很有可能在屏幕空间中没多大变化，也就导致了世界空间步进需要更多的次数来达到较好的反射效果。在这篇文章中展示了一个非常好的方法，计算裁剪空间和屏幕空间的起点和终点的坐标，通过对裁剪空间的z、裁剪空间的1/w、屏幕空间的xy进行线性插值，省去了每一次步进所需要的矩阵运算，十分值得使用。\n本文的目标是，在一个Shader中使用尽量少的步进次数得到正确的反射颜色。随机采样、模糊、菲涅尔效应之类的不在本文的考虑范围之内。本文仅考虑Windows平台下DX11的Shader，这样能省去很多的平台适配的代码，使用的Unity版本是Unity 2022.3.21f1，在文章的最后会附上最终的Shader代码。\n反射的计算 参数的选择 计算反射基本上只需要三个参数，一个是Max Distance，只考虑距离反射点一定范围内的物体带来的反射，一个是Step Count，更多的步进次数带来更精确的反射，同时也增加性能消耗，最后一个是Thickness Params，对于一个物体，默认其厚度为depth * _Thickness.y + _Thickness.x，这样当射线经过物体背面时不会被认为发生了交叉。\n深度比较 步进的时候比较什么深度也是一个值得思考的问题。将步进的深度记为rayDepth，将采样获得的深度记为sampleDepth，一个很简单的想法在标准化设备空间进行比较，因为直接采样深度图就能获取到标准化设备空间的深度值，当rayDepth \u003c sampleDepth的时候，射线和场景发生了交叉。又或是对实际的深度进行比较，这样能够指定一个厚度，当深度的差大于厚度时，认为射线从场景物体的后面穿了过去并没有发生交叉，当rayDepth \u003e sampleDepth \u0026\u0026 rayDepth \u003c sampleDepth + thickness的时候，射线和场景发生了交叉。此外裁剪空间的Z分量也能用来判断是否发生了交叉，这里不再赘述。深度图的采样方式则应该使用PointClamp的方式，使用线性插值的话在一前一后的两个面的边缘很可能会被认为发生了交叉，导致画面上有不少的小点，除非另外有一张标记物体边缘的贴图可以用来排除掉这部分的交叉点。\n光线步进 伪代码很简单：\n记k0、k1分别是步进起点和终点的裁剪空间坐标的w分量的倒数。 记q0、q1分别是步进起点和终点的裁剪空间坐标的xyz分量。 记p0、p1分别是步进起点和终点的标准化设备空间坐标的xy分量。 记w是一个在(0, 1)之间按照1.0f/_StepCount递增的变量。 对每一次步进，更新w的值，并对上面的三组分量线性插值得到k、q、p。 使用q.z * k获得rayDepth，使用p采样深度图获得sampleDepth。 如果rayDepth \u003c sampleDepth，射线和场景发生了交叉，跳出循环，返回p。 使用p采样颜色图，获得反射的颜色。 效果是这样的（步进次数为32次）: 看上去非常糟糕，最明显的是拉扯的效果。它主要有两个产生的原因：一是我们并没有使用厚度来判断射线是否从物体的背面穿过，这导致了悬空的物体下方会有很长的拉扯；二是我们并没有对超出屏幕范围的位置进行限制，这导致了我们使用屏幕外的坐标采样深度图但返回了Clamp之后的深度值。\n厚度检测 为了解决上面的厚度问题，我们新增了一个方法由于判断步进的位置是否在物体后面。我们需要使用的是距离相机的线性深度linearRayDepth和linearSampleDepth。上文说到我们使用linearSampleDepth * _Thickness.y + _Thickness.x来作为一个场景中一个物体的厚度，我们只需要判断(linearRayDepth-linearSampleDepth-_Thickness.x) / linearSampleDepth和_Thickness.y的大小即可，如果前式大于后式，则表明射线从物体后面穿过。\nfloat getThicknessDiff(float diff, float linearSampleDepth, float2 thicknessParams) { return (diff - thicknessParams.x) / linearSampleDepth; } 伪代码变成了：\n如果rayZ \u003c sampleZ且thicknessDiff \u003c _Thickness.y，射线和场景发生了交叉，跳出循环，返回p。 效果是这样的（步进次数为32次）: 视锥体裁剪 对于超出屏幕空间的p1，会带来两个坏处，一是采样了超出范围的深度图得到了错误的深度值，二是减少了有效采样的次数。因此我们可以考虑将p1限制在屏幕空间内，这里新增了一个方法用于将步进终点限制在视锥体内部。我们记nf为近裁剪面深度和远裁剪面深度值（正数），s为视锥体的左右和上下的斜率（正数），s在数值上为float2(asepect * tan(fovy * 0.5f), tan(fovy * 0.5f)，注意为了方便计算，这里from和to的z分量为正数。下面的算法应该还能优化一些，不过已经够用了。\n事实上我还写了一个Shadertoy用来演示，使用鼠标进行交互：\nFrustum Clip 2D\n#define INFINITY 1e10 float3 frustumClip(float3 from, float3 to, float2 nf, float2 s) { float3 dir = to - from; float3 signDir = sign(dir); float nfSlab = signDir.z * (nf.y - nf.x) * 0.5f + (nf.y + nf.x) * 0.5f; float lenZ = (nfSlab - from.z) / dir.z; if (dir.z == 0.0f) lenZ = INFINITY; float2 ss = sign(dir.xy - s * dir.z) * s; float2 denom = ss * dir.z - dir.xy; float2 lenXY = (from.xy - ss * from.z) / denom; if (lenXY.x \u003c 0.0f || denom.x == 0.0f) lenXY.x = INFINITY; if (lenXY.y \u003c 0.0f || denom.y == 0.0f) lenXY.y = INFINITY; float len = min(min(1.0f, lenZ), min(lenXY.x, lenXY.y)); float3 clippedVS = from + dir * len; return clippedVS; } 伪代码变成了：\n将步进终点进行视锥体裁剪得到clippedPosVS，再进一步得到终点的裁剪空间坐标endCS。 效果是这样的（步进次数为32次）: 看上去有那么点反射的意思了，视锥体剔除一定程度地减少了每次步进的像素数，因此补上了一部分的窟窿。但是反射的颜色扭扭曲曲的。\n二分法查找 我们上一步获得的p虽然确保了在物体内部，但距离实际的交点仍有一部分的距离，我们可以通过二分法查找减少两者之间的误差。为了进行二分法查找，我们需要记录最后两次步进的w值，记为w1和w2（w1 \u003e w2）。每次二分法时，取w = 0.5f * (w1 + w2)，如果检测到相交，则w1 = w，否则w2 = w，进入下一个循环。\n伪代码变成了：\n将步进终点进行视锥体裁剪得到clippedPosVS，再进一步得到终点的裁剪空间坐标endCS。 记k0、k1分别是步进起点和终点的裁剪空间坐标的w分量的倒数。 记q0、q1分别是步进起点和终点的裁剪空间坐标的xyz分量。 记p0、p1分别是步进起点和终点的标准化设备空间坐标的xy分量。 记w1是一个在(0, 1)之间按照1.0f/_StepCount递增的变量，w1和w2初始化为0。 对每一次步进，w2=w1，更新w1的值，并对上面的三组分量线性插值得到k、q、p。 使用q.z * k获得rayDepth，使用p采样深度图获得sampleDepth。 如果rayZ \u003c sampleZ且thicknessDiff \u003c _Thickness.y，射线和场景发生了交叉，跳出循环。 记w为w1和w2的平均数，按照567判断是否发生交叉，根据是否交叉更新w1或w2，直到结束二分法循环。 使用p采样颜色图，获得反射的颜色。 效果是这样的（步进次数为32次，二分法查找次数为5次）: 可以看到反射的效果看上去不那么扭扭曲曲的了（左下角尤为明显），但是两段颜色之间仍然有着空隙，这来自于我们的厚度测试，它将潜在的交叉排除在外了。\n潜在的交叉 为了计算潜在的交叉，我们需要回顾之前做厚度测试的代码。当射线穿过物体后面时，如果前一次射线还在物体前方，我们可以记录两者之间的差距thicknessDiff，如果它的值小于最小的差距minThicknessDiff，我们将其作为潜在的交叉，更新minThicknessDiff，并记录当前的w1和w2用于后续的二分法查找。在二分法时我们需要判断发生了交叉还是发生了潜在的交叉，如果发生了交叉，我们执行原有的代码，如果发生的是潜在的交叉，在二分法时我们也需要记录thicknessDiff，找到最小的小于_Thickness.y的thicknessDiff，使用当前w插值得到的p采样获得最终的颜色。\n伪代码变成了：\n将步进终点进行视锥体裁剪得到clippedPosVS，再进一步得到终点的裁剪空间坐标endCS。 记k0、k1分别是步进起点和终点的裁剪空间坐标的w分量的倒数。 记q0、q1分别是步进起点和终点的裁剪空间坐标的xyz分量。 记p0、p1分别是步进起点和终点的标准化设备空间坐标的xy分量。 记w1是一个在(0, 1)之间按照1.0f/_StepCount递增的变量，w1和w2初始化为0。 对每一次步进，w2=w1，更新w1的值，并对上面的三组分量线性插值得到k、q、p。 使用q.z * k获得rayDepth，使用p采样深度图获得sampleDepth。 如果rayZ \u003c sampleZ且thicknessDiff \u003c _Thickness.y，射线和场景发生了交叉，跳出循环。 否则如果rayZ \u003c sampleZ且thicknessDiff \u003e _Thickness.y且上一次射线在物体前方，将thicknessDiff和最小值进行比较，如果更小则更新最小值，记录此时的w1和w2，记为发生了潜在的交叉，继续循环。 如果发生了交叉，记w为w1和w2的平均数，按照567判断是否发生交叉，根据是否交叉更新w1或w2，直到结束二分法循环。 否则如果发生了潜在交叉，按照567判断是否发生交叉，使用最小的thicknessDiff更新p。 使用p采样颜色图，获得反射的颜色。 效果是这样的（步进次数为32次，二分法查找次数为5次）: 下图是步进次数为64次，二分法查找5次的效果： 最终的代码 /* // Copyright (c) 2024 zznewclear@gmail.com // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE // SOFTWARE. */ Shader \"zznewclear13/SSRShader\" { Properties { [Toggle(USE_POTENTIAL_HIT)] _UsePotentialHit (\"Use Potential Hit\", Float) = 1.0 [Toggle(USE_FRUSTUM_CLIP)] _UseFrustumClip (\"Use Frustum Clip\", Float) = 1.0 [Toggle(USE_BINARY_SEARCH)] _UseBinarySearch (\"Use Binary Search\", Float) = 1.0 [Toggle(USE_THICKNESS)] _UseThickness (\"Use Thickness\", Float) = 1.0 _MaxDistance (\"Max Distance\", Range(0.1, 100.0)) = 15.0 [int] _StepCount (\"Step Count\", Float) = 32 _ThicknessParams (\"Thickness Params\", Vector) = (0.1, 0.02, 0.0, 0.0) } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" #pragma shader_feature _ USE_POTENTIAL_HIT #pragma shader_feature _ USE_FRUSTUM_CLIP #pragma shader_feature _ USE_BINARY_SEARCH #pragma shader_feature _ USE_THICKNESS #define INFINITY 1e10 #define DEPTH_SAMPLER sampler_PointClamp Texture2D _CameraOpaqueTexture; Texture2D _CameraDepthTexture; CBUFFER_START(UnityPerMaterial) float _MaxDistance; int _StepCount; float2 _ThicknessParams; CBUFFER_END struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float3 positionWS : TEXCOORD0; float3 normalWS : TEXCOORD1; float2 uv : TEXCOORD2; float3 viewWS : TEXCOORD3; }; Varyings vert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS); output.positionCS = vpi.positionCS; output.positionWS = vpi.positionWS; output.normalWS = vni.normalWS; output.uv = input.texcoord; output.viewWS = GetCameraPositionWS() - vpi.positionWS; return output; } float3 frustumClip(float3 from, float3 to, float2 nf, float2 s) { float3 dir = to - from; float3 signDir = sign(dir); float nfSlab = signDir.z * (nf.y - nf.x) * 0.5f + (nf.y + nf.x) * 0.5f; float lenZ = (nfSlab - from.z) / dir.z; if (dir.z == 0.0f) lenZ = INFINITY; float2 ss = sign(dir.xy - s * dir.z) * s; float2 denom = ss * dir.z - dir.xy; float2 lenXY = (from.xy - ss * from.z) / denom; if (lenXY.x \u003c 0.0f || denom.x == 0.0f) lenXY.x = INFINITY; if (lenXY.y \u003c 0.0f || denom.y == 0.0f) lenXY.y = INFINITY; float len = min(min(1.0f, lenZ), min(lenXY.x, lenXY.y)); float3 clippedVS = from + dir * len; return clippedVS; } float getThicknessDiff(float diff, float linearSampleDepth, float2 thicknessParams) { return (diff - thicknessParams.x) / linearSampleDepth; } float4 frag(Varyings input) : SV_TARGET { float3 positionWS = input.positionWS; float3 normalWS = normalize(input.normalWS); float3 viewWS = normalize(input.viewWS); float3 reflWS = reflect(-viewWS, normalWS); float3 env = GlossyEnvironmentReflection(reflWS, 0.0f, 1.0f); float3 color = env; float3 originWS = positionWS; float3 endWS = positionWS + reflWS * _MaxDistance; #if defined(USE_FRUSTUM_CLIP) float3 originVS = mul(UNITY_MATRIX_V, float4(originWS, 1.0f)).xyz; float3 endVS = mul(UNITY_MATRIX_V, float4(endWS, 1.0f)).xyz; float3 flipZ = float3(1.0f, 1.0f, -1.0f); float3 clippedVS = frustumClip(originVS * flipZ, endVS * flipZ, _ProjectionParams.yz, float2(1.0f, -1.0f) / UNITY_MATRIX_P._m00_m11); clippedVS *= flipZ; float4 originCS = mul(UNITY_MATRIX_VP, float4(originWS, 1.0f)); float4 endCS = mul(UNITY_MATRIX_P, float4(clippedVS, 1.0f)); #else float4 originCS = mul(UNITY_MATRIX_VP, float4(originWS, 1.0f)); float4 endCS = mul(UNITY_MATRIX_VP, float4(endWS, 1.0f)); #endif float k0 = 1.0f / originCS.w; float k1 = 1.0f / endCS.w; float3 q0 = originCS.xyz; float3 q1 = endCS.xyz; float2 p0 = originCS.xy * float2(1.0f, -1.0f) * k0 * 0.5f + 0.5f; float2 p1 = endCS.xy * float2(1.0f, -1.0f) * k1 * 0.5f + 0.5f; #if defined(USE_POTENTIAL_HIT) float w1 = 0.0f; float w2 = 0.0f; bool hit = false; bool lastHit = false; bool potentialHit = false; float2 potentialW12 = float2(0.0f, 0.0f); float minPotentialHitPos = INFINITY; [unroll(64)] for (int i=0; i\u003c_StepCount; ++i) { w2 = w1; w1 += 1.0f / float(_StepCount); float3 q = lerp(q0, q1, w1); float2 p = lerp(p0, p1, w1); float k = lerp(k0, k1, w1); float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r; float linearSampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams); float linearRayDepth = LinearEyeDepth(q.z * k, _ZBufferParams); float hitDiff = linearRayDepth - linearSampleDepth; float thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams); if (hitDiff \u003e 0.0f) { if (thicknessDiff \u003c _ThicknessParams.y) { hit = true; break; } else if(!lastHit) { potentialHit = true; if (minPotentialHitPos \u003e thicknessDiff) { minPotentialHitPos = thicknessDiff; potentialW12 = float2(w1, w2); } } } lastHit = hitDiff \u003e 0.0f; } #else float w1 = 0.0f; float w2 = 0.0f; bool hit = false; [unroll(64)] for (int i=0; i\u003c_StepCount; ++i) { w2 = w1; w1 += 1.0f / float(_StepCount); float3 q = lerp(q0, q1, w1); float2 p = lerp(p0, p1, w1); float k = lerp(k0, k1, w1); float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r; #if defined(USE_THICKNESS) float linearSampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams); float linearRayDepth = LinearEyeDepth(q.z * k, _ZBufferParams); float hitDiff = linearRayDepth - linearSampleDepth; float thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams); if (hitDiff \u003e 0.0f \u0026\u0026 thicknessDiff \u003c _ThicknessParams.y) { hit = true; break; } #else if (q.z * k \u003c sampleDepth) { hit = true; break; } #endif } #endif #if defined(USE_POTENTIAL_HIT) if (hit || potentialHit) { if (!hit) { w1 = potentialW12.x; w2 = potentialW12.y; } bool realHit = false; float2 hitPos; float minThicknessDiff = _ThicknessParams.y; [unroll(5)] for (int i=0; i\u003c5; ++i) { float w = 0.5f * (w1 + w2); float3 q = lerp(q0, q1, w); float2 p = lerp(p0, p1, w); float k = lerp(k0, k1, w); float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r; float linearSampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams); float linearRayDepth = LinearEyeDepth(q.z * k, _ZBufferParams); float hitDiff = linearRayDepth - linearSampleDepth; if (hitDiff \u003e 0.0f) { w1 = w; if (hit) hitPos = p; } else { w2 = w; } float thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams); float absThicknessDiff = abs(thicknessDiff); if (!hit \u0026\u0026 absThicknessDiff \u003c minThicknessDiff) { realHit = true; minThicknessDiff = thicknessDiff; hitPos = p; } } if (hit || realHit) color = _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb * 0.3f; } #elif defined(USE_BINARY_SEARCH) if (hit) { float2 hitPos; [unroll(5)] for (int i=0; i\u003c5; ++i) { float w = 0.5f * (w1 + w2); float3 q = lerp(q0, q1, w); float2 p = lerp(p0, p1, w); float k = lerp(k0, k1, w); float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r; if (q.z * k \u003c sampleDepth) { w1 = w; hitPos = p; } else { w2 = w; } } color = _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb * 0.3f; } #else if (hit) { float2 hitPos = lerp(p0, p1, w1); color = _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb * 0.3f; } #endif return float4(color, 1.0f); } ENDHLSL SubShader { Tags { \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" } LOD 100 Pass { HLSLPROGRAM #pragma vertex vert #pragma fragment frag ENDHLSL } } } 优化的方向 目前还有一个值得优化的方向，就是根据p0和p1之间的像素距离控制总体的步进次数，总不至于对10个像素步进64次吧。不过这个就比较简单了，留给有空的人来做吧。至于随机采样、模糊和菲涅尔，等到真的用到的时候再去考虑吧。\n后记 2024简直就是开幕雷击，各种糟糕的事情接踵而至，有时候会有深深的无力感。可能只有写博客和Shadertoy才能给我带来最强的满足感吧，希望真的有人能从我的博客和Shadertoy中有所收获。本来是打算写一篇Contact Shadow的，但是发现屏幕空间ray marching其实并不是那么一件简单的事情，因此想先写完这个再继续我的Contact Shadow。说实在的我对这篇博客的质量还是比较满意的，打算再写个英文版的去投稿Graphics Programming weekly，拭目以待.gif。\n","wordCount":"1447","inLanguage":"en","image":"https://zznewclear13.github.io/posts/screen-space-reflection/posts/images/ScreenSpaceReflection_64.png","datePublished":"2024-03-09T17:00:00+08:00","dateModified":"2024-03-09T17:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/screen-space-reflection/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">屏幕空间反射</h1><div class=post-description>目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色.</div><div class=post-meta><span title='2024-03-09 17:00:00 +0800 CST'>March 9, 2024</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/screen-space-reflection.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/ScreenSpaceReflection_64.png alt="Screen Space Reflection Cover"><p>Screen Space Reflection Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>屏幕空间反射</div></summary><div class=inner><ul><li><a href=#%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4%e5%8f%8d%e5%b0%84 aria-label=屏幕空间反射>屏幕空间反射</a></li><li><a href=#%e5%8f%8d%e5%b0%84%e7%9a%84%e8%ae%a1%e7%ae%97 aria-label=反射的计算>反射的计算</a><ul><li><a href=#%e5%8f%82%e6%95%b0%e7%9a%84%e9%80%89%e6%8b%a9 aria-label=参数的选择>参数的选择</a></li><li><a href=#%e6%b7%b1%e5%ba%a6%e6%af%94%e8%be%83 aria-label=深度比较>深度比较</a></li><li><a href=#%e5%85%89%e7%ba%bf%e6%ad%a5%e8%bf%9b aria-label=光线步进>光线步进</a></li><li><a href=#%e5%8e%9a%e5%ba%a6%e6%a3%80%e6%b5%8b aria-label=厚度检测>厚度检测</a></li><li><a href=#%e8%a7%86%e9%94%a5%e4%bd%93%e8%a3%81%e5%89%aa aria-label=视锥体裁剪>视锥体裁剪</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%b3%95%e6%9f%a5%e6%89%be aria-label=二分法查找>二分法查找</a></li><li><a href=#%e6%bd%9c%e5%9c%a8%e7%9a%84%e4%ba%a4%e5%8f%89 aria-label=潜在的交叉>潜在的交叉</a></li><li><a href=#%e6%9c%80%e7%bb%88%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=最终的代码>最终的代码</a></li><li><a href=#%e4%bc%98%e5%8c%96%e7%9a%84%e6%96%b9%e5%90%91 aria-label=优化的方向>优化的方向</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=屏幕空间反射>屏幕空间反射<a hidden class=anchor aria-hidden=true href=#屏幕空间反射>#</a></h2><p>屏幕空间反射也是一个老生常谈的效果了，但正如本博客的宗旨，要从千篇一律中脱颖而出，这篇文章也将介绍与众不同的，至少我在网上没有见到过的计算屏幕空间反射的方法。</p><p>网上有很多很多的屏幕空间反射的教程，绝大部分的流程是这样的：计算世界空间的反射方向，使用一个大部分情况下是统一的步长在世界空间中步进，对于每一次步进，计算标准化设备空间的坐标，将当前的深度和深度图进行比较，如果在深度图之后，认为发生了交叉，采样当前点的颜色值并返回。这种方法能看到很多很多看上去非常完美的反射效果，但几乎没有人会提及所需要的步进次数，因为它往往高得惊人，关于这点我们后续还会谈到。而且对于不同远近的物体，想要达到比较好反射效果，其需要的步长往往是不同的，也很少有人去做这方面的思考。稍好一些的会考虑在交叉之后做几次二分法查找，这样能够让一段一段的反射后的颜色带上下颠倒，使画面看上去更加连贯，后面也能看到对比。还有一些会考虑在计算标准化设备空间的坐标后，根据坐标和[-1, 1]之间的大小关系，提前结束步进或是对反射的颜色和环境反射进行插值。目前看来最好的步进方法，是预先计算Hierarchical ZBuffer，通过对更高LOD步进的方法，使用更少的步进次数达到同样的步进效果，但是Hierarchical ZBuffer并不是一个所有项目都能有的特性。</p><p>网上能找到的最有用的教程，是Morgan McGuire写的<a href=http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html>Screen Space Ray Tracing</a>。在他的这篇文章中也提到了为什么在世界空间中步进是不好的，因为世界空间步进的位置在经过透视变换后，很有可能在屏幕空间中没多大变化，也就导致了世界空间步进需要更多的次数来达到较好的反射效果。在这篇文章中展示了一个非常好的方法，计算裁剪空间和屏幕空间的起点和终点的坐标，通过对裁剪空间的z、裁剪空间的1/w、屏幕空间的xy进行线性插值，省去了每一次步进所需要的矩阵运算，十分值得使用。</p><p>本文的目标是，在一个Shader中使用尽量少的步进次数得到正确的反射颜色。随机采样、模糊、菲涅尔效应之类的不在本文的考虑范围之内。本文仅考虑Windows平台下DX11的Shader，这样能省去很多的平台适配的代码，使用的Unity版本是Unity 2022.3.21f1，在文章的最后会附上最终的Shader代码。</p><h2 id=反射的计算>反射的计算<a hidden class=anchor aria-hidden=true href=#反射的计算>#</a></h2><h3 id=参数的选择>参数的选择<a hidden class=anchor aria-hidden=true href=#参数的选择>#</a></h3><p>计算反射基本上只需要三个参数，一个是<code>Max Distance</code>，只考虑距离反射点一定范围内的物体带来的反射，一个是<code>Step Count</code>，更多的步进次数带来更精确的反射，同时也增加性能消耗，最后一个是<code>Thickness Params</code>，对于一个物体，默认其厚度为<code>depth * _Thickness.y + _Thickness.x</code>，这样当射线经过物体背面时不会被认为发生了交叉。</p><h3 id=深度比较>深度比较<a hidden class=anchor aria-hidden=true href=#深度比较>#</a></h3><p>步进的时候比较什么深度也是一个值得思考的问题。将步进的深度记为<code>rayDepth</code>，将采样获得的深度记为<code>sampleDepth</code>，一个很简单的想法在标准化设备空间进行比较，因为直接采样深度图就能获取到标准化设备空间的深度值，当<code>rayDepth &lt; sampleDepth</code>的时候，射线和场景发生了交叉。又或是对实际的深度进行比较，这样能够指定一个厚度，当深度的差大于厚度时，认为射线从场景物体的后面穿了过去并没有发生交叉，当<code>rayDepth > sampleDepth && rayDepth &lt; sampleDepth + thickness</code>的时候，射线和场景发生了交叉。此外裁剪空间的Z分量也能用来判断是否发生了交叉，这里不再赘述。深度图的采样方式则应该使用<code>PointClamp</code>的方式，使用线性插值的话在一前一后的两个面的边缘很可能会被认为发生了交叉，导致画面上有不少的小点，除非另外有一张标记物体边缘的贴图可以用来排除掉这部分的交叉点。</p><h3 id=光线步进>光线步进<a hidden class=anchor aria-hidden=true href=#光线步进>#</a></h3><p>伪代码很简单：</p><blockquote><ol><li>记<code>k0</code>、<code>k1</code>分别是步进起点和终点的裁剪空间坐标的w分量的倒数。</li><li>记<code>q0</code>、<code>q1</code>分别是步进起点和终点的裁剪空间坐标的xyz分量。</li><li>记<code>p0</code>、<code>p1</code>分别是步进起点和终点的标准化设备空间坐标的xy分量。</li><li>记<code>w</code>是一个在(0, 1)之间按照<code>1.0f/_StepCount</code>递增的变量。</li><li>对每一次步进，更新<code>w</code>的值，并对上面的三组分量线性插值得到<code>k</code>、<code>q</code>、<code>p</code>。</li><li>使用<code>q.z * k</code>获得<code>rayDepth</code>，使用<code>p</code>采样深度图获得<code>sampleDepth</code>。</li><li>如果<code>rayDepth &lt; sampleDepth</code>，射线和场景发生了交叉，跳出循环，返回<code>p</code>。</li><li>使用<code>p</code>采样颜色图，获得反射的颜色。</li></ol></blockquote><p>效果是这样的（步进次数为32次）:
<img loading=lazy src=../images/ScreenSpaceReflection_Naive.png#center alt="Screen Space Reflection Naive"></p><p>看上去非常糟糕，最明显的是拉扯的效果。它主要有两个产生的原因：一是我们并没有使用厚度来判断射线是否从物体的背面穿过，这导致了悬空的物体下方会有很长的拉扯；二是我们并没有对超出屏幕范围的位置进行限制，这导致了我们使用屏幕外的坐标采样深度图但返回了Clamp之后的深度值。</p><h3 id=厚度检测>厚度检测<a hidden class=anchor aria-hidden=true href=#厚度检测>#</a></h3><p>为了解决上面的厚度问题，我们新增了一个方法由于判断步进的位置是否在物体后面。我们需要使用的是距离相机的线性深度<code>linearRayDepth</code>和<code>linearSampleDepth</code>。上文说到我们使用<code>linearSampleDepth * _Thickness.y + _Thickness.x</code>来作为一个场景中一个物体的厚度，我们只需要判断<code>(linearRayDepth-linearSampleDepth-_Thickness.x) / linearSampleDepth</code>和<code>_Thickness.y</code>的大小即可，如果前式大于后式，则表明射线从物体后面穿过。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>    <span style=color:#66d9ef>float</span> getThicknessDiff(<span style=color:#66d9ef>float</span> diff, <span style=color:#66d9ef>float</span> linearSampleDepth, <span style=color:#66d9ef>float2</span> thicknessParams)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (diff <span style=color:#f92672>-</span> thicknessParams.x) <span style=color:#f92672>/</span> linearSampleDepth;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>伪代码变成了：</p><blockquote><ol start=7><li>如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff &lt; _Thickness.y</code>，射线和场景发生了交叉，跳出循环，返回<code>p</code>。</li></ol></blockquote><p>效果是这样的（步进次数为32次）:
<img loading=lazy src=../images/ScreenSpaceReflection_ThicknessTest.png#center alt="Screen Space Reflection Thickness Test"></p><h3 id=视锥体裁剪>视锥体裁剪<a hidden class=anchor aria-hidden=true href=#视锥体裁剪>#</a></h3><p>对于超出屏幕空间的<code>p1</code>，会带来两个坏处，一是采样了超出范围的深度图得到了错误的深度值，二是减少了有效采样的次数。因此我们可以考虑将<code>p1</code>限制在屏幕空间内，这里新增了一个方法用于将步进终点限制在视锥体内部。我们记<code>nf</code>为近裁剪面深度和远裁剪面深度值（正数），<code>s</code>为视锥体的左右和上下的斜率（正数），<code>s</code>在数值上为<code>float2(asepect * tan(fovy * 0.5f), tan(fovy * 0.5f)</code>，注意为了方便计算，这里<code>from</code>和<code>to</code>的z分量为正数。下面的算法应该还能优化一些，不过已经够用了。</p><p>事实上我还写了一个Shadertoy用来演示，使用鼠标进行交互：</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/4XfSDB?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Frustum Clip 2D</p></figure><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#define INFINITY 1e10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> frustumClip(<span style=color:#66d9ef>float3</span> from, <span style=color:#66d9ef>float3</span> to, <span style=color:#66d9ef>float2</span> nf, <span style=color:#66d9ef>float2</span> s)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> dir <span style=color:#f92672>=</span> to <span style=color:#f92672>-</span> from;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> signDir <span style=color:#f92672>=</span> sign(dir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> nfSlab <span style=color:#f92672>=</span> signDir.z <span style=color:#f92672>*</span> (nf.y <span style=color:#f92672>-</span> nf.x) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> (nf.y <span style=color:#f92672>+</span> nf.x) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> lenZ <span style=color:#f92672>=</span> (nfSlab <span style=color:#f92672>-</span> from.z) <span style=color:#f92672>/</span> dir.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dir.z <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0f</span>) lenZ <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> ss <span style=color:#f92672>=</span> sign(dir.xy <span style=color:#f92672>-</span> s <span style=color:#f92672>*</span> dir.z) <span style=color:#f92672>*</span> s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> denom <span style=color:#f92672>=</span> ss <span style=color:#f92672>*</span> dir.z <span style=color:#f92672>-</span> dir.xy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> lenXY <span style=color:#f92672>=</span> (from.xy <span style=color:#f92672>-</span> ss <span style=color:#f92672>*</span> from.z) <span style=color:#f92672>/</span> denom;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (lenXY.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>||</span> denom.x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0f</span>) lenXY.x <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (lenXY.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>||</span> denom.y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0f</span>) lenXY.y <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> len <span style=color:#f92672>=</span> min(min(<span style=color:#ae81ff>1.0f</span>, lenZ), min(lenXY.x, lenXY.y));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> clippedVS <span style=color:#f92672>=</span> from <span style=color:#f92672>+</span> dir <span style=color:#f92672>*</span> len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> clippedVS;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>伪代码变成了：</p><blockquote><ol start=0><li>将步进终点进行视锥体裁剪得到<code>clippedPosVS</code>，再进一步得到终点的裁剪空间坐标<code>endCS</code>。</li></ol></blockquote><p>效果是这样的（步进次数为32次）:
<img loading=lazy src=../images/ScreenSpaceReflection_FrustumClip.png#center alt="Screen Space Reflection Frustum Clip"></p><p>看上去有那么点反射的意思了，视锥体剔除一定程度地减少了每次步进的像素数，因此补上了一部分的窟窿。但是反射的颜色扭扭曲曲的。</p><h3 id=二分法查找>二分法查找<a hidden class=anchor aria-hidden=true href=#二分法查找>#</a></h3><p>我们上一步获得的<code>p</code>虽然确保了在物体内部，但距离实际的交点仍有一部分的距离，我们可以通过二分法查找减少两者之间的误差。为了进行二分法查找，我们需要记录最后两次步进的<code>w</code>值，记为<code>w1</code>和<code>w2</code>（<code>w1 > w2</code>）。每次二分法时，取<code>w = 0.5f * (w1 + w2)</code>，如果检测到相交，则<code>w1 = w</code>，否则<code>w2 = w</code>，进入下一个循环。</p><p>伪代码变成了：</p><blockquote><ol start=0><li>将步进终点进行视锥体裁剪得到<code>clippedPosVS</code>，再进一步得到终点的裁剪空间坐标<code>endCS</code>。</li><li>记<code>k0</code>、<code>k1</code>分别是步进起点和终点的裁剪空间坐标的w分量的倒数。</li><li>记<code>q0</code>、<code>q1</code>分别是步进起点和终点的裁剪空间坐标的xyz分量。</li><li>记<code>p0</code>、<code>p1</code>分别是步进起点和终点的标准化设备空间坐标的xy分量。</li><li>记<code>w1</code>是一个在(0, 1)之间按照<code>1.0f/_StepCount</code>递增的变量，<code>w1</code>和<code>w2</code>初始化为0。</li><li>对每一次步进，<code>w2=w1</code>，更新<code>w1</code>的值，并对上面的三组分量线性插值得到<code>k</code>、<code>q</code>、<code>p</code>。</li><li>使用<code>q.z * k</code>获得<code>rayDepth</code>，使用<code>p</code>采样深度图获得<code>sampleDepth</code>。</li><li>如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff &lt; _Thickness.y</code>，射线和场景发生了交叉，跳出循环。</li><li>记<code>w</code>为<code>w1</code>和<code>w2</code>的平均数，按照567判断是否发生交叉，根据是否交叉更新<code>w1</code>或<code>w2</code>，直到结束二分法循环。</li><li>使用<code>p</code>采样颜色图，获得反射的颜色。</li></ol></blockquote><p>效果是这样的（步进次数为32次，二分法查找次数为5次）:
<img loading=lazy src=../images/ScreenSpaceReflection_BinarySearch.png#center alt="Screen Space Reflection Binary Search"></p><p>可以看到反射的效果看上去不那么扭扭曲曲的了（左下角尤为明显），但是两段颜色之间仍然有着空隙，这来自于我们的厚度测试，它将潜在的交叉排除在外了。</p><h3 id=潜在的交叉>潜在的交叉<a hidden class=anchor aria-hidden=true href=#潜在的交叉>#</a></h3><p>为了计算潜在的交叉，我们需要回顾之前做厚度测试的代码。当射线穿过物体后面时，如果前一次射线还在物体前方，我们可以记录两者之间的差距<code>thicknessDiff</code>，如果它的值小于最小的差距<code>minThicknessDiff</code>，我们将其作为潜在的交叉，更新<code>minThicknessDiff</code>，并记录当前的<code>w1</code>和<code>w2</code>用于后续的二分法查找。在二分法时我们需要判断发生了交叉还是发生了潜在的交叉，如果发生了交叉，我们执行原有的代码，如果发生的是潜在的交叉，在二分法时我们也需要记录<code>thicknessDiff</code>，找到最小的小于<code>_Thickness.y</code>的<code>thicknessDiff</code>，使用当前<code>w</code>插值得到的<code>p</code>采样获得最终的颜色。</p><p>伪代码变成了：</p><blockquote><ol start=0><li>将步进终点进行视锥体裁剪得到<code>clippedPosVS</code>，再进一步得到终点的裁剪空间坐标<code>endCS</code>。</li><li>记<code>k0</code>、<code>k1</code>分别是步进起点和终点的裁剪空间坐标的w分量的倒数。</li><li>记<code>q0</code>、<code>q1</code>分别是步进起点和终点的裁剪空间坐标的xyz分量。</li><li>记<code>p0</code>、<code>p1</code>分别是步进起点和终点的标准化设备空间坐标的xy分量。</li><li>记<code>w1</code>是一个在(0, 1)之间按照<code>1.0f/_StepCount</code>递增的变量，<code>w1</code>和<code>w2</code>初始化为0。</li><li>对每一次步进，<code>w2=w1</code>，更新<code>w1</code>的值，并对上面的三组分量线性插值得到<code>k</code>、<code>q</code>、<code>p</code>。</li><li>使用<code>q.z * k</code>获得<code>rayDepth</code>，使用<code>p</code>采样深度图获得<code>sampleDepth</code>。</li><li>如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff &lt; _Thickness.y</code>，射线和场景发生了交叉，跳出循环。</li><li>否则如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff > _Thickness.y</code>且上一次射线在物体前方，将<code>thicknessDiff</code>和最小值进行比较，如果更小则更新最小值，记录此时的<code>w1</code>和<code>w2</code>，记为发生了潜在的交叉，继续循环。</li><li>如果发生了交叉，记<code>w</code>为<code>w1</code>和<code>w2</code>的平均数，按照567判断是否发生交叉，根据是否交叉更新<code>w1</code>或<code>w2</code>，直到结束二分法循环。</li><li>否则如果发生了潜在交叉，按照567判断是否发生交叉，使用最小的<code>thicknessDiff</code>更新<code>p</code>。</li><li>使用<code>p</code>采样颜色图，获得反射的颜色。</li></ol></blockquote><p>效果是这样的（步进次数为32次，二分法查找次数为5次）:
<img loading=lazy src=../images/ScreenSpaceReflection_PotentialHit.png#center alt="Screen Space Reflection Potential Hit">
下图是步进次数为64次，二分法查找5次的效果：
<img loading=lazy src=../images/ScreenSpaceReflection_64.png#center alt="Screen Space Reflection Potential Hit"></p><h3 id=最终的代码>最终的代码<a hidden class=anchor aria-hidden=true href=#最终的代码>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Copyright (c) 2024 zznewclear@gmail.com
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Permission is hereby granted, free of charge, to any person obtaining a copy
</span></span></span><span style=display:flex><span><span style=color:#75715e>// of this software and associated documentation files (the &#34;Software&#34;), to deal
</span></span></span><span style=display:flex><span><span style=color:#75715e>// in the Software without restriction, including without limitation the rights
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
</span></span></span><span style=display:flex><span><span style=color:#75715e>// copies of the Software, and to permit persons to whom the Software is
</span></span></span><span style=display:flex><span><span style=color:#75715e>// furnished to do so, subject to the following conditions:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The above copyright notice and this permission notice shall be included in all
</span></span></span><span style=display:flex><span><span style=color:#75715e>// copies or substantial portions of the Software.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</span></span></span><span style=display:flex><span><span style=color:#75715e>// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
</span></span></span><span style=display:flex><span><span style=color:#75715e>// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</span></span></span><span style=display:flex><span><span style=color:#75715e>// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
</span></span></span><span style=display:flex><span><span style=color:#75715e>// SOFTWARE.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/SSRShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        [Toggle(USE_POTENTIAL_HIT)] _UsePotentialHit (<span style=color:#e6db74>&#34;Use Potential Hit&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>        [Toggle(USE_FRUSTUM_CLIP)] _UseFrustumClip (<span style=color:#e6db74>&#34;Use Frustum Clip&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>        [Toggle(USE_BINARY_SEARCH)] _UseBinarySearch (<span style=color:#e6db74>&#34;Use Binary Search&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>        [Toggle(USE_THICKNESS)] _UseThickness (<span style=color:#e6db74>&#34;Use Thickness&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        _MaxDistance (<span style=color:#e6db74>&#34;Max Distance&#34;</span>, Range(<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>100.0</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>15.0</span>
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>int</span>] _StepCount (<span style=color:#e6db74>&#34;Step Count&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>        _ThicknessParams (<span style=color:#e6db74>&#34;Thickness Params&#34;</span>, Vector) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.02</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature _ USE_POTENTIAL_HIT
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature _ USE_FRUSTUM_CLIP
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature _ USE_BINARY_SEARCH
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature _ USE_THICKNESS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>define INFINITY <span style=color:#ae81ff>1</span>e10
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>define DEPTH_SAMPLER sampler_PointClamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Texture2D</span> _CameraOpaqueTexture;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Texture2D</span> _CameraDepthTexture;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _MaxDistance;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> _StepCount;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> _ThicknessParams;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS   <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalWS     <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewWS       <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.positionWS <span style=color:#f92672>=</span> vpi.positionWS;
</span></span><span style=display:flex><span>        output.normalWS <span style=color:#f92672>=</span> vni.normalWS;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        output.viewWS <span style=color:#f92672>=</span> GetCameraPositionWS() <span style=color:#f92672>-</span> vpi.positionWS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> frustumClip(<span style=color:#66d9ef>float3</span> from, <span style=color:#66d9ef>float3</span> to, <span style=color:#66d9ef>float2</span> nf, <span style=color:#66d9ef>float2</span> s)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> dir <span style=color:#f92672>=</span> to <span style=color:#f92672>-</span> from;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> signDir <span style=color:#f92672>=</span> sign(dir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> nfSlab <span style=color:#f92672>=</span> signDir.z <span style=color:#f92672>*</span> (nf.y <span style=color:#f92672>-</span> nf.x) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> (nf.y <span style=color:#f92672>+</span> nf.x) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lenZ <span style=color:#f92672>=</span> (nfSlab <span style=color:#f92672>-</span> from.z) <span style=color:#f92672>/</span> dir.z;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dir.z <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0f</span>) lenZ <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> ss <span style=color:#f92672>=</span> sign(dir.xy <span style=color:#f92672>-</span> s <span style=color:#f92672>*</span> dir.z) <span style=color:#f92672>*</span> s;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> denom <span style=color:#f92672>=</span> ss <span style=color:#f92672>*</span> dir.z <span style=color:#f92672>-</span> dir.xy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> lenXY <span style=color:#f92672>=</span> (from.xy <span style=color:#f92672>-</span> ss <span style=color:#f92672>*</span> from.z) <span style=color:#f92672>/</span> denom;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lenXY.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>||</span> denom.x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0f</span>) lenXY.x <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lenXY.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>||</span> denom.y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0f</span>) lenXY.y <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> len <span style=color:#f92672>=</span> min(min(<span style=color:#ae81ff>1.0f</span>, lenZ), min(lenXY.x, lenXY.y));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> clippedVS <span style=color:#f92672>=</span> from <span style=color:#f92672>+</span> dir <span style=color:#f92672>*</span> len;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> clippedVS;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> getThicknessDiff(<span style=color:#66d9ef>float</span> diff, <span style=color:#66d9ef>float</span> linearSampleDepth, <span style=color:#66d9ef>float2</span> thicknessParams)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (diff <span style=color:#f92672>-</span> thicknessParams.x) <span style=color:#f92672>/</span> linearSampleDepth;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS <span style=color:#f92672>=</span> input.positionWS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalWS <span style=color:#f92672>=</span> normalize(input.normalWS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewWS <span style=color:#f92672>=</span> normalize(input.viewWS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> reflWS <span style=color:#f92672>=</span> reflect(<span style=color:#f92672>-</span>viewWS, normalWS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> env <span style=color:#f92672>=</span> GlossyEnvironmentReflection(reflWS, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> env;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> originWS <span style=color:#f92672>=</span> positionWS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> endWS <span style=color:#f92672>=</span> positionWS <span style=color:#f92672>+</span> reflWS <span style=color:#f92672>*</span> _MaxDistance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(USE_FRUSTUM_CLIP)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> originVS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_V, <span style=color:#66d9ef>float4</span>(originWS, <span style=color:#ae81ff>1.0f</span>)).xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> endVS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_V, <span style=color:#66d9ef>float4</span>(endWS, <span style=color:#ae81ff>1.0f</span>)).xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> flipZ <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> clippedVS <span style=color:#f92672>=</span> frustumClip(originVS <span style=color:#f92672>*</span> flipZ, endVS <span style=color:#f92672>*</span> flipZ, _ProjectionParams.yz, <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> UNITY_MATRIX_P._m00_m11);
</span></span><span style=display:flex><span>        clippedVS <span style=color:#f92672>*=</span> flipZ;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> originCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(originWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> endCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_P, <span style=color:#66d9ef>float4</span>(clippedVS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> originCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(originWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> endCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(endWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> k0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> originCS.w;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> k1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> endCS.w;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> q0 <span style=color:#f92672>=</span> originCS.xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> q1 <span style=color:#f92672>=</span> endCS.xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p0 <span style=color:#f92672>=</span> originCS.xy <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>*</span> k0 <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p1 <span style=color:#f92672>=</span> endCS.xy <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>*</span> k1 <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(USE_POTENTIAL_HIT)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> w1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> w2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> hit <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> lastHit <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> potentialHit <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> potentialW12 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> minPotentialHitPos <span style=color:#f92672>=</span> INFINITY;
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>64</span>)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>_StepCount; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            w2 <span style=color:#f92672>=</span> w1;
</span></span><span style=display:flex><span>            w1 <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> <span style=color:#66d9ef>float</span>(_StepCount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> q <span style=color:#f92672>=</span> lerp(q0, q1, w1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> p <span style=color:#f92672>=</span> lerp(p0, p1, w1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> k <span style=color:#f92672>=</span> lerp(k0, k1, w1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> sampleDepth <span style=color:#f92672>=</span> _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> linearSampleDepth <span style=color:#f92672>=</span> LinearEyeDepth(sampleDepth, _ZBufferParams);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> linearRayDepth <span style=color:#f92672>=</span> LinearEyeDepth(q.z <span style=color:#f92672>*</span> k, _ZBufferParams);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> hitDiff <span style=color:#f92672>=</span> linearRayDepth <span style=color:#f92672>-</span> linearSampleDepth;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> thicknessDiff <span style=color:#f92672>=</span> getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (hitDiff <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0f</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (thicknessDiff <span style=color:#f92672>&lt;</span> _ThicknessParams.y)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    hit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>lastHit)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    potentialHit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (minPotentialHitPos <span style=color:#f92672>&gt;</span> thicknessDiff)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        minPotentialHitPos <span style=color:#f92672>=</span> thicknessDiff;
</span></span><span style=display:flex><span>                        potentialW12 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(w1, w2);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            lastHit <span style=color:#f92672>=</span> hitDiff <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> w1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> w2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> hit <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>64</span>)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>_StepCount; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            w2 <span style=color:#f92672>=</span> w1;
</span></span><span style=display:flex><span>            w1 <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> <span style=color:#66d9ef>float</span>(_StepCount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> q <span style=color:#f92672>=</span> lerp(q0, q1, w1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> p <span style=color:#f92672>=</span> lerp(p0, p1, w1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> k <span style=color:#f92672>=</span> lerp(k0, k1, w1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> sampleDepth <span style=color:#f92672>=</span> _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(USE_THICKNESS)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> linearSampleDepth <span style=color:#f92672>=</span> LinearEyeDepth(sampleDepth, _ZBufferParams);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> linearRayDepth <span style=color:#f92672>=</span> LinearEyeDepth(q.z <span style=color:#f92672>*</span> k, _ZBufferParams);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> hitDiff <span style=color:#f92672>=</span> linearRayDepth <span style=color:#f92672>-</span> linearSampleDepth;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> thicknessDiff <span style=color:#f92672>=</span> getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (hitDiff <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>&amp;&amp;</span> thicknessDiff <span style=color:#f92672>&lt;</span> _ThicknessParams.y)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                hit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }       
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (q.z <span style=color:#f92672>*</span> k <span style=color:#f92672>&lt;</span> sampleDepth)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                hit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(USE_POTENTIAL_HIT)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hit <span style=color:#f92672>||</span> potentialHit)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hit)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                w1 <span style=color:#f92672>=</span> potentialW12.x;
</span></span><span style=display:flex><span>                w2 <span style=color:#f92672>=</span> potentialW12.y;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bool</span> realHit <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> hitPos;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> minThicknessDiff <span style=color:#f92672>=</span> _ThicknessParams.y;
</span></span><span style=display:flex><span>            [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>5</span>)]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> w <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> (w1 <span style=color:#f92672>+</span> w2);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> q <span style=color:#f92672>=</span> lerp(q0, q1, w);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> p <span style=color:#f92672>=</span> lerp(p0, p1, w);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> k <span style=color:#f92672>=</span> lerp(k0, k1, w);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleDepth <span style=color:#f92672>=</span> _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> linearSampleDepth <span style=color:#f92672>=</span> LinearEyeDepth(sampleDepth, _ZBufferParams);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> linearRayDepth <span style=color:#f92672>=</span> LinearEyeDepth(q.z <span style=color:#f92672>*</span> k, _ZBufferParams);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> hitDiff <span style=color:#f92672>=</span> linearRayDepth <span style=color:#f92672>-</span> linearSampleDepth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (hitDiff <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0f</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    w1 <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (hit) hitPos <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    w2 <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> thicknessDiff <span style=color:#f92672>=</span> getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> absThicknessDiff <span style=color:#f92672>=</span> abs(thicknessDiff);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hit <span style=color:#f92672>&amp;&amp;</span> absThicknessDiff <span style=color:#f92672>&lt;</span> minThicknessDiff) 
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    realHit <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    minThicknessDiff <span style=color:#f92672>=</span> thicknessDiff;
</span></span><span style=display:flex><span>                    hitPos <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (hit <span style=color:#f92672>||</span> realHit) color <span style=color:#f92672>=</span> _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.3f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#elif defined(USE_BINARY_SEARCH)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hit)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> hitPos;
</span></span><span style=display:flex><span>            [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>5</span>)]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> w <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> (w1 <span style=color:#f92672>+</span> w2);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> q <span style=color:#f92672>=</span> lerp(q0, q1, w);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> p <span style=color:#f92672>=</span> lerp(p0, p1, w);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> k <span style=color:#f92672>=</span> lerp(k0, k1, w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleDepth <span style=color:#f92672>=</span> _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (q.z <span style=color:#f92672>*</span> k <span style=color:#f92672>&lt;</span> sampleDepth)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    w1 <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>                    hitPos <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    w2 <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            color <span style=color:#f92672>=</span> _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.3f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hit)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> hitPos <span style=color:#f92672>=</span> lerp(p0, p1, w1);
</span></span><span style=display:flex><span>            color <span style=color:#f92672>=</span> _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.3f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> }
</span></span><span style=display:flex><span>        LOD <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=优化的方向>优化的方向<a hidden class=anchor aria-hidden=true href=#优化的方向>#</a></h3><p>目前还有一个值得优化的方向，就是根据<code>p0</code>和<code>p1</code>之间的像素距离控制总体的步进次数，总不至于对10个像素步进64次吧。不过这个就比较简单了，留给有空的人来做吧。至于随机采样、模糊和菲涅尔，等到真的用到的时候再去考虑吧。</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>2024简直就是开幕雷击，各种糟糕的事情接踵而至，有时候会有深深的无力感。可能只有写博客和Shadertoy才能给我带来最强的满足感吧，希望真的有人能从我的博客和Shadertoy中有所收获。本来是打算写一篇Contact Shadow的，但是发现屏幕空间ray marching其实并不是那么一件简单的事情，因此想先写完这个再继续我的Contact Shadow。说实在的我对这篇博客的质量还是比较满意的，打算再写个英文版的去投稿Graphics Programming weekly，拭目以待.gif。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/screen-space-reflection/>Screen Space Reflection</a></li><li><a href=https://zznewclear13.github.io/tags/screen-space/>Screen Space</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/screen-space-reflection-en/><span class=title>« Prev</span><br><span>Screen Space Reflection</span>
</a><a class=next href=https://zznewclear13.github.io/posts/unity-high-quality-bloom/><span class=title>Next »</span><br><span>Unity的高质量的Bloom效果</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>