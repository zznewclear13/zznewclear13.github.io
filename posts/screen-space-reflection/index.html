<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>屏幕空间反射 | ZZNEWCLEAR13</title><meta name=keywords content="Screen Space Reflection,Screen Space"><meta name=description content="目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/screen-space-reflection/><link crossorigin=anonymous href=/assets/css/stylesheet.min.05062af87031756c80e5d65f0cc75e37e589bbf77383569463393b1f73d94f87.css integrity="sha256-BQYq+HAxdWyA5dZfDMdeN+WJu/dzg1aUYzk7H3PZT4c=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="屏幕空间反射"><meta property="og:description" content="目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/screen-space-reflection/"><meta property="og:image" content="https://zznewclear13.github.io/posts/screen-space-reflection/posts/images/ScreenSpaceReflection_64.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-09T17:00:00+08:00"><meta property="article:modified_time" content="2024-03-09T17:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/screen-space-reflection/posts/images/ScreenSpaceReflection_64.png"><meta name=twitter:title content="屏幕空间反射"><meta name=twitter:description content="目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"屏幕空间反射","item":"https://zznewclear13.github.io/posts/screen-space-reflection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"屏幕空间反射","name":"屏幕空间反射","description":"目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色.","keywords":["Screen Space Reflection","Screen Space"],"articleBody":"屏幕空间反射 屏幕空间反射也是一个老生常谈的效果了，但正如本博客的宗旨，要从千篇一律中脱颖而出，这篇文章也将介绍与众不同的，至少我在网上没有见到过的计算屏幕空间反射的方法。\n网上有很多很多的屏幕空间反射的教程，绝大部分的流程是这样的：计算世界空间的反射方向，使用一个大部分情况下是统一的步长在世界空间中步进，对于每一次步进，计算标准化设备空间的坐标，将当前的深度和深度图进行比较，如果在深度图之后，认为发生了交叉，采样当前点的颜色值并返回。这种方法能看到很多很多看上去非常完美的反射效果，但几乎没有人会提及所需要的步进次数，因为它往往高得惊人，关于这点我们后续还会谈到。而且对于不同远近的物体，想要达到比较好反射效果，其需要的步长往往是不同的，也很少有人去做这方面的思考。稍好一些的会考虑在交叉之后做几次二分法查找，这样能够让一段一段的反射后的颜色带上下颠倒，使画面看上去更加连贯，后面也能看到对比。还有一些会考虑在计算标准化设备空间的坐标后，根据坐标和[-1, 1]之间的大小关系，提前结束步进或是对反射的颜色和环境反射进行插值。目前看来最好的步进方法，是预先计算Hierarchical ZBuffer，通过对更高LOD步进的方法，使用更少的步进次数达到同样的步进效果，但是Hierarchical ZBuffer并不是一个所有项目都能有的特性。\n网上能找到的最有用的教程，是Morgan McGuire写的Screen Space Ray Tracing。在他的这篇文章中也提到了为什么在世界空间中步进是不好的，因为世界空间步进的位置在经过透视变换后，很有可能在屏幕空间中没多大变化，也就导致了世界空间步进需要更多的次数来达到较好的反射效果。在这篇文章中展示了一个非常好的方法，计算裁剪空间和屏幕空间的起点和终点的坐标，通过对裁剪空间的z、裁剪空间的1/w、屏幕空间的xy进行线性插值，省去了每一次步进所需要的矩阵运算，十分值得使用。\n本文的目标是，在一个Shader中使用尽量少的步进次数得到正确的反射颜色。随机采样、模糊、菲涅尔效应之类的不在本文的考虑范围之内。本文仅考虑Windows平台下DX11的Shader，这样能省去很多的平台适配的代码，使用的Unity版本是Unity 2022.3.21f1，在文章的最后会附上最终的Shader代码。\n反射的计算 参数的选择 计算反射基本上只需要三个参数，一个是Max Distance，只考虑距离反射点一定范围内的物体带来的反射，一个是Step Count，更多的步进次数带来更精确的反射，同时也增加性能消耗，最后一个是Thickness Params，对于一个物体，默认其厚度为depth * _Thickness.y + _Thickness.x，这样当射线经过物体背面时不会被认为发生了交叉。\n深度比较 步进的时候比较什么深度也是一个值得思考的问题。将步进的深度记为rayDepth，将采样获得的深度记为sampleDepth，一个很简单的想法在标准化设备空间进行比较，因为直接采样深度图就能获取到标准化设备空间的深度值，当rayDepth 的时候，射线和场景发生了交叉。又或是对实际的深度进行比较，这样能够指定一个厚度，当深度的差大于厚度时，认为射线从场景物体的后面穿了过去并没有发生交叉，当rayDepth  sampleDepth \u0026\u0026 rayDepth 的时候，射线和场景发生了交叉。此外裁剪空间的Z分量也能用来判断是否发生了交叉，这里不再赘述。深度图的采样方式则应该使用PointClamp的方式，使用线性插值的话在一前一后的两个面的边缘很可能会被认为发生了交叉，导致画面上有不少的小点，除非另外有一张标记物体边缘的贴图可以用来排除掉这部分的交叉点。\n光线步进 伪代码很简单：\n  记k0、k1分别是步进起点和终点的裁剪空间坐标的w分量的倒数。 记q0、q1分别是步进起点和终点的裁剪空间坐标的xyz分量。 记p0、p1分别是步进起点和终点的标准化设备空间坐标的xy分量。 记w是一个在(0, 1)之间按照1.0f/_StepCount递增的变量。 对每一次步进，更新w的值，并对上面的三组分量线性插值得到k、q、p。 使用q.z * k获得rayDepth，使用p采样深度图获得sampleDepth。 如果rayDepth ，射线和场景发生了交叉，跳出循环，返回p。 使用p采样颜色图，获得反射的颜色。   效果是这样的（步进次数为32次）: 看上去非常糟糕，最明显的是拉扯的效果。它主要有两个产生的原因：一是我们并没有使用厚度来判断射线是否从物体的背面穿过，这导致了悬空的物体下方会有很长的拉扯；二是我们并没有对超出屏幕范围的位置进行限制，这导致了我们使用屏幕外的坐标采样深度图但返回了Clamp之后的深度值。\n厚度检测 为了解决上面的厚度问题，我们新增了一个方法由于判断步进的位置是否在物体后面。我们需要使用的是距离相机的线性深度linearRayDepth和linearSampleDepth。上文说到我们使用linearSampleDepth * _Thickness.y + _Thickness.x来作为一个场景中一个物体的厚度，我们只需要判断(linearRayDepth-linearSampleDepth-_Thickness.x) / linearSampleDepth和_Thickness.y的大小即可，如果前式大于后式，则表明射线从物体后面穿过。\nfloat getThicknessDiff(float diff, float linearSampleDepth, float2 thicknessParams)\r{\rreturn (diff - thicknessParams.x) / linearSampleDepth;\r}\r伪代码变成了：\n 如果rayZ 且thicknessDiff ，射线和场景发生了交叉，跳出循环，返回p。   效果是这样的（步进次数为32次）: 视锥体裁剪 对于超出屏幕空间的p1，会带来两个坏处，一是采样了超出范围的深度图得到了错误的深度值，二是减少了有效采样的次数。因此我们可以考虑将p1限制在屏幕空间内，这里新增了一个方法用于将步进终点限制在视锥体内部。我们记nf为近裁剪面深度和远裁剪面深度值（正数），s为视锥体上下和左右的斜率（正数），s在数值上为float2(asepect * tan(fovy * 0.5f), tan(fovy * 0.5f)，注意为了方便计算，这里from和to的z分量为正数。下面的算法应该还能优化一些，不过已经够用了。\n事实上我还写了一个Shadertoy用来演示，使用鼠标进行交互：\n\rFrustum Clip 2D\n\r#define INFINITY 1e10\rfloat3 frustumClip(float3 from, float3 to, float2 nf, float2 s)\r{\rfloat3 dir = to - from;\rfloat3 signDir = sign(dir);\rfloat nfSlab = signDir.z * (nf.y - nf.x) * 0.5f + (nf.y + nf.x) * 0.5f;\rfloat lenZ = (nfSlab - from.z) / dir.z;\rif (dir.z == 0.0f) lenZ = INFINITY;\rfloat2 ss = sign(dir.xy - s * dir.z) * s;\rfloat2 denom = ss * dir.z - dir.xy;\rfloat2 lenXY = (from.xy - ss * from.z) / denom;\rif (lenXY.x 伪代码变成了：\n 将步进终点进行视锥体裁剪得到clippedPosVS，再进一步得到终点的裁剪空间坐标endCS。   效果是这样的（步进次数为32次）: 看上去有那么点反射的意思了，视锥体剔除一定程度地减少了每次步进的像素数，因此补上了一部分的窟窿。但是反射的颜色扭扭曲曲的。\n二分法查找 我们上一步获得的p虽然确保了在物体内部，但距离实际的交点仍有一部分的距离，我们可以通过二分法查找减少两者之间的误差。为了进行二分法查找，我们需要记录最后两次步进的w值，记为w1和w2（w1  w2）。每次二分法时，取w = 0.5f * (w1 + w2)，如果检测到相交，则w1 = w，否则w2 = w，进入下一个循环。\n伪代码变成了：\n 将步进终点进行视锥体裁剪得到clippedPosVS，再进一步得到终点的裁剪空间坐标endCS。 记k0、k1分别是步进起点和终点的裁剪空间坐标的w分量的倒数。 记q0、q1分别是步进起点和终点的裁剪空间坐标的xyz分量。 记p0、p1分别是步进起点和终点的标准化设备空间坐标的xy分量。 记w1是一个在(0, 1)之间按照1.0f/_StepCount递增的变量，w1和w2初始化为0。 对每一次步进，w2=w1，更新w1的值，并对上面的三组分量线性插值得到k、q、p。 使用q.z * k获得rayDepth，使用p采样深度图获得sampleDepth。 如果rayZ 且thicknessDiff ，射线和场景发生了交叉，跳出循环。 记w为w1和w2的平均数，按照567判断是否发生交叉，根据是否交叉更新w1或w2，直到结束二分法循环。 使用p采样颜色图，获得反射的颜色。   效果是这样的（步进次数为32次，二分法查找次数为5次）: 可以看到反射的效果看上去不那么扭扭曲曲的了（左下角尤为明显），但是两段颜色之间仍然有着空隙，这来自于我们的厚度测试，它将潜在的交叉排除在外了。\n潜在的交叉 为了计算潜在的交叉，我们需要回顾之前做厚度测试的代码。当射线穿过物体后面时，如果前一次射线还在物体前方，我们可以记录两者之间的差距thicknessDiff，如果它的值小于最小的差距minThicknessDiff，我们将其作为潜在的交叉，更新minThicknessDiff，并记录当前的w1和w2用于后续的二分法查找。在二分法时我们需要判断发生了交叉还是发生了潜在的交叉，如果发生了交叉，我们执行原有的代码，如果发生的是潜在的交叉，在二分法时我们也需要记录thicknessDiff，找到最小的小于_Thickness.y的thicknessDiff，使用当前w插值得到的p采样获得最终的颜色。\n伪代码变成了：\n 将步进终点进行视锥体裁剪得到clippedPosVS，再进一步得到终点的裁剪空间坐标endCS。 记k0、k1分别是步进起点和终点的裁剪空间坐标的w分量的倒数。 记q0、q1分别是步进起点和终点的裁剪空间坐标的xyz分量。 记p0、p1分别是步进起点和终点的标准化设备空间坐标的xy分量。 记w1是一个在(0, 1)之间按照1.0f/_StepCount递增的变量，w1和w2初始化为0。 对每一次步进，w2=w1，更新w1的值，并对上面的三组分量线性插值得到k、q、p。 使用q.z * k获得rayDepth，使用p采样深度图获得sampleDepth。 如果rayZ 且thicknessDiff ，射线和场景发生了交叉，跳出循环。 否则如果rayZ 且thicknessDiff  _Thickness.y且上一次射线在物体前方，将thicknessDiff和最小值进行比较，如果更小则更新最小值，记录此时的w1和w2，记为发生了潜在的交叉，继续循环。 如果发生了交叉，记w为w1和w2的平均数，按照567判断是否发生交叉，根据是否交叉更新w1或w2，直到结束二分法循环。 否则如果发生了潜在交叉，按照567判断是否发生交叉，使用最小的thicknessDiff更新p。 使用p采样颜色图，获得反射的颜色。   效果是这样的（步进次数为32次，二分法查找次数为5次）: 下图是步进次数为64次，二分法查找5次的效果： 最终的代码 /*\r// Copyright (c) 2024 zznewclear@gmail.com\r// // Permission is hereby granted, free of charge, to any person obtaining a copy\r// of this software and associated documentation files (the \"Software\"), to deal\r// in the Software without restriction, including without limitation the rights\r// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r// copies of the Software, and to permit persons to whom the Software is\r// furnished to do so, subject to the following conditions:\r// // The above copyright notice and this permission notice shall be included in all\r// copies or substantial portions of the Software.\r// // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r// SOFTWARE.\r*/\rShader \"zznewclear13/SSRShader\"\r{\rProperties\r{\r[Toggle(USE_POTENTIAL_HIT)] _UsePotentialHit (\"Use Potential Hit\", Float) = 1.0\r[Toggle(USE_FRUSTUM_CLIP)] _UseFrustumClip (\"Use Frustum Clip\", Float) = 1.0\r[Toggle(USE_BINARY_SEARCH)] _UseBinarySearch (\"Use Binary Search\", Float) = 1.0\r[Toggle(USE_THICKNESS)] _UseThickness (\"Use Thickness\", Float) = 1.0\r_MaxDistance (\"Max Distance\", Range(0.1, 100.0)) = 15.0\r[int] _StepCount (\"Step Count\", Float) = 32\r_ThicknessParams (\"Thickness Params\", Vector) = (0.1, 0.02, 0.0, 0.0)\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\r#pragma shader_feature _ USE_POTENTIAL_HIT\r#pragma shader_feature _ USE_FRUSTUM_CLIP\r#pragma shader_feature _ USE_BINARY_SEARCH\r#pragma shader_feature _ USE_THICKNESS\r#define INFINITY 1e10\r#define DEPTH_SAMPLER sampler_PointClamp\rTexture2D _CameraOpaqueTexture;\rTexture2D _CameraDepthTexture;\rCBUFFER_START(UnityPerMaterial)\rfloat _MaxDistance;\rint _StepCount;\rfloat2 _ThicknessParams;\rCBUFFER_END\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat3 positionWS : TEXCOORD0;\rfloat3 normalWS : TEXCOORD1;\rfloat2 uv : TEXCOORD2;\rfloat3 viewWS : TEXCOORD3;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS);\routput.positionCS = vpi.positionCS;\routput.positionWS = vpi.positionWS;\routput.normalWS = vni.normalWS;\routput.uv = input.texcoord;\routput.viewWS = GetCameraPositionWS() - vpi.positionWS;\rreturn output;\r}\rfloat3 frustumClip(float3 from, float3 to, float2 nf, float2 s)\r{\rfloat3 dir = to - from;\rfloat3 signDir = sign(dir);\rfloat nfSlab = signDir.z * (nf.y - nf.x) * 0.5f + (nf.y + nf.x) * 0.5f;\rfloat lenZ = (nfSlab - from.z) / dir.z;\rif (dir.z == 0.0f) lenZ = INFINITY;\rfloat2 ss = sign(dir.xy - s * dir.z) * s;\rfloat2 denom = ss * dir.z - dir.xy;\rfloat2 lenXY = (from.xy - ss * from.z) / denom;\rif (lenXY.x 0.0f)\r{\rif (thicknessDiff thicknessDiff)\r{\rminPotentialHitPos = thicknessDiff;\rpotentialW12 = float2(w1, w2);\r}\r}\r}\rlastHit = hitDiff  0.0f;\r}\r#else\rfloat w1 = 0.0f;\rfloat w2 = 0.0f;\rbool hit = false;\r[unroll(64)]\rfor (int i=0; i0.0f \u0026\u0026 thicknessDiff 0.0f)\r{\rw1 = w;\rif (hit) hitPos = p;\r}\relse\r{\rw2 = w;\r}\rfloat thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);\rfloat absThicknessDiff = abs(thicknessDiff);\rif (!hit \u0026\u0026 absThicknessDiff 优化的方向 目前还有一个值得优化的方向，就是根据p0和p1之间的像素距离控制总体的步进次数，总不至于对10个像素步进64次吧。不过这个就比较简单了，留给有空的人来做吧。至于随机采样、模糊和菲涅尔，等到真的用到的时候再去考虑吧。\n后记 2024简直就是开幕雷击，各种糟糕的事情接踵而至，有时候会有深深的无力感。可能只有写博客和Shadertoy才能给我带来最强的满足感吧，希望真的有人能从我的博客和Shadertoy中有所收获。本来是打算写一篇Contact Shadow的，但是发现屏幕空间ray marching其实并不是那么一件简单的事情，因此想先写完这个再继续我的Contact Shadow。说实在的我对这篇博客的质量还是比较满意的，打算再写个英文版的去投稿Graphics Programming weekly，拭目以待.gif。\n","wordCount":"1447","inLanguage":"en","image":"https://zznewclear13.github.io/posts/screen-space-reflection/posts/images/ScreenSpaceReflection_64.png","datePublished":"2024-03-09T17:00:00+08:00","dateModified":"2024-03-09T17:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/screen-space-reflection/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>屏幕空间反射</h1><div class=post-description>目标是在一个Shader中使用尽量少的步进次数得到正确的反射颜色.</div><div class=post-meta>March 9, 2024&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/screen-space-reflection.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/ScreenSpaceReflection_64.png alt="Screen Space Reflection Cover"><p>Screen Space Reflection Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>屏幕空间反射</div></summary><div class=inner><ul><li><a href=#%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4%e5%8f%8d%e5%b0%84 aria-label=屏幕空间反射>屏幕空间反射</a></li><li><a href=#%e5%8f%8d%e5%b0%84%e7%9a%84%e8%ae%a1%e7%ae%97 aria-label=反射的计算>反射的计算</a><ul><li><a href=#%e5%8f%82%e6%95%b0%e7%9a%84%e9%80%89%e6%8b%a9 aria-label=参数的选择>参数的选择</a></li><li><a href=#%e6%b7%b1%e5%ba%a6%e6%af%94%e8%be%83 aria-label=深度比较>深度比较</a></li><li><a href=#%e5%85%89%e7%ba%bf%e6%ad%a5%e8%bf%9b aria-label=光线步进>光线步进</a></li><li><a href=#%e5%8e%9a%e5%ba%a6%e6%a3%80%e6%b5%8b aria-label=厚度检测>厚度检测</a></li><li><a href=#%e8%a7%86%e9%94%a5%e4%bd%93%e8%a3%81%e5%89%aa aria-label=视锥体裁剪>视锥体裁剪</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%b3%95%e6%9f%a5%e6%89%be aria-label=二分法查找>二分法查找</a></li><li><a href=#%e6%bd%9c%e5%9c%a8%e7%9a%84%e4%ba%a4%e5%8f%89 aria-label=潜在的交叉>潜在的交叉</a></li><li><a href=#%e6%9c%80%e7%bb%88%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=最终的代码>最终的代码</a></li><li><a href=#%e4%bc%98%e5%8c%96%e7%9a%84%e6%96%b9%e5%90%91 aria-label=优化的方向>优化的方向</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=屏幕空间反射>屏幕空间反射<a hidden class=anchor aria-hidden=true href=#屏幕空间反射>#</a></h2><p>屏幕空间反射也是一个老生常谈的效果了，但正如本博客的宗旨，要从千篇一律中脱颖而出，这篇文章也将介绍与众不同的，至少我在网上没有见到过的计算屏幕空间反射的方法。</p><p>网上有很多很多的屏幕空间反射的教程，绝大部分的流程是这样的：计算世界空间的反射方向，使用一个大部分情况下是统一的步长在世界空间中步进，对于每一次步进，计算标准化设备空间的坐标，将当前的深度和深度图进行比较，如果在深度图之后，认为发生了交叉，采样当前点的颜色值并返回。这种方法能看到很多很多看上去非常完美的反射效果，但几乎没有人会提及所需要的步进次数，因为它往往高得惊人，关于这点我们后续还会谈到。而且对于不同远近的物体，想要达到比较好反射效果，其需要的步长往往是不同的，也很少有人去做这方面的思考。稍好一些的会考虑在交叉之后做几次二分法查找，这样能够让一段一段的反射后的颜色带上下颠倒，使画面看上去更加连贯，后面也能看到对比。还有一些会考虑在计算标准化设备空间的坐标后，根据坐标和[-1, 1]之间的大小关系，提前结束步进或是对反射的颜色和环境反射进行插值。目前看来最好的步进方法，是预先计算Hierarchical ZBuffer，通过对更高LOD步进的方法，使用更少的步进次数达到同样的步进效果，但是Hierarchical ZBuffer并不是一个所有项目都能有的特性。</p><p>网上能找到的最有用的教程，是Morgan McGuire写的<a href=http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html>Screen Space Ray Tracing</a>。在他的这篇文章中也提到了为什么在世界空间中步进是不好的，因为世界空间步进的位置在经过透视变换后，很有可能在屏幕空间中没多大变化，也就导致了世界空间步进需要更多的次数来达到较好的反射效果。在这篇文章中展示了一个非常好的方法，计算裁剪空间和屏幕空间的起点和终点的坐标，通过对裁剪空间的z、裁剪空间的1/w、屏幕空间的xy进行线性插值，省去了每一次步进所需要的矩阵运算，十分值得使用。</p><p>本文的目标是，在一个Shader中使用尽量少的步进次数得到正确的反射颜色。随机采样、模糊、菲涅尔效应之类的不在本文的考虑范围之内。本文仅考虑Windows平台下DX11的Shader，这样能省去很多的平台适配的代码，使用的Unity版本是Unity 2022.3.21f1，在文章的最后会附上最终的Shader代码。</p><h2 id=反射的计算>反射的计算<a hidden class=anchor aria-hidden=true href=#反射的计算>#</a></h2><h3 id=参数的选择>参数的选择<a hidden class=anchor aria-hidden=true href=#参数的选择>#</a></h3><p>计算反射基本上只需要三个参数，一个是<code>Max Distance</code>，只考虑距离反射点一定范围内的物体带来的反射，一个是<code>Step Count</code>，更多的步进次数带来更精确的反射，同时也增加性能消耗，最后一个是<code>Thickness Params</code>，对于一个物体，默认其厚度为<code>depth * _Thickness.y + _Thickness.x</code>，这样当射线经过物体背面时不会被认为发生了交叉。</p><h3 id=深度比较>深度比较<a hidden class=anchor aria-hidden=true href=#深度比较>#</a></h3><p>步进的时候比较什么深度也是一个值得思考的问题。将步进的深度记为<code>rayDepth</code>，将采样获得的深度记为<code>sampleDepth</code>，一个很简单的想法在标准化设备空间进行比较，因为直接采样深度图就能获取到标准化设备空间的深度值，当<code>rayDepth &lt; sampleDepth</code>的时候，射线和场景发生了交叉。又或是对实际的深度进行比较，这样能够指定一个厚度，当深度的差大于厚度时，认为射线从场景物体的后面穿了过去并没有发生交叉，当<code>rayDepth > sampleDepth && rayDepth &lt; sampleDepth + thickness</code>的时候，射线和场景发生了交叉。此外裁剪空间的Z分量也能用来判断是否发生了交叉，这里不再赘述。深度图的采样方式则应该使用<code>PointClamp</code>的方式，使用线性插值的话在一前一后的两个面的边缘很可能会被认为发生了交叉，导致画面上有不少的小点，除非另外有一张标记物体边缘的贴图可以用来排除掉这部分的交叉点。</p><h3 id=光线步进>光线步进<a hidden class=anchor aria-hidden=true href=#光线步进>#</a></h3><p>伪代码很简单：</p><blockquote><ol><li>记<code>k0</code>、<code>k1</code>分别是步进起点和终点的裁剪空间坐标的w分量的倒数。</li><li>记<code>q0</code>、<code>q1</code>分别是步进起点和终点的裁剪空间坐标的xyz分量。</li><li>记<code>p0</code>、<code>p1</code>分别是步进起点和终点的标准化设备空间坐标的xy分量。</li><li>记<code>w</code>是一个在(0, 1)之间按照<code>1.0f/_StepCount</code>递增的变量。</li><li>对每一次步进，更新<code>w</code>的值，并对上面的三组分量线性插值得到<code>k</code>、<code>q</code>、<code>p</code>。</li><li>使用<code>q.z * k</code>获得<code>rayDepth</code>，使用<code>p</code>采样深度图获得<code>sampleDepth</code>。</li><li>如果<code>rayDepth &lt; sampleDepth</code>，射线和场景发生了交叉，跳出循环，返回<code>p</code>。</li><li>使用<code>p</code>采样颜色图，获得反射的颜色。</li></ol></blockquote><p>效果是这样的（步进次数为32次）:
<img loading=lazy src=../images/ScreenSpaceReflection_Naive.png#center alt="Screen Space Reflection Naive"></p><p>看上去非常糟糕，最明显的是拉扯的效果。它主要有两个产生的原因：一是我们并没有使用厚度来判断射线是否从物体的背面穿过，这导致了悬空的物体下方会有很长的拉扯；二是我们并没有对超出屏幕范围的位置进行限制，这导致了我们使用屏幕外的坐标采样深度图但返回了Clamp之后的深度值。</p><h3 id=厚度检测>厚度检测<a hidden class=anchor aria-hidden=true href=#厚度检测>#</a></h3><p>为了解决上面的厚度问题，我们新增了一个方法由于判断步进的位置是否在物体后面。我们需要使用的是距离相机的线性深度<code>linearRayDepth</code>和<code>linearSampleDepth</code>。上文说到我们使用<code>linearSampleDepth * _Thickness.y + _Thickness.x</code>来作为一个场景中一个物体的厚度，我们只需要判断<code>(linearRayDepth-linearSampleDepth-_Thickness.x) / linearSampleDepth</code>和<code>_Thickness.y</code>的大小即可，如果前式大于后式，则表明射线从物体后面穿过。</p><pre><code class=language-HLSL data-lang=HLSL>    float getThicknessDiff(float diff, float linearSampleDepth, float2 thicknessParams)
    {
        return (diff - thicknessParams.x) / linearSampleDepth;
    }
</code></pre><p>伪代码变成了：</p><blockquote><ol start=7><li>如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff &lt; _Thickness.y</code>，射线和场景发生了交叉，跳出循环，返回<code>p</code>。</li></ol></blockquote><p>效果是这样的（步进次数为32次）:
<img loading=lazy src=../images/ScreenSpaceReflection_ThicknessTest.png#center alt="Screen Space Reflection Thickness Test"></p><h3 id=视锥体裁剪>视锥体裁剪<a hidden class=anchor aria-hidden=true href=#视锥体裁剪>#</a></h3><p>对于超出屏幕空间的<code>p1</code>，会带来两个坏处，一是采样了超出范围的深度图得到了错误的深度值，二是减少了有效采样的次数。因此我们可以考虑将<code>p1</code>限制在屏幕空间内，这里新增了一个方法用于将步进终点限制在视锥体内部。我们记<code>nf</code>为近裁剪面深度和远裁剪面深度值（正数），<code>s</code>为视锥体上下和左右的斜率（正数），<code>s</code>在数值上为<code>float2(asepect * tan(fovy * 0.5f), tan(fovy * 0.5f)</code>，注意为了方便计算，这里<code>from</code>和<code>to</code>的z分量为正数。下面的算法应该还能优化一些，不过已经够用了。</p><p>事实上我还写了一个Shadertoy用来演示，使用鼠标进行交互：</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/4XfSDB?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Frustum Clip 2D</p></figure><pre><code class=language-HLSL data-lang=HLSL>#define INFINITY 1e10

float3 frustumClip(float3 from, float3 to, float2 nf, float2 s)
{
    float3 dir = to - from;
    float3 signDir = sign(dir);

    float nfSlab = signDir.z * (nf.y - nf.x) * 0.5f + (nf.y + nf.x) * 0.5f;
    float lenZ = (nfSlab - from.z) / dir.z;
    if (dir.z == 0.0f) lenZ = INFINITY;

    float2 ss = sign(dir.xy - s * dir.z) * s;
    float2 denom = ss * dir.z - dir.xy;
    float2 lenXY = (from.xy - ss * from.z) / denom;
    if (lenXY.x &lt; 0.0f || denom.x == 0.0f) lenXY.x = INFINITY;
    if (lenXY.y &lt; 0.0f || denom.y == 0.0f) lenXY.y = INFINITY;

    float len = min(min(1.0f, lenZ), min(lenXY.x, lenXY.y));
    float3 clippedVS = from + dir * len;
    return clippedVS;
}
</code></pre><p>伪代码变成了：</p><blockquote><ol start=0><li>将步进终点进行视锥体裁剪得到<code>clippedPosVS</code>，再进一步得到终点的裁剪空间坐标<code>endCS</code>。</li></ol></blockquote><p>效果是这样的（步进次数为32次）:
<img loading=lazy src=../images/ScreenSpaceReflection_FrustumClip.png#center alt="Screen Space Reflection Frustum Clip"></p><p>看上去有那么点反射的意思了，视锥体剔除一定程度地减少了每次步进的像素数，因此补上了一部分的窟窿。但是反射的颜色扭扭曲曲的。</p><h3 id=二分法查找>二分法查找<a hidden class=anchor aria-hidden=true href=#二分法查找>#</a></h3><p>我们上一步获得的<code>p</code>虽然确保了在物体内部，但距离实际的交点仍有一部分的距离，我们可以通过二分法查找减少两者之间的误差。为了进行二分法查找，我们需要记录最后两次步进的<code>w</code>值，记为<code>w1</code>和<code>w2</code>（<code>w1 > w2</code>）。每次二分法时，取<code>w = 0.5f * (w1 + w2)</code>，如果检测到相交，则<code>w1 = w</code>，否则<code>w2 = w</code>，进入下一个循环。</p><p>伪代码变成了：</p><blockquote><ol start=0><li>将步进终点进行视锥体裁剪得到<code>clippedPosVS</code>，再进一步得到终点的裁剪空间坐标<code>endCS</code>。</li><li>记<code>k0</code>、<code>k1</code>分别是步进起点和终点的裁剪空间坐标的w分量的倒数。</li><li>记<code>q0</code>、<code>q1</code>分别是步进起点和终点的裁剪空间坐标的xyz分量。</li><li>记<code>p0</code>、<code>p1</code>分别是步进起点和终点的标准化设备空间坐标的xy分量。</li><li>记<code>w1</code>是一个在(0, 1)之间按照<code>1.0f/_StepCount</code>递增的变量，<code>w1</code>和<code>w2</code>初始化为0。</li><li>对每一次步进，<code>w2=w1</code>，更新<code>w1</code>的值，并对上面的三组分量线性插值得到<code>k</code>、<code>q</code>、<code>p</code>。</li><li>使用<code>q.z * k</code>获得<code>rayDepth</code>，使用<code>p</code>采样深度图获得<code>sampleDepth</code>。</li><li>如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff &lt; _Thickness.y</code>，射线和场景发生了交叉，跳出循环。</li><li>记<code>w</code>为<code>w1</code>和<code>w2</code>的平均数，按照567判断是否发生交叉，根据是否交叉更新<code>w1</code>或<code>w2</code>，直到结束二分法循环。</li><li>使用<code>p</code>采样颜色图，获得反射的颜色。</li></ol></blockquote><p>效果是这样的（步进次数为32次，二分法查找次数为5次）:
<img loading=lazy src=../images/ScreenSpaceReflection_BinarySearch.png#center alt="Screen Space Reflection Binary Search"></p><p>可以看到反射的效果看上去不那么扭扭曲曲的了（左下角尤为明显），但是两段颜色之间仍然有着空隙，这来自于我们的厚度测试，它将潜在的交叉排除在外了。</p><h3 id=潜在的交叉>潜在的交叉<a hidden class=anchor aria-hidden=true href=#潜在的交叉>#</a></h3><p>为了计算潜在的交叉，我们需要回顾之前做厚度测试的代码。当射线穿过物体后面时，如果前一次射线还在物体前方，我们可以记录两者之间的差距<code>thicknessDiff</code>，如果它的值小于最小的差距<code>minThicknessDiff</code>，我们将其作为潜在的交叉，更新<code>minThicknessDiff</code>，并记录当前的<code>w1</code>和<code>w2</code>用于后续的二分法查找。在二分法时我们需要判断发生了交叉还是发生了潜在的交叉，如果发生了交叉，我们执行原有的代码，如果发生的是潜在的交叉，在二分法时我们也需要记录<code>thicknessDiff</code>，找到最小的小于<code>_Thickness.y</code>的<code>thicknessDiff</code>，使用当前<code>w</code>插值得到的<code>p</code>采样获得最终的颜色。</p><p>伪代码变成了：</p><blockquote><ol start=0><li>将步进终点进行视锥体裁剪得到<code>clippedPosVS</code>，再进一步得到终点的裁剪空间坐标<code>endCS</code>。</li><li>记<code>k0</code>、<code>k1</code>分别是步进起点和终点的裁剪空间坐标的w分量的倒数。</li><li>记<code>q0</code>、<code>q1</code>分别是步进起点和终点的裁剪空间坐标的xyz分量。</li><li>记<code>p0</code>、<code>p1</code>分别是步进起点和终点的标准化设备空间坐标的xy分量。</li><li>记<code>w1</code>是一个在(0, 1)之间按照<code>1.0f/_StepCount</code>递增的变量，<code>w1</code>和<code>w2</code>初始化为0。</li><li>对每一次步进，<code>w2=w1</code>，更新<code>w1</code>的值，并对上面的三组分量线性插值得到<code>k</code>、<code>q</code>、<code>p</code>。</li><li>使用<code>q.z * k</code>获得<code>rayDepth</code>，使用<code>p</code>采样深度图获得<code>sampleDepth</code>。</li><li>如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff &lt; _Thickness.y</code>，射线和场景发生了交叉，跳出循环。</li><li>否则如果<code>rayZ &lt; sampleZ</code>且<code>thicknessDiff > _Thickness.y</code>且上一次射线在物体前方，将<code>thicknessDiff</code>和最小值进行比较，如果更小则更新最小值，记录此时的<code>w1</code>和<code>w2</code>，记为发生了潜在的交叉，继续循环。</li><li>如果发生了交叉，记<code>w</code>为<code>w1</code>和<code>w2</code>的平均数，按照567判断是否发生交叉，根据是否交叉更新<code>w1</code>或<code>w2</code>，直到结束二分法循环。</li><li>否则如果发生了潜在交叉，按照567判断是否发生交叉，使用最小的<code>thicknessDiff</code>更新<code>p</code>。</li><li>使用<code>p</code>采样颜色图，获得反射的颜色。</li></ol></blockquote><p>效果是这样的（步进次数为32次，二分法查找次数为5次）:
<img loading=lazy src=../images/ScreenSpaceReflection_PotentialHit.png#center alt="Screen Space Reflection Potential Hit">
下图是步进次数为64次，二分法查找5次的效果：
<img loading=lazy src=../images/ScreenSpaceReflection_64.png#center alt="Screen Space Reflection Potential Hit"></p><h3 id=最终的代码>最终的代码<a hidden class=anchor aria-hidden=true href=#最终的代码>#</a></h3><pre><code class=language-HLSL data-lang=HLSL>/*
// Copyright (c) 2024 zznewclear@gmail.com
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
*/

Shader &quot;zznewclear13/SSRShader&quot;
{
    Properties
    {
        [Toggle(USE_POTENTIAL_HIT)] _UsePotentialHit (&quot;Use Potential Hit&quot;, Float) = 1.0
        [Toggle(USE_FRUSTUM_CLIP)] _UseFrustumClip (&quot;Use Frustum Clip&quot;, Float) = 1.0
        [Toggle(USE_BINARY_SEARCH)] _UseBinarySearch (&quot;Use Binary Search&quot;, Float) = 1.0
        [Toggle(USE_THICKNESS)] _UseThickness (&quot;Use Thickness&quot;, Float) = 1.0
        
        _MaxDistance (&quot;Max Distance&quot;, Range(0.1, 100.0)) = 15.0
        [int] _StepCount (&quot;Step Count&quot;, Float) = 32
        _ThicknessParams (&quot;Thickness Params&quot;, Vector) = (0.1, 0.02, 0.0, 0.0)
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;
    
    #pragma shader_feature _ USE_POTENTIAL_HIT
    #pragma shader_feature _ USE_FRUSTUM_CLIP
    #pragma shader_feature _ USE_BINARY_SEARCH
    #pragma shader_feature _ USE_THICKNESS

    #define INFINITY 1e10
    #define DEPTH_SAMPLER sampler_PointClamp

    Texture2D _CameraOpaqueTexture;
    Texture2D _CameraDepthTexture;
    CBUFFER_START(UnityPerMaterial)
    float _MaxDistance;
    int _StepCount;
    float2 _ThicknessParams;
    CBUFFER_END

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float2 texcoord     : TEXCOORD0;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float3 positionWS   : TEXCOORD0;
        float3 normalWS     : TEXCOORD1;
        float2 uv           : TEXCOORD2;
        float3 viewWS       : TEXCOORD3;
    };

    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS);

        output.positionCS = vpi.positionCS;
        output.positionWS = vpi.positionWS;
        output.normalWS = vni.normalWS;
        output.uv = input.texcoord;
        output.viewWS = GetCameraPositionWS() - vpi.positionWS;
        return output;
    }

    float3 frustumClip(float3 from, float3 to, float2 nf, float2 s)
    {
        float3 dir = to - from;
        float3 signDir = sign(dir);

        float nfSlab = signDir.z * (nf.y - nf.x) * 0.5f + (nf.y + nf.x) * 0.5f;
        float lenZ = (nfSlab - from.z) / dir.z;
        if (dir.z == 0.0f) lenZ = INFINITY;

        float2 ss = sign(dir.xy - s * dir.z) * s;
        float2 denom = ss * dir.z - dir.xy;
        float2 lenXY = (from.xy - ss * from.z) / denom;
        if (lenXY.x &lt; 0.0f || denom.x == 0.0f) lenXY.x = INFINITY;
        if (lenXY.y &lt; 0.0f || denom.y == 0.0f) lenXY.y = INFINITY;

        float len = min(min(1.0f, lenZ), min(lenXY.x, lenXY.y));
        float3 clippedVS = from + dir * len;
        return clippedVS;
    }

    float getThicknessDiff(float diff, float linearSampleDepth, float2 thicknessParams)
    {
        return (diff - thicknessParams.x) / linearSampleDepth;
    }

    float4 frag(Varyings input) : SV_TARGET
    {
        float3 positionWS = input.positionWS;
        float3 normalWS = normalize(input.normalWS);
        float3 viewWS = normalize(input.viewWS);
        float3 reflWS = reflect(-viewWS, normalWS);
        float3 env = GlossyEnvironmentReflection(reflWS, 0.0f, 1.0f);
        float3 color = env;

        float3 originWS = positionWS;
        float3 endWS = positionWS + reflWS * _MaxDistance;

#if defined(USE_FRUSTUM_CLIP)
        float3 originVS = mul(UNITY_MATRIX_V, float4(originWS, 1.0f)).xyz;
        float3 endVS = mul(UNITY_MATRIX_V, float4(endWS, 1.0f)).xyz;
        float3 flipZ = float3(1.0f, 1.0f, -1.0f);
        float3 clippedVS = frustumClip(originVS * flipZ, endVS * flipZ, _ProjectionParams.yz, float2(1.0f, -1.0f) / UNITY_MATRIX_P._m00_m11);
        clippedVS *= flipZ;
        float4 originCS = mul(UNITY_MATRIX_VP, float4(originWS, 1.0f));
        float4 endCS = mul(UNITY_MATRIX_P, float4(clippedVS, 1.0f));
#else
        float4 originCS = mul(UNITY_MATRIX_VP, float4(originWS, 1.0f));
        float4 endCS = mul(UNITY_MATRIX_VP, float4(endWS, 1.0f));
#endif

        float k0 = 1.0f / originCS.w;
        float k1 = 1.0f / endCS.w;
        float3 q0 = originCS.xyz;
        float3 q1 = endCS.xyz;
        float2 p0 = originCS.xy * float2(1.0f, -1.0f) * k0 * 0.5f + 0.5f;
        float2 p1 = endCS.xy * float2(1.0f, -1.0f) * k1 * 0.5f + 0.5f;

#if defined(USE_POTENTIAL_HIT)
        float w1 = 0.0f;
        float w2 = 0.0f;
        bool hit = false;
        bool lastHit = false;
        bool potentialHit = false;
        float2 potentialW12 = float2(0.0f, 0.0f);
        float minPotentialHitPos = INFINITY;
        [unroll(64)]
        for (int i=0; i&lt;_StepCount; ++i)
        {
            w2 = w1;
            w1 += 1.0f / float(_StepCount);

            float3 q = lerp(q0, q1, w1);
            float2 p = lerp(p0, p1, w1);
            float k = lerp(k0, k1, w1);
            float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
            float linearSampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams);
            float linearRayDepth = LinearEyeDepth(q.z * k, _ZBufferParams);

            float hitDiff = linearRayDepth - linearSampleDepth;
            float thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);
            if (hitDiff &gt; 0.0f)
            {
                if (thicknessDiff &lt; _ThicknessParams.y)
                {
                    hit = true;
                    break;
                }
                else if(!lastHit)
                {
                    potentialHit = true;
                    if (minPotentialHitPos &gt; thicknessDiff)
                    {
                        minPotentialHitPos = thicknessDiff;
                        potentialW12 = float2(w1, w2);
                    }
                }
            }
            lastHit = hitDiff &gt; 0.0f;
        }
#else
        float w1 = 0.0f;
        float w2 = 0.0f;
        bool hit = false;
        [unroll(64)]
        for (int i=0; i&lt;_StepCount; ++i)
        {
            w2 = w1;
            w1 += 1.0f / float(_StepCount);

            float3 q = lerp(q0, q1, w1);
            float2 p = lerp(p0, p1, w1);
            float k = lerp(k0, k1, w1);
            float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
#if defined(USE_THICKNESS)
            float linearSampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams);
            float linearRayDepth = LinearEyeDepth(q.z * k, _ZBufferParams);

            float hitDiff = linearRayDepth - linearSampleDepth;
            float thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);
            if (hitDiff &gt; 0.0f &amp;&amp; thicknessDiff &lt; _ThicknessParams.y)
            {
                hit = true;
                break;
            }       
#else
            if (q.z * k &lt; sampleDepth)
            {
                hit = true;
                break;
            }
#endif
        }
#endif

#if defined(USE_POTENTIAL_HIT)
        if (hit || potentialHit)
        {
            if (!hit)
            {
                w1 = potentialW12.x;
                w2 = potentialW12.y;
            }

            bool realHit = false;
            float2 hitPos;
            float minThicknessDiff = _ThicknessParams.y;
            [unroll(5)]
            for (int i=0; i&lt;5; ++i)
            {
                float w = 0.5f * (w1 + w2);
                float3 q = lerp(q0, q1, w1);
                float2 p = lerp(p0, p1, w1);
                float k = lerp(k0, k1, w1);
                float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
                float linearSampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams);
                float linearRayDepth = LinearEyeDepth(q.z * k, _ZBufferParams);
                float hitDiff = linearRayDepth - linearSampleDepth;

                if (hitDiff &gt; 0.0f)
                {
                    w1 = w;
                    if (hit) hitPos = p;
                }
                else
                {
                    w2 = w;
                }

                float thicknessDiff = getThicknessDiff(hitDiff, linearSampleDepth, _ThicknessParams);
                float absThicknessDiff = abs(thicknessDiff);
                if (!hit &amp;&amp; absThicknessDiff &lt; minThicknessDiff) 
                {
                    realHit = true;
                    minThicknessDiff = thicknessDiff;
                    hitPos = p;
                }
            }

            if (hit || realHit) color = _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb * 0.3f;
        }
#elif defined(USE_BINARY_SEARCH)
        if (hit)
        {
            float2 hitPos;
            [unroll(5)]
            for (int i=0; i&lt;5; ++i)
            {
                float w = 0.5f * (w1 + w2);
                float3 q = lerp(q0, q1, w1);
                float2 p = lerp(p0, p1, w1);
                float k = lerp(k0, k1, w1);

                float sampleDepth = _CameraDepthTexture.Sample(DEPTH_SAMPLER, p).r;
                if (q.z * k &lt; sampleDepth)
                {
                    w1 = w;
                    hitPos = p;
                }
                else
                {
                    w2 = w;
                }
            }
            color = _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb * 0.3f;
        }
#else
        if (hit)
        {
            float2 hitPos = lerp(p0, p1, w1);
            color = _CameraOpaqueTexture.Sample(sampler_LinearClamp, hitPos).rgb * 0.3f;
        }
#endif

        return float4(color, 1.0f);
    }

    ENDHLSL

    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot;=&quot;Transparent&quot; }
        LOD 100

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h3 id=优化的方向>优化的方向<a hidden class=anchor aria-hidden=true href=#优化的方向>#</a></h3><p>目前还有一个值得优化的方向，就是根据<code>p0</code>和<code>p1</code>之间的像素距离控制总体的步进次数，总不至于对10个像素步进64次吧。不过这个就比较简单了，留给有空的人来做吧。至于随机采样、模糊和菲涅尔，等到真的用到的时候再去考虑吧。</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>2024简直就是开幕雷击，各种糟糕的事情接踵而至，有时候会有深深的无力感。可能只有写博客和Shadertoy才能给我带来最强的满足感吧，希望真的有人能从我的博客和Shadertoy中有所收获。本来是打算写一篇Contact Shadow的，但是发现屏幕空间ray marching其实并不是那么一件简单的事情，因此想先写完这个再继续我的Contact Shadow。说实在的我对这篇博客的质量还是比较满意的，打算再写个英文版的去投稿Graphics Programming weekly，拭目以待.gif。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/screen-space-reflection/>Screen Space Reflection</a></li><li><a href=https://zznewclear13.github.io/tags/screen-space/>Screen Space</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/screen-space-reflection-en/><span class=title>« Prev Page</span><br><span>Screen Space Reflection</span></a>
<a class=next href=https://zznewclear13.github.io/posts/unity-high-quality-bloom/><span class=title>Next Page »</span><br><span>Unity的高质量的Bloom效果</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>