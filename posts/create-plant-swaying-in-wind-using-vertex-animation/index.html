<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰© | ZZNEWCLEAR13</title>
<meta name=keywords content="Vertex Animation,Space Transformation"><meta name=description content="åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©"><meta property="og:description" content="åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/"><meta property="og:image" content="https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/posts/images/VertexAnimatedPlant.gif"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-06T12:00:00+08:00"><meta property="article:modified_time" content="2022-01-06T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/posts/images/VertexAnimatedPlant.gif"><meta name=twitter:title content="ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©"><meta name=twitter:description content="åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©","item":"https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©","name":"ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©","description":"åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹.","keywords":["Vertex Animation","Space Transformation"],"articleBody":"åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ æœ€ç›´æ¥çš„åŠ¨æœºæ˜¯çœ‹äº†é¡½çš®ç‹—åœ¨Siggraph 2016ä¸Šçš„PPTï¼Œé‡Œé¢ä»‹ç»äº†é¡½çš®ç‹—åœ¨ç¥ç§˜æµ·åŸŸä¸­æ˜¯å¦‚ä½•è®©æ¤è¢«éšé£é£˜è¡çš„ã€‚ä»–ä»¬ä»‹ç»äº†ä¸€ç§å°†æ¤è¢«çš„æ¯ä¸€éƒ¨åˆ†çš„pivotçš„ç‰©ä½“ç©ºé—´åæ ‡å†™åˆ°é¡¶ç‚¹è‰²é‡Œï¼Œç„¶ååœ¨shaderä¸­ä½¿ç”¨è¿™ä¸ªåæ ‡è¿›è¡Œé£çš„æ•ˆæœçš„è®¡ç®—çš„æ–¹æ³•ã€‚è¾ƒä¸ºéœ‡æ’¼åœ¨é£å¹è¿‡è‰åŸæ—¶ï¼Œæ¤è¢«è¿›è¡Œå¼¯æ›²åï¼Œè‰è¡¨é¢çš„é«˜å…‰ä¼šæœ‰ä¸€ç§æ—¶ç©ºä¸Šçš„èµ·ä¼æ„Ÿï¼ˆä¹Ÿå°±æ˜¯è¯´ç¥ç§˜æµ·åŸŸçš„æ¤è¢«çš„æ³•çº¿ä¹Ÿä¼šè¢«é£å½±å“ï¼‰ã€‚æ‰€ä»¥æˆ‘ä¹Ÿæƒ³è¦å€ŸåŠ©å†™pivotçš„æ–¹æ³•æ¥åˆ¶ä½œæ¤è¢«å—åˆ°é£å¹çš„æ•ˆæœï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•è®¡ç®—å‡ºæ­£ç¡®çš„é£å¹ä¹‹åçš„æ¤è¢«çš„æ³•çº¿ï¼ˆåŒæ—¶ç”±äºæ³•çº¿è´´å›¾çš„å­˜åœ¨ï¼Œè¿˜è¦è®¡ç®—æ­£ç¡®çš„åˆ‡çº¿ï¼‰ã€‚\nç¨å¾®ç¿»äº†ä¸€ä¸‹ç½‘ä¸Šçš„èµ„æ–™ï¼ˆä¹Ÿæ²¡ä»”ç»†åœ°å»æœç´¢ï¼‰ï¼Œå¤§éƒ¨åˆ†çš„å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„é¡¶ç‚¹åŠ¨ç”»ï¼Œæœ‰çš„æ˜¯ç”¨çš„sinï¼Œæœ‰çš„å°±ç›´æ¥å¹³ç§»ã€‚è¿™å°±äº§ç”Ÿäº†ç¬¬äºŒä¸ªéœ€æ±‚ï¼Œæ¤è¢«åœ¨é¡¶ç‚¹åŠ¨ç”»ä¸­åº”è¯¥ä¿æŒå·®ä¸å¤šçš„é•¿åº¦ï¼Œä¸ç„¶ä¼šå‘ç°å¾ˆæ˜æ˜¾çš„æ‹‰ä¼¸çš„æ•ˆæœã€‚\nå½“ç„¶æœ€å¥½è¿˜èƒ½æŠ•å°„å‡ºæ­£å¸¸çš„å½±å­äº†ï¼Œè¿™ä¸€æ­¥åªéœ€è¦æŠŠé¡¶ç‚¹ç€è‰²å™¨å¤åˆ¶ä¸€ä»½åˆ°æŠ•å°„å½±å­çš„passé‡Œå°±å¯ä»¥äº†ã€‚\nè¿™é‡Œä½¿ç”¨çš„æ¤è¢«æ¨¡å‹æ˜¯MegaScansä¸Šçš„CORDYLINEæ¨¡å‹ä¸­çš„var12è¿™ä¸ªå°æ¨¡å‹ã€‚\néš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³• Unityçš„é¡¶ç‚¹è‰²é™åˆ¶ ç¨å¾®æµ‹è¯•ä¸€ä¸‹å°±èƒ½å‘ç°ï¼ŒUnityçš„é¡¶ç‚¹è‰²æ˜¯UNorm8çš„æ ¼å¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºä½ åœ¨Mayaæˆ–æ˜¯3ds Maxé‡Œå¯¼å‡ºçš„æ¨¡å‹çš„é¡¶ç‚¹è‰²ä¿¡æ¯æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå¯¼å…¥åˆ°Unityä¸­å°±ä¼šå˜æˆåªæœ‰256ç²¾åº¦çš„UNorm8ã€‚é¡½çš®ç‹—ä½¿ç”¨çš„æ˜¯è‡ªå·±çš„å¼•æ“ï¼Œæ‰€ä»¥å®ƒä»¬èƒ½å¤Ÿä½¿ç”¨å…¨ç²¾åº¦çš„é¡¶ç‚¹è‰²ï¼Œä½†æ˜¯ç”±äºUnityçš„å¼•æ“é™åˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘åˆ°å¯¼å‡ºpivotçš„é¡¶ç‚¹åæ ‡åˆ°æ¨¡å‹çš„UVä¸­ã€‚\nä½†æ˜¯å¾ˆä¸å¹¸çš„æ˜¯ï¼Œfbxå¯¼å…¥åˆ°Unityæ—¶ï¼Œå³ä½¿UVæ˜¯float4çš„ç±»å‹ï¼ˆä¹Ÿå°±æ˜¯16bytes)ï¼Œåœ¨Unityä¸­åªä¼šè¯†åˆ«UVçš„å‰ä¸¤ä½ã€‚æ‰€ä»¥åªèƒ½æ— å¥ˆçš„å°†pivotçš„é¡¶ç‚¹åæ ‡ï¼ˆfloat3çš„æ•°æ®ï¼‰å‚¨å­˜åˆ°ä¸¤ä¸ªUVçš„ä¸‰ä¸ªé€šé“é‡Œï¼ŒåŒæ—¶å°†pivotçš„å±‚çº§å­˜åˆ°å‰©ä¸‹çš„ä¸€ä¸ªé€šé“é‡Œã€‚æˆ‘ä¸çŸ¥é“é¡½çš®ç‹—å…·ä½“æ˜¯æ€ä¹ˆè®¡ç®—pivotçš„å±‚çº§å…³ç³»çš„ï¼Œä»–åœ¨PPTä¸­å†™çš„æ˜¯æ— éœ€è®¡ç®—ï¼Œä½†æˆ‘åœ¨å®é™…æ“ä½œä¸­åªèƒ½ä¸€å±‚ä¸€å±‚çš„ç®—ï¼ˆè€Œä¸”åªèƒ½ç®—ä¸¤å±‚ï¼‰ï¼Œä¹Ÿå¸Œæœ›çŸ¥é“å…·ä½“æ€ä¹ˆæ“ä½œçš„äººå‘ŠçŸ¥ä¸€ä¸‹æ–¹æ³•ã€‚\næ‰€ä»¥æ¥ä¸‹æ¥è¦åšçš„æ˜¯åœ¨Mayaä¸­æŠŠpivotçš„ç‰©ä½“ç©ºé—´åæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°å¯¹åº”é¡¶ç‚¹çš„æŸä¸¤å¥—UVä¸­ï¼Œæœ¬æ–‡æ˜¯å†™åˆ°ç¬¬äºŒå¥—å’Œç¬¬ä¸‰å¥—UVä¸­ï¼ˆä¹Ÿå°±æ˜¯TEXCOORD1å’ŒTEXCOORD2ï¼‰ã€‚äºæ˜¯æˆ‘æ¶è¡¥äº†ä¸€ä¸‹mayaçš„pythonè„šæœ¬çš„å†™æ³•ï¼Œä¸è¿‡åœ¨å†™æ•°å€¼åˆ°UVä¸­æ—¶ï¼Œåˆé‡åˆ°äº†ä¸€ä¸ªå°é—®é¢˜ã€‚Mayaçš„cmds.polyEditUVè¿™ä¸ªæ–¹æ³•ï¼Œæ˜æ˜èƒ½ä¼ å…¥uvSetNameè¿™ä¸ªå‚æ•°ï¼Œç”¨äºæ“ä½œå¯¹åº”çš„UVï¼Œä½†æˆ‘å®é™…ä½¿ç”¨æ—¶åªèƒ½å†™æ•°å€¼åˆ°å½“å‰çš„UVä¸­ï¼Œå¯¼è‡´æœ€åå†™çš„è„šæœ¬åªèƒ½åƒµç¡¬çš„æ“ä½œå½“å‰UVï¼Œæ¯æ¬¡åˆ‡æ¢UVæ—¶éœ€è¦é‡æ–°ä¿®æ”¹è„šæœ¬å†è¿è¡Œä¸€æ¬¡ã€‚\næœ€ç»ˆçš„è„šæœ¬æ˜¯è¿™æ ·çš„ï¼š\nVertexPivotWriteTool.py import maya.cmds as cmds targetVertexStr = \"Select any vertex to start.\" vertexColorStr = \"Select any vertex to start.\" pivotPosition = [0.0, 0.0, 0.0] def ui(): if cmds.window(\"VertexPivotWriteTool\", exists = True): cmds.deleteUI(\"VertexPivotWriteTool\") global targetVertexStr global targetVertexField global vertexColorStr global vertexColorField global pivotLayer vertexPivotWindow = cmds.window(\"VertexPivotWriteTool\", widthHeight = [500, 400]) form = cmds.formLayout(numberOfDivisions = 100) pivotLayerLable = cmds.text(\"Pivot Layer (0 for root pivot)\") pivotLayer = cmds.intField() cmds.intField(pivotLayer, e = True, minValue = 0, maxValue = 5, step = 1, value = 0) targetVertexButton = cmds.button(\"Target Vertex\", command = 'GetTargetVertex()') targetVertexField = cmds.textField(text=targetVertexStr, width = 300) #writeVertexButton = cmds.button(\"Write to Vertex Color\", command = 'WriteToVertexColor()') writeVertexButton = cmds.button(\"Write to Vertex Texcoord\", command = 'WriteToVertexTexcoord()') targetVertexColorButton = cmds.button(\"Show Vertex Color\", command = 'GetTargetVertexColor()') vertexColorField = cmds.textField(text=vertexColorStr, width = 300) cmds.showWindow(vertexPivotWindow) cmds.formLayout(form, e=True, attachForm = ( [pivotLayerLable, 'left', 25], [pivotLayerLable, 'top', 20], [pivotLayer, 'right', 25], [pivotLayer, 'top', 20], [targetVertexButton, 'left', 25], [targetVertexButton, 'top', 60], [targetVertexField, 'right', 25], [targetVertexField, 'top', 60], [writeVertexButton, 'left', 25], [writeVertexButton, 'top', 100], [targetVertexColorButton, 'left', 25], [targetVertexColorButton, 'bottom', 20], [vertexColorField, 'right', 25], [vertexColorField, 'bottom', 20], )) def GetPivotLayer(): value = cmds.intField(pivotLayer, q=True, value=True) print(\"pivotLayerValue is: \" + str(value)) return value def GetTargetVertex(): print(\"Get Target Vertex...\") selVertices = cmds.ls(selection = True) global targetVertexStr global pivotPosition if len(selVertices) == 0: targetVertexStr = \"No vetex selected!\" elif len(selVertices) \u003e= 2: targetVertexStr = \"Too many vertices selected! Expected 1, got \" + str(len(selVertices)) else: pivotPosition = cmds.pointPosition(selVertices[0]) tempStr = \"(\" for axis in range(len(pivotPosition)): if axis \u003e= 1: tempStr += \", \" tempStr += \"{:.2f}\".format(pivotPosition[axis]) tempStr += \")\" targetVertexStr = tempStr cmds.textField(targetVertexField, e= True, text = targetVertexStr) def GetTargetVertexColor(): print(\"Get Target Vertex...\") selVertices = cmds.ls(selection = True) global vertexColorStr if len(selVertices) == 0: vertexColorStr = \"No vetex selected!\" elif len(selVertices) \u003e= 2: vertexColorStr = \"Too many vertices selected! Expected 1, got \" + str(len(selVertices)) else: vertexColor = cmds.polyColorPerVertex(query=True, rgb=True) tempStr = \"(\" for axis in range(len(vertexColor)): if axis \u003e= 1: tempStr += \", \" tempStr += \"{:.2f}\".format(vertexColor[axis]) tempStr += \")\" vertexColorStr = tempStr cmds.textField(vertexColorField, e= True, text = vertexColorStr) def WriteToVertexColor(): print(\"Write To Vertex Color...\") selVertices = cmds.ls(selection = True) for vertex in selVertices: cmds.polyColorPerVertex(vertex, rgb=(pivotPosition[0], pivotPosition[1], pivotPosition[2])) def WriteToVertexTexcoord(): print(\"Write To Vertex Coord...\") pivotLayerValue = GetPivotLayer() allUVSets = cmds.polyUVSet( query=True, allUVSets=True ) uvSetCount = len(allUVSets) cmds.polyEditUV(relative = False, uValue = pivotPosition[0], vValue = pivotPosition[1]) #cmds.polyEditUV(relative = False, uValue = pivotPosition[2], vValue = pivotLayerValue) ui() å› ä¸ºç§ç§é™åˆ¶ï¼Œä½¿ç”¨æ—¶è¾ƒä¸ºå¤æ‚ï¼Œå¦‚æœæœ‰æ›´å¥½çš„è„šæœ¬çš„è¯ï¼Œä¹Ÿå¾ˆæ„Ÿè°¢åˆ†äº«å‡ºæ¥å‘Šè¯‰æˆ‘ã€‚é¦–å…ˆæ˜¯è¦åœ¨UVé›†ç¼–è¾‘å™¨ä¸­ï¼Œä¸ºæ¨¡å‹æ–°å¢ä¸¤å¥—UVï¼Œç”±äºä½¿ç”¨çš„MegaScansæ¨¡å‹æœ¬èº«æœ‰ä¸¤å¥—ä¸åŒçš„UVï¼Œæ“ä½œæ˜¯æŠŠåŸæ¥çš„ç¬¬äºŒå¥—UVç§»åŠ¨åˆ°ç¬¬å››å¥—UVä¸­ï¼Œç„¶åæŠŠç¬¬ä¸€å¥—UVå¤åˆ¶åˆ°ç¬¬äºŒç¬¬ä¸‰å¥—UVä¸­ï¼Œç„¶ååœ¨UVç¼–è¾‘å™¨ä¸­å®šä½å½“å‰UVåˆ°ç¬¬äºŒå¥—UVã€‚åœ¨è„šæœ¬ç¼–è¾‘å™¨ä¸­æ‰“å¼€æˆ–è€…å¤åˆ¶ä¸Šé¢çš„VertexPivotWriteTool.pyï¼Œé€šè¿‡Crtl + Enterå¯ä»¥ç”Ÿæˆè¯¥è„šæœ¬çš„ä¸€ä¸ªçª—å£ã€‚ç„¶åæ‰§è¡Œä¸‹è¿°æ“ä½œï¼šé¦–å…ˆæ˜¯å°†æ¯ä¸ªpivotçš„å‰ä¸¤ä¸ªåæ ‡å†™åˆ°ç¬¬äºŒå¥—UVä¸­ï¼Œå¯¹èŒæ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€åº•ä¸‹çš„é¡¶ç‚¹ï¼Œå¯¹å¶ç‰‡æ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€æ¥è¿‘èŒçš„é¡¶ç‚¹ï¼Œé€‰ä¸­è¿™ä¸ªé¡¶ç‚¹ç„¶åç‚¹å‡»Target Vertexï¼Œåœ¨çª—å£ä¸­å¯ä»¥çœ‹åˆ°è¿™ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼›ç„¶ååœ¨UVç¼–è¾‘å™¨é€‰ä¸­è¯¥èŒæˆ–è€…å¶ç‰‡çš„UVå£³ï¼Œç‚¹å‡»Write to Vertex Texcoordï¼Œåœ¨UVç¼–è¾‘å™¨ä¸­å¯ä»¥çœ‹åˆ°UVåç¼©æˆäº†ä¸€ä¸ªç‚¹ï¼ˆå¾€å¾€æ‰¾ä¸åˆ°ï¼‰ï¼›å¯¹ç¬¬äºŒå¥—UVä¸­çš„æ‰€æœ‰çš„UVå£³æ‰§è¡Œä¸Šè¿°æ“ä½œï¼›ç„¶åå°†å½“å‰UVåˆ‡æ¢åˆ°ç¬¬ä¸‰å¥—UVï¼ŒåŒæ—¶æ³¨é‡Šæ‰è„šæœ¬çš„ç¬¬117è¡Œï¼Œå–æ¶ˆæ³¨é‡Šè„šæœ¬çš„ç¬¬118è¡Œï¼Œç„¶åè¾“å…¥Crtl + Enteré‡æ–°ç”Ÿæˆä¸€éå·¥å…·ï¼›è¿™æ—¶æˆ‘ä»¬å°†è¦æŠŠæ¯ä¸ªpivotçš„æœ€åä¸€ä¸ªåæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°ç¬¬ä¸‰å¥—UVä¸­ï¼›å¯¹æ¤è¢«çš„æ¯ä¸€ç‰‡å¶å­å’Œæå¹²ï¼Œåˆ¤æ–­å…¶pivotçš„å±‚çº§ï¼ˆä»¥ç°åœ¨ä½¿ç”¨çš„MegaScansæ¨¡å‹ä¸ºä¾‹ï¼ŒèŒçš„å±‚çº§æ˜¯0ï¼Œå…¶ä»–å¶ç‰‡çš„å±‚çº§æ˜¯1ï¼‰ï¼Œåœ¨Pivot Layerä¸­è¾“å…¥å±‚çº§ï¼›ç„¶åé‡å¤åˆ¤æ–­å±‚çº§ï¼Œé€‰æ‹©é¡¶ç‚¹ï¼Œå†™å…¥UVï¼›æœ€åæœ€åï¼Œä¸è¦å¿˜è®°æŠŠè„šæœ¬è¿˜åŸæˆæœ€å¼€å§‹çš„æ ·å­ã€‚è¿™æ ·å°±æŠŠæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„pivotåæ ‡å†™å…¥åˆ°ç¬¬äºŒå’Œç¬¬ä¸‰å¥—UVäº†ï¼å¯¼å‡ºåˆ°Unityå°±å¯ä»¥äº†ã€‚\nå¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿ é¦–å…ˆæ¥çœ‹è¿™æ ·ä¸€å¼ å›¾ï¼š\nè¿™å¼ å›¾è¡¨ç°äº†åœ¨Bend Spaceä¸­æŠŠçº¢è‰²çš„çº¿æ®µå¼¯æ›²åˆ°ç»¿è‰²çº¿æ®µçš„ç®—æ³•ï¼ŒXè½´æ˜¯é£çš„æ–¹å‘ï¼Œå¯ä»¥çœ‹åˆ°é£çš„å¼ºåº¦è¶Šé«˜ï¼ŒRadiusçš„å¤§å°å°±è¶Šå°ã€‚åŒæ—¶ä¸ºäº†è®¡ç®—å‡ºæ­£ç¡®çš„æ³•çº¿å’Œåˆ‡çº¿ï¼Œéœ€è¦åŒæ ·çš„è®¡ç®—å‡ºAxisXå’ŒAxisZåœ¨Bend Spaceä¸­çš„å‘é‡ã€‚ä½¿ç”¨è¿™ä¸ªç®—æ³•ï¼Œå½“æ¨¡å‹å¤„åœ¨Bend Spaceçš„Zè½´ä¸Šæ—¶ï¼Œä¸ä¼šå—åˆ°æ‰­æ›²ï¼Œå½“å…¶Xè½´å¤§äº0æ—¶ï¼Œä¼šå—åˆ°å‹ç¼©ï¼Œå½“Xè½´å°äº0æ—¶ï¼Œä¼šå—åˆ°æ‹‰ä¼¸ã€‚åŒæ ·çš„ï¼Œè¿™ç§ç®—æ³•å¯ä»¥æ¨å¹¿åˆ°ä¸‰ç»´ç©ºé—´ä¸­ï¼ŒåŒæ—¶æ‰­æ›²Yè½´å’ŒZè½´ï¼Œæˆ‘ç‰¹åœ°å†™äº†ä¸€ä¸ªC#è„šæœ¬æ¥å¯¹å˜æ¢çš„ç»“æœè¿›è¡Œå¯è§†åŒ–ã€‚\nWindDebugger.cs using UnityEngine; using Unity.Mathematics; public class WindDebugger : MonoBehaviour { public bool draw = true; public float debugRadius = 0.01f; public float debugLength = 0.2f; public Color pivotColor; public Color sphereColor; public float radius; public float3 originalPosition; private void DrawAxes(Color color, Vector3 pos, Vector3 tangent, Vector3 bitangent, Vector3 normal) { Gizmos.color = color; Gizmos.DrawSphere(pos, debugRadius); Gizmos.color = Color.red; Gizmos.DrawLine(pos, pos + tangent * debugLength); Gizmos.color = Color.green; Gizmos.DrawLine(pos, pos + bitangent * debugLength); Gizmos.color = Color.blue; Gizmos.DrawLine(pos, pos + normal * debugLength); } private float3 CircleTransform(float3 positionBS, float radius, out float3 axisX, out float3 axisY, out float3 axisZ) { float radVal = math.length(positionBS.xy) / radius; float sinVal = math.sin(radVal); float cosVal = math.cos(radVal); float2 normalizeDir = math.normalize(positionBS.xy); float3 targetPosBS = new float3((radius * sinVal) * normalizeDir, radius - radius * cosVal); float3 tempAxisX = new float3(-sinVal * normalizeDir, cosVal); float3 tempAxisY = new float3(normalizeDir.y, -normalizeDir.x, 0.0f); float3 tempAxisZ = new float3(cosVal * normalizeDir, sinVal); axisX = tempAxisX; axisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ; axisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ; float3 newPositionBS = targetPosBS + axisX * positionBS.z; return newPositionBS; } private void OnDrawGizmos() { if (!draw) { return; } Color originalColor = Gizmos.color; Gizmos.color = sphereColor; Gizmos.DrawSphere(new float3(0.0f, 0.0f, radius), radius); float3 axisX, axisY, axisZ; float3 newPosition = CircleTransform(originalPosition, radius, out axisX, out axisY, out axisZ); DrawAxes(pivotColor, newPosition, axisY, axisZ, axisX); DrawAxes(pivotColor, originalPosition, new float3(1.0f, 0.0f, 0.0f), new float3(0.0f, 1.0f, 0.0f), new float3(0.0f, 0.0f, 1.0f)); Gizmos.color = Color.black; Gizmos.DrawLine(float3.zero, originalPosition); Gizmos.color = Color.white; Gizmos.DrawLine(float3.zero, newPosition); Gizmos.color = originalColor; } } å…¶ä»–çš„ä¸€äº›é—®é¢˜ ç”±äºæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ä¸­ç”¨åˆ°äº†å¾ˆå¤šçš„åæ ‡å˜æ¢ï¼Œéœ€è¦ç‰¹åˆ«çš„æ³¨æ„æ¯ä¸€æ¬¡å˜æ¢æ˜¯ä»ä»€ä¹ˆç©ºé—´å˜æ¢åˆ°ä»€ä¹ˆç©ºé—´ã€‚é¦–å…ˆæ˜¯ç‰©ä½“ç©ºé—´åˆ°é£çš„å¼¯æ›²ç©ºé—´ï¼Œç”±äºæˆ‘ä»¬CircleTransformæ–¹æ³•æ˜¯è®¤ä¸ºé£æ˜¯å¹å‘Xè½´æ­£æ–¹å‘çš„ï¼Œæ‰€ä»¥éœ€è¦å…ˆå¯¹æ‰€æœ‰çš„åæ ‡ã€å‘é‡è¿›è¡Œä¸€ä¸ªå˜æ¢ï¼Œç”±äºåªæ¶‰åŠåˆ°æ—‹è½¬ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ªfloat3x3çš„çŸ©é˜µæ¥è¡¨ç¤ºä»ç‰©ä½“ç©ºé—´åˆ°å¼¯æ›²ç©ºé—´çš„å˜æ¢çŸ©é˜µã€‚\nç„¶ååˆ†ä¸¤ç§æƒ…å†µï¼šä¸€ç§æ˜¯Pivot Layerä¸º0çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ‰€ä½¿ç”¨çš„æ¨¡å‹çš„èŒä¸Šçš„é¡¶ç‚¹ã€‚è¿™ç§ç›¸å¯¹ç®€å•ï¼Œå°†é¡¶ç‚¹åœ¨ç‰©ä½“Bend Spaceä¸­è¿›è¡ŒCircleTransformåï¼Œå°±èƒ½è·å¾—æ–°çš„Bend Spaceçš„åæ ‡å’Œæ–°çš„ä¸‰ä¸ªè½´çš„å‘é‡ï¼ˆæ–°çš„ä¸‰ä¸ªè½´å¯ä»¥ç»„åˆå‡ºé¡¶ç‚¹çš„Bend Spaceåˆ°ç‰©ä½“çš„Bend Spaceçš„å˜æ¢çŸ©é˜µï¼‰ï¼Œå¯ä»¥è®¡ç®—å‡ºé¡¶ç‚¹ã€æ³•çº¿å’Œåˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡å’Œå‘é‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚\nç¬¬äºŒç§æ˜¯Pivot Layerä¸º1çš„é¡¶ç‚¹ï¼Œè¦å…ˆè®¡ç®—å‡ºPivotçš„æ–°çš„ç‰©ä½“Bend Spaceåæ ‡ï¼Œç„¶ååœ¨å…¶åŸºç¡€ä¸Šè®¡ç®—å‡ºæ¯ä¸€ä¸ªé¡¶ç‚¹ç›¸å¯¹äºPivot Bend Spaceçš„æ–°çš„åæ ‡ï¼Œç„¶åä¸€å±‚å¥—ä¸€å±‚çš„ç®—å›é¡¶ç‚¹åŠå…¶æ³•çº¿åˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘åœ¨è®¡ç®—pivotçš„Bend Spaceæ—¶ï¼Œæ‰€ä½¿ç”¨çš„ç©ºé—´å’Œä¹‹å‰å›¾ä¸Šä¸å¤ªä¸€æ ·ï¼Œæ˜¯AxisZ, AxisYå’Œ-AxisXå¯¹åº”æ–°çš„Bend Spaceçš„XYZè½´ï¼Œè¿™æ ·èƒ½è®©å‚ç›´äºæå¹²çš„å¶ç‰‡æœ‰æ›´å¥½çš„é£å¹çš„æ•ˆæœã€‚\nä¸ºäº†è®©éšé£æ‘†åŠ¨çš„æ•ˆæœçœ‹ä¸Šå»æ›´è‡ªç„¶ï¼Œé™¤äº†æŒ‰ç…§åœ†å½¢æ¥å˜æ¢é¡¶ç‚¹ä¹‹å¤–ï¼Œå‚è€ƒé¡½çš®ç‹—çš„æ¼”è®²ï¼Œè¿˜è¦ç»™æå¹²çš„æ‘‡æ™ƒæ·»åŠ ä¸€ä¸ªå’Œè·ç¦»ç›¸å…³çš„å»¶è¿Ÿï¼Œè¿™æ ·ä¸ä¼šæ˜¾å¾—ç”Ÿç¡¬ã€‚è‡³äºéšé£é£˜åŠ¨çš„é¢‘ç‡ï¼Œå°±éšä¾¿æ‰¾ä¸€ä¸ªsinå‡½æ•°çš„ç»„åˆå°±å¯ä»¥äº†ã€‚\nå…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ é¡¶ç‚¹ç€è‰²å™¨å°±æŒ‰ç…§ä¹‹å‰ä»‹ç»çš„æ¥åšå°±å¯ä»¥äº†ã€‚ç”±äºè¾ƒå¥½çœ‹çš„æ¤è¢«éƒ½æ˜¯åŒé¢æ¸²æŸ“çš„ï¼Œåœ¨Cullçš„å‚æ•°é‡Œé¢é€‰æ‹©Offã€‚è¿™æ ·åŒæ ·çš„ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æ¨¡å‹èƒŒé¢çš„æ³•çº¿å’Œæ­£é¢çš„æ³•çº¿æ˜¯ç›¸åŒçš„ï¼Œè¿™é‡Œéœ€è¦ä½¿ç”¨HLSLç‰‡å…ƒç€è‰²å™¨çš„VFACEè¯­ä¹‰ï¼Œæ¥åˆ¤æ–­å½“å‰é¢æ˜¯æ­£é¢è¿˜æ˜¯èƒŒé¢ï¼Œå¦‚æœæ˜¯èƒŒé¢çš„è¯éœ€è¦åè½¬ä¸€ä¸‹æ³•çº¿ã€‚è¿™é‡Œå†™çš„Shaderä¹ŸåŒæ—¶å†™äº†é˜´å½±ã€æ·±åº¦å›¾å’Œçƒ˜ç„™æ‰€éœ€è¦çš„passã€‚\nVertexAnimationPlantShader.shader Shader \"zznewclear13/VertexAnimationPlantShader\" { Properties { _BaseColor (\"Base Color\", color) = (1, 1, 1, 1) _BaseMap(\"Base Map\", 2D) = \"white\" {} _BumpMap (\"Bump Map\", 2D) = \"bump\" {} _BumpIntensity (\"Bump Intensity\", range(0, 1)) = 1 _RoughnessMap(\"Roughness Map\", 2D) = \"white\" {} _RoughnessIntensity (\"Roughness Intensity\", range(0, 1)) = 1 _MetallicMap (\"Metallic Map\", 2D) = \"black\" {} _MetallicIntensity (\"Metallic Intensity\", range(0, 1)) = 1 _WindDirection (\"Wind Direction\", vector) = (1.0, 0.0, 0.0, 0.0) _WindIntensity (\"Wind Intensity\", float) = 1 _WindVariety (\"Wind Variety\", range(0, 10)) = 0.5 _BranchDelay (\"Branch Delay\", range(0, 10)) = 2 _WindVarietyLeaves (\"Wind Variety Leaves\", range(0, 10)) = 1 _BranchDelayLeaves (\"Branch Delay Leaves\", range(0, 10)) = 3 _WindVaryFrequency (\"Wind Vary Frequency\", float) = 5 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" sampler2D _BaseMap; sampler2D _BumpMap; sampler2D _RoughnessMap; sampler2D _MetallicMap; CBUFFER_START(UnityPerMaterial) float4 _BaseColor; float4 _BaseMap_ST; float _BumpIntensity; float _RoughnessIntensity; float _MetallicIntensity; float4 _WindDirection; float _WindIntensity; float _WindVariety; float _BranchDelay; float _WindVarietyLeaves; float _BranchDelayLeaves; float _WindVaryFrequency; CBUFFER_END //Apply wind variety float GetVariety(float timeFunction) { return sin(timeFunction) + 0.25 * sin(timeFunction * 1.5) + 0.1 * sin(timeFunction * 0.33); } //CircleTransform transforms a current bend space point to a new position in bend space, //and output three axes of next bend space. //New position is in current bend space and ready for use. //Normal and tangent in current bend space can be calculated by axes. float3 CircleTransform(float3 positionBS, float windIntensity, out float3 axisX, out float3 axisY, out float3 axisZ) { float intensity = windIntensity; if(intensity == 0.0 || length(positionBS.yz) == 0.0) { axisX = float3(1.0, 0.0, 0.0); axisY = float3(0.0, 1.0, 0.0); axisZ = float3(0.0, 0.0, 1.0); return positionBS; } float radius = rcp(intensity); float radVal = length(positionBS.yz) * intensity; float sinVal = sin(radVal); float cosVal = cos(radVal); float2 normalizeDir = normalize(positionBS.yz); float3 targetPosBS = float3(radius - radius * cosVal, (radius * sinVal) * normalizeDir); float3 tempAxisX = float3(cosVal, -sinVal * normalizeDir); float3 tempAxisY = float3(0.0, normalizeDir.y, -normalizeDir.x); float3 tempAxisZ = float3(sinVal, cosVal * normalizeDir); axisX = tempAxisX; axisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ; axisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ; float3 newPositionBS = targetPosBS + axisX * positionBS.x; return newPositionBS; } //windDirection: object space, upVec: world upVec in object space void InitBendSpace(float3 windDirection, float3 upVec, out float3x3 objectToBend, out float3x3 bendToObject) { float3 u = windDirection; float3 v = normalize(cross(upVec, u)); float3 w = cross(u, v); //Object space to bend space objectToBend = float3x3(u, v, w); //Bend space to object space bendToObject = float3x3(u.x, v.x, w.x, u.y, v.y, w.y, u.z, v.z, w.z); } ENDHLSL SubShader { Tags{ \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\"} Pass { Name \"ForwardLit\" Tags{\"LightMode\" = \"UniversalForward\"} Cull Off Blend SrcAlpha OneMinusSrcAlpha ZWrite On HLSLPROGRAM #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" #pragma shader_feature_local _NORMALMAP #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING #pragma multi_compile _ SHADOWS_SHADOWMASK #pragma multi_compile_fragment _ _SHADOWS_SOFT #pragma multi_compile _ LIGHTMAP_ON #pragma vertex LitPassVert #pragma fragment LitPassFrag struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord0 : TEXCOORD0; float2 texcoord1 : TEXCOORD1; float2 texcoord2 : TEXCOORD2; float2 staticLightmapUV : TEXCOORD3; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float3 positionWS : TEXCOORD1; float3 normalWS : TEXCOORD2; float4 tangentWS : TEXCOORD3; float4 shadowCoord : TEXCOORD4; DECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, 5); UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; ////////////////////////////////// //GGX BRDF and related functions// ////////////////////////////////// float D(float ndoth, float roughness) { float a = ndoth * roughness; float k = roughness / (1.0 - ndoth * ndoth + a * a); return k * k; } float G(float ndotl, float ndotv, float roughness) { float a2 = roughness * roughness; float gv = ndotv * sqrt((1.0 - a2) * ndotl * ndotl + a2); float gl = ndotl * sqrt((1.0 - a2) * ndotv * ndotv + a2); return 0.5 * rcp(gv + gl); } float3 F(float3 specular, float hdotl) { return specular + (1 - specular) * pow(1 - hdotl, 5); } float3 GGXBRDF(float3 wi, float3 wo, float3 normal, float3 specular, float roughness) { float3 h = normalize(wi + wo); float ndotv = max(dot(normal, wo), 1e-5); float ndoth = max(dot(normal, h), 0.0); float ndotl = max(dot(normal, wi), 0.0); float hdotl = max(dot(h, wi), 0.0); float d = D(ndoth, roughness); float g = G(ndotl, ndotv, roughness); float3 f = F(specular, hdotl); return d * g * f; } Varyings LitPassVert(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_TRANSFER_INSTANCE_ID(input, output); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); //Pivot positions are stored in TEXCOORD1.xy and TEXCOORD2.x. float3 pivotPosition = float3(input.texcoord1.xy, input.texcoord2.x) * 0.01; float3 pointOffset = input.positionOS.xyz - pivotPosition; //Initialize Bend Space. float3 windDirectionOS = mul((float3x3)UNITY_MATRIX_I_M, _WindDirection.xyz); float3 upVec = mul((float3x3)UNITY_MATRIX_I_M, float3(0.0, 1.0, 0.0)); windDirectionOS = normalize(windDirectionOS); upVec = normalize(upVec); float3x3 objectToBend, bendToObject; InitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject); //Initialize vertex data, transform from object space to bend space. float3 pivotPositionBS = mul(objectToBend, pivotPosition); float3 pointOffsetBS = mul(objectToBend, pointOffset); float3 originalTangentBS = mul(objectToBend, input.tangentOS.xyz); float3 originalNormalBS = mul(objectToBend, input.normalOS); float3 windPointBS; float3 windTangentBS; float3 windNormalBS; //TEXCOORD2.y is used to check pivot layers. 0 is root layer. if(input.texcoord2.y \u003e 0.5) { ////////////////////////////////// //Calculate pivot root transform// ////////////////////////////////// //Get pivot wind intensity. float intensity = _WindIntensity; float magnitude = length(pivotPositionBS); intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay); //Calculate new position bent by wind in bend space, //and save the transform matrix. float3 axisX, axisY, axisZ; float3 windPivotPositionBS = CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ); float4x4 pivotBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), float4(0.0, 0.0, 0.0, 1.0)); ///////////////////////////// //Calculate point transform// ///////////////////////////// //Switch axes, transform to next bend space (point bend space). pointOffsetBS = float3(pointOffsetBS.z, pointOffsetBS.y, -pointOffsetBS.x); //Get point wind intensity. intensity = abs(axisZ.x) * _WindIntensity;//_WindIntensityLeaves; magnitude = length(pointOffsetBS); intensity += _WindVarietyLeaves * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelayLeaves); //Calculate new position bent by wind in bend space, //and save the transform matrix from point bend space to pivot bend space. //This transform matrix can be used to calculate normal and tangent. float3 windPointPositionBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ); float4x4 pointBSToPivotBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), float4(0.0, 0.0, 0.0, 1.0)); //Switch axes, transform to pivot bend space. windPointPositionBS = float3(-windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x); //Calculate position, normal and tangent in pivot bend space. float3 windPointPS = windPointPositionBS; float3 windTangentPS = mul((float3x3)pointBSToPivotBS, originalTangentBS); float3 windNormalPS = mul((float3x3)pointBSToPivotBS, originalNormalBS); //Calculate position, normal and tangent in object bend space. windPointBS = mul(pivotBSToObjBS, float4(windPointPS, 1.0)).xyz; windTangentBS = mul((float3x3)pivotBSToObjBS, windTangentPS); windNormalBS = mul((float3x3)pivotBSToObjBS, windNormalPS); } else { ////////////////////////////////// //Calculate point transform only// ////////////////////////////////// //Get point wind intensity. float intensity = _WindIntensity; float magnitude = length(pointOffsetBS); intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay); float3 axisX, axisY, axisZ; float3 windPointOffsetBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ); float4x4 pointBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), float4(0.0, 0.0, 0.0, 1.0)); windPointBS = windPointOffsetBS + pivotPositionBS; windTangentBS = mul((float3x3)pointBSToObjBS, originalTangentBS); windNormalBS = mul((float3x3)pointBSToObjBS, originalNormalBS); } //Transform from bend space to object space float3 pivotPositionOS = mul(bendToObject, windPointBS); float3 pivotTangentOS = mul(bendToObject, windTangentBS); float3 pivotNormalOS = mul(bendToObject, windNormalBS); VertexPositionInputs vertexInput = GetVertexPositionInputs(pivotPositionOS); VertexNormalInputs normalInput = GetVertexNormalInputs(pivotNormalOS, float4(pivotTangentOS, input.tangentOS.w)); output.positionCS = vertexInput.positionCS; output.uv = TRANSFORM_TEX(input.texcoord0, _BaseMap); output.positionWS = vertexInput.positionWS; output.normalWS = normalInput.normalWS; output.tangentWS = float4(normalInput.tangentWS, input.tangentOS.w); output.shadowCoord = TransformWorldToShadowCoord(vertexInput.positionWS); OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV); OUTPUT_SH(normalInput.normalWS.xyz, output.vertexSH); output.normalWS = normalInput.normalWS; return output; } float4 LitPassFrag(Varyings input, float vFace : VFACE) : SV_TARGET { UNITY_SETUP_INSTANCE_ID(input); UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); //wo float3 positionWS = input.positionWS; float3 viewDirWS = GetWorldSpaceNormalizeViewDir(positionWS); //wi float4 shadowCoord = TransformWorldToShadowCoord(positionWS); float4 shadowMask = SAMPLE_SHADOWMASK(input.staticLightmapUV); Light mainLight = GetMainLight(shadowCoord, positionWS, shadowMask); //normal float3 normalMap = UnpackNormal(tex2D(_BumpMap, input.uv)); normalMap.xy *= _BumpIntensity; float3 bitangentWS = cross(input.normalWS, input.tangentWS.xyz) * input.tangentWS.w; float3x3 tbn = float3x3(input.tangentWS.xyz, bitangentWS, input.normalWS); float3 normalWS = mul(normalMap, tbn); normalWS = normalize(input.normalWS); //If we are looking and back faces, revert the normal. normalWS = vFace \u003e 0.5 ? normalWS: -normalWS; //material properties float4 baseMap = tex2D(_BaseMap, input.uv) * _BaseColor; clip(baseMap.a - 0.5); float roughnessMap = tex2D(_RoughnessMap, input.uv).r; float roughness = max(roughnessMap * _RoughnessIntensity, 1e-2); float metallicMap = tex2D(_MetallicMap, input.uv).r; float metallic = metallicMap * _MetallicIntensity; float oneMinusReflectivity = kDieletricSpec.a * (1 - metallic); float reflectivity = 1.0 - oneMinusReflectivity; float3 diffuse = baseMap.rgb * oneMinusReflectivity; float3 specular = lerp(kDieletricSpec.rgb, baseMap.rgb, metallic); //gi float3 bakedGI = SAMPLE_GI(input.staticLightmapUV, input.vertexSH, normalWS); MixRealtimeAndBakedGI(mainLight, normalWS, bakedGI); float3 giDiffuse = bakedGI; float3 reflectVector = reflect(-viewDirWS, normalWS); float3 giSpecular = GlossyEnvironmentReflection(reflectVector, positionWS, roughness, 1.0); //directional lights float3 directDiffuse = diffuse; float3 directSpecular = GGXBRDF(mainLight.direction, viewDirWS, normalWS, specular, roughness); float ndotl = saturate(dot(mainLight.direction, normalWS)); float atten = mainLight.shadowAttenuation; //indirectional lights float3 indirectDiffse = giDiffuse * diffuse; float surfaceReduction = rcp(roughness * roughness + 1.0); float grazingTerm = saturate(1.0 - roughness + reflectivity); float ndotv = saturate(dot(normalWS, viewDirWS)); float fresnelTerm = pow(1.0 - ndotv, 5.0); float3 indirectSpecular = giSpecular * surfaceReduction * lerp(specular, grazingTerm, fresnelTerm); //final compose float3 directBRDF = (directDiffuse + directSpecular) * mainLight.color * atten * ndotl; float3 indirectBRDF = indirectDiffse + indirectSpecular; float3 finalColor = directBRDF + indirectBRDF; return float4(finalColor, baseMap.a); } ENDHLSL } Pass { Name \"ShadowCaster\" Tags{\"LightMode\" = \"ShadowCaster\"} HLSLPROGRAM #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\" #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment float3 _LightDirection; struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord0 : TEXCOORD0; float2 texcoord1 : TEXCOORD1; float2 texcoord2 : TEXCOORD2; float4 color : COLOR; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; }; Varyings ShadowPassVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_TRANSFER_INSTANCE_ID(input, output); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); float3 pivotPosition = float3(input.texcoord1.xy, input.texcoord2.x) * 0.01; float3 pointOffset = input.positionOS.xyz - pivotPosition; float3 windDirectionOS = mul((float3x3)UNITY_MATRIX_I_M, _WindDirection.xyz); float3 upVec = mul((float3x3)UNITY_MATRIX_I_M, float3(0.0, 1.0, 0.0)); windDirectionOS = normalize(windDirectionOS); upVec = normalize(upVec); float3x3 objectToBend, bendToObject; InitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject); float3 pivotPositionBS = mul(objectToBend, pivotPosition); float3 pointOffsetBS = mul(objectToBend, pointOffset); float3 originalTangentBS = mul(objectToBend, input.tangentOS.xyz); float3 originalNormalBS = mul(objectToBend, input.normalOS); float3 windPointBS; float3 windTangentBS; float3 windNormalBS; if(input.texcoord2.y \u003e 0.5) { float intensity = _WindIntensity; float magnitude = length(pivotPositionBS); intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay); float3 axisX, axisY, axisZ; float3 windPivotPositionBS = CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ); float4x4 pivotBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), float4(0.0, 0.0, 0.0, 1.0)); pointOffsetBS = float3(pointOffsetBS.z, pointOffsetBS.y, -pointOffsetBS.x); intensity = abs(axisZ.x) * _WindIntensity;//_WindIntensityLeaves; magnitude = length(pointOffsetBS); intensity += _WindVarietyLeaves * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelayLeaves); float3 windPointPositionBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ); float4x4 pointBSToPivotBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), float4(0.0, 0.0, 0.0, 1.0)); windPointPositionBS = float3(-windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x); float3 windPointPS = windPointPositionBS; float3 windTangentPS = mul((float3x3)pointBSToPivotBS, originalTangentBS); float3 windNormalPS = mul((float3x3)pointBSToPivotBS, originalNormalBS); windPointBS = mul(pivotBSToObjBS, float4(windPointPS, 1.0)).xyz; windTangentBS = mul((float3x3)pivotBSToObjBS, windTangentPS); windNormalBS = mul((float3x3)pivotBSToObjBS, windNormalPS); } else { float intensity = _WindIntensity; float magnitude = length(pointOffsetBS); intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay); float3 axisX, axisY, axisZ; float3 windPointOffsetBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ); float4x4 pointBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), float4(0.0, 0.0, 0.0, 1.0)); windPointBS = windPointOffsetBS + pivotPositionBS; windTangentBS = mul((float3x3)pointBSToObjBS, originalTangentBS); windNormalBS = mul((float3x3)pointBSToObjBS, originalNormalBS); } float3 pivotPositionOS = mul(bendToObject, windPointBS); float3 pivotTangentOS = mul(bendToObject, windTangentBS); float3 pivotNormalOS = mul(bendToObject, windNormalBS); VertexPositionInputs vertexInput = GetVertexPositionInputs(pivotPositionOS); VertexNormalInputs normalInput = GetVertexNormalInputs(pivotNormalOS, float4(pivotTangentOS, input.tangentOS.w)); output.uv = TRANSFORM_TEX(input.texcoord0, _BaseMap); output.positionCS = TransformWorldToHClip(ApplyShadowBias(vertexInput.positionWS, normalInput.normalWS, _LightDirection)); return output; } half4 ShadowPassFragment(Varyings input) : SV_TARGET { return 0.0; } ENDHLSL } Pass { Name \"DepthOnly\" Tags{\"LightMode\" = \"DepthOnly\"} HLSLPROGRAM #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment struct Attributes { float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; float4 color : COLOR; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; Varyings DepthOnlyVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS); output.uv = input.texcoord; output.positionCS = vertexInput.positionCS; return output; } half4 DepthOnlyFragment(Varyings input) : SV_TARGET { return 0.0; } ENDHLSL } Pass { Name \"Meta\" Tags{\"LightMode\" = \"Meta\"} HLSLPROGRAM #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\" #pragma vertex MetaVertex #pragma fragment MetaFragment struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float2 uv2 : TEXCOORD2; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; }; Varyings MetaVertex(Attributes input) { Varyings output; output.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST); output.uv = TRANSFORM_TEX(input.uv0, _BaseMap); return output; } half4 MetaFragment(Varyings input) : SV_Target { //material properties float4 baseMap = tex2D(_BaseMap, input.uv); float roughnessMap = tex2D(_RoughnessMap, input.uv).r; float roughness = max(roughnessMap * _RoughnessIntensity, 1e-2); float metallicMap = tex2D(_MetallicMap, input.uv).r; float metallic = metallicMap * _MetallicIntensity; float oneMinusReflectivity = kDieletricSpec.a * (1 - metallic); float reflectivity = 1.0 - oneMinusReflectivity; float3 diffuse = baseMap.rgb * oneMinusReflectivity; float3 specular = lerp(kDieletricSpec.rgb, baseMap.rgb, metallic); MetaInput metaInput; metaInput.Albedo = diffuse; metaInput.SpecularColor = specular; metaInput.Emission = 0; return MetaFragment(metaInput); } ENDHLSL } } } åç»­çš„æ€è€ƒ é¦–å…ˆå…ˆè®²å¥½çš„æ–¹é¢ï¼Œé£å¹åŠ¨çš„æ•ˆæœç¡®å®ååˆ†è‡ªç„¶ï¼ŒåŒæ ·çš„è®¡ç®—å‡ºçš„æ­£ç¡®çš„æ³•çº¿åœ¨PBRçš„æ¸²æŸ“ä¸­ä¹Ÿååˆ†é‡è¦ï¼ˆé¡¶ç‚¹åŠ¨ç”»ä¸­æ­£ç¡®çš„æ³•çº¿å°¤å…¶ä¸æ˜“ï¼ï¼‰ã€‚ä½†æ˜¯ä¸è¶³ä¹‹å¤„æ˜¯çŸ©é˜µè¿ç®—è¿‡å¤šäº†ï¼Œä¸è¿‡çŸ©é˜µè¿ç®—å…¨éƒ½åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œæ¶ˆè€—ä¹Ÿä¸æ˜¯ç‰¹åˆ«å¤§ã€‚å¤ªå¤šçš„çŸ©é˜µè¿ç®—ä¹Ÿå¯¼è‡´äº†è¿™ç§ç®—æ³•çš„æ‰©å±•æ€§ä¸æ˜¯å¾ˆå¥½ï¼Œå¦‚æœæƒ³è¦æœ‰Pivot Layerä¸º3çš„é¡¶ç‚¹ï¼Œåœ¨ç›®å‰çš„ç®—æ³•é‡Œé¢æ˜¯æ²¡åŠæ³•è®¡ç®—çš„ï¼Œä¹Ÿä¸çŸ¥é“é¡½çš®ç‹—æ˜¯æ€ä¹ˆåšçš„äº†ã€‚åœ¨æ¨¡å‹çš„å½¢çŠ¶ä¸æ˜¯ç‰¹åˆ«å¥½çš„æ—¶å€™ï¼Œæ¯”å¦‚ä¸€ä¸ªquadæ¥æ¸²æŸ“è‰ï¼Œæˆ–è€…æ˜¯æ¨¡å‹å¶å­æ­ªæ­ªæ‰­æ‰­çš„ï¼Œä¼šæœ‰æ¯”è¾ƒå¤§çš„å˜å½¢ã€‚ä¸è¿‡ä»”ç»†è®¾ç½®æ¯ä¸€ä¸ªé¡¶ç‚¹çš„Pivotçš„è¯ï¼Œåº”è¯¥è¿˜æ˜¯èƒ½å¤Ÿè§£å†³ä¸€éƒ¨åˆ†é—®é¢˜çš„ï¼Œå½“ç„¶æ‹™åŠ£çš„Mayaè„šæœ¬åˆæˆäº†ä¸€ä¸ªç—›ç‚¹ã€‚\næ€»çš„æ¥è¯´æˆ‘è¿˜æ˜¯æ¯”è¾ƒæ»¡æ„çš„ï¼Œä¹Ÿç®—æ˜¯è§£å†³äº†ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„é—®é¢˜ï¼Œå½“ç„¶äº†ï¼Œæˆ‘å¯¹hugoèƒ½å¤Ÿæ”¯æŒgifå›¾ç‰‡æ›´åŠ æ»¡æ„ï¼\n","wordCount":"2794","inLanguage":"en","image":"https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/posts/images/VertexAnimatedPlant.gif","datePublished":"2022-01-06T12:00:00+08:00","dateModified":"2022-01-06T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©</h1><div class=post-description>åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹.</div><div class=post-meta><span title='2022-01-06 12:00:00 +0800 CST'>January 6, 2022</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/create-plant-swaying-in-wind-using-vertex-animation.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/VertexAnimatedPlant.gif alt="Vertex Animated Plant Cover"><p>Vertex Animated Plant</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba%e5%92%8c%e6%83%b3%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%9a%84%e6%95%88%e6%9e%9c aria-label=åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ>åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ</a></li><li><a href=#%e9%9a%be%e7%82%b9%e5%92%8c%e7%9b%b8%e5%af%b9%e5%ba%94%e7%9a%84%e5%ba%94%e5%af%b9%e6%96%b9%e6%b3%95 aria-label=éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•>éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•</a><ul><li><a href=#unity%e7%9a%84%e9%a1%b6%e7%82%b9%e8%89%b2%e9%99%90%e5%88%b6 aria-label=Unityçš„é¡¶ç‚¹è‰²é™åˆ¶>Unityçš„é¡¶ç‚¹è‰²é™åˆ¶</a><ul><li><a href=#vertexpivotwritetoolpy aria-label=VertexPivotWriteTool.py>VertexPivotWriteTool.py</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%ae%a1%e7%ae%97%e6%8b%89%e4%bc%b8%e8%be%83%e5%b0%8f%e7%9a%84%e9%a3%8e%e7%9a%84%e6%95%88%e6%9e%9c%e5%b9%b6%e4%b8%94%e8%ae%a1%e7%ae%97%e5%af%b9%e5%ba%94%e7%9a%84%e6%b3%95%e7%ba%bf aria-label=å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿>å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿</a><ul><li><a href=#winddebuggercs aria-label=WindDebugger.cs>WindDebugger.cs</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98 aria-label=å…¶ä»–çš„ä¸€äº›é—®é¢˜>å…¶ä»–çš„ä¸€äº›é—®é¢˜</a></li></ul></li><li><a href=#%e5%85%b7%e4%bd%93%e4%bb%a3%e7%a0%81%e5%92%8c%e7%9b%b8%e5%85%b3%e7%9a%84%e6%80%9d%e8%80%83 aria-label=å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ>å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ</a><ul><li><a href=#vertexanimationplantshadershader aria-label=VertexAnimationPlantShader.shader>VertexAnimationPlantShader.shader</a></li></ul></li><li><a href=#%e5%90%8e%e7%bb%ad%e7%9a%84%e6%80%9d%e8%80%83 aria-label=åç»­çš„æ€è€ƒ>åç»­çš„æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ>åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ>#</a></h2><p>æœ€ç›´æ¥çš„åŠ¨æœºæ˜¯çœ‹äº†é¡½çš®ç‹—åœ¨Siggraph 2016ä¸Šçš„<a href=http://advances.realtimerendering.com/other/2016/naughty_dog/index.html>PPT</a>ï¼Œé‡Œé¢ä»‹ç»äº†é¡½çš®ç‹—åœ¨ç¥ç§˜æµ·åŸŸä¸­æ˜¯å¦‚ä½•è®©æ¤è¢«éšé£é£˜è¡çš„ã€‚ä»–ä»¬ä»‹ç»äº†ä¸€ç§å°†æ¤è¢«çš„æ¯ä¸€éƒ¨åˆ†çš„pivotçš„ç‰©ä½“ç©ºé—´åæ ‡å†™åˆ°é¡¶ç‚¹è‰²é‡Œï¼Œç„¶ååœ¨shaderä¸­ä½¿ç”¨è¿™ä¸ªåæ ‡è¿›è¡Œé£çš„æ•ˆæœçš„è®¡ç®—çš„æ–¹æ³•ã€‚è¾ƒä¸ºéœ‡æ’¼åœ¨é£å¹è¿‡è‰åŸæ—¶ï¼Œæ¤è¢«è¿›è¡Œå¼¯æ›²åï¼Œè‰è¡¨é¢çš„é«˜å…‰ä¼šæœ‰ä¸€ç§æ—¶ç©ºä¸Šçš„èµ·ä¼æ„Ÿï¼ˆä¹Ÿå°±æ˜¯è¯´ç¥ç§˜æµ·åŸŸçš„æ¤è¢«çš„æ³•çº¿ä¹Ÿä¼šè¢«é£å½±å“ï¼‰ã€‚æ‰€ä»¥æˆ‘ä¹Ÿæƒ³è¦å€ŸåŠ©å†™pivotçš„æ–¹æ³•æ¥åˆ¶ä½œæ¤è¢«å—åˆ°é£å¹çš„æ•ˆæœï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•è®¡ç®—å‡ºæ­£ç¡®çš„é£å¹ä¹‹åçš„æ¤è¢«çš„æ³•çº¿ï¼ˆåŒæ—¶ç”±äºæ³•çº¿è´´å›¾çš„å­˜åœ¨ï¼Œè¿˜è¦è®¡ç®—æ­£ç¡®çš„åˆ‡çº¿ï¼‰ã€‚</p><p>ç¨å¾®ç¿»äº†ä¸€ä¸‹ç½‘ä¸Šçš„èµ„æ–™ï¼ˆä¹Ÿæ²¡ä»”ç»†åœ°å»æœç´¢ï¼‰ï¼Œå¤§éƒ¨åˆ†çš„å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„é¡¶ç‚¹åŠ¨ç”»ï¼Œæœ‰çš„æ˜¯ç”¨çš„sinï¼Œæœ‰çš„å°±ç›´æ¥å¹³ç§»ã€‚è¿™å°±äº§ç”Ÿäº†ç¬¬äºŒä¸ªéœ€æ±‚ï¼Œæ¤è¢«åœ¨é¡¶ç‚¹åŠ¨ç”»ä¸­åº”è¯¥ä¿æŒå·®ä¸å¤šçš„é•¿åº¦ï¼Œä¸ç„¶ä¼šå‘ç°å¾ˆæ˜æ˜¾çš„æ‹‰ä¼¸çš„æ•ˆæœã€‚</p><p>å½“ç„¶æœ€å¥½è¿˜èƒ½æŠ•å°„å‡ºæ­£å¸¸çš„å½±å­äº†ï¼Œè¿™ä¸€æ­¥åªéœ€è¦æŠŠé¡¶ç‚¹ç€è‰²å™¨å¤åˆ¶ä¸€ä»½åˆ°æŠ•å°„å½±å­çš„passé‡Œå°±å¯ä»¥äº†ã€‚</p><p>è¿™é‡Œä½¿ç”¨çš„æ¤è¢«æ¨¡å‹æ˜¯MegaScansä¸Šçš„<a href="https://quixel.com/megascans/home?assetId=selnS">CORDYLINE</a>æ¨¡å‹ä¸­çš„var12è¿™ä¸ªå°æ¨¡å‹ã€‚</p><h2 id=éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•>éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•>#</a></h2><h3 id=unityçš„é¡¶ç‚¹è‰²é™åˆ¶>Unityçš„é¡¶ç‚¹è‰²é™åˆ¶<a hidden class=anchor aria-hidden=true href=#unityçš„é¡¶ç‚¹è‰²é™åˆ¶>#</a></h3><p>ç¨å¾®æµ‹è¯•ä¸€ä¸‹å°±èƒ½å‘ç°ï¼ŒUnityçš„é¡¶ç‚¹è‰²æ˜¯<code>UNorm8</code>çš„æ ¼å¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºä½ åœ¨Mayaæˆ–æ˜¯3ds Maxé‡Œå¯¼å‡ºçš„æ¨¡å‹çš„é¡¶ç‚¹è‰²ä¿¡æ¯æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå¯¼å…¥åˆ°Unityä¸­å°±ä¼šå˜æˆåªæœ‰256ç²¾åº¦çš„<code>UNorm8</code>ã€‚é¡½çš®ç‹—ä½¿ç”¨çš„æ˜¯è‡ªå·±çš„å¼•æ“ï¼Œæ‰€ä»¥å®ƒä»¬èƒ½å¤Ÿä½¿ç”¨å…¨ç²¾åº¦çš„é¡¶ç‚¹è‰²ï¼Œä½†æ˜¯ç”±äºUnityçš„å¼•æ“é™åˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘åˆ°å¯¼å‡ºpivotçš„é¡¶ç‚¹åæ ‡åˆ°æ¨¡å‹çš„UVä¸­ã€‚</p><p>ä½†æ˜¯å¾ˆä¸å¹¸çš„æ˜¯ï¼Œfbxå¯¼å…¥åˆ°Unityæ—¶ï¼Œå³ä½¿UVæ˜¯<code>float4</code>çš„ç±»å‹ï¼ˆä¹Ÿå°±æ˜¯16bytes)ï¼Œåœ¨Unityä¸­åªä¼šè¯†åˆ«UVçš„å‰ä¸¤ä½ã€‚æ‰€ä»¥åªèƒ½æ— å¥ˆçš„å°†pivotçš„é¡¶ç‚¹åæ ‡ï¼ˆ<code>float3</code>çš„æ•°æ®ï¼‰å‚¨å­˜åˆ°ä¸¤ä¸ªUVçš„ä¸‰ä¸ªé€šé“é‡Œï¼ŒåŒæ—¶å°†pivotçš„å±‚çº§å­˜åˆ°å‰©ä¸‹çš„ä¸€ä¸ªé€šé“é‡Œã€‚æˆ‘ä¸çŸ¥é“é¡½çš®ç‹—å…·ä½“æ˜¯æ€ä¹ˆè®¡ç®—pivotçš„å±‚çº§å…³ç³»çš„ï¼Œä»–åœ¨PPTä¸­å†™çš„æ˜¯æ— éœ€è®¡ç®—ï¼Œä½†æˆ‘åœ¨å®é™…æ“ä½œä¸­åªèƒ½ä¸€å±‚ä¸€å±‚çš„ç®—ï¼ˆè€Œä¸”åªèƒ½ç®—ä¸¤å±‚ï¼‰ï¼Œä¹Ÿå¸Œæœ›çŸ¥é“å…·ä½“æ€ä¹ˆæ“ä½œçš„äººå‘ŠçŸ¥ä¸€ä¸‹æ–¹æ³•ã€‚</p><p>æ‰€ä»¥æ¥ä¸‹æ¥è¦åšçš„æ˜¯åœ¨Mayaä¸­æŠŠpivotçš„ç‰©ä½“ç©ºé—´åæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°å¯¹åº”é¡¶ç‚¹çš„æŸä¸¤å¥—UVä¸­ï¼Œæœ¬æ–‡æ˜¯å†™åˆ°ç¬¬äºŒå¥—å’Œç¬¬ä¸‰å¥—UVä¸­ï¼ˆä¹Ÿå°±æ˜¯<code>TEXCOORD1</code>å’Œ<code>TEXCOORD2</code>ï¼‰ã€‚äºæ˜¯æˆ‘æ¶è¡¥äº†ä¸€ä¸‹mayaçš„pythonè„šæœ¬çš„å†™æ³•ï¼Œä¸è¿‡åœ¨å†™æ•°å€¼åˆ°UVä¸­æ—¶ï¼Œåˆé‡åˆ°äº†ä¸€ä¸ªå°é—®é¢˜ã€‚Mayaçš„<code>cmds.polyEditUV</code>è¿™ä¸ªæ–¹æ³•ï¼Œæ˜æ˜èƒ½ä¼ å…¥<code>uvSetName</code>è¿™ä¸ªå‚æ•°ï¼Œç”¨äºæ“ä½œå¯¹åº”çš„UVï¼Œä½†æˆ‘å®é™…ä½¿ç”¨æ—¶åªèƒ½å†™æ•°å€¼åˆ°å½“å‰çš„UVä¸­ï¼Œå¯¼è‡´æœ€åå†™çš„è„šæœ¬åªèƒ½åƒµç¡¬çš„æ“ä½œå½“å‰UVï¼Œæ¯æ¬¡åˆ‡æ¢UVæ—¶éœ€è¦é‡æ–°ä¿®æ”¹è„šæœ¬å†è¿è¡Œä¸€æ¬¡ã€‚</p><p>æœ€ç»ˆçš„è„šæœ¬æ˜¯è¿™æ ·çš„ï¼š</p><h4 id=vertexpivotwritetoolpy>VertexPivotWriteTool.py<a hidden class=anchor aria-hidden=true href=#vertexpivotwritetoolpy>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#f92672>import</span> maya.cmds <span style=color:#66d9ef>as</span> cmds
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>targetVertexStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Select any vertex to start.&#34;</span>
</span></span><span style=display:flex><span>vertexColorStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Select any vertex to start.&#34;</span>
</span></span><span style=display:flex><span>pivotPosition <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ui</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cmds<span style=color:#f92672>.</span>window(<span style=color:#e6db74>&#34;VertexPivotWriteTool&#34;</span>, exists <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>        cmds<span style=color:#f92672>.</span>deleteUI(<span style=color:#e6db74>&#34;VertexPivotWriteTool&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> targetVertexStr
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> targetVertexField
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> vertexColorStr
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> vertexColorField
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> pivotLayer
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vertexPivotWindow <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>window(<span style=color:#e6db74>&#34;VertexPivotWriteTool&#34;</span>, widthHeight <span style=color:#f92672>=</span> [<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>400</span>])
</span></span><span style=display:flex><span>    form <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>formLayout(numberOfDivisions <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pivotLayerLable <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>text(<span style=color:#e6db74>&#34;Pivot Layer (0 for root pivot)&#34;</span>)
</span></span><span style=display:flex><span>    pivotLayer <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>intField()
</span></span><span style=display:flex><span>    cmds<span style=color:#f92672>.</span>intField(pivotLayer, e <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>, minValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, maxValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, step <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, value <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    targetVertexButton <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>button(<span style=color:#e6db74>&#34;Target Vertex&#34;</span>, command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GetTargetVertex()&#39;</span>)
</span></span><span style=display:flex><span>    targetVertexField <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>textField(text<span style=color:#f92672>=</span>targetVertexStr, width <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#writeVertexButton = cmds.button(&#34;Write to Vertex Color&#34;, command = &#39;WriteToVertexColor()&#39;)</span>
</span></span><span style=display:flex><span>    writeVertexButton <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>button(<span style=color:#e6db74>&#34;Write to Vertex Texcoord&#34;</span>, command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;WriteToVertexTexcoord()&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    targetVertexColorButton <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>button(<span style=color:#e6db74>&#34;Show Vertex Color&#34;</span>, command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GetTargetVertexColor()&#39;</span>)
</span></span><span style=display:flex><span>    vertexColorField <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>textField(text<span style=color:#f92672>=</span>vertexColorStr, width <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cmds<span style=color:#f92672>.</span>showWindow(vertexPivotWindow)
</span></span><span style=display:flex><span>    cmds<span style=color:#f92672>.</span>formLayout(form, e<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, attachForm <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        [pivotLayerLable, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [pivotLayerLable, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>20</span>],
</span></span><span style=display:flex><span>        [pivotLayer, <span style=color:#e6db74>&#39;right&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [pivotLayer, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>20</span>],
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        [targetVertexButton, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [targetVertexButton, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>60</span>],
</span></span><span style=display:flex><span>        [targetVertexField, <span style=color:#e6db74>&#39;right&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [targetVertexField, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>60</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        [writeVertexButton, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [writeVertexButton, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>100</span>],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        [targetVertexColorButton, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [targetVertexColorButton, <span style=color:#e6db74>&#39;bottom&#39;</span>, <span style=color:#ae81ff>20</span>],
</span></span><span style=display:flex><span>        [vertexColorField, <span style=color:#e6db74>&#39;right&#39;</span>, <span style=color:#ae81ff>25</span>],
</span></span><span style=display:flex><span>        [vertexColorField, <span style=color:#e6db74>&#39;bottom&#39;</span>, <span style=color:#ae81ff>20</span>],
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    ))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GetPivotLayer</span>():
</span></span><span style=display:flex><span>    value <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>intField(pivotLayer, q<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, value<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;pivotLayerValue is: &#34;</span> <span style=color:#f92672>+</span> str(value))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GetTargetVertex</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Get Target Vertex...&#34;</span>)
</span></span><span style=display:flex><span>    selVertices <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>ls(selection <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> targetVertexStr
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> pivotPosition
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(selVertices) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        targetVertexStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;No vetex selected!&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> len(selVertices) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        targetVertexStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Too many vertices selected! Expected 1, got &#34;</span> <span style=color:#f92672>+</span> str(len(selVertices))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        pivotPosition <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>pointPosition(selVertices[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>        tempStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;(&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> axis <span style=color:#f92672>in</span> range(len(pivotPosition)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> axis <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;, &#34;</span>
</span></span><span style=display:flex><span>            tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:.2f}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(pivotPosition[axis])
</span></span><span style=display:flex><span>        tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;)&#34;</span>    
</span></span><span style=display:flex><span>        targetVertexStr <span style=color:#f92672>=</span> tempStr
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cmds<span style=color:#f92672>.</span>textField(targetVertexField, e<span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>, text <span style=color:#f92672>=</span> targetVertexStr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GetTargetVertexColor</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Get Target Vertex...&#34;</span>)
</span></span><span style=display:flex><span>    selVertices <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>ls(selection <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> vertexColorStr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(selVertices) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        vertexColorStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;No vetex selected!&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> len(selVertices) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        vertexColorStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Too many vertices selected! Expected 1, got &#34;</span> <span style=color:#f92672>+</span> str(len(selVertices))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        vertexColor <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>polyColorPerVertex(query<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, rgb<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        tempStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;(&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> axis <span style=color:#f92672>in</span> range(len(vertexColor)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> axis <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;, &#34;</span>                
</span></span><span style=display:flex><span>            tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:.2f}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(vertexColor[axis])
</span></span><span style=display:flex><span>        tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;)&#34;</span>    
</span></span><span style=display:flex><span>        vertexColorStr <span style=color:#f92672>=</span> tempStr
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cmds<span style=color:#f92672>.</span>textField(vertexColorField, e<span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>, text <span style=color:#f92672>=</span> vertexColorStr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>WriteToVertexColor</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Write To Vertex Color...&#34;</span>)
</span></span><span style=display:flex><span>    selVertices <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>ls(selection <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> selVertices:
</span></span><span style=display:flex><span>        cmds<span style=color:#f92672>.</span>polyColorPerVertex(vertex, rgb<span style=color:#f92672>=</span>(pivotPosition[<span style=color:#ae81ff>0</span>], pivotPosition[<span style=color:#ae81ff>1</span>], pivotPosition[<span style=color:#ae81ff>2</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>WriteToVertexTexcoord</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Write To Vertex Coord...&#34;</span>)
</span></span><span style=display:flex><span>    pivotLayerValue <span style=color:#f92672>=</span> GetPivotLayer()
</span></span><span style=display:flex><span>    allUVSets <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>polyUVSet( query<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, allUVSets<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span> )
</span></span><span style=display:flex><span>    uvSetCount <span style=color:#f92672>=</span> len(allUVSets)
</span></span><span style=display:flex><span>    cmds<span style=color:#f92672>.</span>polyEditUV(relative <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, uValue <span style=color:#f92672>=</span> pivotPosition[<span style=color:#ae81ff>0</span>], vValue <span style=color:#f92672>=</span> pivotPosition[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    <span style=color:#75715e>#cmds.polyEditUV(relative = False, uValue = pivotPosition[2], vValue = pivotLayerValue)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ui()
</span></span></code></pre></div><p><img loading=lazy src=../images/VertexPivotWriteTool.jpg#center alt="Vertex Pivot Write Tool"></p><p>å› ä¸ºç§ç§é™åˆ¶ï¼Œä½¿ç”¨æ—¶è¾ƒä¸ºå¤æ‚ï¼Œå¦‚æœæœ‰æ›´å¥½çš„è„šæœ¬çš„è¯ï¼Œä¹Ÿå¾ˆæ„Ÿè°¢åˆ†äº«å‡ºæ¥å‘Šè¯‰æˆ‘ã€‚é¦–å…ˆæ˜¯è¦åœ¨<code>UVé›†ç¼–è¾‘å™¨</code>ä¸­ï¼Œä¸ºæ¨¡å‹æ–°å¢ä¸¤å¥—UVï¼Œç”±äºä½¿ç”¨çš„MegaScansæ¨¡å‹æœ¬èº«æœ‰ä¸¤å¥—ä¸åŒçš„UVï¼Œæ“ä½œæ˜¯æŠŠåŸæ¥çš„ç¬¬äºŒå¥—UVç§»åŠ¨åˆ°ç¬¬å››å¥—UVä¸­ï¼Œç„¶åæŠŠç¬¬ä¸€å¥—UVå¤åˆ¶åˆ°ç¬¬äºŒç¬¬ä¸‰å¥—UVä¸­ï¼Œç„¶ååœ¨<code>UVç¼–è¾‘å™¨</code>ä¸­å®šä½å½“å‰UVåˆ°ç¬¬äºŒå¥—UVã€‚åœ¨è„šæœ¬ç¼–è¾‘å™¨ä¸­æ‰“å¼€æˆ–è€…å¤åˆ¶ä¸Šé¢çš„<code>VertexPivotWriteTool.py</code>ï¼Œé€šè¿‡<code>Crtl + Enter</code>å¯ä»¥ç”Ÿæˆè¯¥è„šæœ¬çš„ä¸€ä¸ªçª—å£ã€‚ç„¶åæ‰§è¡Œä¸‹è¿°æ“ä½œï¼šé¦–å…ˆæ˜¯å°†æ¯ä¸ªpivotçš„å‰ä¸¤ä¸ªåæ ‡å†™åˆ°ç¬¬äºŒå¥—UVä¸­ï¼Œå¯¹èŒæ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€åº•ä¸‹çš„é¡¶ç‚¹ï¼Œå¯¹å¶ç‰‡æ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€æ¥è¿‘èŒçš„é¡¶ç‚¹ï¼Œé€‰ä¸­è¿™ä¸ªé¡¶ç‚¹ç„¶åç‚¹å‡»<code>Target Vertex</code>ï¼Œåœ¨çª—å£ä¸­å¯ä»¥çœ‹åˆ°è¿™ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼›ç„¶ååœ¨<code>UVç¼–è¾‘å™¨</code>é€‰ä¸­è¯¥èŒæˆ–è€…å¶ç‰‡çš„UVå£³ï¼Œç‚¹å‡»<code>Write to Vertex Texcoord</code>ï¼Œåœ¨<code>UVç¼–è¾‘å™¨</code>ä¸­å¯ä»¥çœ‹åˆ°UVåç¼©æˆäº†ä¸€ä¸ªç‚¹ï¼ˆå¾€å¾€æ‰¾ä¸åˆ°ï¼‰ï¼›å¯¹ç¬¬äºŒå¥—UVä¸­çš„æ‰€æœ‰çš„UVå£³æ‰§è¡Œä¸Šè¿°æ“ä½œï¼›ç„¶åå°†å½“å‰UVåˆ‡æ¢åˆ°ç¬¬ä¸‰å¥—UVï¼ŒåŒæ—¶æ³¨é‡Šæ‰è„šæœ¬çš„ç¬¬117è¡Œï¼Œå–æ¶ˆæ³¨é‡Šè„šæœ¬çš„ç¬¬118è¡Œï¼Œç„¶åè¾“å…¥<code>Crtl + Enter</code>é‡æ–°ç”Ÿæˆä¸€éå·¥å…·ï¼›è¿™æ—¶æˆ‘ä»¬å°†è¦æŠŠæ¯ä¸ªpivotçš„æœ€åä¸€ä¸ªåæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°ç¬¬ä¸‰å¥—UVä¸­ï¼›å¯¹æ¤è¢«çš„æ¯ä¸€ç‰‡å¶å­å’Œæå¹²ï¼Œåˆ¤æ–­å…¶pivotçš„å±‚çº§ï¼ˆä»¥ç°åœ¨ä½¿ç”¨çš„MegaScansæ¨¡å‹ä¸ºä¾‹ï¼ŒèŒçš„å±‚çº§æ˜¯0ï¼Œå…¶ä»–å¶ç‰‡çš„å±‚çº§æ˜¯1ï¼‰ï¼Œåœ¨Pivot Layerä¸­è¾“å…¥å±‚çº§ï¼›ç„¶åé‡å¤åˆ¤æ–­å±‚çº§ï¼Œé€‰æ‹©é¡¶ç‚¹ï¼Œå†™å…¥UVï¼›æœ€åæœ€åï¼Œä¸è¦å¿˜è®°æŠŠè„šæœ¬è¿˜åŸæˆæœ€å¼€å§‹çš„æ ·å­ã€‚è¿™æ ·å°±æŠŠæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„pivotåæ ‡å†™å…¥åˆ°ç¬¬äºŒå’Œç¬¬ä¸‰å¥—UVäº†ï¼å¯¼å‡ºåˆ°Unityå°±å¯ä»¥äº†ã€‚</p><h3 id=å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿>å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿<a hidden class=anchor aria-hidden=true href=#å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿>#</a></h3><p>é¦–å…ˆæ¥çœ‹è¿™æ ·ä¸€å¼ å›¾ï¼š</p><p><img loading=lazy src=../images/CircleTransformDiagram.jpg#center alt="Circle Transform Diagram"></p><p>è¿™å¼ å›¾è¡¨ç°äº†åœ¨Bend Spaceä¸­æŠŠçº¢è‰²çš„çº¿æ®µå¼¯æ›²åˆ°ç»¿è‰²çº¿æ®µçš„ç®—æ³•ï¼ŒXè½´æ˜¯é£çš„æ–¹å‘ï¼Œå¯ä»¥çœ‹åˆ°é£çš„å¼ºåº¦è¶Šé«˜ï¼ŒRadiusçš„å¤§å°å°±è¶Šå°ã€‚åŒæ—¶ä¸ºäº†è®¡ç®—å‡ºæ­£ç¡®çš„æ³•çº¿å’Œåˆ‡çº¿ï¼Œéœ€è¦åŒæ ·çš„è®¡ç®—å‡ºAxisXå’ŒAxisZåœ¨Bend Spaceä¸­çš„å‘é‡ã€‚ä½¿ç”¨è¿™ä¸ªç®—æ³•ï¼Œå½“æ¨¡å‹å¤„åœ¨Bend Spaceçš„Zè½´ä¸Šæ—¶ï¼Œä¸ä¼šå—åˆ°æ‰­æ›²ï¼Œå½“å…¶Xè½´å¤§äº0æ—¶ï¼Œä¼šå—åˆ°å‹ç¼©ï¼Œå½“Xè½´å°äº0æ—¶ï¼Œä¼šå—åˆ°æ‹‰ä¼¸ã€‚åŒæ ·çš„ï¼Œè¿™ç§ç®—æ³•å¯ä»¥æ¨å¹¿åˆ°ä¸‰ç»´ç©ºé—´ä¸­ï¼ŒåŒæ—¶æ‰­æ›²Yè½´å’ŒZè½´ï¼Œæˆ‘ç‰¹åœ°å†™äº†ä¸€ä¸ªC#è„šæœ¬æ¥å¯¹å˜æ¢çš„ç»“æœè¿›è¡Œå¯è§†åŒ–ã€‚</p><h4 id=winddebuggercs>WindDebugger.cs<a hidden class=anchor aria-hidden=true href=#winddebuggercs>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Mathematics;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WindDebugger</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> draw = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> debugRadius = <span style=color:#ae81ff>0.01f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> debugLength = <span style=color:#ae81ff>0.2f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Color pivotColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Color sphereColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> radius;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> float3 originalPosition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DrawAxes(Color color, Vector3 pos, Vector3 tangent, Vector3 bitangent, Vector3 normal)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Gizmos.color = color;
</span></span><span style=display:flex><span>        Gizmos.DrawSphere(pos, debugRadius);
</span></span><span style=display:flex><span>        Gizmos.color = Color.red;
</span></span><span style=display:flex><span>        Gizmos.DrawLine(pos, pos + tangent * debugLength);
</span></span><span style=display:flex><span>        Gizmos.color = Color.green;
</span></span><span style=display:flex><span>        Gizmos.DrawLine(pos, pos + bitangent * debugLength);
</span></span><span style=display:flex><span>        Gizmos.color = Color.blue;
</span></span><span style=display:flex><span>        Gizmos.DrawLine(pos, pos + normal * debugLength);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> float3 CircleTransform(float3 positionBS, <span style=color:#66d9ef>float</span> radius, <span style=color:#66d9ef>out</span> float3 axisX, <span style=color:#66d9ef>out</span> float3 axisY, <span style=color:#66d9ef>out</span> float3 axisZ)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> radVal = math.length(positionBS.xy) / radius;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sinVal = math.sin(radVal);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> cosVal = math.cos(radVal);
</span></span><span style=display:flex><span>        float2 normalizeDir = math.normalize(positionBS.xy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        float3 targetPosBS = <span style=color:#66d9ef>new</span> float3((radius * sinVal) * normalizeDir, radius - radius * cosVal);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        float3 tempAxisX = <span style=color:#66d9ef>new</span> float3(-sinVal * normalizeDir, cosVal);
</span></span><span style=display:flex><span>        float3 tempAxisY = <span style=color:#66d9ef>new</span> float3(normalizeDir.y, -normalizeDir.x, <span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>        float3 tempAxisZ = <span style=color:#66d9ef>new</span> float3(cosVal * normalizeDir, sinVal);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        axisX = tempAxisX;
</span></span><span style=display:flex><span>        axisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ;
</span></span><span style=display:flex><span>        axisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        float3 newPositionBS = targetPosBS + axisX * positionBS.z;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newPositionBS;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDrawGizmos()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!draw)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Color originalColor = Gizmos.color;
</span></span><span style=display:flex><span>        Gizmos.color = sphereColor;
</span></span><span style=display:flex><span>        Gizmos.DrawSphere(<span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, radius), radius);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        float3 axisX, axisY, axisZ;
</span></span><span style=display:flex><span>        float3 newPosition = CircleTransform(originalPosition, radius, <span style=color:#66d9ef>out</span> axisX, <span style=color:#66d9ef>out</span> axisY, <span style=color:#66d9ef>out</span> axisZ);
</span></span><span style=display:flex><span>        DrawAxes(pivotColor, newPosition, axisY, axisZ, axisX);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DrawAxes(pivotColor, originalPosition, <span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>), <span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>), <span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Gizmos.color = Color.black;
</span></span><span style=display:flex><span>        Gizmos.DrawLine(float3.zero, originalPosition);
</span></span><span style=display:flex><span>        Gizmos.color = Color.white;
</span></span><span style=display:flex><span>        Gizmos.DrawLine(float3.zero, newPosition);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Gizmos.color = originalColor;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=å…¶ä»–çš„ä¸€äº›é—®é¢˜>å…¶ä»–çš„ä¸€äº›é—®é¢˜<a hidden class=anchor aria-hidden=true href=#å…¶ä»–çš„ä¸€äº›é—®é¢˜>#</a></h3><p>ç”±äºæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ä¸­ç”¨åˆ°äº†å¾ˆå¤šçš„åæ ‡å˜æ¢ï¼Œéœ€è¦ç‰¹åˆ«çš„æ³¨æ„æ¯ä¸€æ¬¡å˜æ¢æ˜¯ä»ä»€ä¹ˆç©ºé—´å˜æ¢åˆ°ä»€ä¹ˆç©ºé—´ã€‚é¦–å…ˆæ˜¯ç‰©ä½“ç©ºé—´åˆ°é£çš„å¼¯æ›²ç©ºé—´ï¼Œç”±äºæˆ‘ä»¬<code>CircleTransform</code>æ–¹æ³•æ˜¯è®¤ä¸ºé£æ˜¯å¹å‘Xè½´æ­£æ–¹å‘çš„ï¼Œæ‰€ä»¥éœ€è¦å…ˆå¯¹æ‰€æœ‰çš„åæ ‡ã€å‘é‡è¿›è¡Œä¸€ä¸ªå˜æ¢ï¼Œç”±äºåªæ¶‰åŠåˆ°æ—‹è½¬ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ª<code>float3x3</code>çš„çŸ©é˜µæ¥è¡¨ç¤ºä»ç‰©ä½“ç©ºé—´åˆ°å¼¯æ›²ç©ºé—´çš„å˜æ¢çŸ©é˜µã€‚</p><p>ç„¶ååˆ†ä¸¤ç§æƒ…å†µï¼šä¸€ç§æ˜¯Pivot Layerä¸º0çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ‰€ä½¿ç”¨çš„æ¨¡å‹çš„èŒä¸Šçš„é¡¶ç‚¹ã€‚è¿™ç§ç›¸å¯¹ç®€å•ï¼Œå°†é¡¶ç‚¹åœ¨ç‰©ä½“Bend Spaceä¸­è¿›è¡Œ<code>CircleTransform</code>åï¼Œå°±èƒ½è·å¾—æ–°çš„Bend Spaceçš„åæ ‡å’Œæ–°çš„ä¸‰ä¸ªè½´çš„å‘é‡ï¼ˆæ–°çš„ä¸‰ä¸ªè½´å¯ä»¥ç»„åˆå‡ºé¡¶ç‚¹çš„Bend Spaceåˆ°ç‰©ä½“çš„Bend Spaceçš„å˜æ¢çŸ©é˜µï¼‰ï¼Œå¯ä»¥è®¡ç®—å‡ºé¡¶ç‚¹ã€æ³•çº¿å’Œåˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡å’Œå‘é‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚</p><p>ç¬¬äºŒç§æ˜¯Pivot Layerä¸º1çš„é¡¶ç‚¹ï¼Œè¦å…ˆè®¡ç®—å‡ºPivotçš„æ–°çš„ç‰©ä½“Bend Spaceåæ ‡ï¼Œç„¶ååœ¨å…¶åŸºç¡€ä¸Šè®¡ç®—å‡ºæ¯ä¸€ä¸ªé¡¶ç‚¹ç›¸å¯¹äºPivot Bend Spaceçš„æ–°çš„åæ ‡ï¼Œç„¶åä¸€å±‚å¥—ä¸€å±‚çš„ç®—å›é¡¶ç‚¹åŠå…¶æ³•çº¿åˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘åœ¨è®¡ç®—pivotçš„Bend Spaceæ—¶ï¼Œæ‰€ä½¿ç”¨çš„ç©ºé—´å’Œä¹‹å‰å›¾ä¸Šä¸å¤ªä¸€æ ·ï¼Œæ˜¯<code>AxisZ, AxisYå’Œ-AxisX</code>å¯¹åº”æ–°çš„Bend Spaceçš„XYZè½´ï¼Œè¿™æ ·èƒ½è®©å‚ç›´äºæå¹²çš„å¶ç‰‡æœ‰æ›´å¥½çš„é£å¹çš„æ•ˆæœã€‚</p><p>ä¸ºäº†è®©éšé£æ‘†åŠ¨çš„æ•ˆæœçœ‹ä¸Šå»æ›´è‡ªç„¶ï¼Œé™¤äº†æŒ‰ç…§åœ†å½¢æ¥å˜æ¢é¡¶ç‚¹ä¹‹å¤–ï¼Œå‚è€ƒé¡½çš®ç‹—çš„æ¼”è®²ï¼Œè¿˜è¦ç»™æå¹²çš„æ‘‡æ™ƒæ·»åŠ ä¸€ä¸ªå’Œè·ç¦»ç›¸å…³çš„å»¶è¿Ÿï¼Œè¿™æ ·ä¸ä¼šæ˜¾å¾—ç”Ÿç¡¬ã€‚è‡³äºéšé£é£˜åŠ¨çš„é¢‘ç‡ï¼Œå°±éšä¾¿æ‰¾ä¸€ä¸ªsinå‡½æ•°çš„ç»„åˆå°±å¯ä»¥äº†ã€‚</p><h2 id=å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ>å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ>#</a></h2><p>é¡¶ç‚¹ç€è‰²å™¨å°±æŒ‰ç…§ä¹‹å‰ä»‹ç»çš„æ¥åšå°±å¯ä»¥äº†ã€‚ç”±äºè¾ƒå¥½çœ‹çš„æ¤è¢«éƒ½æ˜¯åŒé¢æ¸²æŸ“çš„ï¼Œåœ¨Cullçš„å‚æ•°é‡Œé¢é€‰æ‹©Offã€‚è¿™æ ·åŒæ ·çš„ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æ¨¡å‹èƒŒé¢çš„æ³•çº¿å’Œæ­£é¢çš„æ³•çº¿æ˜¯ç›¸åŒçš„ï¼Œè¿™é‡Œéœ€è¦ä½¿ç”¨HLSLç‰‡å…ƒç€è‰²å™¨çš„<code>VFACE</code>è¯­ä¹‰ï¼Œæ¥åˆ¤æ–­å½“å‰é¢æ˜¯æ­£é¢è¿˜æ˜¯èƒŒé¢ï¼Œå¦‚æœæ˜¯èƒŒé¢çš„è¯éœ€è¦åè½¬ä¸€ä¸‹æ³•çº¿ã€‚è¿™é‡Œå†™çš„Shaderä¹ŸåŒæ—¶å†™äº†é˜´å½±ã€æ·±åº¦å›¾å’Œçƒ˜ç„™æ‰€éœ€è¦çš„passã€‚</p><h3 id=vertexanimationplantshadershader>VertexAnimationPlantShader.shader<a hidden class=anchor aria-hidden=true href=#vertexanimationplantshadershader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/VertexAnimationPlantShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _BaseColor (<span style=color:#e6db74>&#34;Base Color&#34;</span>, color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _BaseMap(<span style=color:#e6db74>&#34;Base Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _BumpMap (<span style=color:#e6db74>&#34;Bump Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bump&#34;</span> {}
</span></span><span style=display:flex><span>        _BumpIntensity (<span style=color:#e6db74>&#34;Bump Intensity&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _RoughnessMap(<span style=color:#e6db74>&#34;Roughness Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _RoughnessIntensity (<span style=color:#e6db74>&#34;Roughness Intensity&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _MetallicMap (<span style=color:#e6db74>&#34;Metallic Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;black&#34;</span> {}
</span></span><span style=display:flex><span>        _MetallicIntensity (<span style=color:#e6db74>&#34;Metallic Intensity&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _WindDirection (<span style=color:#e6db74>&#34;Wind Direction&#34;</span>, <span style=color:#66d9ef>vector</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>        _WindIntensity (<span style=color:#e6db74>&#34;Wind Intensity&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _WindVariety (<span style=color:#e6db74>&#34;Wind Variety&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>        _BranchDelay (<span style=color:#e6db74>&#34;Branch Delay&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _WindVarietyLeaves (<span style=color:#e6db74>&#34;Wind Variety Leaves&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _BranchDelayLeaves (<span style=color:#e6db74>&#34;Branch Delay Leaves&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _WindVaryFrequency (<span style=color:#e6db74>&#34;Wind Vary Frequency&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    sampler2D _BaseMap;
</span></span><span style=display:flex><span>    sampler2D _BumpMap;
</span></span><span style=display:flex><span>    sampler2D _RoughnessMap;
</span></span><span style=display:flex><span>    sampler2D _MetallicMap;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _BaseColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _BaseMap_ST;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _BumpIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _RoughnessIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _MetallicIntensity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _WindDirection;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _WindIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _WindVariety;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _BranchDelay;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _WindVarietyLeaves;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _BranchDelayLeaves;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _WindVaryFrequency;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Apply wind variety</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> GetVariety(<span style=color:#66d9ef>float</span> timeFunction)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sin(timeFunction) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.25</span> <span style=color:#f92672>*</span> sin(timeFunction <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.5</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.1</span> <span style=color:#f92672>*</span> sin(timeFunction <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.33</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//CircleTransform transforms a current bend space point to a new position in bend space,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//and output three axes of next bend space.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//New position is in current bend space and ready for use.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Normal and tangent in current bend space can be calculated by axes.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> CircleTransform(<span style=color:#66d9ef>float3</span> positionBS, <span style=color:#66d9ef>float</span> windIntensity, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float3</span> axisX, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float3</span> axisY, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float3</span> axisZ)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> intensity <span style=color:#f92672>=</span> windIntensity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(intensity <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>||</span> length(positionBS.yz) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            axisX <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>            axisY <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>            axisZ <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> positionBS;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> radius <span style=color:#f92672>=</span> rcp(intensity);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> radVal <span style=color:#f92672>=</span> length(positionBS.yz) <span style=color:#f92672>*</span> intensity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sinVal <span style=color:#f92672>=</span> sin(radVal);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> cosVal <span style=color:#f92672>=</span> cos(radVal);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> normalizeDir <span style=color:#f92672>=</span> normalize(positionBS.yz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> targetPosBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(radius <span style=color:#f92672>-</span> radius <span style=color:#f92672>*</span> cosVal, (radius <span style=color:#f92672>*</span> sinVal) <span style=color:#f92672>*</span> normalizeDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tempAxisX <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(cosVal, <span style=color:#f92672>-</span>sinVal <span style=color:#f92672>*</span> normalizeDir);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tempAxisY <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.0</span>, normalizeDir.y, <span style=color:#f92672>-</span>normalizeDir.x);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tempAxisZ <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(sinVal, cosVal <span style=color:#f92672>*</span> normalizeDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        axisX <span style=color:#f92672>=</span> tempAxisX;
</span></span><span style=display:flex><span>        axisY <span style=color:#f92672>=</span> normalizeDir.y <span style=color:#f92672>*</span> tempAxisY <span style=color:#f92672>+</span> normalizeDir.x <span style=color:#f92672>*</span> tempAxisZ;
</span></span><span style=display:flex><span>        axisZ <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>normalizeDir.x <span style=color:#f92672>*</span> tempAxisY <span style=color:#f92672>+</span> normalizeDir.y <span style=color:#f92672>*</span> tempAxisZ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> newPositionBS <span style=color:#f92672>=</span> targetPosBS <span style=color:#f92672>+</span> axisX <span style=color:#f92672>*</span> positionBS.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newPositionBS;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//windDirection: object space, upVec: world upVec in object space</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> InitBendSpace(<span style=color:#66d9ef>float3</span> windDirection, <span style=color:#66d9ef>float3</span> upVec, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float3x3</span> objectToBend, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float3x3</span> bendToObject)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> u <span style=color:#f92672>=</span> windDirection;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> v <span style=color:#f92672>=</span> normalize(cross(upVec, u));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> w <span style=color:#f92672>=</span> cross(u, v);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Object space to bend space       </span>
</span></span><span style=display:flex><span>        objectToBend <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3x3</span>(u, v, w);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Bend space to object space</span>
</span></span><span style=display:flex><span>        bendToObject <span style=color:#f92672>=</span>  <span style=color:#66d9ef>float3x3</span>(u.x, v.x, w.x, u.y, v.y, w.y, u.z, v.z, w.z);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags{ <span style=color:#e6db74>&#34;RenderType&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Transparent&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Name <span style=color:#e6db74>&#34;ForwardLit&#34;</span>
</span></span><span style=display:flex><span>            Tags{<span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UniversalForward&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Cull Off
</span></span><span style=display:flex><span>            Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style=display:flex><span>            ZWrite On
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature_local _NORMALMAP
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile _ SHADOWS_SHADOWMASK       
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile_fragment _ _SHADOWS_SOFT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile _ LIGHTMAP_ON
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex LitPassVert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment LitPassFrag
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionOS           <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> normalOS             <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> tangentOS            <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord0            <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord1            <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord2            <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> staticLightmapUV     <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>                UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionCS               <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv                       <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> positionWS               <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> normalWS                 <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> tangentWS                <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> shadowCoord              <span style=color:#f92672>:</span> TEXCOORD4;
</span></span><span style=display:flex><span>                DECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>                UNITY_VERTEX_OUTPUT_STEREO
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//////////////////////////////////</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//GGX BRDF and related functions//</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//////////////////////////////////</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> D(<span style=color:#66d9ef>float</span> ndoth, <span style=color:#66d9ef>float</span> roughness)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> a <span style=color:#f92672>=</span> ndoth <span style=color:#f92672>*</span> roughness;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> k <span style=color:#f92672>=</span> roughness <span style=color:#f92672>/</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> ndoth <span style=color:#f92672>*</span> ndoth <span style=color:#f92672>+</span> a <span style=color:#f92672>*</span> a);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> k <span style=color:#f92672>*</span> k;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> G(<span style=color:#66d9ef>float</span> ndotl, <span style=color:#66d9ef>float</span> ndotv, <span style=color:#66d9ef>float</span> roughness)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> a2 <span style=color:#f92672>=</span> roughness <span style=color:#f92672>*</span> roughness;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> gv <span style=color:#f92672>=</span> ndotv <span style=color:#f92672>*</span> sqrt((<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> a2) <span style=color:#f92672>*</span> ndotl <span style=color:#f92672>*</span> ndotl <span style=color:#f92672>+</span> a2);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> gl <span style=color:#f92672>=</span> ndotl <span style=color:#f92672>*</span> sqrt((<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> a2) <span style=color:#f92672>*</span> ndotv <span style=color:#f92672>*</span> ndotv <span style=color:#f92672>+</span> a2);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> rcp(gv <span style=color:#f92672>+</span> gl);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> F(<span style=color:#66d9ef>float3</span> specular, <span style=color:#66d9ef>float</span> hdotl)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> specular <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> specular) <span style=color:#f92672>*</span> pow(<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> hdotl, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> GGXBRDF(<span style=color:#66d9ef>float3</span> wi, <span style=color:#66d9ef>float3</span> wo, <span style=color:#66d9ef>float3</span> normal, <span style=color:#66d9ef>float3</span> specular, <span style=color:#66d9ef>float</span> roughness)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> h <span style=color:#f92672>=</span> normalize(wi <span style=color:#f92672>+</span> wo);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> ndotv <span style=color:#f92672>=</span> max(dot(normal, wo), <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> ndoth <span style=color:#f92672>=</span> max(dot(normal, h), <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> ndotl <span style=color:#f92672>=</span> max(dot(normal, wi), <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> hdotl <span style=color:#f92672>=</span> max(dot(h, wi), <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> d <span style=color:#f92672>=</span> D(ndoth, roughness);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> g <span style=color:#f92672>=</span> G(ndotl, ndotv, roughness);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> f <span style=color:#f92672>=</span> F(specular, hdotl);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> d <span style=color:#f92672>*</span> g <span style=color:#f92672>*</span> f;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Varyings LitPassVert(Attributes input)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                UNITY_SETUP_INSTANCE_ID(input);
</span></span><span style=display:flex><span>                UNITY_TRANSFER_INSTANCE_ID(input, output);
</span></span><span style=display:flex><span>                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//Pivot positions are stored in TEXCOORD1.xy and TEXCOORD2.x.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotPosition <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(input.texcoord1.xy, input.texcoord2.x) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.01</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pointOffset <span style=color:#f92672>=</span> input.positionOS.xyz <span style=color:#f92672>-</span> pivotPosition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//Initialize Bend Space.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windDirectionOS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_I_M, _WindDirection.xyz);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> upVec <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_I_M, <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>));
</span></span><span style=display:flex><span>                windDirectionOS <span style=color:#f92672>=</span> normalize(windDirectionOS);
</span></span><span style=display:flex><span>                upVec <span style=color:#f92672>=</span> normalize(upVec);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3x3</span> objectToBend, bendToObject;
</span></span><span style=display:flex><span>                InitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//Initialize vertex data, transform from object space to bend space.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotPositionBS <span style=color:#f92672>=</span> mul(objectToBend, pivotPosition);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pointOffsetBS <span style=color:#f92672>=</span> mul(objectToBend, pointOffset);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> originalTangentBS <span style=color:#f92672>=</span> mul(objectToBend, input.tangentOS.xyz);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> originalNormalBS <span style=color:#f92672>=</span> mul(objectToBend, input.normalOS);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windPointBS;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windTangentBS;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windNormalBS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//TEXCOORD2.y is used to check pivot layers. 0 is root layer.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(input.texcoord2.y <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//////////////////////////////////</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate pivot root transform//</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//////////////////////////////////</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Get pivot wind intensity.</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> intensity <span style=color:#f92672>=</span> _WindIntensity;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> magnitude <span style=color:#f92672>=</span> length(pivotPositionBS);
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>+=</span> _WindVariety <span style=color:#f92672>*</span> GetVariety(_Time.y <span style=color:#f92672>*</span> _WindVaryFrequency <span style=color:#f92672>-</span> magnitude <span style=color:#f92672>*</span> _BranchDelay);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate new position bent by wind in bend space,</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//and save the transform matrix.</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> axisX, axisY, axisZ;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPivotPositionBS <span style=color:#f92672>=</span> CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float4x4</span> pivotBSToObjBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4x4</span>(<span style=color:#66d9ef>float4</span>(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), <span style=color:#66d9ef>float4</span>(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), <span style=color:#66d9ef>float4</span>(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>/////////////////////////////</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate point transform//</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>/////////////////////////////</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Switch axes, transform to next bend space (point bend space).</span>
</span></span><span style=display:flex><span>                    pointOffsetBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(pointOffsetBS.z, pointOffsetBS.y, <span style=color:#f92672>-</span>pointOffsetBS.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Get point wind intensity.</span>
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>=</span> abs(axisZ.x) <span style=color:#f92672>*</span> _WindIntensity;<span style=color:#75715e>//_WindIntensityLeaves;</span>
</span></span><span style=display:flex><span>                    magnitude <span style=color:#f92672>=</span> length(pointOffsetBS);
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>+=</span> _WindVarietyLeaves <span style=color:#f92672>*</span> GetVariety(_Time.y <span style=color:#f92672>*</span> _WindVaryFrequency <span style=color:#f92672>-</span> magnitude <span style=color:#f92672>*</span> _BranchDelayLeaves);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate new position bent by wind in bend space,</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//and save the transform matrix from point bend space to pivot bend space.</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//This transform matrix can be used to calculate normal and tangent.</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPointPositionBS <span style=color:#f92672>=</span> CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float4x4</span> pointBSToPivotBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4x4</span>(<span style=color:#66d9ef>float4</span>(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), <span style=color:#66d9ef>float4</span>(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), <span style=color:#66d9ef>float4</span>(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Switch axes, transform to pivot bend space.</span>
</span></span><span style=display:flex><span>                    windPointPositionBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#f92672>-</span>windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate position, normal and tangent in pivot bend space.</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPointPS <span style=color:#f92672>=</span> windPointPositionBS;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windTangentPS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToPivotBS, originalTangentBS);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windNormalPS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToPivotBS, originalNormalBS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate position, normal and tangent in object bend space.</span>
</span></span><span style=display:flex><span>                    windPointBS <span style=color:#f92672>=</span> mul(pivotBSToObjBS, <span style=color:#66d9ef>float4</span>(windPointPS, <span style=color:#ae81ff>1.0</span>)).xyz;
</span></span><span style=display:flex><span>                    windTangentBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pivotBSToObjBS, windTangentPS);
</span></span><span style=display:flex><span>                    windNormalBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pivotBSToObjBS, windNormalPS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//////////////////////////////////</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Calculate point transform only//</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//////////////////////////////////</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Get point wind intensity.</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> intensity <span style=color:#f92672>=</span> _WindIntensity;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> magnitude <span style=color:#f92672>=</span> length(pointOffsetBS);
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>+=</span> _WindVariety <span style=color:#f92672>*</span> GetVariety(_Time.y <span style=color:#f92672>*</span> _WindVaryFrequency <span style=color:#f92672>-</span> magnitude <span style=color:#f92672>*</span> _BranchDelay);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> axisX, axisY, axisZ;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPointOffsetBS <span style=color:#f92672>=</span> CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float4x4</span> pointBSToObjBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4x4</span>(<span style=color:#66d9ef>float4</span>(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), <span style=color:#66d9ef>float4</span>(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), <span style=color:#66d9ef>float4</span>(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    windPointBS <span style=color:#f92672>=</span> windPointOffsetBS <span style=color:#f92672>+</span> pivotPositionBS;
</span></span><span style=display:flex><span>                    windTangentBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToObjBS, originalTangentBS);
</span></span><span style=display:flex><span>                    windNormalBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToObjBS, originalNormalBS);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//Transform from bend space to object space</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotPositionOS <span style=color:#f92672>=</span> mul(bendToObject, windPointBS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotTangentOS <span style=color:#f92672>=</span> mul(bendToObject, windTangentBS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotNormalOS <span style=color:#f92672>=</span> mul(bendToObject, windNormalBS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                VertexPositionInputs vertexInput <span style=color:#f92672>=</span> GetVertexPositionInputs(pivotPositionOS);
</span></span><span style=display:flex><span>                VertexNormalInputs normalInput <span style=color:#f92672>=</span> GetVertexNormalInputs(pivotNormalOS, <span style=color:#66d9ef>float4</span>(pivotTangentOS, input.tangentOS.w));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                output.positionCS <span style=color:#f92672>=</span> vertexInput.positionCS;
</span></span><span style=display:flex><span>                output.uv <span style=color:#f92672>=</span> TRANSFORM_TEX(input.texcoord0, _BaseMap);
</span></span><span style=display:flex><span>                output.positionWS <span style=color:#f92672>=</span> vertexInput.positionWS;
</span></span><span style=display:flex><span>                output.normalWS <span style=color:#f92672>=</span> normalInput.normalWS;
</span></span><span style=display:flex><span>                output.tangentWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(normalInput.tangentWS, input.tangentOS.w);
</span></span><span style=display:flex><span>                output.shadowCoord <span style=color:#f92672>=</span> TransformWorldToShadowCoord(vertexInput.positionWS);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);
</span></span><span style=display:flex><span>                OUTPUT_SH(normalInput.normalWS.xyz, output.vertexSH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                output.normalWS <span style=color:#f92672>=</span> normalInput.normalWS;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> LitPassFrag(Varyings input, <span style=color:#66d9ef>float</span> vFace <span style=color:#f92672>:</span> VFACE) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                UNITY_SETUP_INSTANCE_ID(input);
</span></span><span style=display:flex><span>                UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//wo</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> positionWS <span style=color:#f92672>=</span> input.positionWS;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> viewDirWS <span style=color:#f92672>=</span> GetWorldSpaceNormalizeViewDir(positionWS);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>//wi</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> shadowCoord <span style=color:#f92672>=</span> TransformWorldToShadowCoord(positionWS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> shadowMask <span style=color:#f92672>=</span> SAMPLE_SHADOWMASK(input.staticLightmapUV);
</span></span><span style=display:flex><span>                Light mainLight <span style=color:#f92672>=</span> GetMainLight(shadowCoord, positionWS, shadowMask);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//normal</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> normalMap <span style=color:#f92672>=</span> UnpackNormal(tex2D(_BumpMap, input.uv));
</span></span><span style=display:flex><span>                normalMap.xy <span style=color:#f92672>*=</span> _BumpIntensity;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> bitangentWS <span style=color:#f92672>=</span> cross(input.normalWS, input.tangentWS.xyz) <span style=color:#f92672>*</span> input.tangentWS.w;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3x3</span> tbn <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3x3</span>(input.tangentWS.xyz, bitangentWS, input.normalWS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> normalWS <span style=color:#f92672>=</span> mul(normalMap, tbn);
</span></span><span style=display:flex><span>                normalWS <span style=color:#f92672>=</span> normalize(input.normalWS);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//If we are looking and back faces, revert the normal.</span>
</span></span><span style=display:flex><span>                normalWS <span style=color:#f92672>=</span> vFace <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>?</span> normalWS<span style=color:#f92672>:</span> <span style=color:#f92672>-</span>normalWS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//material properties</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> baseMap <span style=color:#f92672>=</span> tex2D(_BaseMap, input.uv) <span style=color:#f92672>*</span> _BaseColor;
</span></span><span style=display:flex><span>                clip(baseMap.a <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> roughnessMap <span style=color:#f92672>=</span> tex2D(_RoughnessMap, input.uv).r;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> roughness <span style=color:#f92672>=</span> max(roughnessMap <span style=color:#f92672>*</span> _RoughnessIntensity, <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> metallicMap <span style=color:#f92672>=</span> tex2D(_MetallicMap, input.uv).r;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> metallic <span style=color:#f92672>=</span> metallicMap <span style=color:#f92672>*</span> _MetallicIntensity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> oneMinusReflectivity <span style=color:#f92672>=</span> kDieletricSpec.a <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> metallic);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> reflectivity <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> oneMinusReflectivity;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> diffuse <span style=color:#f92672>=</span> baseMap.rgb <span style=color:#f92672>*</span> oneMinusReflectivity;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> specular <span style=color:#f92672>=</span> lerp(kDieletricSpec.rgb, baseMap.rgb, metallic);     
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>//gi</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> bakedGI <span style=color:#f92672>=</span> SAMPLE_GI(input.staticLightmapUV, input.vertexSH, normalWS);
</span></span><span style=display:flex><span>                MixRealtimeAndBakedGI(mainLight, normalWS, bakedGI);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> giDiffuse <span style=color:#f92672>=</span> bakedGI;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> reflectVector <span style=color:#f92672>=</span> reflect(<span style=color:#f92672>-</span>viewDirWS, normalWS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> giSpecular <span style=color:#f92672>=</span> GlossyEnvironmentReflection(reflectVector, positionWS, roughness, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//directional lights</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> directDiffuse <span style=color:#f92672>=</span> diffuse;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> directSpecular <span style=color:#f92672>=</span> GGXBRDF(mainLight.direction, viewDirWS, normalWS, specular, roughness);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> ndotl <span style=color:#f92672>=</span> saturate(dot(mainLight.direction, normalWS));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> atten <span style=color:#f92672>=</span> mainLight.shadowAttenuation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//indirectional lights</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> indirectDiffse <span style=color:#f92672>=</span> giDiffuse <span style=color:#f92672>*</span> diffuse;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> surfaceReduction <span style=color:#f92672>=</span> rcp(roughness <span style=color:#f92672>*</span> roughness <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> grazingTerm <span style=color:#f92672>=</span> saturate(<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> roughness <span style=color:#f92672>+</span> reflectivity);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> ndotv <span style=color:#f92672>=</span> saturate(dot(normalWS, viewDirWS));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> fresnelTerm <span style=color:#f92672>=</span> pow(<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> ndotv, <span style=color:#ae81ff>5.0</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> indirectSpecular <span style=color:#f92672>=</span> giSpecular <span style=color:#f92672>*</span> surfaceReduction <span style=color:#f92672>*</span> lerp(specular, grazingTerm, fresnelTerm);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//final compose</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> directBRDF <span style=color:#f92672>=</span> (directDiffuse <span style=color:#f92672>+</span> directSpecular) <span style=color:#f92672>*</span> mainLight.color <span style=color:#f92672>*</span> atten <span style=color:#f92672>*</span> ndotl;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> indirectBRDF <span style=color:#f92672>=</span> indirectDiffse <span style=color:#f92672>+</span> indirectSpecular;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> finalColor <span style=color:#f92672>=</span> directBRDF <span style=color:#f92672>+</span> indirectBRDF;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(finalColor, baseMap.a);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Name <span style=color:#e6db74>&#34;ShadowCaster&#34;</span>
</span></span><span style=display:flex><span>            Tags{<span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ShadowCaster&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex ShadowPassVertex
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment ShadowPassFragment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> _LightDirection;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord0    <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord1    <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord2    <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> color        <span style=color:#f92672>:</span> COLOR;
</span></span><span style=display:flex><span>                UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Varyings ShadowPassVertex(Attributes input)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                UNITY_SETUP_INSTANCE_ID(input);
</span></span><span style=display:flex><span>                UNITY_TRANSFER_INSTANCE_ID(input, output);
</span></span><span style=display:flex><span>                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotPosition <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(input.texcoord1.xy, input.texcoord2.x) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.01</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pointOffset <span style=color:#f92672>=</span> input.positionOS.xyz <span style=color:#f92672>-</span> pivotPosition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windDirectionOS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_I_M, _WindDirection.xyz);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> upVec <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_I_M, <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>));
</span></span><span style=display:flex><span>                windDirectionOS <span style=color:#f92672>=</span> normalize(windDirectionOS);
</span></span><span style=display:flex><span>                upVec <span style=color:#f92672>=</span> normalize(upVec);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3x3</span> objectToBend, bendToObject;
</span></span><span style=display:flex><span>                InitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotPositionBS <span style=color:#f92672>=</span> mul(objectToBend, pivotPosition);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pointOffsetBS <span style=color:#f92672>=</span> mul(objectToBend, pointOffset);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> originalTangentBS <span style=color:#f92672>=</span> mul(objectToBend, input.tangentOS.xyz);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> originalNormalBS <span style=color:#f92672>=</span> mul(objectToBend, input.normalOS);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windPointBS;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windTangentBS;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> windNormalBS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(input.texcoord2.y <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> intensity <span style=color:#f92672>=</span> _WindIntensity;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> magnitude <span style=color:#f92672>=</span> length(pivotPositionBS);
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>+=</span> _WindVariety <span style=color:#f92672>*</span> GetVariety(_Time.y <span style=color:#f92672>*</span> _WindVaryFrequency <span style=color:#f92672>-</span> magnitude <span style=color:#f92672>*</span> _BranchDelay);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> axisX, axisY, axisZ;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPivotPositionBS <span style=color:#f92672>=</span> CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float4x4</span> pivotBSToObjBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4x4</span>(<span style=color:#66d9ef>float4</span>(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), <span style=color:#66d9ef>float4</span>(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), <span style=color:#66d9ef>float4</span>(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    pointOffsetBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(pointOffsetBS.z, pointOffsetBS.y, <span style=color:#f92672>-</span>pointOffsetBS.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>=</span> abs(axisZ.x) <span style=color:#f92672>*</span> _WindIntensity;<span style=color:#75715e>//_WindIntensityLeaves;</span>
</span></span><span style=display:flex><span>                    magnitude <span style=color:#f92672>=</span> length(pointOffsetBS);
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>+=</span> _WindVarietyLeaves <span style=color:#f92672>*</span> GetVariety(_Time.y <span style=color:#f92672>*</span> _WindVaryFrequency <span style=color:#f92672>-</span> magnitude <span style=color:#f92672>*</span> _BranchDelayLeaves);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPointPositionBS <span style=color:#f92672>=</span> CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float4x4</span> pointBSToPivotBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4x4</span>(<span style=color:#66d9ef>float4</span>(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), <span style=color:#66d9ef>float4</span>(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), <span style=color:#66d9ef>float4</span>(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    windPointPositionBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#f92672>-</span>windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPointPS <span style=color:#f92672>=</span> windPointPositionBS;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windTangentPS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToPivotBS, originalTangentBS);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windNormalPS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToPivotBS, originalNormalBS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    windPointBS <span style=color:#f92672>=</span> mul(pivotBSToObjBS, <span style=color:#66d9ef>float4</span>(windPointPS, <span style=color:#ae81ff>1.0</span>)).xyz;
</span></span><span style=display:flex><span>                    windTangentBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pivotBSToObjBS, windTangentPS);
</span></span><span style=display:flex><span>                    windNormalBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pivotBSToObjBS, windNormalPS);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> intensity <span style=color:#f92672>=</span> _WindIntensity;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float</span> magnitude <span style=color:#f92672>=</span> length(pointOffsetBS);
</span></span><span style=display:flex><span>                    intensity <span style=color:#f92672>+=</span> _WindVariety <span style=color:#f92672>*</span> GetVariety(_Time.y <span style=color:#f92672>*</span> _WindVaryFrequency <span style=color:#f92672>-</span> magnitude <span style=color:#f92672>*</span> _BranchDelay);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> axisX, axisY, axisZ;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float3</span> windPointOffsetBS <span style=color:#f92672>=</span> CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>float4x4</span> pointBSToObjBS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4x4</span>(<span style=color:#66d9ef>float4</span>(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), <span style=color:#66d9ef>float4</span>(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), <span style=color:#66d9ef>float4</span>(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    windPointBS <span style=color:#f92672>=</span> windPointOffsetBS <span style=color:#f92672>+</span> pivotPositionBS;
</span></span><span style=display:flex><span>                    windTangentBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToObjBS, originalTangentBS);
</span></span><span style=display:flex><span>                    windNormalBS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)pointBSToObjBS, originalNormalBS);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotPositionOS <span style=color:#f92672>=</span> mul(bendToObject, windPointBS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotTangentOS <span style=color:#f92672>=</span> mul(bendToObject, windTangentBS);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> pivotNormalOS <span style=color:#f92672>=</span> mul(bendToObject, windNormalBS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                VertexPositionInputs vertexInput <span style=color:#f92672>=</span> GetVertexPositionInputs(pivotPositionOS);
</span></span><span style=display:flex><span>                VertexNormalInputs normalInput <span style=color:#f92672>=</span> GetVertexNormalInputs(pivotNormalOS, <span style=color:#66d9ef>float4</span>(pivotTangentOS, input.tangentOS.w));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                output.uv <span style=color:#f92672>=</span> TRANSFORM_TEX(input.texcoord0, _BaseMap);
</span></span><span style=display:flex><span>                output.positionCS <span style=color:#f92672>=</span> TransformWorldToHClip(ApplyShadowBias(vertexInput.positionWS, normalInput.normalWS, _LightDirection));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>half4</span> ShadowPassFragment(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Name <span style=color:#e6db74>&#34;DepthOnly&#34;</span>
</span></span><span style=display:flex><span>            Tags{<span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;DepthOnly&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex DepthOnlyVertex
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment DepthOnlyFragment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> color        <span style=color:#f92672>:</span> COLOR;
</span></span><span style=display:flex><span>                UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>                UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style=display:flex><span>                UNITY_VERTEX_OUTPUT_STEREO
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Varyings DepthOnlyVertex(Attributes input)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                UNITY_SETUP_INSTANCE_ID(input);
</span></span><span style=display:flex><span>                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                VertexPositionInputs vertexInput <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>                output.positionCS <span style=color:#f92672>=</span> vertexInput.positionCS;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>half4</span> DepthOnlyFragment(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Name <span style=color:#e6db74>&#34;Meta&#34;</span>
</span></span><span style=display:flex><span>            Tags{<span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Meta&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex MetaVertex
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment MetaFragment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv0          <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv1          <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv2          <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Varyings MetaVertex(Attributes input)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Varyings output;
</span></span><span style=display:flex><span>                output.positionCS <span style=color:#f92672>=</span> MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST);
</span></span><span style=display:flex><span>                output.uv <span style=color:#f92672>=</span> TRANSFORM_TEX(input.uv0, _BaseMap);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>half4</span> MetaFragment(Varyings input) <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_Target</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>//material properties</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float4</span> baseMap <span style=color:#f92672>=</span> tex2D(_BaseMap, input.uv);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> roughnessMap <span style=color:#f92672>=</span> tex2D(_RoughnessMap, input.uv).r;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> roughness <span style=color:#f92672>=</span> max(roughnessMap <span style=color:#f92672>*</span> _RoughnessIntensity, <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> metallicMap <span style=color:#f92672>=</span> tex2D(_MetallicMap, input.uv).r;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> metallic <span style=color:#f92672>=</span> metallicMap <span style=color:#f92672>*</span> _MetallicIntensity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> oneMinusReflectivity <span style=color:#f92672>=</span> kDieletricSpec.a <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> metallic);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> reflectivity <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> oneMinusReflectivity;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> diffuse <span style=color:#f92672>=</span> baseMap.rgb <span style=color:#f92672>*</span> oneMinusReflectivity;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> specular <span style=color:#f92672>=</span> lerp(kDieletricSpec.rgb, baseMap.rgb, metallic);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                MetaInput metaInput;
</span></span><span style=display:flex><span>                metaInput.Albedo <span style=color:#f92672>=</span> diffuse;
</span></span><span style=display:flex><span>                metaInput.SpecularColor <span style=color:#f92672>=</span> specular;
</span></span><span style=display:flex><span>                metaInput.Emission <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> MetaFragment(metaInput);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åç»­çš„æ€è€ƒ>åç»­çš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#åç»­çš„æ€è€ƒ>#</a></h2><p>é¦–å…ˆå…ˆè®²å¥½çš„æ–¹é¢ï¼Œé£å¹åŠ¨çš„æ•ˆæœç¡®å®ååˆ†è‡ªç„¶ï¼ŒåŒæ ·çš„è®¡ç®—å‡ºçš„æ­£ç¡®çš„æ³•çº¿åœ¨PBRçš„æ¸²æŸ“ä¸­ä¹Ÿååˆ†é‡è¦ï¼ˆé¡¶ç‚¹åŠ¨ç”»ä¸­æ­£ç¡®çš„æ³•çº¿å°¤å…¶ä¸æ˜“ï¼ï¼‰ã€‚ä½†æ˜¯ä¸è¶³ä¹‹å¤„æ˜¯çŸ©é˜µè¿ç®—è¿‡å¤šäº†ï¼Œä¸è¿‡çŸ©é˜µè¿ç®—å…¨éƒ½åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œæ¶ˆè€—ä¹Ÿä¸æ˜¯ç‰¹åˆ«å¤§ã€‚å¤ªå¤šçš„çŸ©é˜µè¿ç®—ä¹Ÿå¯¼è‡´äº†è¿™ç§ç®—æ³•çš„æ‰©å±•æ€§ä¸æ˜¯å¾ˆå¥½ï¼Œå¦‚æœæƒ³è¦æœ‰Pivot Layerä¸º3çš„é¡¶ç‚¹ï¼Œåœ¨ç›®å‰çš„ç®—æ³•é‡Œé¢æ˜¯æ²¡åŠæ³•è®¡ç®—çš„ï¼Œä¹Ÿä¸çŸ¥é“é¡½çš®ç‹—æ˜¯æ€ä¹ˆåšçš„äº†ã€‚åœ¨æ¨¡å‹çš„å½¢çŠ¶ä¸æ˜¯ç‰¹åˆ«å¥½çš„æ—¶å€™ï¼Œæ¯”å¦‚ä¸€ä¸ªquadæ¥æ¸²æŸ“è‰ï¼Œæˆ–è€…æ˜¯æ¨¡å‹å¶å­æ­ªæ­ªæ‰­æ‰­çš„ï¼Œä¼šæœ‰æ¯”è¾ƒå¤§çš„å˜å½¢ã€‚ä¸è¿‡ä»”ç»†è®¾ç½®æ¯ä¸€ä¸ªé¡¶ç‚¹çš„Pivotçš„è¯ï¼Œåº”è¯¥è¿˜æ˜¯èƒ½å¤Ÿè§£å†³ä¸€éƒ¨åˆ†é—®é¢˜çš„ï¼Œå½“ç„¶æ‹™åŠ£çš„Mayaè„šæœ¬åˆæˆäº†ä¸€ä¸ªç—›ç‚¹ã€‚</p><p>æ€»çš„æ¥è¯´æˆ‘è¿˜æ˜¯æ¯”è¾ƒæ»¡æ„çš„ï¼Œä¹Ÿç®—æ˜¯è§£å†³äº†ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„é—®é¢˜ï¼Œå½“ç„¶äº†ï¼Œæˆ‘å¯¹hugoèƒ½å¤Ÿæ”¯æŒgifå›¾ç‰‡æ›´åŠ æ»¡æ„ï¼</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/vertex-animation/>Vertex Animation</a></li><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/get-view-space-normal-from-depth-texture/><span class=title>Â« Prev</span><br><span>ä»æ·±åº¦å›¾ä¸­è·å–è§†ç©ºé—´çš„æ³•çº¿</span>
</a><a class=next href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><span class=title>Next Â»</span><br><span>åœ¨Unityçš„UIä¸­ç»˜åˆ¶ç­‰å®½çš„è´èµ›å°”æ›²çº¿</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>