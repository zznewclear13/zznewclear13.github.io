<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰© | ZZNEWCLEAR13</title><meta name=keywords content="Vertex Animation,Space Transformation"><meta name=description content="åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/><link crossorigin=anonymous href=/assets/css/stylesheet.a6fe470bfe70eb4fad7ee3efc590e817f121cf0f6d66fa91de327cf6bfbad62d.css integrity="sha256-pv5HC/5w60+tfuPvxZDoF/Ehzw9tZvqR3jJ89r+61i0=" rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©"><meta property="og:description" content="åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/"><meta property="og:image" content="https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/posts/images/VertexAnimatedPlant.gif"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-06T12:00:00+08:00"><meta property="article:modified_time" content="2022-01-06T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/posts/images/VertexAnimatedPlant.gif"><meta name=twitter:title content="ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©"><meta name=twitter:description content="åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©","item":"https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©","name":"ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©","description":"åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹.","keywords":["Vertex Animation","Space Transformation"],"articleBody":"åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ æœ€ç›´æ¥çš„åŠ¨æœºæ˜¯çœ‹äº†é¡½çš®ç‹—åœ¨Siggraph 2016ä¸Šçš„PPTï¼Œé‡Œé¢ä»‹ç»äº†é¡½çš®ç‹—åœ¨ç¥ç§˜æµ·åŸŸä¸­æ˜¯å¦‚ä½•è®©æ¤è¢«éšé£é£˜è¡çš„ã€‚ä»–ä»¬ä»‹ç»äº†ä¸€ç§å°†æ¤è¢«çš„æ¯ä¸€éƒ¨åˆ†çš„pivotçš„ç‰©ä½“ç©ºé—´åæ ‡å†™åˆ°é¡¶ç‚¹è‰²é‡Œï¼Œç„¶ååœ¨shaderä¸­ä½¿ç”¨è¿™ä¸ªåæ ‡è¿›è¡Œé£çš„æ•ˆæœçš„è®¡ç®—çš„æ–¹æ³•ã€‚è¾ƒä¸ºéœ‡æ’¼åœ¨é£å¹è¿‡è‰åŸæ—¶ï¼Œæ¤è¢«è¿›è¡Œå¼¯æ›²åï¼Œè‰è¡¨é¢çš„é«˜å…‰ä¼šæœ‰ä¸€ç§æ—¶ç©ºä¸Šçš„èµ·ä¼æ„Ÿï¼ˆä¹Ÿå°±æ˜¯è¯´ç¥ç§˜æµ·åŸŸçš„æ¤è¢«çš„æ³•çº¿ä¹Ÿä¼šè¢«é£å½±å“ï¼‰ã€‚æ‰€ä»¥æˆ‘ä¹Ÿæƒ³è¦å€ŸåŠ©å†™pivotçš„æ–¹æ³•æ¥åˆ¶ä½œæ¤è¢«å—åˆ°é£å¹çš„æ•ˆæœï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•è®¡ç®—å‡ºæ­£ç¡®çš„é£å¹ä¹‹åçš„æ¤è¢«çš„æ³•çº¿ï¼ˆåŒæ—¶ç”±äºæ³•çº¿è´´å›¾çš„å­˜åœ¨ï¼Œè¿˜è¦è®¡ç®—æ­£ç¡®çš„åˆ‡çº¿ï¼‰ã€‚\nç¨å¾®ç¿»äº†ä¸€ä¸‹ç½‘ä¸Šçš„èµ„æ–™ï¼ˆä¹Ÿæ²¡ä»”ç»†åœ°å»æœç´¢ï¼‰ï¼Œå¤§éƒ¨åˆ†çš„å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„é¡¶ç‚¹åŠ¨ç”»ï¼Œæœ‰çš„æ˜¯ç”¨çš„sinï¼Œæœ‰çš„å°±ç›´æ¥å¹³ç§»ã€‚è¿™å°±äº§ç”Ÿäº†ç¬¬äºŒä¸ªéœ€æ±‚ï¼Œæ¤è¢«åœ¨é¡¶ç‚¹åŠ¨ç”»ä¸­åº”è¯¥ä¿æŒå·®ä¸å¤šçš„é•¿åº¦ï¼Œä¸ç„¶ä¼šå‘ç°å¾ˆæ˜æ˜¾çš„æ‹‰ä¼¸çš„æ•ˆæœã€‚\nå½“ç„¶æœ€å¥½è¿˜èƒ½æŠ•å°„å‡ºæ­£å¸¸çš„å½±å­äº†ï¼Œè¿™ä¸€æ­¥åªéœ€è¦æŠŠé¡¶ç‚¹ç€è‰²å™¨å¤åˆ¶ä¸€ä»½åˆ°æŠ•å°„å½±å­çš„passé‡Œå°±å¯ä»¥äº†ã€‚\nè¿™é‡Œä½¿ç”¨çš„æ¤è¢«æ¨¡å‹æ˜¯MegaScansä¸Šçš„CORDYLINEæ¨¡å‹ä¸­çš„var12è¿™ä¸ªå°æ¨¡å‹ã€‚\néš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³• Unityçš„é¡¶ç‚¹è‰²é™åˆ¶ ç¨å¾®æµ‹è¯•ä¸€ä¸‹å°±èƒ½å‘ç°ï¼ŒUnityçš„é¡¶ç‚¹è‰²æ˜¯UNorm8çš„æ ¼å¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºä½ åœ¨Mayaæˆ–æ˜¯3ds Maxé‡Œå¯¼å‡ºçš„æ¨¡å‹çš„é¡¶ç‚¹è‰²ä¿¡æ¯æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå¯¼å…¥åˆ°Unityä¸­å°±ä¼šå˜æˆåªæœ‰256ç²¾åº¦çš„UNorm8ã€‚é¡½çš®ç‹—ä½¿ç”¨çš„æ˜¯è‡ªå·±çš„å¼•æ“ï¼Œæ‰€ä»¥å®ƒä»¬èƒ½å¤Ÿä½¿ç”¨å…¨ç²¾åº¦çš„é¡¶ç‚¹è‰²ï¼Œä½†æ˜¯ç”±äºUnityçš„å¼•æ“é™åˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘åˆ°å¯¼å‡ºpivotçš„é¡¶ç‚¹åæ ‡åˆ°æ¨¡å‹çš„UVä¸­ã€‚\nä½†æ˜¯å¾ˆä¸å¹¸çš„æ˜¯ï¼Œfbxå¯¼å…¥åˆ°Unityæ—¶ï¼Œå³ä½¿UVæ˜¯float4çš„ç±»å‹ï¼ˆä¹Ÿå°±æ˜¯16bytes)ï¼Œåœ¨Unityä¸­åªä¼šè¯†åˆ«UVçš„å‰ä¸¤ä½ã€‚æ‰€ä»¥åªèƒ½æ— å¥ˆçš„å°†pivotçš„é¡¶ç‚¹åæ ‡ï¼ˆfloat3çš„æ•°æ®ï¼‰å‚¨å­˜åˆ°ä¸¤ä¸ªUVçš„ä¸‰ä¸ªé€šé“é‡Œï¼ŒåŒæ—¶å°†pivotçš„å±‚çº§å­˜åˆ°å‰©ä¸‹çš„ä¸€ä¸ªé€šé“é‡Œã€‚æˆ‘ä¸çŸ¥é“é¡½çš®ç‹—å…·ä½“æ˜¯æ€ä¹ˆè®¡ç®—pivotçš„å±‚çº§å…³ç³»çš„ï¼Œä»–åœ¨PPTä¸­å†™çš„æ˜¯æ— éœ€è®¡ç®—ï¼Œä½†æˆ‘åœ¨å®é™…æ“ä½œä¸­åªèƒ½ä¸€å±‚ä¸€å±‚çš„ç®—ï¼ˆè€Œä¸”åªèƒ½ç®—ä¸¤å±‚ï¼‰ï¼Œä¹Ÿå¸Œæœ›çŸ¥é“å…·ä½“æ€ä¹ˆæ“ä½œçš„äººå‘ŠçŸ¥ä¸€ä¸‹æ–¹æ³•ã€‚\næ‰€ä»¥æ¥ä¸‹æ¥è¦åšçš„æ˜¯åœ¨Mayaä¸­æŠŠpivotçš„ç‰©ä½“ç©ºé—´åæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°å¯¹åº”é¡¶ç‚¹çš„æŸä¸¤å¥—UVä¸­ï¼Œæœ¬æ–‡æ˜¯å†™åˆ°ç¬¬äºŒå¥—å’Œç¬¬ä¸‰å¥—UVä¸­ï¼ˆä¹Ÿå°±æ˜¯TEXCOORD1å’ŒTEXCOORD2ï¼‰ã€‚äºæ˜¯æˆ‘æ¶è¡¥äº†ä¸€ä¸‹mayaçš„pythonè„šæœ¬çš„å†™æ³•ï¼Œä¸è¿‡åœ¨å†™æ•°å€¼åˆ°UVä¸­æ—¶ï¼Œåˆé‡åˆ°äº†ä¸€ä¸ªå°é—®é¢˜ã€‚Mayaçš„cmds.polyEditUVè¿™ä¸ªæ–¹æ³•ï¼Œæ˜æ˜èƒ½ä¼ å…¥uvSetNameè¿™ä¸ªå‚æ•°ï¼Œç”¨äºæ“ä½œå¯¹åº”çš„UVï¼Œä½†æˆ‘å®é™…ä½¿ç”¨æ—¶åªèƒ½å†™æ•°å€¼åˆ°å½“å‰çš„UVä¸­ï¼Œå¯¼è‡´æœ€åå†™çš„è„šæœ¬åªèƒ½åƒµç¡¬çš„æ“ä½œå½“å‰UVï¼Œæ¯æ¬¡åˆ‡æ¢UVæ—¶éœ€è¦é‡æ–°ä¿®æ”¹è„šæœ¬å†è¿è¡Œä¸€æ¬¡ã€‚\næœ€ç»ˆçš„è„šæœ¬æ˜¯è¿™æ ·çš„ï¼š\nVertexPivotWriteTool.py import maya.cmds as cmds targetVertexStr = \"Select any vertex to start.\" vertexColorStr = \"Select any vertex to start.\" pivotPosition = [0.0, 0.0, 0.0] def ui(): if cmds.window(\"VertexPivotWriteTool\", exists = True): cmds.deleteUI(\"VertexPivotWriteTool\") global targetVertexStr global targetVertexField global vertexColorStr global vertexColorField global pivotLayer vertexPivotWindow = cmds.window(\"VertexPivotWriteTool\", widthHeight = [500, 400]) form = cmds.formLayout(numberOfDivisions = 100) pivotLayerLable = cmds.text(\"Pivot Layer (0 for root pivot)\") pivotLayer = cmds.intField() cmds.intField(pivotLayer, e = True, minValue = 0, maxValue = 5, step = 1, value = 0) targetVertexButton = cmds.button(\"Target Vertex\", command = 'GetTargetVertex()') targetVertexField = cmds.textField(text=targetVertexStr, width = 300) #writeVertexButton = cmds.button(\"Write to Vertex Color\", command = 'WriteToVertexColor()') writeVertexButton = cmds.button(\"Write to Vertex Texcoord\", command = 'WriteToVertexTexcoord()') targetVertexColorButton = cmds.button(\"Show Vertex Color\", command = 'GetTargetVertexColor()') vertexColorField = cmds.textField(text=vertexColorStr, width = 300) cmds.showWindow(vertexPivotWindow) cmds.formLayout(form, e=True, attachForm = ( [pivotLayerLable, 'left', 25], [pivotLayerLable, 'top', 20], [pivotLayer, 'right', 25], [pivotLayer, 'top', 20], [targetVertexButton, 'left', 25], [targetVertexButton, 'top', 60], [targetVertexField, 'right', 25], [targetVertexField, 'top', 60], [writeVertexButton, 'left', 25], [writeVertexButton, 'top', 100], [targetVertexColorButton, 'left', 25], [targetVertexColorButton, 'bottom', 20], [vertexColorField, 'right', 25], [vertexColorField, 'bottom', 20], )) def GetPivotLayer(): value = cmds.intField(pivotLayer, q=True, value=True) print(\"pivotLayerValue is: \" + str(value)) return value def GetTargetVertex(): print(\"Get Target Vertex...\") selVertices = cmds.ls(selection = True) global targetVertexStr global pivotPosition if len(selVertices) == 0: targetVertexStr = \"No vetex selected!\" elif len(selVertices) = 2: targetVertexStr = \"Too many vertices selected! Expected 1, got \" + str(len(selVertices)) else: pivotPosition = cmds.pointPosition(selVertices[0]) tempStr = \"(\" for axis in range(len(pivotPosition)): if axis = 1: tempStr += \", \" tempStr += \"{:.2f}\".format(pivotPosition[axis]) tempStr += \")\" targetVertexStr = tempStr cmds.textField(targetVertexField, e= True, text = targetVertexStr) def GetTargetVertexColor(): print(\"Get Target Vertex...\") selVertices = cmds.ls(selection = True) global vertexColorStr if len(selVertices) == 0: vertexColorStr = \"No vetex selected!\" elif len(selVertices) = 2: vertexColorStr = \"Too many vertices selected! Expected 1, got \" + str(len(selVertices)) else: vertexColor = cmds.polyColorPerVertex(query=True, rgb=True) tempStr = \"(\" for axis in range(len(vertexColor)): if axis = 1: tempStr += \", \" tempStr += \"{:.2f}\".format(vertexColor[axis]) tempStr += \")\" vertexColorStr = tempStr cmds.textField(vertexColorField, e= True, text = vertexColorStr) def WriteToVertexColor(): print(\"Write To Vertex Color...\") selVertices = cmds.ls(selection = True) for vertex in selVertices: cmds.polyColorPerVertex(vertex, rgb=(pivotPosition[0], pivotPosition[1], pivotPosition[2])) def WriteToVertexTexcoord(): print(\"Write To Vertex Coord...\") pivotLayerValue = GetPivotLayer() allUVSets = cmds.polyUVSet( query=True, allUVSets=True ) uvSetCount = len(allUVSets) cmds.polyEditUV(relative = False, uValue = pivotPosition[0], vValue = pivotPosition[1]) #cmds.polyEditUV(relative = False, uValue = pivotPosition[2], vValue = pivotLayerValue) ui() å› ä¸ºç§ç§é™åˆ¶ï¼Œä½¿ç”¨æ—¶è¾ƒä¸ºå¤æ‚ï¼Œå¦‚æœæœ‰æ›´å¥½çš„è„šæœ¬çš„è¯ï¼Œä¹Ÿå¾ˆæ„Ÿè°¢åˆ†äº«å‡ºæ¥å‘Šè¯‰æˆ‘ã€‚é¦–å…ˆæ˜¯è¦åœ¨UVé›†ç¼–è¾‘å™¨ä¸­ï¼Œä¸ºæ¨¡å‹æ–°å¢ä¸¤å¥—UVï¼Œç”±äºä½¿ç”¨çš„MegaScansæ¨¡å‹æœ¬èº«æœ‰ä¸¤å¥—ä¸åŒçš„UVï¼Œæ“ä½œæ˜¯æŠŠåŸæ¥çš„ç¬¬äºŒå¥—UVç§»åŠ¨åˆ°ç¬¬å››å¥—UVä¸­ï¼Œç„¶åæŠŠç¬¬ä¸€å¥—UVå¤åˆ¶åˆ°ç¬¬äºŒç¬¬ä¸‰å¥—UVä¸­ï¼Œç„¶ååœ¨UVç¼–è¾‘å™¨ä¸­å®šä½å½“å‰UVåˆ°ç¬¬äºŒå¥—UVã€‚åœ¨è„šæœ¬ç¼–è¾‘å™¨ä¸­æ‰“å¼€æˆ–è€…å¤åˆ¶ä¸Šé¢çš„VertexPivotWriteTool.pyï¼Œé€šè¿‡Crtl + Enterå¯ä»¥ç”Ÿæˆè¯¥è„šæœ¬çš„ä¸€ä¸ªçª—å£ã€‚ç„¶åæ‰§è¡Œä¸‹è¿°æ“ä½œï¼šé¦–å…ˆæ˜¯å°†æ¯ä¸ªpivotçš„å‰ä¸¤ä¸ªåæ ‡å†™åˆ°ç¬¬äºŒå¥—UVä¸­ï¼Œå¯¹èŒæ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€åº•ä¸‹çš„é¡¶ç‚¹ï¼Œå¯¹å¶ç‰‡æ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€æ¥è¿‘èŒçš„é¡¶ç‚¹ï¼Œé€‰ä¸­è¿™ä¸ªé¡¶ç‚¹ç„¶åç‚¹å‡»Target Vertexï¼Œåœ¨çª—å£ä¸­å¯ä»¥çœ‹åˆ°è¿™ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼›ç„¶ååœ¨UVç¼–è¾‘å™¨é€‰ä¸­è¯¥èŒæˆ–è€…å¶ç‰‡çš„UVå£³ï¼Œç‚¹å‡»Write to Vertex Texcoordï¼Œåœ¨UVç¼–è¾‘å™¨ä¸­å¯ä»¥çœ‹åˆ°UVåç¼©æˆäº†ä¸€ä¸ªç‚¹ï¼ˆå¾€å¾€æ‰¾ä¸åˆ°ï¼‰ï¼›å¯¹ç¬¬äºŒå¥—UVä¸­çš„æ‰€æœ‰çš„UVå£³æ‰§è¡Œä¸Šè¿°æ“ä½œï¼›ç„¶åå°†å½“å‰UVåˆ‡æ¢åˆ°ç¬¬ä¸‰å¥—UVï¼ŒåŒæ—¶æ³¨é‡Šæ‰è„šæœ¬çš„ç¬¬117è¡Œï¼Œå–æ¶ˆæ³¨é‡Šè„šæœ¬çš„ç¬¬118è¡Œï¼Œç„¶åè¾“å…¥Crtl + Enteré‡æ–°ç”Ÿæˆä¸€éå·¥å…·ï¼›è¿™æ—¶æˆ‘ä»¬å°†è¦æŠŠæ¯ä¸ªpivotçš„æœ€åä¸€ä¸ªåæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°ç¬¬ä¸‰å¥—UVä¸­ï¼›å¯¹æ¤è¢«çš„æ¯ä¸€ç‰‡å¶å­å’Œæå¹²ï¼Œåˆ¤æ–­å…¶pivotçš„å±‚çº§ï¼ˆä»¥ç°åœ¨ä½¿ç”¨çš„MegaScansæ¨¡å‹ä¸ºä¾‹ï¼ŒèŒçš„å±‚çº§æ˜¯0ï¼Œå…¶ä»–å¶ç‰‡çš„å±‚çº§æ˜¯1ï¼‰ï¼Œåœ¨Pivot Layerä¸­è¾“å…¥å±‚çº§ï¼›ç„¶åé‡å¤åˆ¤æ–­å±‚çº§ï¼Œé€‰æ‹©é¡¶ç‚¹ï¼Œå†™å…¥UVï¼›æœ€åæœ€åï¼Œä¸è¦å¿˜è®°æŠŠè„šæœ¬è¿˜åŸæˆæœ€å¼€å§‹çš„æ ·å­ã€‚è¿™æ ·å°±æŠŠæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„pivotåæ ‡å†™å…¥åˆ°ç¬¬äºŒå’Œç¬¬ä¸‰å¥—UVäº†ï¼å¯¼å‡ºåˆ°Unityå°±å¯ä»¥äº†ã€‚\nå¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿ é¦–å…ˆæ¥çœ‹è¿™æ ·ä¸€å¼ å›¾ï¼š\nè¿™å¼ å›¾è¡¨ç°äº†åœ¨Bend Spaceä¸­æŠŠçº¢è‰²çš„çº¿æ®µå¼¯æ›²åˆ°ç»¿è‰²çº¿æ®µçš„ç®—æ³•ï¼ŒXè½´æ˜¯é£çš„æ–¹å‘ï¼Œå¯ä»¥çœ‹åˆ°é£çš„å¼ºåº¦è¶Šé«˜ï¼ŒRadiusçš„å¤§å°å°±è¶Šå°ã€‚åŒæ—¶ä¸ºäº†è®¡ç®—å‡ºæ­£ç¡®çš„æ³•çº¿å’Œåˆ‡çº¿ï¼Œéœ€è¦åŒæ ·çš„è®¡ç®—å‡ºAxisXå’ŒAxisZåœ¨Bend Spaceä¸­çš„å‘é‡ã€‚ä½¿ç”¨è¿™ä¸ªç®—æ³•ï¼Œå½“æ¨¡å‹å¤„åœ¨Bend Spaceçš„Zè½´ä¸Šæ—¶ï¼Œä¸ä¼šå—åˆ°æ‰­æ›²ï¼Œå½“å…¶Xè½´å¤§äº0æ—¶ï¼Œä¼šå—åˆ°å‹ç¼©ï¼Œå½“Xè½´å°äº0æ—¶ï¼Œä¼šå—åˆ°æ‹‰ä¼¸ã€‚åŒæ ·çš„ï¼Œè¿™ç§ç®—æ³•å¯ä»¥æ¨å¹¿åˆ°ä¸‰ç»´ç©ºé—´ä¸­ï¼ŒåŒæ—¶æ‰­æ›²Yè½´å’ŒZè½´ï¼Œæˆ‘ç‰¹åœ°å†™äº†ä¸€ä¸ªC#è„šæœ¬æ¥å¯¹å˜æ¢çš„ç»“æœè¿›è¡Œå¯è§†åŒ–ã€‚\nWindDebugger.cs using UnityEngine; using Unity.Mathematics; public class WindDebugger : MonoBehaviour { public bool draw = true; public float debugRadius = 0.01f; public float debugLength = 0.2f; public Color pivotColor; public Color sphereColor; public float radius; public float3 originalPosition; private void DrawAxes(Color color, Vector3 pos, Vector3 tangent, Vector3 bitangent, Vector3 normal) { Gizmos.color = color; Gizmos.DrawSphere(pos, debugRadius); Gizmos.color = Color.red; Gizmos.DrawLine(pos, pos + tangent * debugLength); Gizmos.color = Color.green; Gizmos.DrawLine(pos, pos + bitangent * debugLength); Gizmos.color = Color.blue; Gizmos.DrawLine(pos, pos + normal * debugLength); } private float3 CircleTransform(float3 positionBS, float radius, out float3 axisX, out float3 axisY, out float3 axisZ) { float radVal = math.length(positionBS.xy) / radius; float sinVal = math.sin(radVal); float cosVal = math.cos(radVal); float2 normalizeDir = math.normalize(positionBS.xy); float3 targetPosBS = new float3((radius * sinVal) * normalizeDir, radius - radius * cosVal); float3 tempAxisX = new float3(-sinVal * normalizeDir, cosVal); float3 tempAxisY = new float3(normalizeDir.y, -normalizeDir.x, 0.0f); float3 tempAxisZ = new float3(cosVal * normalizeDir, sinVal); axisX = tempAxisX; axisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ; axisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ; float3 newPositionBS = targetPosBS + axisX * positionBS.z; return newPositionBS; } private void OnDrawGizmos() { if (!draw) { return; } Color originalColor = Gizmos.color; Gizmos.color = sphereColor; Gizmos.DrawSphere(new float3(0.0f, 0.0f, radius), radius); float3 axisX, axisY, axisZ; float3 newPosition = CircleTransform(originalPosition, radius, out axisX, out axisY, out axisZ); DrawAxes(pivotColor, newPosition, axisY, axisZ, axisX); DrawAxes(pivotColor, originalPosition, new float3(1.0f, 0.0f, 0.0f), new float3(0.0f, 1.0f, 0.0f), new float3(0.0f, 0.0f, 1.0f)); Gizmos.color = Color.black; Gizmos.DrawLine(float3.zero, originalPosition); Gizmos.color = Color.white; Gizmos.DrawLine(float3.zero, newPosition); Gizmos.color = originalColor; } } å…¶ä»–çš„ä¸€äº›é—®é¢˜ ç”±äºæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ä¸­ç”¨åˆ°äº†å¾ˆå¤šçš„åæ ‡å˜æ¢ï¼Œéœ€è¦ç‰¹åˆ«çš„æ³¨æ„æ¯ä¸€æ¬¡å˜æ¢æ˜¯ä»ä»€ä¹ˆç©ºé—´å˜æ¢åˆ°ä»€ä¹ˆç©ºé—´ã€‚é¦–å…ˆæ˜¯ç‰©ä½“ç©ºé—´åˆ°é£çš„å¼¯æ›²ç©ºé—´ï¼Œç”±äºæˆ‘ä»¬CircleTransformæ–¹æ³•æ˜¯è®¤ä¸ºé£æ˜¯å¹å‘Xè½´æ­£æ–¹å‘çš„ï¼Œæ‰€ä»¥éœ€è¦å…ˆå¯¹æ‰€æœ‰çš„åæ ‡ã€å‘é‡è¿›è¡Œä¸€ä¸ªå˜æ¢ï¼Œç”±äºåªæ¶‰åŠåˆ°æ—‹è½¬ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ªfloat3x3çš„çŸ©é˜µæ¥è¡¨ç¤ºä»ç‰©ä½“ç©ºé—´åˆ°å¼¯æ›²ç©ºé—´çš„å˜æ¢çŸ©é˜µã€‚\nç„¶ååˆ†ä¸¤ç§æƒ…å†µï¼šä¸€ç§æ˜¯Pivot Layerä¸º0çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ‰€ä½¿ç”¨çš„æ¨¡å‹çš„èŒä¸Šçš„é¡¶ç‚¹ã€‚è¿™ç§ç›¸å¯¹ç®€å•ï¼Œå°†é¡¶ç‚¹åœ¨ç‰©ä½“Bend Spaceä¸­è¿›è¡ŒCircleTransformåï¼Œå°±èƒ½è·å¾—æ–°çš„Bend Spaceçš„åæ ‡å’Œæ–°çš„ä¸‰ä¸ªè½´çš„å‘é‡ï¼ˆæ–°çš„ä¸‰ä¸ªè½´å¯ä»¥ç»„åˆå‡ºé¡¶ç‚¹çš„Bend Spaceåˆ°ç‰©ä½“çš„Bend Spaceçš„å˜æ¢çŸ©é˜µï¼‰ï¼Œå¯ä»¥è®¡ç®—å‡ºé¡¶ç‚¹ã€æ³•çº¿å’Œåˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡å’Œå‘é‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚\nç¬¬äºŒç§æ˜¯Pivot Layerä¸º1çš„é¡¶ç‚¹ï¼Œè¦å…ˆè®¡ç®—å‡ºPivotçš„æ–°çš„ç‰©ä½“Bend Spaceåæ ‡ï¼Œç„¶ååœ¨å…¶åŸºç¡€ä¸Šè®¡ç®—å‡ºæ¯ä¸€ä¸ªé¡¶ç‚¹ç›¸å¯¹äºPivot Bend Spaceçš„æ–°çš„åæ ‡ï¼Œç„¶åä¸€å±‚å¥—ä¸€å±‚çš„ç®—å›é¡¶ç‚¹åŠå…¶æ³•çº¿åˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘åœ¨è®¡ç®—pivotçš„Bend Spaceæ—¶ï¼Œæ‰€ä½¿ç”¨çš„ç©ºé—´å’Œä¹‹å‰å›¾ä¸Šä¸å¤ªä¸€æ ·ï¼Œæ˜¯AxisZ, AxisYå’Œ-AxisXå¯¹åº”æ–°çš„Bend Spaceçš„XYZè½´ï¼Œè¿™æ ·èƒ½è®©å‚ç›´äºæå¹²çš„å¶ç‰‡æœ‰æ›´å¥½çš„é£å¹çš„æ•ˆæœã€‚\nä¸ºäº†è®©éšé£æ‘†åŠ¨çš„æ•ˆæœçœ‹ä¸Šå»æ›´è‡ªç„¶ï¼Œé™¤äº†æŒ‰ç…§åœ†å½¢æ¥å˜æ¢é¡¶ç‚¹ä¹‹å¤–ï¼Œå‚è€ƒé¡½çš®ç‹—çš„æ¼”è®²ï¼Œè¿˜è¦ç»™æå¹²çš„æ‘‡æ™ƒæ·»åŠ ä¸€ä¸ªå’Œè·ç¦»ç›¸å…³çš„å»¶è¿Ÿï¼Œè¿™æ ·ä¸ä¼šæ˜¾å¾—ç”Ÿç¡¬ã€‚è‡³äºéšé£é£˜åŠ¨çš„é¢‘ç‡ï¼Œå°±éšä¾¿æ‰¾ä¸€ä¸ªsinå‡½æ•°çš„ç»„åˆå°±å¯ä»¥äº†ã€‚\nå…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ é¡¶ç‚¹ç€è‰²å™¨å°±æŒ‰ç…§ä¹‹å‰ä»‹ç»çš„æ¥åšå°±å¯ä»¥äº†ã€‚ç”±äºè¾ƒå¥½çœ‹çš„æ¤è¢«éƒ½æ˜¯åŒé¢æ¸²æŸ“çš„ï¼Œåœ¨Cullçš„å‚æ•°é‡Œé¢é€‰æ‹©Offã€‚è¿™æ ·åŒæ ·çš„ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æ¨¡å‹èƒŒé¢çš„æ³•çº¿å’Œæ­£é¢çš„æ³•çº¿æ˜¯ç›¸åŒçš„ï¼Œè¿™é‡Œéœ€è¦ä½¿ç”¨HLSLç‰‡å…ƒç€è‰²å™¨çš„VFACEè¯­ä¹‰ï¼Œæ¥åˆ¤æ–­å½“å‰é¢æ˜¯æ­£é¢è¿˜æ˜¯èƒŒé¢ï¼Œå¦‚æœæ˜¯èƒŒé¢çš„è¯éœ€è¦åè½¬ä¸€ä¸‹æ³•çº¿ã€‚è¿™é‡Œå†™çš„Shaderä¹ŸåŒæ—¶å†™äº†é˜´å½±ã€æ·±åº¦å›¾å’Œçƒ˜ç„™æ‰€éœ€è¦çš„passã€‚\nVertexAnimationPlantShader.shader Shader \"zznewclear13/VertexAnimationPlantShader\"\r{\rProperties\r{\r_BaseColor (\"Base Color\", color) = (1, 1, 1, 1)\r_BaseMap(\"Base Map\", 2D) = \"white\" {}\r_BumpMap (\"Bump Map\", 2D) = \"bump\" {}\r_BumpIntensity (\"Bump Intensity\", range(0, 1)) = 1\r_RoughnessMap(\"Roughness Map\", 2D) = \"white\" {}\r_RoughnessIntensity (\"Roughness Intensity\", range(0, 1)) = 1\r_MetallicMap (\"Metallic Map\", 2D) = \"black\" {}\r_MetallicIntensity (\"Metallic Intensity\", range(0, 1)) = 1\r_WindDirection (\"Wind Direction\", vector) = (1.0, 0.0, 0.0, 0.0)\r_WindIntensity (\"Wind Intensity\", float) = 1\r_WindVariety (\"Wind Variety\", range(0, 10)) = 0.5\r_BranchDelay (\"Branch Delay\", range(0, 10)) = 2\r_WindVarietyLeaves (\"Wind Variety Leaves\", range(0, 10)) = 1\r_BranchDelayLeaves (\"Branch Delay Leaves\", range(0, 10)) = 3\r_WindVaryFrequency (\"Wind Vary Frequency\", float) = 5\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\rsampler2D _BaseMap;\rsampler2D _BumpMap;\rsampler2D _RoughnessMap;\rsampler2D _MetallicMap;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat4 _BaseMap_ST;\rfloat _BumpIntensity;\rfloat _RoughnessIntensity;\rfloat _MetallicIntensity;\rfloat4 _WindDirection;\rfloat _WindIntensity;\rfloat _WindVariety;\rfloat _BranchDelay;\rfloat _WindVarietyLeaves;\rfloat _BranchDelayLeaves;\rfloat _WindVaryFrequency;\rCBUFFER_END\r//Apply wind variety\rfloat GetVariety(float timeFunction)\r{\rreturn sin(timeFunction) + 0.25 * sin(timeFunction * 1.5) + 0.1 * sin(timeFunction * 0.33);\r}\r//CircleTransform transforms a current bend space point to a new position in bend space,\r//and output three axes of next bend space.\r//New position is in current bend space and ready for use.\r//Normal and tangent in current bend space can be calculated by axes.\rfloat3 CircleTransform(float3 positionBS, float windIntensity, out float3 axisX, out float3 axisY, out float3 axisZ)\r{\rfloat intensity = windIntensity;\rif(intensity == 0.0 || length(positionBS.yz) == 0.0)\r{\raxisX = float3(1.0, 0.0, 0.0);\raxisY = float3(0.0, 1.0, 0.0);\raxisZ = float3(0.0, 0.0, 1.0);\rreturn positionBS;\r}\rfloat radius = rcp(intensity);\rfloat radVal = length(positionBS.yz) * intensity;\rfloat sinVal = sin(radVal);\rfloat cosVal = cos(radVal);\rfloat2 normalizeDir = normalize(positionBS.yz);\rfloat3 targetPosBS = float3(radius - radius * cosVal, (radius * sinVal) * normalizeDir);\rfloat3 tempAxisX = float3(cosVal, -sinVal * normalizeDir);\rfloat3 tempAxisY = float3(0.0, normalizeDir.y, -normalizeDir.x);\rfloat3 tempAxisZ = float3(sinVal, cosVal * normalizeDir);\raxisX = tempAxisX;\raxisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ;\raxisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ;\rfloat3 newPositionBS = targetPosBS + axisX * positionBS.x;\rreturn newPositionBS;\r}\r//windDirection: object space, upVec: world upVec in object space\rvoid InitBendSpace(float3 windDirection, float3 upVec, out float3x3 objectToBend, out float3x3 bendToObject)\r{\rfloat3 u = windDirection;\rfloat3 v = normalize(cross(upVec, u));\rfloat3 w = cross(u, v);\r//Object space to bend space objectToBend = float3x3(u, v, w);\r//Bend space to object space\rbendToObject = float3x3(u.x, v.x, w.x, u.y, v.y, w.y, u.z, v.z, w.z);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\" = \"Transparent\" \"Queue\" = \"Transparent\"}\rPass\r{\rName \"ForwardLit\"\rTags{\"LightMode\" = \"UniversalForward\"}\rCull Off\rBlend SrcAlpha OneMinusSrcAlpha\rZWrite On\rHLSLPROGRAM\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\r#pragma shader_feature_local _NORMALMAP\r#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\r#pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\r#pragma multi_compile _ SHADOWS_SHADOWMASK #pragma multi_compile_fragment _ _SHADOWS_SOFT\r#pragma multi_compile _ LIGHTMAP_ON\r#pragma vertex LitPassVert\r#pragma fragment LitPassFrag\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord0 : TEXCOORD0;\rfloat2 texcoord1 : TEXCOORD1;\rfloat2 texcoord2 : TEXCOORD2;\rfloat2 staticLightmapUV : TEXCOORD3;\rUNITY_VERTEX_INPUT_INSTANCE_ID\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat3 positionWS : TEXCOORD1;\rfloat3 normalWS : TEXCOORD2;\rfloat4 tangentWS : TEXCOORD3;\rfloat4 shadowCoord : TEXCOORD4;\rDECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, 5);\rUNITY_VERTEX_INPUT_INSTANCE_ID\rUNITY_VERTEX_OUTPUT_STEREO\r};\r//////////////////////////////////\r//GGX BRDF and related functions//\r//////////////////////////////////\rfloat D(float ndoth, float roughness)\r{\rfloat a = ndoth * roughness;\rfloat k = roughness / (1.0 - ndoth * ndoth + a * a);\rreturn k * k;\r}\rfloat G(float ndotl, float ndotv, float roughness)\r{\rfloat a2 = roughness * roughness;\rfloat gv = ndotv * sqrt((1.0 - a2) * ndotl * ndotl + a2);\rfloat gl = ndotl * sqrt((1.0 - a2) * ndotv * ndotv + a2);\rreturn 0.5 * rcp(gv + gl);\r}\rfloat3 F(float3 specular, float hdotl)\r{\rreturn specular + (1 - specular) * pow(1 - hdotl, 5);\r}\rfloat3 GGXBRDF(float3 wi, float3 wo, float3 normal, float3 specular, float roughness)\r{\rfloat3 h = normalize(wi + wo);\rfloat ndotv = max(dot(normal, wo), 1e-5);\rfloat ndoth = max(dot(normal, h), 0.0);\rfloat ndotl = max(dot(normal, wi), 0.0);\rfloat hdotl = max(dot(h, wi), 0.0);\rfloat d = D(ndoth, roughness);\rfloat g = G(ndotl, ndotv, roughness);\rfloat3 f = F(specular, hdotl);\rreturn d * g * f;\r}\rVaryings LitPassVert(Attributes input)\r{\rVaryings output = (Varyings)0;\rUNITY_SETUP_INSTANCE_ID(input);\rUNITY_TRANSFER_INSTANCE_ID(input, output);\rUNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\r//Pivot positions are stored in TEXCOORD1.xy and TEXCOORD2.x.\rfloat3 pivotPosition = float3(input.texcoord1.xy, input.texcoord2.x) * 0.01;\rfloat3 pointOffset = input.positionOS.xyz - pivotPosition;\r//Initialize Bend Space.\rfloat3 windDirectionOS = mul((float3x3)UNITY_MATRIX_I_M, _WindDirection.xyz);\rfloat3 upVec = mul((float3x3)UNITY_MATRIX_I_M, float3(0.0, 1.0, 0.0));\rwindDirectionOS = normalize(windDirectionOS);\rupVec = normalize(upVec);\rfloat3x3 objectToBend, bendToObject;\rInitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject);\r//Initialize vertex data, transform from object space to bend space.\rfloat3 pivotPositionBS = mul(objectToBend, pivotPosition);\rfloat3 pointOffsetBS = mul(objectToBend, pointOffset);\rfloat3 originalTangentBS = mul(objectToBend, input.tangentOS.xyz);\rfloat3 originalNormalBS = mul(objectToBend, input.normalOS);\rfloat3 windPointBS;\rfloat3 windTangentBS;\rfloat3 windNormalBS;\r//TEXCOORD2.y is used to check pivot layers. 0 is root layer.\rif(input.texcoord2.y  0.5)\r{\r//////////////////////////////////\r//Calculate pivot root transform//\r//////////////////////////////////\r//Get pivot wind intensity.\rfloat intensity = _WindIntensity;\rfloat magnitude = length(pivotPositionBS);\rintensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);\r//Calculate new position bent by wind in bend space,\r//and save the transform matrix.\rfloat3 axisX, axisY, axisZ;\rfloat3 windPivotPositionBS = CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ);\rfloat4x4 pivotBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));\r/////////////////////////////\r//Calculate point transform//\r/////////////////////////////\r//Switch axes, transform to next bend space (point bend space).\rpointOffsetBS = float3(pointOffsetBS.z, pointOffsetBS.y, -pointOffsetBS.x);\r//Get point wind intensity.\rintensity = abs(axisZ.x) * _WindIntensity;//_WindIntensityLeaves;\rmagnitude = length(pointOffsetBS);\rintensity += _WindVarietyLeaves * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelayLeaves);\r//Calculate new position bent by wind in bend space,\r//and save the transform matrix from point bend space to pivot bend space.\r//This transform matrix can be used to calculate normal and tangent.\rfloat3 windPointPositionBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);\rfloat4x4 pointBSToPivotBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));\r//Switch axes, transform to pivot bend space.\rwindPointPositionBS = float3(-windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x);\r//Calculate position, normal and tangent in pivot bend space.\rfloat3 windPointPS = windPointPositionBS;\rfloat3 windTangentPS = mul((float3x3)pointBSToPivotBS, originalTangentBS);\rfloat3 windNormalPS = mul((float3x3)pointBSToPivotBS, originalNormalBS);\r//Calculate position, normal and tangent in object bend space.\rwindPointBS = mul(pivotBSToObjBS, float4(windPointPS, 1.0)).xyz;\rwindTangentBS = mul((float3x3)pivotBSToObjBS, windTangentPS);\rwindNormalBS = mul((float3x3)pivotBSToObjBS, windNormalPS);\r}\relse\r{\r//////////////////////////////////\r//Calculate point transform only//\r//////////////////////////////////\r//Get point wind intensity.\rfloat intensity = _WindIntensity;\rfloat magnitude = length(pointOffsetBS);\rintensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);\rfloat3 axisX, axisY, axisZ;\rfloat3 windPointOffsetBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);\rfloat4x4 pointBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), float4(0.0, 0.0, 0.0, 1.0));\rwindPointBS = windPointOffsetBS + pivotPositionBS;\rwindTangentBS = mul((float3x3)pointBSToObjBS, originalTangentBS);\rwindNormalBS = mul((float3x3)pointBSToObjBS, originalNormalBS);\r}\r//Transform from bend space to object space\rfloat3 pivotPositionOS = mul(bendToObject, windPointBS);\rfloat3 pivotTangentOS = mul(bendToObject, windTangentBS);\rfloat3 pivotNormalOS = mul(bendToObject, windNormalBS);\rVertexPositionInputs vertexInput = GetVertexPositionInputs(pivotPositionOS);\rVertexNormalInputs normalInput = GetVertexNormalInputs(pivotNormalOS, float4(pivotTangentOS, input.tangentOS.w));\routput.positionCS = vertexInput.positionCS;\routput.uv = TRANSFORM_TEX(input.texcoord0, _BaseMap);\routput.positionWS = vertexInput.positionWS;\routput.normalWS = normalInput.normalWS;\routput.tangentWS = float4(normalInput.tangentWS, input.tangentOS.w);\routput.shadowCoord = TransformWorldToShadowCoord(vertexInput.positionWS);\rOUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);\rOUTPUT_SH(normalInput.normalWS.xyz, output.vertexSH);\routput.normalWS = normalInput.normalWS;\rreturn output;\r}\rfloat4 LitPassFrag(Varyings input, float vFace : VFACE) : SV_TARGET\r{\rUNITY_SETUP_INSTANCE_ID(input);\rUNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);\r//wo\rfloat3 positionWS = input.positionWS;\rfloat3 viewDirWS = GetWorldSpaceNormalizeViewDir(positionWS);\r//wi\rfloat4 shadowCoord = TransformWorldToShadowCoord(positionWS);\rfloat4 shadowMask = SAMPLE_SHADOWMASK(input.staticLightmapUV);\rLight mainLight = GetMainLight(shadowCoord, positionWS, shadowMask);\r//normal\rfloat3 normalMap = UnpackNormal(tex2D(_BumpMap, input.uv));\rnormalMap.xy *= _BumpIntensity;\rfloat3 bitangentWS = cross(input.normalWS, input.tangentWS.xyz) * input.tangentWS.w;\rfloat3x3 tbn = float3x3(input.tangentWS.xyz, bitangentWS, input.normalWS);\rfloat3 normalWS = mul(normalMap, tbn);\rnormalWS = normalize(input.normalWS);\r//If we are looking and back faces, revert the normal.\rnormalWS = vFace  0.5 ? normalWS: -normalWS;\r//material properties\rfloat4 baseMap = tex2D(_BaseMap, input.uv) * _BaseColor;\rclip(baseMap.a - 0.5);\rfloat roughnessMap = tex2D(_RoughnessMap, input.uv).r;\rfloat roughness = max(roughnessMap * _RoughnessIntensity, 1e-2);\rfloat metallicMap = tex2D(_MetallicMap, input.uv).r;\rfloat metallic = metallicMap * _MetallicIntensity;\rfloat oneMinusReflectivity = kDieletricSpec.a * (1 - metallic);\rfloat reflectivity = 1.0 - oneMinusReflectivity;\rfloat3 diffuse = baseMap.rgb * oneMinusReflectivity;\rfloat3 specular = lerp(kDieletricSpec.rgb, baseMap.rgb, metallic); //gi\rfloat3 bakedGI = SAMPLE_GI(input.staticLightmapUV, input.vertexSH, normalWS);\rMixRealtimeAndBakedGI(mainLight, normalWS, bakedGI);\rfloat3 giDiffuse = bakedGI;\rfloat3 reflectVector = reflect(-viewDirWS, normalWS);\rfloat3 giSpecular = GlossyEnvironmentReflection(reflectVector, positionWS, roughness, 1.0);\r//directional lights\rfloat3 directDiffuse = diffuse;\rfloat3 directSpecular = GGXBRDF(mainLight.direction, viewDirWS, normalWS, specular, roughness);\rfloat ndotl = saturate(dot(mainLight.direction, normalWS));\rfloat atten = mainLight.shadowAttenuation;\r//indirectional lights\rfloat3 indirectDiffse = giDiffuse * diffuse;\rfloat surfaceReduction = rcp(roughness * roughness + 1.0);\rfloat grazingTerm = saturate(1.0 - roughness + reflectivity);\rfloat ndotv = saturate(dot(normalWS, viewDirWS));\rfloat fresnelTerm = pow(1.0 - ndotv, 5.0);\rfloat3 indirectSpecular = giSpecular * surfaceReduction * lerp(specular, grazingTerm, fresnelTerm);\r//final compose\rfloat3 directBRDF = (directDiffuse + directSpecular) * mainLight.color * atten * ndotl;\rfloat3 indirectBRDF = indirectDiffse + indirectSpecular;\rfloat3 finalColor = directBRDF + indirectBRDF;\rreturn float4(finalColor, baseMap.a);\r}\rENDHLSL\r}\rPass\r{\rName \"ShadowCaster\"\rTags{\"LightMode\" = \"ShadowCaster\"}\rHLSLPROGRAM\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\r#pragma vertex ShadowPassVertex\r#pragma fragment ShadowPassFragment\rfloat3 _LightDirection;\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord0 : TEXCOORD0;\rfloat2 texcoord1 : TEXCOORD1;\rfloat2 texcoord2 : TEXCOORD2;\rfloat4 color : COLOR;\rUNITY_VERTEX_INPUT_INSTANCE_ID\r};\rstruct Varyings\r{\rfloat2 uv : TEXCOORD0;\rfloat4 positionCS : SV_POSITION;\r};\rVaryings ShadowPassVertex(Attributes input)\r{\rVaryings output = (Varyings)0;\rUNITY_SETUP_INSTANCE_ID(input);\rUNITY_TRANSFER_INSTANCE_ID(input, output);\rUNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\rfloat3 pivotPosition = float3(input.texcoord1.xy, input.texcoord2.x) * 0.01;\rfloat3 pointOffset = input.positionOS.xyz - pivotPosition;\rfloat3 windDirectionOS = mul((float3x3)UNITY_MATRIX_I_M, _WindDirection.xyz);\rfloat3 upVec = mul((float3x3)UNITY_MATRIX_I_M, float3(0.0, 1.0, 0.0));\rwindDirectionOS = normalize(windDirectionOS);\rupVec = normalize(upVec);\rfloat3x3 objectToBend, bendToObject;\rInitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject);\rfloat3 pivotPositionBS = mul(objectToBend, pivotPosition);\rfloat3 pointOffsetBS = mul(objectToBend, pointOffset);\rfloat3 originalTangentBS = mul(objectToBend, input.tangentOS.xyz);\rfloat3 originalNormalBS = mul(objectToBend, input.normalOS);\rfloat3 windPointBS;\rfloat3 windTangentBS;\rfloat3 windNormalBS;\rif(input.texcoord2.y  0.5)\r{\rfloat intensity = _WindIntensity;\rfloat magnitude = length(pivotPositionBS);\rintensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);\rfloat3 axisX, axisY, axisZ;\rfloat3 windPivotPositionBS = CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ);\rfloat4x4 pivotBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));\rpointOffsetBS = float3(pointOffsetBS.z, pointOffsetBS.y, -pointOffsetBS.x);\rintensity = abs(axisZ.x) * _WindIntensity;//_WindIntensityLeaves;\rmagnitude = length(pointOffsetBS);\rintensity += _WindVarietyLeaves * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelayLeaves);\rfloat3 windPointPositionBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);\rfloat4x4 pointBSToPivotBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));\rwindPointPositionBS = float3(-windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x);\rfloat3 windPointPS = windPointPositionBS;\rfloat3 windTangentPS = mul((float3x3)pointBSToPivotBS, originalTangentBS);\rfloat3 windNormalPS = mul((float3x3)pointBSToPivotBS, originalNormalBS);\rwindPointBS = mul(pivotBSToObjBS, float4(windPointPS, 1.0)).xyz;\rwindTangentBS = mul((float3x3)pivotBSToObjBS, windTangentPS);\rwindNormalBS = mul((float3x3)pivotBSToObjBS, windNormalPS);\r}\relse\r{\rfloat intensity = _WindIntensity;\rfloat magnitude = length(pointOffsetBS);\rintensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);\rfloat3 axisX, axisY, axisZ;\rfloat3 windPointOffsetBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);\rfloat4x4 pointBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), float4(0.0, 0.0, 0.0, 1.0));\rwindPointBS = windPointOffsetBS + pivotPositionBS;\rwindTangentBS = mul((float3x3)pointBSToObjBS, originalTangentBS);\rwindNormalBS = mul((float3x3)pointBSToObjBS, originalNormalBS);\r}\rfloat3 pivotPositionOS = mul(bendToObject, windPointBS);\rfloat3 pivotTangentOS = mul(bendToObject, windTangentBS);\rfloat3 pivotNormalOS = mul(bendToObject, windNormalBS);\rVertexPositionInputs vertexInput = GetVertexPositionInputs(pivotPositionOS);\rVertexNormalInputs normalInput = GetVertexNormalInputs(pivotNormalOS, float4(pivotTangentOS, input.tangentOS.w));\routput.uv = TRANSFORM_TEX(input.texcoord0, _BaseMap);\routput.positionCS = TransformWorldToHClip(ApplyShadowBias(vertexInput.positionWS, normalInput.normalWS, _LightDirection));\rreturn output;\r}\rhalf4 ShadowPassFragment(Varyings input) : SV_TARGET\r{\rreturn 0.0;\r}\rENDHLSL\r}\rPass\r{\rName \"DepthOnly\"\rTags{\"LightMode\" = \"DepthOnly\"}\rHLSLPROGRAM\r#pragma vertex DepthOnlyVertex\r#pragma fragment DepthOnlyFragment\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat2 texcoord : TEXCOORD0;\rfloat4 color : COLOR;\rUNITY_VERTEX_INPUT_INSTANCE_ID\r};\rstruct Varyings\r{\rfloat2 uv : TEXCOORD0;\rfloat4 positionCS : SV_POSITION;\rUNITY_VERTEX_INPUT_INSTANCE_ID\rUNITY_VERTEX_OUTPUT_STEREO\r};\rVaryings DepthOnlyVertex(Attributes input)\r{\rVaryings output = (Varyings)0;\rUNITY_SETUP_INSTANCE_ID(input);\rUNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\rVertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS);\routput.uv = input.texcoord;\routput.positionCS = vertexInput.positionCS;\rreturn output;\r}\rhalf4 DepthOnlyFragment(Varyings input) : SV_TARGET\r{\rreturn 0.0;\r}\rENDHLSL\r}\rPass\r{\rName \"Meta\"\rTags{\"LightMode\" = \"Meta\"}\rHLSLPROGRAM\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\r#pragma vertex MetaVertex\r#pragma fragment MetaFragment\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat2 uv0 : TEXCOORD0;\rfloat2 uv1 : TEXCOORD1;\rfloat2 uv2 : TEXCOORD2;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\r};\rVaryings MetaVertex(Attributes input)\r{\rVaryings output;\routput.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST);\routput.uv = TRANSFORM_TEX(input.uv0, _BaseMap);\rreturn output;\r}\rhalf4 MetaFragment(Varyings input) : SV_Target\r{\r//material properties\rfloat4 baseMap = tex2D(_BaseMap, input.uv);\rfloat roughnessMap = tex2D(_RoughnessMap, input.uv).r;\rfloat roughness = max(roughnessMap * _RoughnessIntensity, 1e-2);\rfloat metallicMap = tex2D(_MetallicMap, input.uv).r;\rfloat metallic = metallicMap * _MetallicIntensity;\rfloat oneMinusReflectivity = kDieletricSpec.a * (1 - metallic);\rfloat reflectivity = 1.0 - oneMinusReflectivity;\rfloat3 diffuse = baseMap.rgb * oneMinusReflectivity;\rfloat3 specular = lerp(kDieletricSpec.rgb, baseMap.rgb, metallic);\rMetaInput metaInput;\rmetaInput.Albedo = diffuse;\rmetaInput.SpecularColor = specular;\rmetaInput.Emission = 0;\rreturn MetaFragment(metaInput);\r}\rENDHLSL\r}\r}\r}\råç»­çš„æ€è€ƒ é¦–å…ˆå…ˆè®²å¥½çš„æ–¹é¢ï¼Œé£å¹åŠ¨çš„æ•ˆæœç¡®å®ååˆ†è‡ªç„¶ï¼ŒåŒæ ·çš„è®¡ç®—å‡ºçš„æ­£ç¡®çš„æ³•çº¿åœ¨PBRçš„æ¸²æŸ“ä¸­ä¹Ÿååˆ†é‡è¦ï¼ˆé¡¶ç‚¹åŠ¨ç”»ä¸­æ­£ç¡®çš„æ³•çº¿å°¤å…¶ä¸æ˜“ï¼ï¼‰ã€‚ä½†æ˜¯ä¸è¶³ä¹‹å¤„æ˜¯çŸ©é˜µè¿ç®—è¿‡å¤šäº†ï¼Œä¸è¿‡çŸ©é˜µè¿ç®—å…¨éƒ½åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œæ¶ˆè€—ä¹Ÿä¸æ˜¯ç‰¹åˆ«å¤§ã€‚å¤ªå¤šçš„çŸ©é˜µè¿ç®—ä¹Ÿå¯¼è‡´äº†è¿™ç§ç®—æ³•çš„æ‰©å±•æ€§ä¸æ˜¯å¾ˆå¥½ï¼Œå¦‚æœæƒ³è¦æœ‰Pivot Layerä¸º3çš„é¡¶ç‚¹ï¼Œåœ¨ç›®å‰çš„ç®—æ³•é‡Œé¢æ˜¯æ²¡åŠæ³•è®¡ç®—çš„ï¼Œä¹Ÿä¸çŸ¥é“é¡½çš®ç‹—æ˜¯æ€ä¹ˆåšçš„äº†ã€‚åœ¨æ¨¡å‹çš„å½¢çŠ¶ä¸æ˜¯ç‰¹åˆ«å¥½çš„æ—¶å€™ï¼Œæ¯”å¦‚ä¸€ä¸ªquadæ¥æ¸²æŸ“è‰ï¼Œæˆ–è€…æ˜¯æ¨¡å‹å¶å­æ­ªæ­ªæ‰­æ‰­çš„ï¼Œä¼šæœ‰æ¯”è¾ƒå¤§çš„å˜å½¢ã€‚ä¸è¿‡ä»”ç»†è®¾ç½®æ¯ä¸€ä¸ªé¡¶ç‚¹çš„Pivotçš„è¯ï¼Œåº”è¯¥è¿˜æ˜¯èƒ½å¤Ÿè§£å†³ä¸€éƒ¨åˆ†é—®é¢˜çš„ï¼Œå½“ç„¶æ‹™åŠ£çš„Mayaè„šæœ¬åˆæˆäº†ä¸€ä¸ªç—›ç‚¹ã€‚\næ€»çš„æ¥è¯´æˆ‘è¿˜æ˜¯æ¯”è¾ƒæ»¡æ„çš„ï¼Œä¹Ÿç®—æ˜¯è§£å†³äº†ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„é—®é¢˜ï¼Œå½“ç„¶äº†ï¼Œæˆ‘å¯¹hugoèƒ½å¤Ÿæ”¯æŒgifå›¾ç‰‡æ›´åŠ æ»¡æ„ï¼\n","wordCount":"2794","inLanguage":"en","image":"https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/posts/images/VertexAnimatedPlant.gif","datePublished":"2022-01-06T12:00:00+08:00","dateModified":"2022-01-06T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©</h1><div class=post-description>åŒ…å«äº†ä»Mayaåˆ°Unityçš„ä¸€æ•´å¥—åˆ¶ä½œæµç¨‹.</div><div class=post-meta><span title="2022-01-06 12:00:00 +0800 CST">January 6, 2022</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/create-plant-swaying-in-wind-using-vertex-animation.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/VertexAnimatedPlant.gif alt="Vertex Animated Plant Cover"><p>Vertex Animated Plant</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä½¿ç”¨é¡¶ç‚¹åŠ¨ç”»åˆ¶ä½œéšé£é£˜åŠ¨çš„æ¤ç‰©</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba%e5%92%8c%e6%83%b3%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%9a%84%e6%95%88%e6%9e%9c aria-label=åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ>åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ</a></li><li><a href=#%e9%9a%be%e7%82%b9%e5%92%8c%e7%9b%b8%e5%af%b9%e5%ba%94%e7%9a%84%e5%ba%94%e5%af%b9%e6%96%b9%e6%b3%95 aria-label=éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•>éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•</a><ul><li><a href=#unity%e7%9a%84%e9%a1%b6%e7%82%b9%e8%89%b2%e9%99%90%e5%88%b6 aria-label=Unityçš„é¡¶ç‚¹è‰²é™åˆ¶>Unityçš„é¡¶ç‚¹è‰²é™åˆ¶</a><ul><li><a href=#vertexpivotwritetoolpy aria-label=VertexPivotWriteTool.py>VertexPivotWriteTool.py</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%ae%a1%e7%ae%97%e6%8b%89%e4%bc%b8%e8%be%83%e5%b0%8f%e7%9a%84%e9%a3%8e%e7%9a%84%e6%95%88%e6%9e%9c%e5%b9%b6%e4%b8%94%e8%ae%a1%e7%ae%97%e5%af%b9%e5%ba%94%e7%9a%84%e6%b3%95%e7%ba%bf aria-label=å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿>å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿</a><ul><li><a href=#winddebuggercs aria-label=WindDebugger.cs>WindDebugger.cs</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98 aria-label=å…¶ä»–çš„ä¸€äº›é—®é¢˜>å…¶ä»–çš„ä¸€äº›é—®é¢˜</a></li></ul></li><li><a href=#%e5%85%b7%e4%bd%93%e4%bb%a3%e7%a0%81%e5%92%8c%e7%9b%b8%e5%85%b3%e7%9a%84%e6%80%9d%e8%80%83 aria-label=å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ>å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ</a><ul><li><a href=#vertexanimationplantshadershader aria-label=VertexAnimationPlantShader.shader>VertexAnimationPlantShader.shader</a></li></ul></li><li><a href=#%e5%90%8e%e7%bb%ad%e7%9a%84%e6%80%9d%e8%80%83 aria-label=åç»­çš„æ€è€ƒ>åç»­çš„æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ>åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#åŠ¨æœºå’Œæƒ³è¦å®ç°çš„æ•ˆæœ>#</a></h2><p>æœ€ç›´æ¥çš„åŠ¨æœºæ˜¯çœ‹äº†é¡½çš®ç‹—åœ¨Siggraph 2016ä¸Šçš„<a href=http://advances.realtimerendering.com/other/2016/naughty_dog/index.html>PPT</a>ï¼Œé‡Œé¢ä»‹ç»äº†é¡½çš®ç‹—åœ¨ç¥ç§˜æµ·åŸŸä¸­æ˜¯å¦‚ä½•è®©æ¤è¢«éšé£é£˜è¡çš„ã€‚ä»–ä»¬ä»‹ç»äº†ä¸€ç§å°†æ¤è¢«çš„æ¯ä¸€éƒ¨åˆ†çš„pivotçš„ç‰©ä½“ç©ºé—´åæ ‡å†™åˆ°é¡¶ç‚¹è‰²é‡Œï¼Œç„¶ååœ¨shaderä¸­ä½¿ç”¨è¿™ä¸ªåæ ‡è¿›è¡Œé£çš„æ•ˆæœçš„è®¡ç®—çš„æ–¹æ³•ã€‚è¾ƒä¸ºéœ‡æ’¼åœ¨é£å¹è¿‡è‰åŸæ—¶ï¼Œæ¤è¢«è¿›è¡Œå¼¯æ›²åï¼Œè‰è¡¨é¢çš„é«˜å…‰ä¼šæœ‰ä¸€ç§æ—¶ç©ºä¸Šçš„èµ·ä¼æ„Ÿï¼ˆä¹Ÿå°±æ˜¯è¯´ç¥ç§˜æµ·åŸŸçš„æ¤è¢«çš„æ³•çº¿ä¹Ÿä¼šè¢«é£å½±å“ï¼‰ã€‚æ‰€ä»¥æˆ‘ä¹Ÿæƒ³è¦å€ŸåŠ©å†™pivotçš„æ–¹æ³•æ¥åˆ¶ä½œæ¤è¢«å—åˆ°é£å¹çš„æ•ˆæœï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•è®¡ç®—å‡ºæ­£ç¡®çš„é£å¹ä¹‹åçš„æ¤è¢«çš„æ³•çº¿ï¼ˆåŒæ—¶ç”±äºæ³•çº¿è´´å›¾çš„å­˜åœ¨ï¼Œè¿˜è¦è®¡ç®—æ­£ç¡®çš„åˆ‡çº¿ï¼‰ã€‚</p><p>ç¨å¾®ç¿»äº†ä¸€ä¸‹ç½‘ä¸Šçš„èµ„æ–™ï¼ˆä¹Ÿæ²¡ä»”ç»†åœ°å»æœç´¢ï¼‰ï¼Œå¤§éƒ¨åˆ†çš„å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„é¡¶ç‚¹åŠ¨ç”»ï¼Œæœ‰çš„æ˜¯ç”¨çš„sinï¼Œæœ‰çš„å°±ç›´æ¥å¹³ç§»ã€‚è¿™å°±äº§ç”Ÿäº†ç¬¬äºŒä¸ªéœ€æ±‚ï¼Œæ¤è¢«åœ¨é¡¶ç‚¹åŠ¨ç”»ä¸­åº”è¯¥ä¿æŒå·®ä¸å¤šçš„é•¿åº¦ï¼Œä¸ç„¶ä¼šå‘ç°å¾ˆæ˜æ˜¾çš„æ‹‰ä¼¸çš„æ•ˆæœã€‚</p><p>å½“ç„¶æœ€å¥½è¿˜èƒ½æŠ•å°„å‡ºæ­£å¸¸çš„å½±å­äº†ï¼Œè¿™ä¸€æ­¥åªéœ€è¦æŠŠé¡¶ç‚¹ç€è‰²å™¨å¤åˆ¶ä¸€ä»½åˆ°æŠ•å°„å½±å­çš„passé‡Œå°±å¯ä»¥äº†ã€‚</p><p>è¿™é‡Œä½¿ç”¨çš„æ¤è¢«æ¨¡å‹æ˜¯MegaScansä¸Šçš„<a href="https://quixel.com/megascans/home?assetId=selnS">CORDYLINE</a>æ¨¡å‹ä¸­çš„var12è¿™ä¸ªå°æ¨¡å‹ã€‚</p><h2 id=éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•>éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#éš¾ç‚¹å’Œç›¸å¯¹åº”çš„åº”å¯¹æ–¹æ³•>#</a></h2><h3 id=unityçš„é¡¶ç‚¹è‰²é™åˆ¶>Unityçš„é¡¶ç‚¹è‰²é™åˆ¶<a hidden class=anchor aria-hidden=true href=#unityçš„é¡¶ç‚¹è‰²é™åˆ¶>#</a></h3><p>ç¨å¾®æµ‹è¯•ä¸€ä¸‹å°±èƒ½å‘ç°ï¼ŒUnityçš„é¡¶ç‚¹è‰²æ˜¯<code>UNorm8</code>çš„æ ¼å¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºä½ åœ¨Mayaæˆ–æ˜¯3ds Maxé‡Œå¯¼å‡ºçš„æ¨¡å‹çš„é¡¶ç‚¹è‰²ä¿¡æ¯æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå¯¼å…¥åˆ°Unityä¸­å°±ä¼šå˜æˆåªæœ‰256ç²¾åº¦çš„<code>UNorm8</code>ã€‚é¡½çš®ç‹—ä½¿ç”¨çš„æ˜¯è‡ªå·±çš„å¼•æ“ï¼Œæ‰€ä»¥å®ƒä»¬èƒ½å¤Ÿä½¿ç”¨å…¨ç²¾åº¦çš„é¡¶ç‚¹è‰²ï¼Œä½†æ˜¯ç”±äºUnityçš„å¼•æ“é™åˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘åˆ°å¯¼å‡ºpivotçš„é¡¶ç‚¹åæ ‡åˆ°æ¨¡å‹çš„UVä¸­ã€‚</p><p>ä½†æ˜¯å¾ˆä¸å¹¸çš„æ˜¯ï¼Œfbxå¯¼å…¥åˆ°Unityæ—¶ï¼Œå³ä½¿UVæ˜¯<code>float4</code>çš„ç±»å‹ï¼ˆä¹Ÿå°±æ˜¯16bytes)ï¼Œåœ¨Unityä¸­åªä¼šè¯†åˆ«UVçš„å‰ä¸¤ä½ã€‚æ‰€ä»¥åªèƒ½æ— å¥ˆçš„å°†pivotçš„é¡¶ç‚¹åæ ‡ï¼ˆ<code>float3</code>çš„æ•°æ®ï¼‰å‚¨å­˜åˆ°ä¸¤ä¸ªUVçš„ä¸‰ä¸ªé€šé“é‡Œï¼ŒåŒæ—¶å°†pivotçš„å±‚çº§å­˜åˆ°å‰©ä¸‹çš„ä¸€ä¸ªé€šé“é‡Œã€‚æˆ‘ä¸çŸ¥é“é¡½çš®ç‹—å…·ä½“æ˜¯æ€ä¹ˆè®¡ç®—pivotçš„å±‚çº§å…³ç³»çš„ï¼Œä»–åœ¨PPTä¸­å†™çš„æ˜¯æ— éœ€è®¡ç®—ï¼Œä½†æˆ‘åœ¨å®é™…æ“ä½œä¸­åªèƒ½ä¸€å±‚ä¸€å±‚çš„ç®—ï¼ˆè€Œä¸”åªèƒ½ç®—ä¸¤å±‚ï¼‰ï¼Œä¹Ÿå¸Œæœ›çŸ¥é“å…·ä½“æ€ä¹ˆæ“ä½œçš„äººå‘ŠçŸ¥ä¸€ä¸‹æ–¹æ³•ã€‚</p><p>æ‰€ä»¥æ¥ä¸‹æ¥è¦åšçš„æ˜¯åœ¨Mayaä¸­æŠŠpivotçš„ç‰©ä½“ç©ºé—´åæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°å¯¹åº”é¡¶ç‚¹çš„æŸä¸¤å¥—UVä¸­ï¼Œæœ¬æ–‡æ˜¯å†™åˆ°ç¬¬äºŒå¥—å’Œç¬¬ä¸‰å¥—UVä¸­ï¼ˆä¹Ÿå°±æ˜¯<code>TEXCOORD1</code>å’Œ<code>TEXCOORD2</code>ï¼‰ã€‚äºæ˜¯æˆ‘æ¶è¡¥äº†ä¸€ä¸‹mayaçš„pythonè„šæœ¬çš„å†™æ³•ï¼Œä¸è¿‡åœ¨å†™æ•°å€¼åˆ°UVä¸­æ—¶ï¼Œåˆé‡åˆ°äº†ä¸€ä¸ªå°é—®é¢˜ã€‚Mayaçš„<code>cmds.polyEditUV</code>è¿™ä¸ªæ–¹æ³•ï¼Œæ˜æ˜èƒ½ä¼ å…¥<code>uvSetName</code>è¿™ä¸ªå‚æ•°ï¼Œç”¨äºæ“ä½œå¯¹åº”çš„UVï¼Œä½†æˆ‘å®é™…ä½¿ç”¨æ—¶åªèƒ½å†™æ•°å€¼åˆ°å½“å‰çš„UVä¸­ï¼Œå¯¼è‡´æœ€åå†™çš„è„šæœ¬åªèƒ½åƒµç¡¬çš„æ“ä½œå½“å‰UVï¼Œæ¯æ¬¡åˆ‡æ¢UVæ—¶éœ€è¦é‡æ–°ä¿®æ”¹è„šæœ¬å†è¿è¡Œä¸€æ¬¡ã€‚</p><p>æœ€ç»ˆçš„è„šæœ¬æ˜¯è¿™æ ·çš„ï¼š</p><h4 id=vertexpivotwritetoolpy>VertexPivotWriteTool.py<a hidden class=anchor aria-hidden=true href=#vertexpivotwritetoolpy>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=color:#f92672>import</span> maya.cmds <span style=color:#f92672>as</span> cmds

targetVertexStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Select any vertex to start.&#34;</span>
vertexColorStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Select any vertex to start.&#34;</span>
pivotPosition <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>]

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ui</span>():
    <span style=color:#66d9ef>if</span> cmds<span style=color:#f92672>.</span>window(<span style=color:#e6db74>&#34;VertexPivotWriteTool&#34;</span>, exists <span style=color:#f92672>=</span> True):
        cmds<span style=color:#f92672>.</span>deleteUI(<span style=color:#e6db74>&#34;VertexPivotWriteTool&#34;</span>)

    <span style=color:#66d9ef>global</span> targetVertexStr
    <span style=color:#66d9ef>global</span> targetVertexField
    <span style=color:#66d9ef>global</span> vertexColorStr
    <span style=color:#66d9ef>global</span> vertexColorField
    <span style=color:#66d9ef>global</span> pivotLayer

    vertexPivotWindow <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>window(<span style=color:#e6db74>&#34;VertexPivotWriteTool&#34;</span>, widthHeight <span style=color:#f92672>=</span> [<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>400</span>])
    form <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>formLayout(numberOfDivisions <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>)

    pivotLayerLable <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>text(<span style=color:#e6db74>&#34;Pivot Layer (0 for root pivot)&#34;</span>)
    pivotLayer <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>intField()
    cmds<span style=color:#f92672>.</span>intField(pivotLayer, e <span style=color:#f92672>=</span> True, minValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, maxValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>, step <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, value <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>)

    targetVertexButton <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>button(<span style=color:#e6db74>&#34;Target Vertex&#34;</span>, command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GetTargetVertex()&#39;</span>)
    targetVertexField <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>textField(text<span style=color:#f92672>=</span>targetVertexStr, width <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>)
    <span style=color:#75715e>#writeVertexButton = cmds.button(&#34;Write to Vertex Color&#34;, command = &#39;WriteToVertexColor()&#39;)</span>
    writeVertexButton <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>button(<span style=color:#e6db74>&#34;Write to Vertex Texcoord&#34;</span>, command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;WriteToVertexTexcoord()&#39;</span>)
    
    targetVertexColorButton <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>button(<span style=color:#e6db74>&#34;Show Vertex Color&#34;</span>, command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GetTargetVertexColor()&#39;</span>)
    vertexColorField <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>textField(text<span style=color:#f92672>=</span>vertexColorStr, width <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>)
    
    cmds<span style=color:#f92672>.</span>showWindow(vertexPivotWindow)
    cmds<span style=color:#f92672>.</span>formLayout(form, e<span style=color:#f92672>=</span>True, attachForm <span style=color:#f92672>=</span> (
    
        [pivotLayerLable, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
        [pivotLayerLable, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>20</span>],
        [pivotLayer, <span style=color:#e6db74>&#39;right&#39;</span>, <span style=color:#ae81ff>25</span>],
        [pivotLayer, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>20</span>],
    
        [targetVertexButton, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
        [targetVertexButton, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>60</span>],
        [targetVertexField, <span style=color:#e6db74>&#39;right&#39;</span>, <span style=color:#ae81ff>25</span>],
        [targetVertexField, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>60</span>],

        [writeVertexButton, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
        [writeVertexButton, <span style=color:#e6db74>&#39;top&#39;</span>, <span style=color:#ae81ff>100</span>],

        [targetVertexColorButton, <span style=color:#e6db74>&#39;left&#39;</span>, <span style=color:#ae81ff>25</span>],
        [targetVertexColorButton, <span style=color:#e6db74>&#39;bottom&#39;</span>, <span style=color:#ae81ff>20</span>],
        [vertexColorField, <span style=color:#e6db74>&#39;right&#39;</span>, <span style=color:#ae81ff>25</span>],
        [vertexColorField, <span style=color:#e6db74>&#39;bottom&#39;</span>, <span style=color:#ae81ff>20</span>],
        
    ))

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GetPivotLayer</span>():
    value <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>intField(pivotLayer, q<span style=color:#f92672>=</span>True, value<span style=color:#f92672>=</span>True)
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;pivotLayerValue is: &#34;</span> <span style=color:#f92672>+</span> str(value))
    <span style=color:#66d9ef>return</span> value
    

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GetTargetVertex</span>():
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Get Target Vertex...&#34;</span>)
    selVertices <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>ls(selection <span style=color:#f92672>=</span> True)

    <span style=color:#66d9ef>global</span> targetVertexStr
    <span style=color:#66d9ef>global</span> pivotPosition

    <span style=color:#66d9ef>if</span> len(selVertices) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        targetVertexStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;No vetex selected!&#34;</span>
    <span style=color:#66d9ef>elif</span> len(selVertices) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
        targetVertexStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Too many vertices selected! Expected 1, got &#34;</span> <span style=color:#f92672>+</span> str(len(selVertices))
    <span style=color:#66d9ef>else</span>:
        pivotPosition <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>pointPosition(selVertices[<span style=color:#ae81ff>0</span>])
        tempStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;(&#34;</span>
        <span style=color:#66d9ef>for</span> axis <span style=color:#f92672>in</span> range(len(pivotPosition)):
            <span style=color:#66d9ef>if</span> axis <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span>:
                tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;, &#34;</span>
            tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;{:.2f}&#34;</span><span style=color:#f92672>.</span>format(pivotPosition[axis])
        tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;)&#34;</span>    
        targetVertexStr <span style=color:#f92672>=</span> tempStr
    
    cmds<span style=color:#f92672>.</span>textField(targetVertexField, e<span style=color:#f92672>=</span> True, text <span style=color:#f92672>=</span> targetVertexStr)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>GetTargetVertexColor</span>():
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Get Target Vertex...&#34;</span>)
    selVertices <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>ls(selection <span style=color:#f92672>=</span> True)

    <span style=color:#66d9ef>global</span> vertexColorStr

    <span style=color:#66d9ef>if</span> len(selVertices) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
        vertexColorStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;No vetex selected!&#34;</span>
    <span style=color:#66d9ef>elif</span> len(selVertices) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
        vertexColorStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Too many vertices selected! Expected 1, got &#34;</span> <span style=color:#f92672>+</span> str(len(selVertices))
    <span style=color:#66d9ef>else</span>:
        vertexColor <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>polyColorPerVertex(query<span style=color:#f92672>=</span>True, rgb<span style=color:#f92672>=</span>True)
        tempStr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;(&#34;</span>
        <span style=color:#66d9ef>for</span> axis <span style=color:#f92672>in</span> range(len(vertexColor)):
            <span style=color:#66d9ef>if</span> axis <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span>:
                tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;, &#34;</span>                
            tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;{:.2f}&#34;</span><span style=color:#f92672>.</span>format(vertexColor[axis])
        tempStr <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;)&#34;</span>    
        vertexColorStr <span style=color:#f92672>=</span> tempStr
    
    cmds<span style=color:#f92672>.</span>textField(vertexColorField, e<span style=color:#f92672>=</span> True, text <span style=color:#f92672>=</span> vertexColorStr)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>WriteToVertexColor</span>():
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Write To Vertex Color...&#34;</span>)
    selVertices <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>ls(selection <span style=color:#f92672>=</span> True)
    <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> selVertices:
        cmds<span style=color:#f92672>.</span>polyColorPerVertex(vertex, rgb<span style=color:#f92672>=</span>(pivotPosition[<span style=color:#ae81ff>0</span>], pivotPosition[<span style=color:#ae81ff>1</span>], pivotPosition[<span style=color:#ae81ff>2</span>]))

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>WriteToVertexTexcoord</span>():
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Write To Vertex Coord...&#34;</span>)
    pivotLayerValue <span style=color:#f92672>=</span> GetPivotLayer()
    allUVSets <span style=color:#f92672>=</span> cmds<span style=color:#f92672>.</span>polyUVSet( query<span style=color:#f92672>=</span>True, allUVSets<span style=color:#f92672>=</span>True )
    uvSetCount <span style=color:#f92672>=</span> len(allUVSets)
    cmds<span style=color:#f92672>.</span>polyEditUV(relative <span style=color:#f92672>=</span> False, uValue <span style=color:#f92672>=</span> pivotPosition[<span style=color:#ae81ff>0</span>], vValue <span style=color:#f92672>=</span> pivotPosition[<span style=color:#ae81ff>1</span>])
    <span style=color:#75715e>#cmds.polyEditUV(relative = False, uValue = pivotPosition[2], vValue = pivotLayerValue)</span>

ui()
</code></pre></div><p><img loading=lazy src=../images/VertexPivotWriteTool.jpg#center alt="Vertex Pivot Write Tool"></p><p>å› ä¸ºç§ç§é™åˆ¶ï¼Œä½¿ç”¨æ—¶è¾ƒä¸ºå¤æ‚ï¼Œå¦‚æœæœ‰æ›´å¥½çš„è„šæœ¬çš„è¯ï¼Œä¹Ÿå¾ˆæ„Ÿè°¢åˆ†äº«å‡ºæ¥å‘Šè¯‰æˆ‘ã€‚é¦–å…ˆæ˜¯è¦åœ¨<code>UVé›†ç¼–è¾‘å™¨</code>ä¸­ï¼Œä¸ºæ¨¡å‹æ–°å¢ä¸¤å¥—UVï¼Œç”±äºä½¿ç”¨çš„MegaScansæ¨¡å‹æœ¬èº«æœ‰ä¸¤å¥—ä¸åŒçš„UVï¼Œæ“ä½œæ˜¯æŠŠåŸæ¥çš„ç¬¬äºŒå¥—UVç§»åŠ¨åˆ°ç¬¬å››å¥—UVä¸­ï¼Œç„¶åæŠŠç¬¬ä¸€å¥—UVå¤åˆ¶åˆ°ç¬¬äºŒç¬¬ä¸‰å¥—UVä¸­ï¼Œç„¶ååœ¨<code>UVç¼–è¾‘å™¨</code>ä¸­å®šä½å½“å‰UVåˆ°ç¬¬äºŒå¥—UVã€‚åœ¨è„šæœ¬ç¼–è¾‘å™¨ä¸­æ‰“å¼€æˆ–è€…å¤åˆ¶ä¸Šé¢çš„<code>VertexPivotWriteTool.py</code>ï¼Œé€šè¿‡<code>Crtl + Enter</code>å¯ä»¥ç”Ÿæˆè¯¥è„šæœ¬çš„ä¸€ä¸ªçª—å£ã€‚ç„¶åæ‰§è¡Œä¸‹è¿°æ“ä½œï¼šé¦–å…ˆæ˜¯å°†æ¯ä¸ªpivotçš„å‰ä¸¤ä¸ªåæ ‡å†™åˆ°ç¬¬äºŒå¥—UVä¸­ï¼Œå¯¹èŒæ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€åº•ä¸‹çš„é¡¶ç‚¹ï¼Œå¯¹å¶ç‰‡æ¥è¯´ï¼Œå…¶pivotæ˜¯æœ€æ¥è¿‘èŒçš„é¡¶ç‚¹ï¼Œé€‰ä¸­è¿™ä¸ªé¡¶ç‚¹ç„¶åç‚¹å‡»<code>Target Vertex</code>ï¼Œåœ¨çª—å£ä¸­å¯ä»¥çœ‹åˆ°è¿™ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼›ç„¶ååœ¨<code>UVç¼–è¾‘å™¨</code>é€‰ä¸­è¯¥èŒæˆ–è€…å¶ç‰‡çš„UVå£³ï¼Œç‚¹å‡»<code>Write to Vertex Texcoord</code>ï¼Œåœ¨<code>UVç¼–è¾‘å™¨</code>ä¸­å¯ä»¥çœ‹åˆ°UVåç¼©æˆäº†ä¸€ä¸ªç‚¹ï¼ˆå¾€å¾€æ‰¾ä¸åˆ°ï¼‰ï¼›å¯¹ç¬¬äºŒå¥—UVä¸­çš„æ‰€æœ‰çš„UVå£³æ‰§è¡Œä¸Šè¿°æ“ä½œï¼›ç„¶åå°†å½“å‰UVåˆ‡æ¢åˆ°ç¬¬ä¸‰å¥—UVï¼ŒåŒæ—¶æ³¨é‡Šæ‰è„šæœ¬çš„ç¬¬117è¡Œï¼Œå–æ¶ˆæ³¨é‡Šè„šæœ¬çš„ç¬¬118è¡Œï¼Œç„¶åè¾“å…¥<code>Crtl + Enter</code>é‡æ–°ç”Ÿæˆä¸€éå·¥å…·ï¼›è¿™æ—¶æˆ‘ä»¬å°†è¦æŠŠæ¯ä¸ªpivotçš„æœ€åä¸€ä¸ªåæ ‡å’Œpivotçš„å±‚çº§å†™åˆ°ç¬¬ä¸‰å¥—UVä¸­ï¼›å¯¹æ¤è¢«çš„æ¯ä¸€ç‰‡å¶å­å’Œæå¹²ï¼Œåˆ¤æ–­å…¶pivotçš„å±‚çº§ï¼ˆä»¥ç°åœ¨ä½¿ç”¨çš„MegaScansæ¨¡å‹ä¸ºä¾‹ï¼ŒèŒçš„å±‚çº§æ˜¯0ï¼Œå…¶ä»–å¶ç‰‡çš„å±‚çº§æ˜¯1ï¼‰ï¼Œåœ¨Pivot Layerä¸­è¾“å…¥å±‚çº§ï¼›ç„¶åé‡å¤åˆ¤æ–­å±‚çº§ï¼Œé€‰æ‹©é¡¶ç‚¹ï¼Œå†™å…¥UVï¼›æœ€åæœ€åï¼Œä¸è¦å¿˜è®°æŠŠè„šæœ¬è¿˜åŸæˆæœ€å¼€å§‹çš„æ ·å­ã€‚è¿™æ ·å°±æŠŠæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„pivotåæ ‡å†™å…¥åˆ°ç¬¬äºŒå’Œç¬¬ä¸‰å¥—UVäº†ï¼å¯¼å‡ºåˆ°Unityå°±å¯ä»¥äº†ã€‚</p><h3 id=å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿>å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœï¼Œå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿<a hidden class=anchor aria-hidden=true href=#å¦‚ä½•è®¡ç®—æ‹‰ä¼¸è¾ƒå°çš„é£çš„æ•ˆæœå¹¶ä¸”è®¡ç®—å¯¹åº”çš„æ³•çº¿>#</a></h3><p>é¦–å…ˆæ¥çœ‹è¿™æ ·ä¸€å¼ å›¾ï¼š</p><p><img loading=lazy src=../images/CircleTransformDiagram.jpg#center alt="Circle Transform Diagram"></p><p>è¿™å¼ å›¾è¡¨ç°äº†åœ¨Bend Spaceä¸­æŠŠçº¢è‰²çš„çº¿æ®µå¼¯æ›²åˆ°ç»¿è‰²çº¿æ®µçš„ç®—æ³•ï¼ŒXè½´æ˜¯é£çš„æ–¹å‘ï¼Œå¯ä»¥çœ‹åˆ°é£çš„å¼ºåº¦è¶Šé«˜ï¼ŒRadiusçš„å¤§å°å°±è¶Šå°ã€‚åŒæ—¶ä¸ºäº†è®¡ç®—å‡ºæ­£ç¡®çš„æ³•çº¿å’Œåˆ‡çº¿ï¼Œéœ€è¦åŒæ ·çš„è®¡ç®—å‡ºAxisXå’ŒAxisZåœ¨Bend Spaceä¸­çš„å‘é‡ã€‚ä½¿ç”¨è¿™ä¸ªç®—æ³•ï¼Œå½“æ¨¡å‹å¤„åœ¨Bend Spaceçš„Zè½´ä¸Šæ—¶ï¼Œä¸ä¼šå—åˆ°æ‰­æ›²ï¼Œå½“å…¶Xè½´å¤§äº0æ—¶ï¼Œä¼šå—åˆ°å‹ç¼©ï¼Œå½“Xè½´å°äº0æ—¶ï¼Œä¼šå—åˆ°æ‹‰ä¼¸ã€‚åŒæ ·çš„ï¼Œè¿™ç§ç®—æ³•å¯ä»¥æ¨å¹¿åˆ°ä¸‰ç»´ç©ºé—´ä¸­ï¼ŒåŒæ—¶æ‰­æ›²Yè½´å’ŒZè½´ï¼Œæˆ‘ç‰¹åœ°å†™äº†ä¸€ä¸ªC#è„šæœ¬æ¥å¯¹å˜æ¢çš„ç»“æœè¿›è¡Œå¯è§†åŒ–ã€‚</p><h4 id=winddebuggercs>WindDebugger.cs<a hidden class=anchor aria-hidden=true href=#winddebuggercs>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> Unity.Mathematics;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WindDebugger</span> : MonoBehaviour
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> draw = <span style=color:#66d9ef>true</span>;

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> debugRadius = <span style=color:#ae81ff>0.01f</span>;
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> debugLength = <span style=color:#ae81ff>0.2f</span>;

    <span style=color:#66d9ef>public</span> Color pivotColor;
    <span style=color:#66d9ef>public</span> Color sphereColor;
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> radius;
    <span style=color:#66d9ef>public</span> float3 originalPosition;

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DrawAxes(Color color, Vector3 pos, Vector3 tangent, Vector3 bitangent, Vector3 normal)
    {
        Gizmos.color = color;
        Gizmos.DrawSphere(pos, debugRadius);
        Gizmos.color = Color.red;
        Gizmos.DrawLine(pos, pos + tangent * debugLength);
        Gizmos.color = Color.green;
        Gizmos.DrawLine(pos, pos + bitangent * debugLength);
        Gizmos.color = Color.blue;
        Gizmos.DrawLine(pos, pos + normal * debugLength);
    }

    <span style=color:#66d9ef>private</span> float3 CircleTransform(float3 positionBS, <span style=color:#66d9ef>float</span> radius, <span style=color:#66d9ef>out</span> float3 axisX, <span style=color:#66d9ef>out</span> float3 axisY, <span style=color:#66d9ef>out</span> float3 axisZ)
    {
        <span style=color:#66d9ef>float</span> radVal = math.length(positionBS.xy) / radius;
        <span style=color:#66d9ef>float</span> sinVal = math.sin(radVal);
        <span style=color:#66d9ef>float</span> cosVal = math.cos(radVal);
        float2 normalizeDir = math.normalize(positionBS.xy);

        float3 targetPosBS = <span style=color:#66d9ef>new</span> float3((radius * sinVal) * normalizeDir, radius - radius * cosVal);

        float3 tempAxisX = <span style=color:#66d9ef>new</span> float3(-sinVal * normalizeDir, cosVal);
        float3 tempAxisY = <span style=color:#66d9ef>new</span> float3(normalizeDir.y, -normalizeDir.x, <span style=color:#ae81ff>0.0f</span>);
        float3 tempAxisZ = <span style=color:#66d9ef>new</span> float3(cosVal * normalizeDir, sinVal);

        axisX = tempAxisX;
        axisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ;
        axisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ;

        float3 newPositionBS = targetPosBS + axisX * positionBS.z;
        <span style=color:#66d9ef>return</span> newPositionBS;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDrawGizmos()
    {
        <span style=color:#66d9ef>if</span> (!draw)
        {
            <span style=color:#66d9ef>return</span>;
        }

        Color originalColor = Gizmos.color;
        Gizmos.color = sphereColor;
        Gizmos.DrawSphere(<span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, radius), radius);

        float3 axisX, axisY, axisZ;
        float3 newPosition = CircleTransform(originalPosition, radius, <span style=color:#66d9ef>out</span> axisX, <span style=color:#66d9ef>out</span> axisY, <span style=color:#66d9ef>out</span> axisZ);
        DrawAxes(pivotColor, newPosition, axisY, axisZ, axisX);

        DrawAxes(pivotColor, originalPosition, <span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>), <span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>), <span style=color:#66d9ef>new</span> float3(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>));

        Gizmos.color = Color.black;
        Gizmos.DrawLine(float3.zero, originalPosition);
        Gizmos.color = Color.white;
        Gizmos.DrawLine(float3.zero, newPosition);

        Gizmos.color = originalColor;
    }
}
</code></pre></div><h3 id=å…¶ä»–çš„ä¸€äº›é—®é¢˜>å…¶ä»–çš„ä¸€äº›é—®é¢˜<a hidden class=anchor aria-hidden=true href=#å…¶ä»–çš„ä¸€äº›é—®é¢˜>#</a></h3><p>ç”±äºæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ä¸­ç”¨åˆ°äº†å¾ˆå¤šçš„åæ ‡å˜æ¢ï¼Œéœ€è¦ç‰¹åˆ«çš„æ³¨æ„æ¯ä¸€æ¬¡å˜æ¢æ˜¯ä»ä»€ä¹ˆç©ºé—´å˜æ¢åˆ°ä»€ä¹ˆç©ºé—´ã€‚é¦–å…ˆæ˜¯ç‰©ä½“ç©ºé—´åˆ°é£çš„å¼¯æ›²ç©ºé—´ï¼Œç”±äºæˆ‘ä»¬<code>CircleTransform</code>æ–¹æ³•æ˜¯è®¤ä¸ºé£æ˜¯å¹å‘Xè½´æ­£æ–¹å‘çš„ï¼Œæ‰€ä»¥éœ€è¦å…ˆå¯¹æ‰€æœ‰çš„åæ ‡ã€å‘é‡è¿›è¡Œä¸€ä¸ªå˜æ¢ï¼Œç”±äºåªæ¶‰åŠåˆ°æ—‹è½¬ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ª<code>float3x3</code>çš„çŸ©é˜µæ¥è¡¨ç¤ºä»ç‰©ä½“ç©ºé—´åˆ°å¼¯æ›²ç©ºé—´çš„å˜æ¢çŸ©é˜µã€‚</p><p>ç„¶ååˆ†ä¸¤ç§æƒ…å†µï¼šä¸€ç§æ˜¯Pivot Layerä¸º0çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ‰€ä½¿ç”¨çš„æ¨¡å‹çš„èŒä¸Šçš„é¡¶ç‚¹ã€‚è¿™ç§ç›¸å¯¹ç®€å•ï¼Œå°†é¡¶ç‚¹åœ¨ç‰©ä½“Bend Spaceä¸­è¿›è¡Œ<code>CircleTransform</code>åï¼Œå°±èƒ½è·å¾—æ–°çš„Bend Spaceçš„åæ ‡å’Œæ–°çš„ä¸‰ä¸ªè½´çš„å‘é‡ï¼ˆæ–°çš„ä¸‰ä¸ªè½´å¯ä»¥ç»„åˆå‡ºé¡¶ç‚¹çš„Bend Spaceåˆ°ç‰©ä½“çš„Bend Spaceçš„å˜æ¢çŸ©é˜µï¼‰ï¼Œå¯ä»¥è®¡ç®—å‡ºé¡¶ç‚¹ã€æ³•çº¿å’Œåˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡å’Œå‘é‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚</p><p>ç¬¬äºŒç§æ˜¯Pivot Layerä¸º1çš„é¡¶ç‚¹ï¼Œè¦å…ˆè®¡ç®—å‡ºPivotçš„æ–°çš„ç‰©ä½“Bend Spaceåæ ‡ï¼Œç„¶ååœ¨å…¶åŸºç¡€ä¸Šè®¡ç®—å‡ºæ¯ä¸€ä¸ªé¡¶ç‚¹ç›¸å¯¹äºPivot Bend Spaceçš„æ–°çš„åæ ‡ï¼Œç„¶åä¸€å±‚å¥—ä¸€å±‚çš„ç®—å›é¡¶ç‚¹åŠå…¶æ³•çº¿åˆ‡çº¿åœ¨ç‰©ä½“Bend Spaceçš„åæ ‡ã€‚æœ€åå†ä»ç‰©ä½“Bend Spaceè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å°±å¯ä»¥äº†ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘åœ¨è®¡ç®—pivotçš„Bend Spaceæ—¶ï¼Œæ‰€ä½¿ç”¨çš„ç©ºé—´å’Œä¹‹å‰å›¾ä¸Šä¸å¤ªä¸€æ ·ï¼Œæ˜¯<code>AxisZ, AxisYå’Œ-AxisX</code>å¯¹åº”æ–°çš„Bend Spaceçš„XYZè½´ï¼Œè¿™æ ·èƒ½è®©å‚ç›´äºæå¹²çš„å¶ç‰‡æœ‰æ›´å¥½çš„é£å¹çš„æ•ˆæœã€‚</p><p>ä¸ºäº†è®©éšé£æ‘†åŠ¨çš„æ•ˆæœçœ‹ä¸Šå»æ›´è‡ªç„¶ï¼Œé™¤äº†æŒ‰ç…§åœ†å½¢æ¥å˜æ¢é¡¶ç‚¹ä¹‹å¤–ï¼Œå‚è€ƒé¡½çš®ç‹—çš„æ¼”è®²ï¼Œè¿˜è¦ç»™æå¹²çš„æ‘‡æ™ƒæ·»åŠ ä¸€ä¸ªå’Œè·ç¦»ç›¸å…³çš„å»¶è¿Ÿï¼Œè¿™æ ·ä¸ä¼šæ˜¾å¾—ç”Ÿç¡¬ã€‚è‡³äºéšé£é£˜åŠ¨çš„é¢‘ç‡ï¼Œå°±éšä¾¿æ‰¾ä¸€ä¸ªsinå‡½æ•°çš„ç»„åˆå°±å¯ä»¥äº†ã€‚</p><h2 id=å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ>å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#å…·ä½“ä»£ç å’Œç›¸å…³çš„æ€è€ƒ>#</a></h2><p>é¡¶ç‚¹ç€è‰²å™¨å°±æŒ‰ç…§ä¹‹å‰ä»‹ç»çš„æ¥åšå°±å¯ä»¥äº†ã€‚ç”±äºè¾ƒå¥½çœ‹çš„æ¤è¢«éƒ½æ˜¯åŒé¢æ¸²æŸ“çš„ï¼Œåœ¨Cullçš„å‚æ•°é‡Œé¢é€‰æ‹©Offã€‚è¿™æ ·åŒæ ·çš„ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æ¨¡å‹èƒŒé¢çš„æ³•çº¿å’Œæ­£é¢çš„æ³•çº¿æ˜¯ç›¸åŒçš„ï¼Œè¿™é‡Œéœ€è¦ä½¿ç”¨HLSLç‰‡å…ƒç€è‰²å™¨çš„<code>VFACE</code>è¯­ä¹‰ï¼Œæ¥åˆ¤æ–­å½“å‰é¢æ˜¯æ­£é¢è¿˜æ˜¯èƒŒé¢ï¼Œå¦‚æœæ˜¯èƒŒé¢çš„è¯éœ€è¦åè½¬ä¸€ä¸‹æ³•çº¿ã€‚è¿™é‡Œå†™çš„Shaderä¹ŸåŒæ—¶å†™äº†é˜´å½±ã€æ·±åº¦å›¾å’Œçƒ˜ç„™æ‰€éœ€è¦çš„passã€‚</p><h3 id=vertexanimationplantshadershader>VertexAnimationPlantShader.shader<a hidden class=anchor aria-hidden=true href=#vertexanimationplantshadershader>#</a></h3><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/VertexAnimationPlantShader&quot;
{
    Properties
    {
        _BaseColor (&quot;Base Color&quot;, color) = (1, 1, 1, 1)
        _BaseMap(&quot;Base Map&quot;, 2D) = &quot;white&quot; {}

        _BumpMap (&quot;Bump Map&quot;, 2D) = &quot;bump&quot; {}
        _BumpIntensity (&quot;Bump Intensity&quot;, range(0, 1)) = 1
        _RoughnessMap(&quot;Roughness Map&quot;, 2D) = &quot;white&quot; {}
        _RoughnessIntensity (&quot;Roughness Intensity&quot;, range(0, 1)) = 1
        _MetallicMap (&quot;Metallic Map&quot;, 2D) = &quot;black&quot; {}
        _MetallicIntensity (&quot;Metallic Intensity&quot;, range(0, 1)) = 1

        _WindDirection (&quot;Wind Direction&quot;, vector) = (1.0, 0.0, 0.0, 0.0)
        _WindIntensity (&quot;Wind Intensity&quot;, float) = 1
        _WindVariety (&quot;Wind Variety&quot;, range(0, 10)) = 0.5
        _BranchDelay (&quot;Branch Delay&quot;, range(0, 10)) = 2

        _WindVarietyLeaves (&quot;Wind Variety Leaves&quot;, range(0, 10)) = 1
        _BranchDelayLeaves (&quot;Branch Delay Leaves&quot;, range(0, 10)) = 3

        _WindVaryFrequency (&quot;Wind Vary Frequency&quot;, float) = 5
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    
    sampler2D _BaseMap;
    sampler2D _BumpMap;
    sampler2D _RoughnessMap;
    sampler2D _MetallicMap;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float4 _BaseMap_ST;
    float _BumpIntensity;
    float _RoughnessIntensity;
    float _MetallicIntensity;

    float4 _WindDirection;
    float _WindIntensity;
    float _WindVariety;
    float _BranchDelay;
    float _WindVarietyLeaves;
    float _BranchDelayLeaves;
    float _WindVaryFrequency;
    CBUFFER_END

    //Apply wind variety
    float GetVariety(float timeFunction)
    {
        return sin(timeFunction) + 0.25 * sin(timeFunction * 1.5) + 0.1 * sin(timeFunction * 0.33);
    }

    //CircleTransform transforms a current bend space point to a new position in bend space,
    //and output three axes of next bend space.
    //New position is in current bend space and ready for use.
    //Normal and tangent in current bend space can be calculated by axes.
    float3 CircleTransform(float3 positionBS, float windIntensity, out float3 axisX, out float3 axisY, out float3 axisZ)
    {
        float intensity = windIntensity;

        if(intensity == 0.0 || length(positionBS.yz) == 0.0)
        {
            axisX = float3(1.0, 0.0, 0.0);
            axisY = float3(0.0, 1.0, 0.0);
            axisZ = float3(0.0, 0.0, 1.0);

            return positionBS;
        }

        float radius = rcp(intensity);
        float radVal = length(positionBS.yz) * intensity;
        float sinVal = sin(radVal);
        float cosVal = cos(radVal);
        float2 normalizeDir = normalize(positionBS.yz);

        float3 targetPosBS = float3(radius - radius * cosVal, (radius * sinVal) * normalizeDir);

        float3 tempAxisX = float3(cosVal, -sinVal * normalizeDir);
        float3 tempAxisY = float3(0.0, normalizeDir.y, -normalizeDir.x);
        float3 tempAxisZ = float3(sinVal, cosVal * normalizeDir);

        axisX = tempAxisX;
        axisY = normalizeDir.y * tempAxisY + normalizeDir.x * tempAxisZ;
        axisZ = -normalizeDir.x * tempAxisY + normalizeDir.y * tempAxisZ;

        float3 newPositionBS = targetPosBS + axisX * positionBS.x;
        return newPositionBS;
    }

    //windDirection: object space, upVec: world upVec in object space
    void InitBendSpace(float3 windDirection, float3 upVec, out float3x3 objectToBend, out float3x3 bendToObject)
    {
        float3 u = windDirection;
        float3 v = normalize(cross(upVec, u));
        float3 w = cross(u, v);
        //Object space to bend space       
        objectToBend = float3x3(u, v, w);
        //Bend space to object space
        bendToObject =  float3x3(u.x, v.x, w.x, u.y, v.y, w.y, u.z, v.z, w.z);
    }

    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;}

        Pass
        {
            Name &quot;ForwardLit&quot;
            Tags{&quot;LightMode&quot; = &quot;UniversalForward&quot;}

            Cull Off
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite On

            HLSLPROGRAM
            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

            #pragma shader_feature_local _NORMALMAP

            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING
            #pragma multi_compile _ SHADOWS_SHADOWMASK       
            #pragma multi_compile_fragment _ _SHADOWS_SOFT

            #pragma multi_compile _ LIGHTMAP_ON

            #pragma vertex LitPassVert
            #pragma fragment LitPassFrag

            struct Attributes
            {
                float4 positionOS           : POSITION;
                float3 normalOS             : NORMAL;
                float4 tangentOS            : TANGENT;
                float2 texcoord0            : TEXCOORD0;
                float2 texcoord1            : TEXCOORD1;
                float2 texcoord2            : TEXCOORD2;
                float2 staticLightmapUV     : TEXCOORD3;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct Varyings
            {
                float4 positionCS               : SV_POSITION;
                float2 uv                       : TEXCOORD0;
                float3 positionWS               : TEXCOORD1;
                float3 normalWS                 : TEXCOORD2;
                float4 tangentWS                : TEXCOORD3;
                float4 shadowCoord              : TEXCOORD4;
                DECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, 5);

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            //////////////////////////////////
            //GGX BRDF and related functions//
            //////////////////////////////////
            float D(float ndoth, float roughness)
            {
                float a = ndoth * roughness;
                float k = roughness / (1.0 - ndoth * ndoth + a * a);
                return k * k;
            }

            float G(float ndotl, float ndotv, float roughness)
            {
                float a2 = roughness * roughness;
                float gv = ndotv * sqrt((1.0 - a2) * ndotl * ndotl + a2);
                float gl = ndotl * sqrt((1.0 - a2) * ndotv * ndotv + a2);
                return 0.5 * rcp(gv + gl);
            }

            float3 F(float3 specular, float hdotl)
            {
                return specular + (1 - specular) * pow(1 - hdotl, 5);
            }

            float3 GGXBRDF(float3 wi, float3 wo, float3 normal, float3 specular, float roughness)
            {
                float3 h = normalize(wi + wo);
                float ndotv = max(dot(normal, wo), 1e-5);
                float ndoth = max(dot(normal, h), 0.0);
                float ndotl = max(dot(normal, wi), 0.0);
                float hdotl = max(dot(h, wi), 0.0);

                float d = D(ndoth, roughness);
                float g = G(ndotl, ndotv, roughness);
                float3 f = F(specular, hdotl);

                return d * g * f;
            }

            Varyings LitPassVert(Attributes input)
            {
                Varyings output = (Varyings)0;
                UNITY_SETUP_INSTANCE_ID(input);
                UNITY_TRANSFER_INSTANCE_ID(input, output);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

                //Pivot positions are stored in TEXCOORD1.xy and TEXCOORD2.x.
                float3 pivotPosition = float3(input.texcoord1.xy, input.texcoord2.x) * 0.01;
                float3 pointOffset = input.positionOS.xyz - pivotPosition;

                //Initialize Bend Space.
                float3 windDirectionOS = mul((float3x3)UNITY_MATRIX_I_M, _WindDirection.xyz);
                float3 upVec = mul((float3x3)UNITY_MATRIX_I_M, float3(0.0, 1.0, 0.0));
                windDirectionOS = normalize(windDirectionOS);
                upVec = normalize(upVec);
                float3x3 objectToBend, bendToObject;
                InitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject);

                //Initialize vertex data, transform from object space to bend space.
                float3 pivotPositionBS = mul(objectToBend, pivotPosition);
                float3 pointOffsetBS = mul(objectToBend, pointOffset);
                float3 originalTangentBS = mul(objectToBend, input.tangentOS.xyz);
                float3 originalNormalBS = mul(objectToBend, input.normalOS);
                
                float3 windPointBS;
                float3 windTangentBS;
                float3 windNormalBS;

                //TEXCOORD2.y is used to check pivot layers. 0 is root layer.
                if(input.texcoord2.y &gt; 0.5)
                {
                    //////////////////////////////////
                    //Calculate pivot root transform//
                    //////////////////////////////////

                    //Get pivot wind intensity.
                    float intensity = _WindIntensity;
                    float magnitude = length(pivotPositionBS);
                    intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);
                    
                    //Calculate new position bent by wind in bend space,
                    //and save the transform matrix.
                    float3 axisX, axisY, axisZ;
                    float3 windPivotPositionBS = CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ);
                    float4x4 pivotBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));

                    /////////////////////////////
                    //Calculate point transform//
                    /////////////////////////////

                    //Switch axes, transform to next bend space (point bend space).
                    pointOffsetBS = float3(pointOffsetBS.z, pointOffsetBS.y, -pointOffsetBS.x);

                    //Get point wind intensity.
                    intensity = abs(axisZ.x) * _WindIntensity;//_WindIntensityLeaves;
                    magnitude = length(pointOffsetBS);
                    intensity += _WindVarietyLeaves * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelayLeaves);
                    
                    //Calculate new position bent by wind in bend space,
                    //and save the transform matrix from point bend space to pivot bend space.
                    //This transform matrix can be used to calculate normal and tangent.
                    float3 windPointPositionBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
                    float4x4 pointBSToPivotBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));
                    
                    //Switch axes, transform to pivot bend space.
                    windPointPositionBS = float3(-windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x);

                    //Calculate position, normal and tangent in pivot bend space.
                    float3 windPointPS = windPointPositionBS;
                    float3 windTangentPS = mul((float3x3)pointBSToPivotBS, originalTangentBS);
                    float3 windNormalPS = mul((float3x3)pointBSToPivotBS, originalNormalBS);

                    //Calculate position, normal and tangent in object bend space.
                    windPointBS = mul(pivotBSToObjBS, float4(windPointPS, 1.0)).xyz;
                    windTangentBS = mul((float3x3)pivotBSToObjBS, windTangentPS);
                    windNormalBS = mul((float3x3)pivotBSToObjBS, windNormalPS);

                }
                else
                {
                    //////////////////////////////////
                    //Calculate point transform only//
                    //////////////////////////////////

                    //Get point wind intensity.
                    float intensity = _WindIntensity;
                    float magnitude = length(pointOffsetBS);
                    intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);
                    
                    float3 axisX, axisY, axisZ;
                    float3 windPointOffsetBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
                    float4x4 pointBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), float4(0.0, 0.0, 0.0, 1.0));

                    windPointBS = windPointOffsetBS + pivotPositionBS;
                    windTangentBS = mul((float3x3)pointBSToObjBS, originalTangentBS);
                    windNormalBS = mul((float3x3)pointBSToObjBS, originalNormalBS);
                }

                //Transform from bend space to object space
                float3 pivotPositionOS = mul(bendToObject, windPointBS);
                float3 pivotTangentOS = mul(bendToObject, windTangentBS);
                float3 pivotNormalOS = mul(bendToObject, windNormalBS);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(pivotPositionOS);
                VertexNormalInputs normalInput = GetVertexNormalInputs(pivotNormalOS, float4(pivotTangentOS, input.tangentOS.w));

                output.positionCS = vertexInput.positionCS;
                output.uv = TRANSFORM_TEX(input.texcoord0, _BaseMap);
                output.positionWS = vertexInput.positionWS;
                output.normalWS = normalInput.normalWS;
                output.tangentWS = float4(normalInput.tangentWS, input.tangentOS.w);
                output.shadowCoord = TransformWorldToShadowCoord(vertexInput.positionWS);
                
                OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);
                OUTPUT_SH(normalInput.normalWS.xyz, output.vertexSH);

                output.normalWS = normalInput.normalWS;
                
                return output;
            }

            float4 LitPassFrag(Varyings input, float vFace : VFACE) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(input);
                UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);

                //wo
                float3 positionWS = input.positionWS;
                float3 viewDirWS = GetWorldSpaceNormalizeViewDir(positionWS);
                
                //wi
                float4 shadowCoord = TransformWorldToShadowCoord(positionWS);
                float4 shadowMask = SAMPLE_SHADOWMASK(input.staticLightmapUV);
                Light mainLight = GetMainLight(shadowCoord, positionWS, shadowMask);

                //normal
                float3 normalMap = UnpackNormal(tex2D(_BumpMap, input.uv));
                normalMap.xy *= _BumpIntensity;
                float3 bitangentWS = cross(input.normalWS, input.tangentWS.xyz) * input.tangentWS.w;
                float3x3 tbn = float3x3(input.tangentWS.xyz, bitangentWS, input.normalWS);
                float3 normalWS = mul(normalMap, tbn);
                normalWS = normalize(input.normalWS);
                //If we are looking and back faces, revert the normal.
                normalWS = vFace &gt; 0.5 ? normalWS: -normalWS;

                //material properties
                float4 baseMap = tex2D(_BaseMap, input.uv) * _BaseColor;
                clip(baseMap.a - 0.5);
                float roughnessMap = tex2D(_RoughnessMap, input.uv).r;
                float roughness = max(roughnessMap * _RoughnessIntensity, 1e-2);
                float metallicMap = tex2D(_MetallicMap, input.uv).r;
                float metallic = metallicMap * _MetallicIntensity;

                float oneMinusReflectivity = kDieletricSpec.a * (1 - metallic);
                float reflectivity = 1.0 - oneMinusReflectivity;
                float3 diffuse = baseMap.rgb * oneMinusReflectivity;
                float3 specular = lerp(kDieletricSpec.rgb, baseMap.rgb, metallic);     
                
                //gi
                float3 bakedGI = SAMPLE_GI(input.staticLightmapUV, input.vertexSH, normalWS);
                MixRealtimeAndBakedGI(mainLight, normalWS, bakedGI);
                float3 giDiffuse = bakedGI;
                float3 reflectVector = reflect(-viewDirWS, normalWS);
                float3 giSpecular = GlossyEnvironmentReflection(reflectVector, positionWS, roughness, 1.0);

                //directional lights
                float3 directDiffuse = diffuse;
                float3 directSpecular = GGXBRDF(mainLight.direction, viewDirWS, normalWS, specular, roughness);
                float ndotl = saturate(dot(mainLight.direction, normalWS));
                float atten = mainLight.shadowAttenuation;

                //indirectional lights
                float3 indirectDiffse = giDiffuse * diffuse;
                float surfaceReduction = rcp(roughness * roughness + 1.0);
                float grazingTerm = saturate(1.0 - roughness + reflectivity);
                float ndotv = saturate(dot(normalWS, viewDirWS));
                float fresnelTerm = pow(1.0 - ndotv, 5.0);
                float3 indirectSpecular = giSpecular * surfaceReduction * lerp(specular, grazingTerm, fresnelTerm);

                //final compose
                float3 directBRDF = (directDiffuse + directSpecular) * mainLight.color * atten * ndotl;
                float3 indirectBRDF = indirectDiffse + indirectSpecular;

                float3 finalColor = directBRDF + indirectBRDF;
                return float4(finalColor, baseMap.a);
            }

            ENDHLSL
        }

        Pass
        {
            Name &quot;ShadowCaster&quot;
            Tags{&quot;LightMode&quot; = &quot;ShadowCaster&quot;}

            HLSLPROGRAM
            #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&quot;
            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl&quot;
            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            float3 _LightDirection;

            struct Attributes
            {
                float4 positionOS   : POSITION;
                float3 normalOS     : NORMAL;
                float4 tangentOS    : TANGENT;
                float2 texcoord0    : TEXCOORD0;
                float2 texcoord1    : TEXCOORD1;
                float2 texcoord2    : TEXCOORD2;
                float4 color        : COLOR;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct Varyings
            {
                float2 uv           : TEXCOORD0;
                float4 positionCS   : SV_POSITION;
            };

            Varyings ShadowPassVertex(Attributes input)
            {
                Varyings output = (Varyings)0;
                UNITY_SETUP_INSTANCE_ID(input);
                UNITY_TRANSFER_INSTANCE_ID(input, output);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

                float3 pivotPosition = float3(input.texcoord1.xy, input.texcoord2.x) * 0.01;
                float3 pointOffset = input.positionOS.xyz - pivotPosition;

                float3 windDirectionOS = mul((float3x3)UNITY_MATRIX_I_M, _WindDirection.xyz);
                float3 upVec = mul((float3x3)UNITY_MATRIX_I_M, float3(0.0, 1.0, 0.0));
                windDirectionOS = normalize(windDirectionOS);
                upVec = normalize(upVec);
                float3x3 objectToBend, bendToObject;
                InitBendSpace(windDirectionOS, upVec, objectToBend, bendToObject);

                float3 pivotPositionBS = mul(objectToBend, pivotPosition);
                float3 pointOffsetBS = mul(objectToBend, pointOffset);
                float3 originalTangentBS = mul(objectToBend, input.tangentOS.xyz);
                float3 originalNormalBS = mul(objectToBend, input.normalOS);
                
                float3 windPointBS;
                float3 windTangentBS;
                float3 windNormalBS;

                if(input.texcoord2.y &gt; 0.5)
                {
                    float intensity = _WindIntensity;
                    float magnitude = length(pivotPositionBS);
                    intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);
                    
                    float3 axisX, axisY, axisZ;
                    float3 windPivotPositionBS = CircleTransform(pivotPositionBS, intensity, axisX, axisY, axisZ);
                    float4x4 pivotBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPivotPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPivotPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPivotPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));

                    pointOffsetBS = float3(pointOffsetBS.z, pointOffsetBS.y, -pointOffsetBS.x);

                    intensity = abs(axisZ.x) * _WindIntensity;//_WindIntensityLeaves;
                    magnitude = length(pointOffsetBS);
                    intensity += _WindVarietyLeaves * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelayLeaves);
                    
                    float3 windPointPositionBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
                    float4x4 pointBSToPivotBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointPositionBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointPositionBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointPositionBS.z), float4(0.0, 0.0, 0.0, 1.0));
                    
                    windPointPositionBS = float3(-windPointPositionBS.z, windPointPositionBS.y, windPointPositionBS.x);

                    float3 windPointPS = windPointPositionBS;
                    float3 windTangentPS = mul((float3x3)pointBSToPivotBS, originalTangentBS);
                    float3 windNormalPS = mul((float3x3)pointBSToPivotBS, originalNormalBS);

                    windPointBS = mul(pivotBSToObjBS, float4(windPointPS, 1.0)).xyz;
                    windTangentBS = mul((float3x3)pivotBSToObjBS, windTangentPS);
                    windNormalBS = mul((float3x3)pivotBSToObjBS, windNormalPS);
                }
                else
                {
                    float intensity = _WindIntensity;
                    float magnitude = length(pointOffsetBS);
                    intensity += _WindVariety * GetVariety(_Time.y * _WindVaryFrequency - magnitude * _BranchDelay);
                    
                    float3 axisX, axisY, axisZ;
                    float3 windPointOffsetBS = CircleTransform(pointOffsetBS, intensity, axisX, axisY, axisZ);
                    float4x4 pointBSToObjBS = float4x4(float4(axisX.x, axisY.x, axisZ.x, windPointOffsetBS.x), float4(axisX.y, axisY.y, axisZ.y, windPointOffsetBS.y), float4(axisX.z, axisY.z, axisZ.z, windPointOffsetBS.z), float4(0.0, 0.0, 0.0, 1.0));

                    windPointBS = windPointOffsetBS + pivotPositionBS;
                    windTangentBS = mul((float3x3)pointBSToObjBS, originalTangentBS);
                    windNormalBS = mul((float3x3)pointBSToObjBS, originalNormalBS);
                }

                float3 pivotPositionOS = mul(bendToObject, windPointBS);
                float3 pivotTangentOS = mul(bendToObject, windTangentBS);
                float3 pivotNormalOS = mul(bendToObject, windNormalBS);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(pivotPositionOS);
                VertexNormalInputs normalInput = GetVertexNormalInputs(pivotNormalOS, float4(pivotTangentOS, input.tangentOS.w));

                output.uv = TRANSFORM_TEX(input.texcoord0, _BaseMap);
                output.positionCS = TransformWorldToHClip(ApplyShadowBias(vertexInput.positionWS, normalInput.normalWS, _LightDirection));
                return output;
            }

            half4 ShadowPassFragment(Varyings input) : SV_TARGET
            {
                return 0.0;
            }

            ENDHLSL
        }

        Pass
        {
            Name &quot;DepthOnly&quot;
            Tags{&quot;LightMode&quot; = &quot;DepthOnly&quot;}

            HLSLPROGRAM
            #pragma vertex DepthOnlyVertex
            #pragma fragment DepthOnlyFragment

            struct Attributes
            {
                float4 positionOS   : POSITION;
                float2 texcoord     : TEXCOORD0;
                float4 color        : COLOR;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            struct Varyings
            {
                float2 uv           : TEXCOORD0;
                float4 positionCS   : SV_POSITION;
                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            Varyings DepthOnlyVertex(Attributes input)
            {
                Varyings output = (Varyings)0;
                UNITY_SETUP_INSTANCE_ID(input);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS);
                
                output.uv = input.texcoord;
                output.positionCS = vertexInput.positionCS;
                
                return output;
            }

            half4 DepthOnlyFragment(Varyings input) : SV_TARGET
            {
                return 0.0;
            }

            ENDHLSL
        }

        Pass
        {
            Name &quot;Meta&quot;
            Tags{&quot;LightMode&quot; = &quot;Meta&quot;}

            HLSLPROGRAM
            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl&quot;

            #pragma vertex MetaVertex
            #pragma fragment MetaFragment

            struct Attributes
            {
                float4 positionOS   : POSITION;
                float3 normalOS     : NORMAL;
                float2 uv0          : TEXCOORD0;
                float2 uv1          : TEXCOORD1;
                float2 uv2          : TEXCOORD2;
            };

            struct Varyings
            {
                float4 positionCS   : SV_POSITION;
                float2 uv           : TEXCOORD0;
            };

            Varyings MetaVertex(Attributes input)
            {
                Varyings output;
                output.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST);
                output.uv = TRANSFORM_TEX(input.uv0, _BaseMap);
                return output;
            }

            half4 MetaFragment(Varyings input) : SV_Target
            {
                //material properties
                float4 baseMap = tex2D(_BaseMap, input.uv);
                float roughnessMap = tex2D(_RoughnessMap, input.uv).r;
                float roughness = max(roughnessMap * _RoughnessIntensity, 1e-2);
                float metallicMap = tex2D(_MetallicMap, input.uv).r;
                float metallic = metallicMap * _MetallicIntensity;

                float oneMinusReflectivity = kDieletricSpec.a * (1 - metallic);
                float reflectivity = 1.0 - oneMinusReflectivity;
                float3 diffuse = baseMap.rgb * oneMinusReflectivity;
                float3 specular = lerp(kDieletricSpec.rgb, baseMap.rgb, metallic);

                MetaInput metaInput;
                metaInput.Albedo = diffuse;
                metaInput.SpecularColor = specular;
                metaInput.Emission = 0;
                return MetaFragment(metaInput);
            }

            ENDHLSL
        }
    }
}
</code></pre><h2 id=åç»­çš„æ€è€ƒ>åç»­çš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#åç»­çš„æ€è€ƒ>#</a></h2><p>é¦–å…ˆå…ˆè®²å¥½çš„æ–¹é¢ï¼Œé£å¹åŠ¨çš„æ•ˆæœç¡®å®ååˆ†è‡ªç„¶ï¼ŒåŒæ ·çš„è®¡ç®—å‡ºçš„æ­£ç¡®çš„æ³•çº¿åœ¨PBRçš„æ¸²æŸ“ä¸­ä¹Ÿååˆ†é‡è¦ï¼ˆé¡¶ç‚¹åŠ¨ç”»ä¸­æ­£ç¡®çš„æ³•çº¿å°¤å…¶ä¸æ˜“ï¼ï¼‰ã€‚ä½†æ˜¯ä¸è¶³ä¹‹å¤„æ˜¯çŸ©é˜µè¿ç®—è¿‡å¤šäº†ï¼Œä¸è¿‡çŸ©é˜µè¿ç®—å…¨éƒ½åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œæ¶ˆè€—ä¹Ÿä¸æ˜¯ç‰¹åˆ«å¤§ã€‚å¤ªå¤šçš„çŸ©é˜µè¿ç®—ä¹Ÿå¯¼è‡´äº†è¿™ç§ç®—æ³•çš„æ‰©å±•æ€§ä¸æ˜¯å¾ˆå¥½ï¼Œå¦‚æœæƒ³è¦æœ‰Pivot Layerä¸º3çš„é¡¶ç‚¹ï¼Œåœ¨ç›®å‰çš„ç®—æ³•é‡Œé¢æ˜¯æ²¡åŠæ³•è®¡ç®—çš„ï¼Œä¹Ÿä¸çŸ¥é“é¡½çš®ç‹—æ˜¯æ€ä¹ˆåšçš„äº†ã€‚åœ¨æ¨¡å‹çš„å½¢çŠ¶ä¸æ˜¯ç‰¹åˆ«å¥½çš„æ—¶å€™ï¼Œæ¯”å¦‚ä¸€ä¸ªquadæ¥æ¸²æŸ“è‰ï¼Œæˆ–è€…æ˜¯æ¨¡å‹å¶å­æ­ªæ­ªæ‰­æ‰­çš„ï¼Œä¼šæœ‰æ¯”è¾ƒå¤§çš„å˜å½¢ã€‚ä¸è¿‡ä»”ç»†è®¾ç½®æ¯ä¸€ä¸ªé¡¶ç‚¹çš„Pivotçš„è¯ï¼Œåº”è¯¥è¿˜æ˜¯èƒ½å¤Ÿè§£å†³ä¸€éƒ¨åˆ†é—®é¢˜çš„ï¼Œå½“ç„¶æ‹™åŠ£çš„Mayaè„šæœ¬åˆæˆäº†ä¸€ä¸ªç—›ç‚¹ã€‚</p><p>æ€»çš„æ¥è¯´æˆ‘è¿˜æ˜¯æ¯”è¾ƒæ»¡æ„çš„ï¼Œä¹Ÿç®—æ˜¯è§£å†³äº†ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„é—®é¢˜ï¼Œå½“ç„¶äº†ï¼Œæˆ‘å¯¹hugoèƒ½å¤Ÿæ”¯æŒgifå›¾ç‰‡æ›´åŠ æ»¡æ„ï¼</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/vertex-animation/>Vertex Animation</a></li><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/get-view-space-normal-from-depth-texture/><span class=title>Â« Prev</span><br><span>ä»æ·±åº¦å›¾ä¸­è·å–è§†ç©ºé—´çš„æ³•çº¿</span></a>
<a class=next href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><span class=title>Next Â»</span><br><span>åœ¨Unityçš„UIä¸­ç»˜åˆ¶ç­‰å®½çš„è´èµ›å°”æ›²çº¿</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>