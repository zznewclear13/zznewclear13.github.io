<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>模仿缺氧的瓦片渲染方法 | ZZNEWCLEAR13</title><meta name=keywords content="Tile Rendering,Procedural,Compute Shader"><meta name=description content="使用Compute Buffer一次性绘制多个瓦片."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/><link crossorigin=anonymous href=/assets/css/stylesheet.min.e1da4ea728c11c74c3956764ea9040885d7c23ab4d30fea8cd5a8ea4071a3f6d.css integrity="sha256-4dpOpyjBHHTDlWdk6pBAiF18I6tNMP6ozVqOpAcaP20=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="模仿缺氧的瓦片渲染方法"><meta property="og:description" content="使用Compute Buffer一次性绘制多个瓦片."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/"><meta property="og:image" content="https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/posts/images/TileRendering.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-20T12:00:00+08:00"><meta property="article:modified_time" content="2023-02-20T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/posts/images/TileRendering.jpg"><meta name=twitter:title content="模仿缺氧的瓦片渲染方法"><meta name=twitter:description content="使用Compute Buffer一次性绘制多个瓦片."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"模仿缺氧的瓦片渲染方法","item":"https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"模仿缺氧的瓦片渲染方法","name":"模仿缺氧的瓦片渲染方法","description":"使用Compute Buffer一次性绘制多个瓦片.","keywords":["Tile Rendering","Procedural","Compute Shader"],"articleBody":"缺氧的瓦片渲染的特点 很可惜我没有在RenderDoc里截到缺氧的帧，不过我还是能从渲染表现上来分析一下缺氧的瓦片渲染的特点。经过一段时间的游玩和从下面这张图中可以看到，缺氧的游戏逻辑是把整个2D的地图分成一个一个格子，每个格子记录了气体、液体、固体和建筑物的信息。气体只是一个扭曲的Shader，液体渲染和计算比较复杂，这里暂时不考虑，建筑物中的墙和管线虽然也有程序化生成再渲染的效果，但和场景中资源类型的固体格子是硬相接的关系，这里也不考虑。本文的研究重点放在资源类型的固体格子的渲染上（不包括这些格子的程序化生成）。\n资源类型的固体格子（这里就简称瓦片了）的特点如下：\n 有多种类型的瓦片 仅在不同类型的瓦片相接时会有黑色的描边 瓦片之间会有排序，优先级高的瓦片会更多地扩张 瓦片之间黑色的描边呈现周期性规律  模仿这种渲染的思路 最简单的思路肯定就是在CPU中计算每一个瓦片应当有的形态，然后找到对应的贴图，把瓦片在GPU中绘制出来了。但是这样子做的话就失去了本文的意义，也太过无趣了。我想的是尽量多地用GPU来计算每个瓦片的形态，同时使用Instancing的方式，绘制每一个瓦片。\n第一个问题是，不规则的瓦片应当如何绘制。如果是正方形的瓦片，能够很轻易地使用一个Quad和纹理来绘制，但是不规则的瓦片，势必会使用透明度混合的方式来绘制，这时对应的模型就会超出瓦片的游戏逻辑上的位置。因此，我想的是绘制的Quad的数量是瓦片实际数量的两倍加一，如下图所示：\n在这张图中，ABC代表了不同类型的瓦片，左边是游戏游玩的时候逻辑上的瓦片分布，ABC是相接的，右边是在渲染的时候的瓦片的分布，在原有瓦片中间插入新的瓦片，专门用来渲染接缝。对于2号瓦片，其左上角右上角右下角左下角（顺时针的顺序）分别是ABCC，决定了这是一块三块相接的瓦片；对于1号瓦片，对应的编号是AACC（通过一些对2取模取余的运算可以排除掉B），决定了这是一块两块相接的瓦片；而对于3和4号瓦片，其编号为CCCC，决定了这两块是没有接缝的瓦片。这时我们又考虑到了瓦片之间优先级的关系，假设CBA，则AACC和AABB的接缝应当是相同的，ABCC和BCCA是旋转了九十度的关系。考虑到必定会有一个瓦片处于最低优先级，我们只需要将最低优先级的瓦片固定到左上角，讨论剩下三个瓦片的优先级与顺序即可。循着这个思路，我们可以把所有可能的接缝画在一张图上，这张图的RGBA通道记录了瓦片的优先级（R优先级最低，A优先级最高，接缝我使用了一个统一的灰色以便后续渲染），图片如下所示，为了比较容易观察，我对A通道做了反向，且对应的在下方标注了优先级顺序。同时我们还对应的写好一个函数用于根据优先级顺序找到对应的接缝类型从而在渲染时找到接缝在图上的位置（见ONITileRender.hlsl中的GetMode(uint a, uint b, uint c)）。\n\r\r由于会有优先级的比较，不可避免地会在GPU中进行排序，使用MergeSort的话，4个元素会有5次比较，由于我们还需要获得每个瓦片在四个瓦片中排序的序号，这里就硬写了手动比较，6次比较和MergeSort的5次也差不太多。我们绘制的图上仅有最低优先级瓦片在左上角的情况，因此我们还需要找到最低优先级瓦片初始的序号，从而在渲染时旋转我们的接缝图（这里就体现了我们使用顺时针编号的优势，方便了旋转的操作，如果是左上角右上角左下角右下角的顺序，就不太好旋转了）。\n知道了每一个接缝图的旋转，我们还需要为其每一个部分（通道）渲染不同的贴图。这里使用了DrawProceduralIndirect来进行Instancing的渲染，DrawCall数量会和瓦片类型的数量一样多。对于一种瓦片，需要渲染的总瓦片数相当于是这类瓦片的图形向外扩展一个瓦片的数量，我们可以通过判断左上右上右下左下的瓦片类型来轻易地判断当前瓦片是否应该和目标瓦片类型一起渲染。我们会使用一个数据数量为瓦片类型数量*(2*地图宽高+1)的StructuredBuffer来统计所有应当绘制的瓦片（实际使用的大小不会大于4*(2*地图宽+1)*(2*地图高+1)）。同时我们会使用一个数据数量为瓦片类型数量*5的ByteAddressBuffer来统计每种瓦片类型Instancing时需要的参数。\n本文中的岩石的2D无缝贴图来自OpenGameArt.org\n具体的代码和相关的解释 由于会用到CommandBuffer进行瓦片的绘制，我就把相关的代码放到Universal RP的Package里了。CPU代码，ONITileRenderManager.cs放在Packages/com.unity.render-pipelines.universal/Runtime/Overrides/下，ONITileRendererFeature.cs放在Packages/com.unity.render-pipelines.universal/Runtime/RendererFeature/下，ONITileRenderPass.cs放在Packages/com.unity.render-pipelines.universal/Runtime/Passes/下；GPU代码，ONITileRender.hlsl，ONITileComputeShader.compute和ONITileRenderShader.shader放在Packages/com.unity.render-pipelines.universal/Shaders/ONITile/下。\nONITileRenderManager用于地图的设置、计算和Buffer的获取。ONITileRendererFeature和ONITileRenderPass用于在Unity URP中渲染瓦片，ONITileComputeShader用于瓦片相关的计算，ONITileRenderShader用于瓦片的渲染。\nONITileRenderManager.cs 这里尤其需要注意每个Buffer的大小。在这个脚本里使用Compute Shader做了三件事：1. 对地图每一个点生成一个随机数作为瓦片类型；2. 从地图中计算每一种瓦片类型需要绘制的数量、位置、解封类型、旋转和应当采样的通道；3. 把ByteAddressBuffer中的数据复制到IndirectArgumentBuffer里。事实上我感觉ComputeShader.Dispatch应该做成一个异步的方法，不过这个调用频率不高，就这样好了。\nusing UnityEngine; [ExecuteInEditMode] public class ONITileRenderManager : MonoBehaviour { [HideInInspector] public static ONITileRenderManager Instance { get; private set; } public ComputeShader oniTileComputeShader; public int tileTypeCount = 4; public Vector2Int tileCount = new Vector2Int(16, 16); public Vector2 tileSize = Vector2.one; public Vector3 tileStartPos; public Vector2 randomSeed; public Texture[] mainTextures = new Texture[] {}; public Vector4 mainTextureST = new Vector4(1.0f, 1.0f, 0.0f, 0.0f); private Vector2Int tileCountExt; public Vector2Int TileCountExt { get { return tileCountExt; } } private Vector4 textureSize; public Vector4 TextureSize { get { return textureSize; } } private Vector4 textureSizeExt; public Vector4 TextureSizeExt { get { return textureSizeExt; } } private ComputeBuffer computeBuffer; public ComputeBuffer ComputeBuffer { get { return computeBuffer; } } private ComputeBuffer argBuffer; public ComputeBuffer ArgBuffer { get { return argBuffer; } } private ComputeBuffer counterBuffer; public ComputeBuffer CounterBuffer { get { return counterBuffer; } } private RenderTexture tileRenderTexture; private RenderTexture tileRenderTextureExt; private bool hasValidBuffer = false; public bool HasValidBuffer { get { return hasValidBuffer; } } struct PerTileProperty { public Vector2Int coord; public uint mode; public uint rotation; public uint channel; } private void EnsureRenderTexture(ref RenderTexture rt, int width, int height) { if (rt == null || rt.width != width || rt.height != height) { if (rt != null) RenderTexture.ReleaseTemporary(rt); RenderTextureDescriptor desc = new RenderTextureDescriptor(width, height, RenderTextureFormat.ARGBInt); desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; rt = RenderTexture.GetTemporary(desc); if (!rt.IsCreated()) rt.Create(); } } private void EnsureComputeBuffer(ref ComputeBuffer cb, int count, int stride, ComputeBufferType cbt = ComputeBufferType.Append) { if (cb == null || cb.count != count || cb.stride != stride) { if (cb != null) cb.Release(); cb = new ComputeBuffer(count, stride, cbt); } } private void OnEnable() { if (Instance != null) { enabled = false; Debug.LogError(\"An instance of ONITileRenderManager already exists.\"); } else { Instance = this; } } private void OnDisable() { Instance = null; } private void OnValidate() { tileTypeCount = Mathf.Max(1, tileTypeCount); tileCount.x = Mathf.Max(1, tileCount.x); tileCount.y = Mathf.Max(1, tileCount.y); tileCountExt = new Vector2Int(tileCount.x * 2 + 1, tileCount.y * 2 + 1); textureSize = new Vector4(tileCount.x, tileCount.y, 1.0f / tileCount.x, 1.0f / tileCount.y); textureSizeExt = new Vector4(tileCountExt.x, tileCountExt.y, 1.0f / tileCountExt.x, 1.0f / tileCountExt.y); EnsureComputeBuffer(ref computeBuffer, tileTypeCount * tileCountExt.x * tileCountExt.y, System.Runtime.InteropServices.Marshal.SizeOf()); EnsureComputeBuffer(ref argBuffer, tileTypeCount * 5, 4, ComputeBufferType.IndirectArguments); EnsureComputeBuffer(ref counterBuffer, tileTypeCount * 5, 4, ComputeBufferType.Raw); EnsureRenderTexture(ref tileRenderTexture, tileCount.x, tileCount.y); EnsureRenderTexture(ref tileRenderTextureExt, tileCountExt.x, tileCountExt.y); GenerateRandomTiles(); hasValidBuffer = false; ExpandTileTexture(); CopyToArgBuffer(); hasValidBuffer = true; } private void GenerateRandomTiles() { if (!oniTileComputeShader) return; int kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_RANDOM_KERNEL_NAME); oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); oniTileComputeShader.SetVector(ONITileShaderConstants.I_RandomSeed, randomSeed); oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount); oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize); oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTiles, tileRenderTexture); oniTileComputeShader.Dispatch(kernelID, Mathf.CeilToInt((float)tileCount.x / x), Mathf.CeilToInt((float)tileCount.y / y), 1); } private void ExpandTileTexture() { if (!oniTileComputeShader) return; int[] data = new int[counterBuffer.count]; for (int i = 0; i if (i % 5 == 0) { data[i] = 6; } else { data[i] = 0; } } counterBuffer.SetData(data); int kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_EXPAND_KERNEL_NAME); oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize); oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSizeExt, textureSizeExt); oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RandomTiles, tileRenderTexture); oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTilesExt, tileRenderTextureExt); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_TileData, computeBuffer); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_CounterBuffer, counterBuffer); oniTileComputeShader.Dispatch(kernelID, Mathf.CeilToInt((float)tileCountExt.x / x), Mathf.CeilToInt((float)tileCountExt.y / y), 1); } private void CopyToArgBuffer() { if (!oniTileComputeShader) return; int kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_COPY_KERNEL_NAME); oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_CounterBuffer, counterBuffer); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_ArgBuffer, ArgBuffer); oniTileComputeShader.Dispatch(kernelID, Mathf.CeilToInt((float)(5*tileTypeCount) / x), 1, 1); } public Bounds GetBounds() { Vector3 start = tileStartPos; Vector2 totalSize = tileSize * tileCountExt; Vector3 size3D = new Vector3(totalSize.x, 0.0f, totalSize.y) + Vector3.one; Vector3 center = start + 0.5f * size3D; return new Bounds(center, size3D); } private void OnDestroy() { if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } if (argBuffer != null) { argBuffer.Release(); argBuffer = null; } if (tileRenderTexture != null) { RenderTexture.ReleaseTemporary(tileRenderTexture); tileRenderTexture = null; } if (tileRenderTextureExt != null) { RenderTexture.ReleaseTemporary(tileRenderTextureExt); tileRenderTextureExt = null; } } public class ONITileShaderConstants { public static readonly string S_RANDOM_KERNEL_NAME = \"RandomMain\"; public static readonly string S_EXPAND_KERNEL_NAME = \"ExpandMain\"; public static readonly string S_COPY_KERNEL_NAME = \"CopyMain\"; public static readonly int I_TextureSize = Shader.PropertyToID(\"_TextureSize\"); public static readonly int I_TextureSizeExt = Shader.PropertyToID(\"_TextureSizeExt\"); public static readonly int I_TileTypeCount = Shader.PropertyToID(\"_TileTypeCount\"); public static readonly int I_RandomSeed = Shader.PropertyToID(\"_RandomSeed\"); public static readonly int I_RandomTiles = Shader.PropertyToID(\"_RandomTiles\"); public static readonly int I_RW_RandomTiles = Shader.PropertyToID(\"_RW_RandomTiles\"); public static readonly int I_RW_RandomTilesExt = Shader.PropertyToID(\"_RW_RandomTilesExt\"); public static readonly int I_RW_TileData = Shader.PropertyToID(\"_RW_TileData\"); public static readonly int I_RW_ArgBuffer = Shader.PropertyToID(\"_RW_ArgBuffer\"); public static readonly int I_CounterBuffer = Shader.PropertyToID(\"_CounterBuffer\"); public static readonly int I_RW_CounterBuffer = Shader.PropertyToID(\"_RW_CounterBuffer\"); public static readonly int I_TileTexture = Shader.PropertyToID(\"_TileTexture\"); public static readonly int I_TileData = Shader.PropertyToID(\"_TileData\"); public static readonly int I_TileSize = Shader.PropertyToID(\"_TileSize\"); public static readonly int I_TileStartPos = Shader.PropertyToID(\"_TileStartPos\"); public static readonly int I_TileType = Shader.PropertyToID(\"_TileType\"); public static readonly int I_MainTexture = Shader.PropertyToID(\"_MainTexture\"); public static readonly int I_MainTexture_ST = Shader.PropertyToID(\"_MainTexture_ST\"); } } ONITileRendererFeature.cs 没什么好说的，照本宣科罢了。\nnamespace UnityEngine.Rendering.Universal { public class ONITileRendererFeature : ScriptableRendererFeature { [System.Serializable] public class ONITileSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingTransparents; public Shader drawShader; public Texture tileTexture; public bool IsValid() { return drawShader != null \u0026\u0026 tileTexture != null; } } private ONITileRenderPass oniTileRenderPass; public ONITileSettings oniTileSettings = new ONITileSettings(); public override void Create() { oniTileRenderPass = new ONITileRenderPass(oniTileSettings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { if (ONITileRenderManager.Instance != null \u0026\u0026 oniTileSettings.IsValid()) { oniTileRenderPass.Setup(ONITileRenderManager.Instance); renderer.EnqueuePass(oniTileRenderPass); } } } } ONITileRenderPass.cs DrawProceduralIndirect需要的argument一共五个uint的数据，分别为每个实例的顶点数，实例数，顶点起始位置，实例起始位置和一个预留给OpenGL的空位。如果我们需要画十三个Quad，我们只需要传入{6, 13, 0, 0, 0}即可。i * 5 * 4意味着对第i个瓦片类型，我们需要读取i*5+0到i*5+4这五个uint的数据作为IndirectDraw的argument，而uint的大小为4。\nnamespace UnityEngine.Rendering.Universal { public class ONITileRenderPass : ScriptableRenderPass { private const string profilerTag = \"ONI Tile Render Pass\"; private ProfilingSampler oniTileRenderSampler = new ProfilingSampler(profilerTag); private ONITileRendererFeature.ONITileSettings settings; private ONITileRenderManager oniTileRenderManager; private Material drawMaterial; public ONITileRenderPass(ONITileRendererFeature.ONITileSettings settings) { this.settings = settings; renderPassEvent = settings.renderPassEvent; if (settings.drawShader != null) { drawMaterial = new Material(settings.drawShader); } } public void Setup(ONITileRenderManager oniTileRenderManager) { this.oniTileRenderManager = oniTileRenderManager; } private void DoONITileRendering(CommandBuffer cmd, Material material) { if(oniTileRenderManager.HasValidBuffer) { MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetBuffer(ONITileRenderManager.ONITileShaderConstants.I_TileData, oniTileRenderManager.ComputeBuffer); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TextureSizeExt, oniTileRenderManager.TextureSizeExt); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileStartPos, oniTileRenderManager.tileStartPos); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileSize, oniTileRenderManager.tileSize); mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_TileTexture, settings.tileTexture); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_MainTexture_ST, oniTileRenderManager.mainTextureST); int mainTextureLength = oniTileRenderManager.mainTextures.Length; for (int i = 0; i if(mainTextureLength  0) { int mainTextureIndex = i % mainTextureLength; mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_MainTexture, oniTileRenderManager.mainTextures[mainTextureIndex]); } mpb.SetInt(ONITileRenderManager.ONITileShaderConstants.I_TileType, i); cmd.DrawProceduralIndirect(Matrix4x4.identity, material, 0, MeshTopology.Triangles, oniTileRenderManager.ArgBuffer, i * 5 * 4, properties:mpb); } } } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, oniTileRenderSampler)) { DoONITileRendering(cmd, drawMaterial); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } } } ONITileRender.hlsl 这里定义了一个结构体PerTileProperty，需要和CPU代码里结构体的数据布局保持一致。事实上，channel和rotation都只是0-3的int类型，占两个bit，可以合并在一起，这样一个PerTileProperty刚好是四个字节，这里就不这么做了。至于中间的函数，我真的不太擅长命名。SortAndReturnIndex在排序的同时，还返回了每个元素在排序后的序号，方便后面的处理。ProcessSortedArray用于处理排序，生成并列第二名第三名。RotateAccordingToMinimum是旋转处理好的排序，从而通过GetMode获取接缝类型。我尽可能地减少了GetMode的分支数量（其实是一种二进制+三进制+特例）。\n#ifndef ONI_TILE_RENDER_HLSL\r#define ONI_TILE_RENDER_HLSL\r#define ONI_TILE_TEXTURE_SIZE 8u\rstruct PerTileProperty\r{\ruint2 coord;\ruint mode;\ruint rotation;\ruint channel;\r};\rSamplerState sampler_LinearClamp;\rSamplerState sampler_PointClamp;\ruint _TileTypeCount;\rfloat4 _TextureSize;\rfloat4 _TextureSizeExt;\rfloat3 _TileStartPos;\rfloat2 _TileSize;\r// https://www.shadertoy.com/view/4djSRW\rfloat hash12(float2 p)\r{\rfloat3 p3 = frac(float3(p.xyx) * .1031);\rp3 += dot(p3, p3.yzx + 33.33);\rreturn frac((p3.x + p3.y) * p3.z);\r}\r// A sort4 function with 6 compares.\r// output: sorted array of input;\r// return: sorted index of elements from input;\ruint4 SortAndReturnIndex(float4 input, out uint output[4])\r{ uint3 ab_ac_ad = input.xxx ONITileComputeShader.compute 这里定义了三个Kernel，分别用于生成随机数，找到所有应渲染的瓦片及其属性，把ByteAddressBuffer的内容复制到IndirectArgumentBuffer。实际运用的话我们不会在GPU里生成瓦片，理论上也没必要做一次Buffer数据的复制。使用了ByteAddressBuffer.InterlockedAdd来获取当前类型的瓦片需要Instancing的数量（并根据这个数量储存对应的PerTileProperty）。\n#pragma kernel RandomMain\r#pragma kernel ExpandMain\r#pragma kernel CopyMain\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"ONITileRender.hlsl\"\rfloat2 _RandomSeed;\rTexture2D _RandomTiles;\rRWTexture2D _RW_RandomTiles;\rRWTexture2D _RW_RandomTilesExt;\rByteAddressBuffer _CounterBuffer;\rRWStructuredBuffer _RW_TileData;\rRWStructuredBuffer _RW_ArgBuffer;\rRWByteAddressBuffer _RW_CounterBuffer;\r[numthreads(8,8,1)]\rvoid RandomMain (uint3 dispatchThreadID : SV_DispatchThreadID)\r{\rif(any((float2)dispatchThreadID.xy = _TextureSize.xy)) return;\rfloat randomVal = hash12(dispatchThreadID.xy + _RandomSeed);\rfloat val = floor(randomVal * _TileTypeCount);\rfloat4 returnColor = float4(val, val, val, val);\r_RW_RandomTiles[dispatchThreadID.xy] = returnColor;\r}\rfloat LoadFromRandomTiles(Texture2D tex, int2 coord, float2 textureSize)\r{\rfloat2 tempCoord = clamp(float2(0.0f, 0.0f), textureSize-1.0f, coord);\rreturn tex.Load(uint3(tempCoord, 0)).r;\r}\r[numthreads(8, 8, 1)]\rvoid ExpandMain (uint3 dispatchThreadID : SV_DispatchThreadID)\r{\rif(any((float2)dispatchThreadID.xy = _TextureSizeExt.xy)) return;\rfloat tr = LoadFromRandomTiles(_RandomTiles, dispatchThreadID.xy / 2, _TextureSize.xy);\rfloat tl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 0)) / 2) - int2(1, 0), _TextureSize.xy);\rfloat br = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(0, 1)) / 2) - int2(0, 1), _TextureSize.xy);\rfloat bl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 1)) / 2) - int2(1, 1), _TextureSize.xy);\r// x y\r// w z\rfloat4 packedColor = float4(tl, tr, br, bl);\ruint output[4];\ruint4 sortedIndex = SortAndReturnIndex(packedColor, output);\ruint4 tempOutput = int4(output[0], output[1], output[2], output[3]);\ruint processedArray[4] = {sortedIndex.x, sortedIndex.y, sortedIndex.z, sortedIndex.w};\rProcessSortedArray(packedColor, tempOutput, processedArray);\ruint4 rotatedIndex = RotateAccordingToMinimum(processedArray, output);\ruint mode = GetMode(rotatedIndex.y, rotatedIndex.z, rotatedIndex.w);\rfor (float i = 0; i = 5 * _TileTypeCount) return;\ruint status;\r_RW_ArgBuffer[dispatchThreadID.x] = _CounterBuffer.Load(4 * dispatchThreadID.x, status);\r}\rONITileRenderShader.shader 由于我们画的TileTexture是从左上角开始的，采样的时候会用到一些用1减去uv的y值，旋转也不会乘上-1。前面给缝隙画上灰色的好处也在这里体现出来，我们可以用两个smoothstep来找到一定程度上抗锯齿的渲染区域和缝隙区域。此外在开启MSAA的时候可能会需要根据uv是否在01之间剔除掉当前像素，不然会有奇怪的边缘锯齿。\nShader \"zznewclear13/ONITileRenderShader\"\r{\rHLSLINCLUDE\r#pragma enable_d3d11_debug_symbols\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"ONITileRender.hlsl\"\rStructuredBuffer _TileData;\rsampler2D _TileTexture;\rsampler2D _MainTexture;\rfloat4 _MainTexture_ST;\ruint _TileType;\rstruct Attributes\r{\ruint vertexID : SV_VERTEXID;\ruint instanceID : SV_INSTANCEID;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat3 positionWS : TEXCOORD1;\ruint mode : TEXCOORD2;\ruint rotation : TEXCOORD3;\ruint channel : TEXCOORD4;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rPerTileProperty prop = _TileData[input.instanceID + _TileType * _TextureSizeExt.x * _TextureSizeExt.y];\ruint vertexIndex = input.vertexID % 3;\ruint triangleID = input.vertexID / 3;\ruint uvX = ((vertexIndex\u00262)1)^triangleID;\ruint uvY = ((vertexIndex+vertexIndex1)\u00261)^triangleID;\rfloat2 uv = float2(uvX, uvY);\rfloat2 tileCoord = (prop.coord + 0.5f) * _TileSize;\rfloat3 center = float3(tileCoord.x, 0.0f, tileCoord.y) + _TileStartPos;\rfloat2 positionWSOffset = (uv - 0.5f) * _TileSize;\rfloat3 positionWS = center + float3(positionWSOffset.x, 0.0f, positionWSOffset.y);\routput.positionCS = mul(UNITY_MATRIX_VP, float4(positionWS, 1.0f));\routput.uv = uv;\routput.positionWS = positionWS;\routput.mode = prop.mode;\routput.rotation = prop.rotation;\routput.channel = prop.channel;\rreturn output;\r}\rfloat4 frag(Varyings input) : SV_TARGET\r{\rfloat2 uv = input.uv;\ruv.y = 1.0f - uv.y;\rint2 startCoord = int2(input.mode % ONI_TILE_TEXTURE_SIZE, input.mode / ONI_TILE_TEXTURE_SIZE);\rfloat2 startUV = (float2)(startCoord) / ONI_TILE_TEXTURE_SIZE;\rfloat rotationVal = (float)(input.rotation) * PI * 0.5f;\rfloat sinVal, cosVal;\rsincos(rotationVal, sinVal, cosVal);\rfloat2x2 rotationMat = float2x2(cosVal, sinVal, -sinVal, cosVal);\rfloat2 rotatedCoord = saturate(mul(rotationMat, uv - 0.5f) + 0.5f);\rfloat2 sampleCoord = startUV + rotatedCoord / ONI_TILE_TEXTURE_SIZE;\rsampleCoord.y = 1.0f - sampleCoord.y;\rfloat4 tileTexture = tex2D(_TileTexture, sampleCoord);\rfloat visColor = tileTexture[input.channel];\rfloat textureMask = smoothstep(0.25f, 1.0f, visColor);\rfloat gapMask = smoothstep(0.0f, 0.25f, visColor);\rfloat3 mainTex = tex2D(_MainTexture, input.positionWS.xz * _MainTexture_ST.xy + _MainTexture_ST.zw).rgb;\rmainTex = lerp(0.0f, mainTex, textureMask);\rfloat4 returnColor = float4(mainTex, gapMask);\rreturn returnColor;\r}\rENDHLSL\rSubShader\r{\rpass\r{\rTags {\"Queue\"=\"Transparent\" \"RenderType\"=\"Transparent\"}\rBlend SrcAlpha OneMinusSrcAlpha\rZTest LEqual\rZWrite Off\rHLSLPROGRAM\r#pragma vertex vert\r#pragma fragment frag\rENDHLSL }\r}\r}\r总结 总之就是很爽很快乐很有成就感。因为画图水平不行，有的地方的接缝差了一点点，也无所谓了。由于之前被HLSL里的Array坑了很多次，这里刻意地去限制了Array的数量，在加上之前玩了一会图灵完备，计算Procedural Quad的UV和顶点坐标简直不在话下，要是以前肯定就写一个长度为6的array进行采样了。对ByteAddressBuffer也有了新的理解，居然能用来计数，从而DrawIndirect或者DispatchIndirect，以前的话我只会CopyCounterValue。最后的最后也夸一下缺氧，画面确实很让人有深刻的印象，液体的渲染更是独树一帜，就是一个人玩太枯燥了。\n","wordCount":"2044","inLanguage":"en","image":"https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/posts/images/TileRendering.jpg","datePublished":"2023-02-20T12:00:00+08:00","dateModified":"2023-02-20T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>模仿缺氧的瓦片渲染方法</h1><div class=post-description>使用Compute Buffer一次性绘制多个瓦片.</div><div class=post-meta>February 20, 2023&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/mimic-oxygen-not-includeds-tile-rendering.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/TileRendering.jpg alt="Tile Rendering Cover"><p>Tile Rendering Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>模仿缺氧的瓦片渲染方法</div></summary><div class=inner><ul><li><a href=#%e7%bc%ba%e6%b0%a7%e7%9a%84%e7%93%a6%e7%89%87%e6%b8%b2%e6%9f%93%e7%9a%84%e7%89%b9%e7%82%b9 aria-label=缺氧的瓦片渲染的特点>缺氧的瓦片渲染的特点</a></li><li><a href=#%e6%a8%a1%e4%bb%bf%e8%bf%99%e7%a7%8d%e6%b8%b2%e6%9f%93%e7%9a%84%e6%80%9d%e8%b7%af aria-label=模仿这种渲染的思路>模仿这种渲染的思路</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81%e5%92%8c%e7%9b%b8%e5%85%b3%e7%9a%84%e8%a7%a3%e9%87%8a aria-label=具体的代码和相关的解释>具体的代码和相关的解释</a><ul><li><a href=#onitilerendermanagercs aria-label=ONITileRenderManager.cs>ONITileRenderManager.cs</a></li><li><a href=#onitilerendererfeaturecs aria-label=ONITileRendererFeature.cs>ONITileRendererFeature.cs</a></li><li><a href=#onitilerenderpasscs aria-label=ONITileRenderPass.cs>ONITileRenderPass.cs</a></li><li><a href=#onitilerenderhlsl aria-label=ONITileRender.hlsl>ONITileRender.hlsl</a></li><li><a href=#onitilecomputeshadercompute aria-label=ONITileComputeShader.compute>ONITileComputeShader.compute</a></li><li><a href=#onitilerendershadershader aria-label=ONITileRenderShader.shader>ONITileRenderShader.shader</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=缺氧的瓦片渲染的特点>缺氧的瓦片渲染的特点<a hidden class=anchor aria-hidden=true href=#缺氧的瓦片渲染的特点>#</a></h2><p>很可惜我没有在RenderDoc里截到缺氧的帧，不过我还是能从渲染表现上来分析一下缺氧的瓦片渲染的特点。经过一段时间的游玩和从下面这张图中可以看到，缺氧的游戏逻辑是把整个2D的地图分成一个一个格子，每个格子记录了气体、液体、固体和建筑物的信息。气体只是一个扭曲的Shader，液体渲染和计算比较复杂，这里暂时不考虑，建筑物中的墙和管线虽然也有程序化生成再渲染的效果，但和场景中资源类型的固体格子是硬相接的关系，这里也不考虑。本文的研究重点放在资源类型的固体格子的渲染上（不包括这些格子的程序化生成）。</p><p><img loading=lazy src=../images/OxygenNotIncluded.jpg#center alt="Oxygen Not Included"></p><p>资源类型的固体格子（这里就简称瓦片了）的特点如下：</p><ol><li>有多种类型的瓦片</li><li>仅在不同类型的瓦片相接时会有黑色的描边</li><li>瓦片之间会有排序，优先级高的瓦片会更多地扩张</li><li>瓦片之间黑色的描边呈现周期性规律</li></ol><h2 id=模仿这种渲染的思路>模仿这种渲染的思路<a hidden class=anchor aria-hidden=true href=#模仿这种渲染的思路>#</a></h2><p>最简单的思路肯定就是在CPU中计算每一个瓦片应当有的形态，然后找到对应的贴图，把瓦片在GPU中绘制出来了。但是这样子做的话就失去了本文的意义，也太过无趣了。我想的是尽量多地用GPU来计算每个瓦片的形态，同时使用Instancing的方式，绘制每一个瓦片。</p><p>第一个问题是，不规则的瓦片应当如何绘制。如果是正方形的瓦片，能够很轻易地使用一个Quad和纹理来绘制，但是不规则的瓦片，势必会使用透明度混合的方式来绘制，这时对应的模型就会超出瓦片的游戏逻辑上的位置。因此，我想的是绘制的Quad的数量是瓦片实际数量的两倍加一，如下图所示：</p><p><img loading=lazy src=../images/TileRenderingDiagram.jpg#center alt="Tile Rendering Diagram"></p><p>在这张图中，ABC代表了不同类型的瓦片，左边是游戏游玩的时候逻辑上的瓦片分布，ABC是相接的，右边是在渲染的时候的瓦片的分布，在原有瓦片中间插入新的瓦片，专门用来渲染接缝。对于2号瓦片，其左上角右上角右下角左下角（顺时针的顺序）分别是ABCC，决定了这是一块三块相接的瓦片；对于1号瓦片，对应的编号是AACC（通过一些对2取模取余的运算可以排除掉B），决定了这是一块两块相接的瓦片；而对于3和4号瓦片，其编号为CCCC，决定了这两块是没有接缝的瓦片。这时我们又考虑到了瓦片之间优先级的关系，假设C>B>A，则AACC和AABB的接缝应当是相同的，ABCC和BCCA是旋转了九十度的关系。考虑到必定会有一个瓦片处于最低优先级，我们只需要将最低优先级的瓦片固定到左上角，讨论剩下三个瓦片的优先级与顺序即可。循着这个思路，我们可以把所有可能的接缝画在一张图上，这张图的RGBA通道记录了瓦片的优先级（R优先级最低，A优先级最高，接缝我使用了一个统一的灰色以便后续渲染），图片如下所示，为了比较容易观察，我对A通道做了反向，且对应的在下方标注了优先级顺序。同时我们还对应的写好一个函数用于根据优先级顺序找到对应的接缝类型从而在渲染时找到接缝在图上的位置（见<a href=#ONITileRender.hlsl>ONITileRender.hlsl</a>中的<code>GetMode(uint a, uint b, uint c)</code>）。</p><figure><img loading=lazy src=../images/TileTexture.png#center width=500px></figure><p>由于会有优先级的比较，不可避免地会在GPU中进行排序，使用MergeSort的话，4个元素会有5次比较，由于我们还需要获得每个瓦片在四个瓦片中排序的序号，这里就硬写了手动比较，6次比较和MergeSort的5次也差不太多。我们绘制的图上仅有最低优先级瓦片在左上角的情况，因此我们还需要找到最低优先级瓦片初始的序号，从而在渲染时旋转我们的接缝图（这里就体现了我们使用顺时针编号的优势，方便了旋转的操作，如果是左上角右上角左下角右下角的顺序，就不太好旋转了）。</p><p>知道了每一个接缝图的旋转，我们还需要为其每一个部分（通道）渲染不同的贴图。这里使用了<code>DrawProceduralIndirect</code>来进行Instancing的渲染，DrawCall数量会和瓦片类型的数量一样多。对于一种瓦片，需要渲染的总瓦片数相当于是这类瓦片的图形向外扩展一个瓦片的数量，我们可以通过判断左上右上右下左下的瓦片类型来轻易地判断当前瓦片是否应该和目标瓦片类型一起渲染。我们会使用一个数据数量为<code>瓦片类型数量*(2*地图宽高+1)</code>的StructuredBuffer来统计所有应当绘制的瓦片（实际使用的大小不会大于<code>4*(2*地图宽+1)*(2*地图高+1)</code>）。同时我们会使用一个数据数量为<code>瓦片类型数量*5</code>的ByteAddressBuffer来统计每种瓦片类型Instancing时需要的参数。</p><p>本文中的岩石的2D无缝贴图来自<a href=https://opengameart.org/content/wall-grass-rock-stone-wood-and-dirt-480>OpenGameArt.org</a></p><h2 id=具体的代码和相关的解释>具体的代码和相关的解释<a hidden class=anchor aria-hidden=true href=#具体的代码和相关的解释>#</a></h2><p>由于会用到CommandBuffer进行瓦片的绘制，我就把相关的代码放到Universal RP的Package里了。CPU代码，<code>ONITileRenderManager.cs</code>放在<code>Packages/com.unity.render-pipelines.universal/Runtime/Overrides/</code>下，<code>ONITileRendererFeature.cs</code>放在<code>Packages/com.unity.render-pipelines.universal/Runtime/RendererFeature/</code>下，<code>ONITileRenderPass.cs</code>放在<code>Packages/com.unity.render-pipelines.universal/Runtime/Passes/</code>下；GPU代码，<code>ONITileRender.hlsl</code>，<code>ONITileComputeShader.compute</code>和<code>ONITileRenderShader.shader</code>放在<code>Packages/com.unity.render-pipelines.universal/Shaders/ONITile/</code>下。</p><p><code>ONITileRenderManager</code>用于地图的设置、计算和Buffer的获取。<code>ONITileRendererFeature</code>和<code>ONITileRenderPass</code>用于在Unity URP中渲染瓦片，<code>ONITileComputeShader</code>用于瓦片相关的计算，<code>ONITileRenderShader</code>用于瓦片的渲染。</p><h3 id=onitilerendermanagercs>ONITileRenderManager.cs<a hidden class=anchor aria-hidden=true href=#onitilerendermanagercs>#</a></h3><p>这里尤其需要注意每个Buffer的大小。在这个脚本里使用Compute Shader做了三件事：1. 对地图每一个点生成一个随机数作为瓦片类型；2. 从地图中计算每一种瓦片类型需要绘制的数量、位置、解封类型、旋转和应当采样的通道；3. 把ByteAddressBuffer中的数据复制到IndirectArgumentBuffer里。事实上我感觉<code>ComputeShader.Dispatch</code>应该做成一个异步的方法，不过这个调用频率不高，就这样好了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[ExecuteInEditMode]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileRenderManager</span> : MonoBehaviour
{
<span style=color:#a6e22e>    [HideInInspector]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ONITileRenderManager Instance { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>public</span> ComputeShader oniTileComputeShader;
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> tileTypeCount = <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>public</span> Vector2Int tileCount = <span style=color:#66d9ef>new</span> Vector2Int(<span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>16</span>);
    <span style=color:#66d9ef>public</span> Vector2 tileSize = Vector2.one;
    <span style=color:#66d9ef>public</span> Vector3 tileStartPos;
    <span style=color:#66d9ef>public</span> Vector2 randomSeed;
    <span style=color:#66d9ef>public</span> Texture[] mainTextures = <span style=color:#66d9ef>new</span> Texture[] {};
    <span style=color:#66d9ef>public</span> Vector4 mainTextureST = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>);

    <span style=color:#66d9ef>private</span> Vector2Int tileCountExt;
    <span style=color:#66d9ef>public</span> Vector2Int TileCountExt { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> tileCountExt; } }
    <span style=color:#66d9ef>private</span> Vector4 textureSize;
    <span style=color:#66d9ef>public</span> Vector4 TextureSize { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> textureSize; } }
    <span style=color:#66d9ef>private</span> Vector4 textureSizeExt;
    <span style=color:#66d9ef>public</span> Vector4 TextureSizeExt { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> textureSizeExt; } }

    <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
    <span style=color:#66d9ef>public</span> ComputeBuffer ComputeBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> computeBuffer; } }
    <span style=color:#66d9ef>private</span> ComputeBuffer argBuffer;
    <span style=color:#66d9ef>public</span> ComputeBuffer ArgBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> argBuffer; } }
    <span style=color:#66d9ef>private</span> ComputeBuffer counterBuffer;
    <span style=color:#66d9ef>public</span> ComputeBuffer CounterBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> counterBuffer; } }
    <span style=color:#66d9ef>private</span> RenderTexture tileRenderTexture;
    <span style=color:#66d9ef>private</span> RenderTexture tileRenderTextureExt;

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> hasValidBuffer = <span style=color:#66d9ef>false</span>;
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> HasValidBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> hasValidBuffer; } }

    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PerTileProperty</span>
    {
        <span style=color:#66d9ef>public</span> Vector2Int coord;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>uint</span> mode;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>uint</span> rotation;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>uint</span> channel;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRenderTexture(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height)
    {
        <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span> || rt.width != width || rt.height != height)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) RenderTexture.ReleaseTemporary(rt);

            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor(width, height, RenderTextureFormat.ARGBInt);
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
            rt = RenderTexture.GetTemporary(desc);
            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer cb, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride, ComputeBufferType cbt = ComputeBufferType.Append)
    {
        <span style=color:#66d9ef>if</span> (cb == <span style=color:#66d9ef>null</span> || cb.count != count || cb.stride != stride)
        {
            <span style=color:#66d9ef>if</span> (cb != <span style=color:#66d9ef>null</span>) cb.Release();

            cb = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, cbt);
        }
    }


    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
    {
        <span style=color:#66d9ef>if</span> (Instance != <span style=color:#66d9ef>null</span>)
        {
            enabled = <span style=color:#66d9ef>false</span>;
            Debug.LogError(<span style=color:#e6db74>&#34;An instance of ONITileRenderManager already exists.&#34;</span>);
        }
        <span style=color:#66d9ef>else</span>
        {
            Instance = <span style=color:#66d9ef>this</span>;
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
    {
        Instance = <span style=color:#66d9ef>null</span>;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnValidate()
    {
        tileTypeCount = Mathf.Max(<span style=color:#ae81ff>1</span>, tileTypeCount);
        tileCount.x = Mathf.Max(<span style=color:#ae81ff>1</span>, tileCount.x);
        tileCount.y = Mathf.Max(<span style=color:#ae81ff>1</span>, tileCount.y);
        tileCountExt = <span style=color:#66d9ef>new</span> Vector2Int(tileCount.x * <span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>, tileCount.y * <span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>);
        textureSize = <span style=color:#66d9ef>new</span> Vector4(tileCount.x, tileCount.y, <span style=color:#ae81ff>1.0f</span> / tileCount.x, <span style=color:#ae81ff>1.0f</span> / tileCount.y);
        textureSizeExt = <span style=color:#66d9ef>new</span> Vector4(tileCountExt.x, tileCountExt.y, <span style=color:#ae81ff>1.0f</span> / tileCountExt.x, <span style=color:#ae81ff>1.0f</span> / tileCountExt.y);

        EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> computeBuffer, tileTypeCount * tileCountExt.x * tileCountExt.y, System.Runtime.InteropServices.Marshal.SizeOf&lt;PerTileProperty&gt;());
        EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> argBuffer, tileTypeCount * <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, ComputeBufferType.IndirectArguments);
        EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> counterBuffer, tileTypeCount * <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, ComputeBufferType.Raw);
        EnsureRenderTexture(<span style=color:#66d9ef>ref</span> tileRenderTexture, tileCount.x, tileCount.y);
        EnsureRenderTexture(<span style=color:#66d9ef>ref</span> tileRenderTextureExt, tileCountExt.x, tileCountExt.y);

        GenerateRandomTiles();
        hasValidBuffer = <span style=color:#66d9ef>false</span>;
        ExpandTileTexture();
        CopyToArgBuffer();
        hasValidBuffer = <span style=color:#66d9ef>true</span>;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateRandomTiles()
    {
        <span style=color:#66d9ef>if</span> (!oniTileComputeShader) <span style=color:#66d9ef>return</span>;

        <span style=color:#66d9ef>int</span> kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_RANDOM_KERNEL_NAME);
        oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_RandomSeed, randomSeed);
        oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize);
        oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTiles, tileRenderTexture);
        oniTileComputeShader.Dispatch(kernelID,
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCount.x / x),
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCount.y / y),
                <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ExpandTileTexture()
    {
        <span style=color:#66d9ef>if</span> (!oniTileComputeShader) <span style=color:#66d9ef>return</span>;

        <span style=color:#66d9ef>int</span>[] data = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[counterBuffer.count];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; data.Length; i++)
        {
            <span style=color:#66d9ef>if</span> (i % <span style=color:#ae81ff>5</span> == <span style=color:#ae81ff>0</span>)
            {
                data[i] = <span style=color:#ae81ff>6</span>;
            }
            <span style=color:#66d9ef>else</span>
            {
                data[i] = <span style=color:#ae81ff>0</span>;
            }
        }
        counterBuffer.SetData(data);

        <span style=color:#66d9ef>int</span> kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_EXPAND_KERNEL_NAME);
        oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSizeExt, textureSizeExt);
        oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RandomTiles, tileRenderTexture);
        oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTilesExt, tileRenderTextureExt);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_TileData, computeBuffer);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_CounterBuffer, counterBuffer);
        oniTileComputeShader.Dispatch(kernelID,
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCountExt.x / x),
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCountExt.y / y),
                <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CopyToArgBuffer()
    {
        <span style=color:#66d9ef>if</span> (!oniTileComputeShader) <span style=color:#66d9ef>return</span>;

        <span style=color:#66d9ef>int</span> kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_COPY_KERNEL_NAME);
        oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_CounterBuffer, counterBuffer);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_ArgBuffer, ArgBuffer);
        oniTileComputeShader.Dispatch(kernelID,
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)(<span style=color:#ae81ff>5</span>*tileTypeCount) / x),
                <span style=color:#ae81ff>1</span>,
                <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>public</span> Bounds GetBounds()
    {
        Vector3 start = tileStartPos;
        Vector2 totalSize = tileSize * tileCountExt;
        Vector3 size3D = <span style=color:#66d9ef>new</span> Vector3(totalSize.x, <span style=color:#ae81ff>0.0f</span>, totalSize.y) + Vector3.one;
        Vector3 center = start + <span style=color:#ae81ff>0.5f</span> * size3D;
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Bounds(center, size3D);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
    {
        <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
        {
            computeBuffer.Release();
            computeBuffer = <span style=color:#66d9ef>null</span>;
        }

        <span style=color:#66d9ef>if</span> (argBuffer != <span style=color:#66d9ef>null</span>)
        {
            argBuffer.Release();
            argBuffer = <span style=color:#66d9ef>null</span>;
        }

        <span style=color:#66d9ef>if</span> (tileRenderTexture != <span style=color:#66d9ef>null</span>)
        {
            RenderTexture.ReleaseTemporary(tileRenderTexture);
            tileRenderTexture = <span style=color:#66d9ef>null</span>;
        }

        <span style=color:#66d9ef>if</span> (tileRenderTextureExt != <span style=color:#66d9ef>null</span>)
        {
            RenderTexture.ReleaseTemporary(tileRenderTextureExt);
            tileRenderTextureExt = <span style=color:#66d9ef>null</span>;
        }
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileShaderConstants</span>
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> S_RANDOM_KERNEL_NAME = <span style=color:#e6db74>&#34;RandomMain&#34;</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> S_EXPAND_KERNEL_NAME = <span style=color:#e6db74>&#34;ExpandMain&#34;</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> S_COPY_KERNEL_NAME = <span style=color:#e6db74>&#34;CopyMain&#34;</span>;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TextureSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TextureSizeExt = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSizeExt&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileTypeCount = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileTypeCount&#34;</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RandomSeed = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RandomSeed&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RandomTiles = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RandomTiles&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_RandomTiles = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_RandomTiles&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_RandomTilesExt = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_RandomTilesExt&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_TileData = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_TileData&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_ArgBuffer = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_ArgBuffer&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_CounterBuffer = Shader.PropertyToID(<span style=color:#e6db74>&#34;_CounterBuffer&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_CounterBuffer = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_CounterBuffer&#34;</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileTexture&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileData = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileData&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileSize&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileStartPos = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileStartPos&#34;</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileType = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileType&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_MainTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_MainTexture&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_MainTexture_ST = Shader.PropertyToID(<span style=color:#e6db74>&#34;_MainTexture_ST&#34;</span>);
    }
}
</code></pre></div><h3 id=onitilerendererfeaturecs>ONITileRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#onitilerendererfeaturecs>#</a></h3><p>没什么好说的，照本宣科罢了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingTransparents;
            <span style=color:#66d9ef>public</span> Shader drawShader;
            <span style=color:#66d9ef>public</span> Texture tileTexture;

            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsValid()
            {
                <span style=color:#66d9ef>return</span> drawShader != <span style=color:#66d9ef>null</span> &amp;&amp; tileTexture != <span style=color:#66d9ef>null</span>;
            }
        }

        <span style=color:#66d9ef>private</span> ONITileRenderPass oniTileRenderPass;
        <span style=color:#66d9ef>public</span> ONITileSettings oniTileSettings = <span style=color:#66d9ef>new</span> ONITileSettings();

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            oniTileRenderPass = <span style=color:#66d9ef>new</span> ONITileRenderPass(oniTileSettings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            <span style=color:#66d9ef>if</span> (ONITileRenderManager.Instance != <span style=color:#66d9ef>null</span>
                &amp;&amp; oniTileSettings.IsValid())
            {
                oniTileRenderPass.Setup(ONITileRenderManager.Instance);
                renderer.EnqueuePass(oniTileRenderPass);
            }
        }
    }
}
</code></pre></div><h3 id=onitilerenderpasscs>ONITileRenderPass.cs<a hidden class=anchor aria-hidden=true href=#onitilerenderpasscs>#</a></h3><p><code>DrawProceduralIndirect</code>需要的argument一共五个uint的数据，分别为每个实例的顶点数，实例数，顶点起始位置，实例起始位置和一个预留给OpenGL的空位。如果我们需要画十三个Quad，我们只需要传入<code>{6, 13, 0, 0, 0}</code>即可。<code>i * 5 * 4</code>意味着对第i个瓦片类型，我们需要读取<code>i*5+0</code>到<code>i*5+4</code>这五个uint的数据作为IndirectDraw的argument，而uint的大小为4。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;ONI Tile Render Pass&#34;</span>;
        <span style=color:#66d9ef>private</span> ProfilingSampler oniTileRenderSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
        <span style=color:#66d9ef>private</span> ONITileRendererFeature.ONITileSettings settings;
        <span style=color:#66d9ef>private</span> ONITileRenderManager oniTileRenderManager;
        <span style=color:#66d9ef>private</span> Material drawMaterial;

        <span style=color:#66d9ef>public</span> ONITileRenderPass(ONITileRendererFeature.ONITileSettings settings)
        {
            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            <span style=color:#66d9ef>if</span> (settings.drawShader != <span style=color:#66d9ef>null</span>)
            {
                drawMaterial = <span style=color:#66d9ef>new</span> Material(settings.drawShader);
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(ONITileRenderManager oniTileRenderManager)
        {
            <span style=color:#66d9ef>this</span>.oniTileRenderManager = oniTileRenderManager;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoONITileRendering(CommandBuffer cmd, Material material)
        {
            <span style=color:#66d9ef>if</span>(oniTileRenderManager.HasValidBuffer)
            {
                MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
                mpb.SetBuffer(ONITileRenderManager.ONITileShaderConstants.I_TileData, oniTileRenderManager.ComputeBuffer);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TextureSizeExt, oniTileRenderManager.TextureSizeExt);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileStartPos, oniTileRenderManager.tileStartPos);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileSize, oniTileRenderManager.tileSize);
                mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_TileTexture, settings.tileTexture);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_MainTexture_ST, oniTileRenderManager.mainTextureST);

                <span style=color:#66d9ef>int</span> mainTextureLength = oniTileRenderManager.mainTextures.Length;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; oniTileRenderManager.tileTypeCount; i++)
                {
                    <span style=color:#66d9ef>if</span>(mainTextureLength &gt; <span style=color:#ae81ff>0</span>)
                    {
                        <span style=color:#66d9ef>int</span> mainTextureIndex = i % mainTextureLength;
                        mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_MainTexture, oniTileRenderManager.mainTextures[mainTextureIndex]);
                    }

                    mpb.SetInt(ONITileRenderManager.ONITileShaderConstants.I_TileType, i);
                    cmd.DrawProceduralIndirect(Matrix4x4.identity, material, <span style=color:#ae81ff>0</span>, MeshTopology.Triangles,
                                                oniTileRenderManager.ArgBuffer, i * <span style=color:#ae81ff>5</span> * <span style=color:#ae81ff>4</span>, properties:mpb);
                }   
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, oniTileRenderSampler))
            {
                DoONITileRendering(cmd, drawMaterial);
            }

            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=onitilerenderhlsl>ONITileRender.hlsl<a hidden class=anchor aria-hidden=true href=#onitilerenderhlsl>#</a></h3><p>这里定义了一个结构体<code>PerTileProperty</code>，需要和CPU代码里结构体的数据布局保持一致。事实上，channel和rotation都只是0-3的int类型，占两个bit，可以合并在一起，这样一个PerTileProperty刚好是四个字节，这里就不这么做了。至于中间的函数，我真的不太擅长命名。<code>SortAndReturnIndex</code>在排序的同时，还返回了每个元素在排序后的序号，方便后面的处理。<code>ProcessSortedArray</code>用于处理排序，生成并列第二名第三名。<code>RotateAccordingToMinimum</code>是旋转处理好的排序，从而通过<code>GetMode</code>获取接缝类型。我尽可能地减少了<code>GetMode</code>的分支数量（其实是一种二进制+三进制+特例）。</p><pre><code class=language-HLSL data-lang=HLSL>#ifndef ONI_TILE_RENDER_HLSL
#define ONI_TILE_RENDER_HLSL

#define ONI_TILE_TEXTURE_SIZE 8u

struct PerTileProperty
{
    uint2 coord;
    uint mode;
    uint rotation;
    uint channel;
};

SamplerState sampler_LinearClamp;
SamplerState sampler_PointClamp;
uint _TileTypeCount;
float4 _TextureSize;
float4 _TextureSizeExt;
float3 _TileStartPos;
float2 _TileSize;

// https://www.shadertoy.com/view/4djSRW
float hash12(float2 p)
{
    float3 p3  = frac(float3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

// A sort4 function with 6 compares.
// output: sorted array of input;
// return: sorted index of elements from input;
uint4 SortAndReturnIndex(float4 input, out uint output[4])
{  
    uint3 ab_ac_ad = input.xxx &lt;= input.yzw ? 0 : 1;
    uint3 bc_bd_cd = input.yyz &lt;= input.zww ? 0 : 1;
    uint indexA = ab_ac_ad.x + ab_ac_ad.y + ab_ac_ad.z;
    uint indexB = 1 - ab_ac_ad.x + bc_bd_cd.x + bc_bd_cd.y;
    uint indexC = 2 - ab_ac_ad.y - bc_bd_cd.x + bc_bd_cd.z;
    uint indexD = 3 - ab_ac_ad.z - bc_bd_cd.y - bc_bd_cd.z;
    
    output[indexA] = 0;
    output[indexB] = 1;
    output[indexC] = 2;
    output[indexD] = 3;

    return uint4(indexA, indexB, indexC, indexD);
}

// Input numbers might have equal elements, adjust sorted index based on that.
void ProcessSortedArray(float4 input, uint4 output, inout uint processedArray[4])
{
    if(input[output.x] == input[output.y])
    {
        processedArray[output.y] -= 1;
        processedArray[output.z] -= 1;
        processedArray[output.w] -= 1;
    }
    if(input[output.y] == input[output.z])
    {
        processedArray[output.z] -= 1;
        processedArray[output.w] -= 1;
    }
    if(input[output.z] == input[output.w])
    {
        processedArray[output.w] -= 1;
    }
}

// Rotate processed array according to the index of minimum element.
uint4 RotateAccordingToMinimum(uint processedArray[4], uint sortedArray[4])
{
    uint minIndex = sortedArray[0];
    uint rotateX = processedArray[(0+minIndex)%4];
    uint rotateY = processedArray[(1+minIndex)%4];
    uint rotateZ = processedArray[(2+minIndex)%4];
    uint rotateW = processedArray[(3+minIndex)%4];
    return uint4(rotateX, rotateY, rotateZ, rotateW);
}

// Get mode based on &quot;sorted-processed-rotated&quot; result, mode is used to sample tile texture later.
// 0 a
// c b
uint GetMode(uint a, uint b, uint c)
{
    if(a==0)
    {
        if(b==0) return c==0 ? 0 : 1;
        if(b==1) return c+2;
        if(b==2) return 5;
    }

    if(a==1)
    {
        return b==3 ? 16 : c+b*3+6;
    }

    if(a==2)
    {
        if(b==0) return 17;
        if(b==1) return c+18;
        if(b==2) return 22;
        if(b==3) return 23;
    }

    if(a==3)
    {
        return b==1 ? 24 : 25;
    }

    return 0;
}

#endif
</code></pre><h3 id=onitilecomputeshadercompute>ONITileComputeShader.compute<a hidden class=anchor aria-hidden=true href=#onitilecomputeshadercompute>#</a></h3><p>这里定义了三个Kernel，分别用于生成随机数，找到所有应渲染的瓦片及其属性，把ByteAddressBuffer的内容复制到IndirectArgumentBuffer。实际运用的话我们不会在GPU里生成瓦片，理论上也没必要做一次Buffer数据的复制。使用了<code>ByteAddressBuffer.InterlockedAdd</code>来获取当前类型的瓦片需要Instancing的数量（并根据这个数量储存对应的PerTileProperty）。</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel RandomMain
#pragma kernel ExpandMain
#pragma kernel CopyMain

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
#include &quot;ONITileRender.hlsl&quot;

float2 _RandomSeed;

Texture2D&lt;float4&gt; _RandomTiles;
RWTexture2D&lt;float4&gt; _RW_RandomTiles;
RWTexture2D&lt;float4&gt; _RW_RandomTilesExt;

ByteAddressBuffer _CounterBuffer;
RWStructuredBuffer&lt;PerTileProperty&gt; _RW_TileData;
RWStructuredBuffer&lt;uint&gt; _RW_ArgBuffer;
RWByteAddressBuffer _RW_CounterBuffer;

[numthreads(8,8,1)]
void RandomMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if(any((float2)dispatchThreadID.xy &gt;= _TextureSize.xy)) return;

    float randomVal = hash12(dispatchThreadID.xy + _RandomSeed);
    float val = floor(randomVal * _TileTypeCount);

    float4 returnColor = float4(val, val, val, val);
    _RW_RandomTiles[dispatchThreadID.xy] = returnColor;
}

float LoadFromRandomTiles(Texture2D&lt;float4&gt; tex, int2 coord, float2 textureSize)
{
    float2 tempCoord = clamp(float2(0.0f, 0.0f), textureSize-1.0f, coord);
    return tex.Load(uint3(tempCoord, 0)).r;
}

[numthreads(8, 8, 1)]
void ExpandMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if(any((float2)dispatchThreadID.xy &gt;= _TextureSizeExt.xy)) return;

    float tr = LoadFromRandomTiles(_RandomTiles, dispatchThreadID.xy / 2, _TextureSize.xy);
    float tl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 0)) / 2) - int2(1, 0), _TextureSize.xy);
    float br = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(0, 1)) / 2) - int2(0, 1), _TextureSize.xy);
    float bl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 1)) / 2) - int2(1, 1), _TextureSize.xy);
    
    // x y
    // w z
    float4 packedColor = float4(tl, tr, br, bl);
    uint output[4];
    uint4 sortedIndex = SortAndReturnIndex(packedColor, output);
    uint4 tempOutput = int4(output[0], output[1], output[2], output[3]);

    uint processedArray[4] = {sortedIndex.x, sortedIndex.y, sortedIndex.z, sortedIndex.w};
    ProcessSortedArray(packedColor, tempOutput, processedArray);
    uint4 rotatedIndex = RotateAccordingToMinimum(processedArray, output);
    uint mode = GetMode(rotatedIndex.y, rotatedIndex.z, rotatedIndex.w);

    for (float i = 0; i &lt; (float)_TileTypeCount; i++)
    {
        bool shouldRender = false;
        int channel = 3;
        if(bl == i)
        {
            shouldRender = true;
            channel = processedArray[3];
        }

        if(br == i)
        {
            shouldRender = true;
            channel = processedArray[2];
        }

        if(tr == i)
        {
            shouldRender = true;
            channel = processedArray[1];
        }

        if(tl == i)
        {
            shouldRender = true;
            channel = processedArray[0];
        }

        if(shouldRender)
        {
            uint totalCount;
            _RW_CounterBuffer.InterlockedAdd(4 + i * 5 * 4, 1, totalCount);
            PerTileProperty prop = (PerTileProperty)0;
            prop.coord = dispatchThreadID.xy;
            prop.mode = mode;
            prop.rotation = tempOutput.x;
            prop.channel = channel;
            _RW_TileData[totalCount + i * _TextureSizeExt.x * _TextureSizeExt.y] = prop;
        }
    }

    _RW_RandomTilesExt[dispatchThreadID.xy] = float4(mode, tempOutput.x, 0.0f, 1.0f);
}

[numthreads(16, 1, 1)]
void CopyMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if(dispatchThreadID.x &gt;= 5 * _TileTypeCount) return;
    uint status;
    _RW_ArgBuffer[dispatchThreadID.x] = _CounterBuffer.Load(4 * dispatchThreadID.x, status);
}
</code></pre><h3 id=onitilerendershadershader>ONITileRenderShader.shader<a hidden class=anchor aria-hidden=true href=#onitilerendershadershader>#</a></h3><p>由于我们画的TileTexture是从左上角开始的，采样的时候会用到一些用1减去uv的y值，旋转也不会乘上-1。前面给缝隙画上灰色的好处也在这里体现出来，我们可以用两个<code>smoothstep</code>来找到一定程度上抗锯齿的渲染区域和缝隙区域。此外在开启MSAA的时候可能会需要根据uv是否在01之间剔除掉当前像素，不然会有奇怪的边缘锯齿。</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/ONITileRenderShader&quot;
{
    HLSLINCLUDE

    #pragma enable_d3d11_debug_symbols
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;ONITileRender.hlsl&quot;

    StructuredBuffer&lt;PerTileProperty&gt; _TileData;
    sampler2D _TileTexture;
    sampler2D _MainTexture;
    float4 _MainTexture_ST;
    uint _TileType;

    struct Attributes
    {
        uint vertexID       : SV_VERTEXID;
        uint instanceID     : SV_INSTANCEID;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float3 positionWS   : TEXCOORD1;
        uint mode           : TEXCOORD2;
        uint rotation       : TEXCOORD3;
        uint channel        : TEXCOORD4;
    };

    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;

        PerTileProperty prop = _TileData[input.instanceID + _TileType * _TextureSizeExt.x * _TextureSizeExt.y];

        uint vertexIndex = input.vertexID % 3;
        uint triangleID = input.vertexID / 3;
        uint uvX = ((vertexIndex&amp;2)&gt;&gt;1)^triangleID;
        uint uvY = ((vertexIndex+vertexIndex&gt;&gt;1)&amp;1)^triangleID;
        float2 uv = float2(uvX, uvY);

        float2 tileCoord = (prop.coord + 0.5f) * _TileSize;
        float3 center = float3(tileCoord.x, 0.0f, tileCoord.y) + _TileStartPos;
        float2 positionWSOffset = (uv - 0.5f) * _TileSize;
        float3 positionWS = center + float3(positionWSOffset.x, 0.0f, positionWSOffset.y);

        output.positionCS = mul(UNITY_MATRIX_VP, float4(positionWS, 1.0f));
        output.uv = uv;
        output.positionWS = positionWS;
        output.mode = prop.mode;
        output.rotation = prop.rotation;
        output.channel = prop.channel;
        return output;
    }

    float4 frag(Varyings input) : SV_TARGET
    {
        float2 uv = input.uv;
        uv.y = 1.0f - uv.y;

        int2 startCoord = int2(input.mode % ONI_TILE_TEXTURE_SIZE, input.mode / ONI_TILE_TEXTURE_SIZE);
        float2 startUV = (float2)(startCoord) / ONI_TILE_TEXTURE_SIZE;

        float rotationVal = (float)(input.rotation) * PI * 0.5f;
        float sinVal, cosVal;
        sincos(rotationVal, sinVal, cosVal);
        float2x2 rotationMat = float2x2(cosVal, sinVal, -sinVal, cosVal);
        float2 rotatedCoord = saturate(mul(rotationMat, uv - 0.5f) + 0.5f);
        float2 sampleCoord = startUV + rotatedCoord / ONI_TILE_TEXTURE_SIZE;
        sampleCoord.y = 1.0f - sampleCoord.y;

        float4 tileTexture = tex2D(_TileTexture, sampleCoord);
        float visColor = tileTexture[input.channel];

        float textureMask = smoothstep(0.25f, 1.0f, visColor);
        float gapMask = smoothstep(0.0f, 0.25f, visColor);

        float3 mainTex = tex2D(_MainTexture, input.positionWS.xz * _MainTexture_ST.xy + _MainTexture_ST.zw).rgb;
        mainTex = lerp(0.0f, mainTex, textureMask);
        float4 returnColor = float4(mainTex, gapMask);

        return returnColor;
    }

    ENDHLSL

    SubShader
    {
        pass
        {
            Tags {&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot;}
            Blend SrcAlpha OneMinusSrcAlpha
            ZTest LEqual
            ZWrite Off
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL       
        }
    }
}
</code></pre><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>总之就是很爽很快乐很有成就感。因为画图水平不行，有的地方的接缝差了一点点，也无所谓了。由于之前被HLSL里的Array坑了很多次，这里刻意地去限制了Array的数量，在加上之前玩了一会图灵完备，计算Procedural Quad的UV和顶点坐标简直不在话下，要是以前肯定就写一个长度为6的array进行采样了。对ByteAddressBuffer也有了新的理解，居然能用来计数，从而DrawIndirect或者DispatchIndirect，以前的话我只会CopyCounterValue。最后的最后也夸一下缺氧，画面确实很让人有深刻的印象，液体的渲染更是独树一帜，就是一个人玩太枯燥了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/tile-rendering/>Tile Rendering</a></li><li><a href=https://zznewclear13.github.io/tags/procedural/>Procedural</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><span class=title>« Prev Page</span><br><span>再议高斯模糊</span></a>
<a class=next href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-ray-marching/><span class=title>Next Page »</span><br><span>使用Ray Marching来渲染体积雾</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>