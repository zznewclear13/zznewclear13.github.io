<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³• | ZZNEWCLEAR13</title><meta name=keywords content="Tile Rendering,Procedural,Compute Shader"><meta name=description content="ä½¿ç”¨Compute Bufferä¸€æ¬¡æ€§ç»˜åˆ¶å¤šä¸ªç“¦ç‰‡."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/><link crossorigin=anonymous href=/assets/css/stylesheet.a6fe470bfe70eb4fad7ee3efc590e817f121cf0f6d66fa91de327cf6bfbad62d.css integrity="sha256-pv5HC/5w60+tfuPvxZDoF/Ehzw9tZvqR3jJ89r+61i0=" rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•"><meta property="og:description" content="ä½¿ç”¨Compute Bufferä¸€æ¬¡æ€§ç»˜åˆ¶å¤šä¸ªç“¦ç‰‡."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/"><meta property="og:image" content="https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/posts/images/TileRendering.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-20T12:00:00+08:00"><meta property="article:modified_time" content="2023-02-20T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/posts/images/TileRendering.jpg"><meta name=twitter:title content="æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•"><meta name=twitter:description content="ä½¿ç”¨Compute Bufferä¸€æ¬¡æ€§ç»˜åˆ¶å¤šä¸ªç“¦ç‰‡."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•","item":"https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•","name":"æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•","description":"ä½¿ç”¨Compute Bufferä¸€æ¬¡æ€§ç»˜åˆ¶å¤šä¸ªç“¦ç‰‡.","keywords":["Tile Rendering","Procedural","Compute Shader"],"articleBody":"ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹ å¾ˆå¯æƒœæˆ‘æ²¡æœ‰åœ¨RenderDocé‡Œæˆªåˆ°ç¼ºæ°§çš„å¸§ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯èƒ½ä»æ¸²æŸ“è¡¨ç°ä¸Šæ¥åˆ†æä¸€ä¸‹ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹ã€‚ç»è¿‡ä¸€æ®µæ—¶é—´çš„æ¸¸ç©å’Œä»ä¸‹é¢è¿™å¼ å›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œç¼ºæ°§çš„æ¸¸æˆé€»è¾‘æ˜¯æŠŠæ•´ä¸ª2Dçš„åœ°å›¾åˆ†æˆä¸€ä¸ªä¸€ä¸ªæ ¼å­ï¼Œæ¯ä¸ªæ ¼å­è®°å½•äº†æ°”ä½“ã€æ¶²ä½“ã€å›ºä½“å’Œå»ºç­‘ç‰©çš„ä¿¡æ¯ã€‚æ°”ä½“åªæ˜¯ä¸€ä¸ªæ‰­æ›²çš„Shaderï¼Œæ¶²ä½“æ¸²æŸ“å’Œè®¡ç®—æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œæš‚æ—¶ä¸è€ƒè™‘ï¼Œå»ºç­‘ç‰©ä¸­çš„å¢™å’Œç®¡çº¿è™½ç„¶ä¹Ÿæœ‰ç¨‹åºåŒ–ç”Ÿæˆå†æ¸²æŸ“çš„æ•ˆæœï¼Œä½†å’Œåœºæ™¯ä¸­èµ„æºç±»å‹çš„å›ºä½“æ ¼å­æ˜¯ç¡¬ç›¸æ¥çš„å…³ç³»ï¼Œè¿™é‡Œä¹Ÿä¸è€ƒè™‘ã€‚æœ¬æ–‡çš„ç ”ç©¶é‡ç‚¹æ”¾åœ¨èµ„æºç±»å‹çš„å›ºä½“æ ¼å­çš„æ¸²æŸ“ä¸Šï¼ˆä¸åŒ…æ‹¬è¿™äº›æ ¼å­çš„ç¨‹åºåŒ–ç”Ÿæˆï¼‰ã€‚\nèµ„æºç±»å‹çš„å›ºä½“æ ¼å­ï¼ˆè¿™é‡Œå°±ç®€ç§°ç“¦ç‰‡äº†ï¼‰çš„ç‰¹ç‚¹å¦‚ä¸‹ï¼š\n æœ‰å¤šç§ç±»å‹çš„ç“¦ç‰‡ ä»…åœ¨ä¸åŒç±»å‹çš„ç“¦ç‰‡ç›¸æ¥æ—¶ä¼šæœ‰é»‘è‰²çš„æè¾¹ ç“¦ç‰‡ä¹‹é—´ä¼šæœ‰æ’åºï¼Œä¼˜å…ˆçº§é«˜çš„ç“¦ç‰‡ä¼šæ›´å¤šåœ°æ‰©å¼  ç“¦ç‰‡ä¹‹é—´é»‘è‰²çš„æè¾¹å‘ˆç°å‘¨æœŸæ€§è§„å¾‹  æ¨¡ä»¿è¿™ç§æ¸²æŸ“çš„æ€è·¯ æœ€ç®€å•çš„æ€è·¯è‚¯å®šå°±æ˜¯åœ¨CPUä¸­è®¡ç®—æ¯ä¸€ä¸ªç“¦ç‰‡åº”å½“æœ‰çš„å½¢æ€ï¼Œç„¶åæ‰¾åˆ°å¯¹åº”çš„è´´å›¾ï¼ŒæŠŠç“¦ç‰‡åœ¨GPUä¸­ç»˜åˆ¶å‡ºæ¥äº†ã€‚ä½†æ˜¯è¿™æ ·å­åšçš„è¯å°±å¤±å»äº†æœ¬æ–‡çš„æ„ä¹‰ï¼Œä¹Ÿå¤ªè¿‡æ— è¶£äº†ã€‚æˆ‘æƒ³çš„æ˜¯å°½é‡å¤šåœ°ç”¨GPUæ¥è®¡ç®—æ¯ä¸ªç“¦ç‰‡çš„å½¢æ€ï¼ŒåŒæ—¶ä½¿ç”¨Instancingçš„æ–¹å¼ï¼Œç»˜åˆ¶æ¯ä¸€ä¸ªç“¦ç‰‡ã€‚\nç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œä¸è§„åˆ™çš„ç“¦ç‰‡åº”å½“å¦‚ä½•ç»˜åˆ¶ã€‚å¦‚æœæ˜¯æ­£æ–¹å½¢çš„ç“¦ç‰‡ï¼Œèƒ½å¤Ÿå¾ˆè½»æ˜“åœ°ä½¿ç”¨ä¸€ä¸ªQuadå’Œçº¹ç†æ¥ç»˜åˆ¶ï¼Œä½†æ˜¯ä¸è§„åˆ™çš„ç“¦ç‰‡ï¼ŒåŠ¿å¿…ä¼šä½¿ç”¨é€æ˜åº¦æ··åˆçš„æ–¹å¼æ¥ç»˜åˆ¶ï¼Œè¿™æ—¶å¯¹åº”çš„æ¨¡å‹å°±ä¼šè¶…å‡ºç“¦ç‰‡çš„æ¸¸æˆé€»è¾‘ä¸Šçš„ä½ç½®ã€‚å› æ­¤ï¼Œæˆ‘æƒ³çš„æ˜¯ç»˜åˆ¶çš„Quadçš„æ•°é‡æ˜¯ç“¦ç‰‡å®é™…æ•°é‡çš„ä¸¤å€åŠ ä¸€ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nåœ¨è¿™å¼ å›¾ä¸­ï¼ŒABCä»£è¡¨äº†ä¸åŒç±»å‹çš„ç“¦ç‰‡ï¼Œå·¦è¾¹æ˜¯æ¸¸æˆæ¸¸ç©çš„æ—¶å€™é€»è¾‘ä¸Šçš„ç“¦ç‰‡åˆ†å¸ƒï¼ŒABCæ˜¯ç›¸æ¥çš„ï¼Œå³è¾¹æ˜¯åœ¨æ¸²æŸ“çš„æ—¶å€™çš„ç“¦ç‰‡çš„åˆ†å¸ƒï¼Œåœ¨åŸæœ‰ç“¦ç‰‡ä¸­é—´æ’å…¥æ–°çš„ç“¦ç‰‡ï¼Œä¸“é—¨ç”¨æ¥æ¸²æŸ“æ¥ç¼ã€‚å¯¹äº2å·ç“¦ç‰‡ï¼Œå…¶å·¦ä¸Šè§’å³ä¸Šè§’å³ä¸‹è§’å·¦ä¸‹è§’ï¼ˆé¡ºæ—¶é’ˆçš„é¡ºåºï¼‰åˆ†åˆ«æ˜¯ABCCï¼Œå†³å®šäº†è¿™æ˜¯ä¸€å—ä¸‰å—ç›¸æ¥çš„ç“¦ç‰‡ï¼›å¯¹äº1å·ç“¦ç‰‡ï¼Œå¯¹åº”çš„ç¼–å·æ˜¯AACCï¼ˆé€šè¿‡ä¸€äº›å¯¹2å–æ¨¡å–ä½™çš„è¿ç®—å¯ä»¥æ’é™¤æ‰Bï¼‰ï¼Œå†³å®šäº†è¿™æ˜¯ä¸€å—ä¸¤å—ç›¸æ¥çš„ç“¦ç‰‡ï¼›è€Œå¯¹äº3å’Œ4å·ç“¦ç‰‡ï¼Œå…¶ç¼–å·ä¸ºCCCCï¼Œå†³å®šäº†è¿™ä¸¤å—æ˜¯æ²¡æœ‰æ¥ç¼çš„ç“¦ç‰‡ã€‚è¿™æ—¶æˆ‘ä»¬åˆè€ƒè™‘åˆ°äº†ç“¦ç‰‡ä¹‹é—´ä¼˜å…ˆçº§çš„å…³ç³»ï¼Œå‡è®¾CBAï¼Œåˆ™AACCå’ŒAABBçš„æ¥ç¼åº”å½“æ˜¯ç›¸åŒçš„ï¼ŒABCCå’ŒBCCAæ˜¯æ—‹è½¬äº†ä¹ååº¦çš„å…³ç³»ã€‚è€ƒè™‘åˆ°å¿…å®šä¼šæœ‰ä¸€ä¸ªç“¦ç‰‡å¤„äºæœ€ä½ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬åªéœ€è¦å°†æœ€ä½ä¼˜å…ˆçº§çš„ç“¦ç‰‡å›ºå®šåˆ°å·¦ä¸Šè§’ï¼Œè®¨è®ºå‰©ä¸‹ä¸‰ä¸ªç“¦ç‰‡çš„ä¼˜å…ˆçº§ä¸é¡ºåºå³å¯ã€‚å¾ªç€è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰å¯èƒ½çš„æ¥ç¼ç”»åœ¨ä¸€å¼ å›¾ä¸Šï¼Œè¿™å¼ å›¾çš„RGBAé€šé“è®°å½•äº†ç“¦ç‰‡çš„ä¼˜å…ˆçº§ï¼ˆRä¼˜å…ˆçº§æœ€ä½ï¼ŒAä¼˜å…ˆçº§æœ€é«˜ï¼Œæ¥ç¼æˆ‘ä½¿ç”¨äº†ä¸€ä¸ªç»Ÿä¸€çš„ç°è‰²ä»¥ä¾¿åç»­æ¸²æŸ“ï¼‰ï¼Œå›¾ç‰‡å¦‚ä¸‹æ‰€ç¤ºï¼Œä¸ºäº†æ¯”è¾ƒå®¹æ˜“è§‚å¯Ÿï¼Œæˆ‘å¯¹Aé€šé“åšäº†åå‘ï¼Œä¸”å¯¹åº”çš„åœ¨ä¸‹æ–¹æ ‡æ³¨äº†ä¼˜å…ˆçº§é¡ºåºã€‚åŒæ—¶æˆ‘ä»¬è¿˜å¯¹åº”çš„å†™å¥½ä¸€ä¸ªå‡½æ•°ç”¨äºæ ¹æ®ä¼˜å…ˆçº§é¡ºåºæ‰¾åˆ°å¯¹åº”çš„æ¥ç¼ç±»å‹ä»è€Œåœ¨æ¸²æŸ“æ—¶æ‰¾åˆ°æ¥ç¼åœ¨å›¾ä¸Šçš„ä½ç½®ï¼ˆè§ONITileRender.hlslä¸­çš„GetMode(uint a, uint b, uint c)ï¼‰ã€‚\n\r\rç”±äºä¼šæœ‰ä¼˜å…ˆçº§çš„æ¯”è¾ƒï¼Œä¸å¯é¿å…åœ°ä¼šåœ¨GPUä¸­è¿›è¡Œæ’åºï¼Œä½¿ç”¨MergeSortçš„è¯ï¼Œ4ä¸ªå…ƒç´ ä¼šæœ‰5æ¬¡æ¯”è¾ƒï¼Œç”±äºæˆ‘ä»¬è¿˜éœ€è¦è·å¾—æ¯ä¸ªç“¦ç‰‡åœ¨å››ä¸ªç“¦ç‰‡ä¸­æ’åºçš„åºå·ï¼Œè¿™é‡Œå°±ç¡¬å†™äº†æ‰‹åŠ¨æ¯”è¾ƒï¼Œ6æ¬¡æ¯”è¾ƒå’ŒMergeSortçš„5æ¬¡ä¹Ÿå·®ä¸å¤ªå¤šã€‚æˆ‘ä»¬ç»˜åˆ¶çš„å›¾ä¸Šä»…æœ‰æœ€ä½ä¼˜å…ˆçº§ç“¦ç‰‡åœ¨å·¦ä¸Šè§’çš„æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦æ‰¾åˆ°æœ€ä½ä¼˜å…ˆçº§ç“¦ç‰‡åˆå§‹çš„åºå·ï¼Œä»è€Œåœ¨æ¸²æŸ“æ—¶æ—‹è½¬æˆ‘ä»¬çš„æ¥ç¼å›¾ï¼ˆè¿™é‡Œå°±ä½“ç°äº†æˆ‘ä»¬ä½¿ç”¨é¡ºæ—¶é’ˆç¼–å·çš„ä¼˜åŠ¿ï¼Œæ–¹ä¾¿äº†æ—‹è½¬çš„æ“ä½œï¼Œå¦‚æœæ˜¯å·¦ä¸Šè§’å³ä¸Šè§’å·¦ä¸‹è§’å³ä¸‹è§’çš„é¡ºåºï¼Œå°±ä¸å¤ªå¥½æ—‹è½¬äº†ï¼‰ã€‚\nçŸ¥é“äº†æ¯ä¸€ä¸ªæ¥ç¼å›¾çš„æ—‹è½¬ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸ºå…¶æ¯ä¸€ä¸ªéƒ¨åˆ†ï¼ˆé€šé“ï¼‰æ¸²æŸ“ä¸åŒçš„è´´å›¾ã€‚è¿™é‡Œä½¿ç”¨äº†DrawProceduralIndirectæ¥è¿›è¡ŒInstancingçš„æ¸²æŸ“ï¼ŒDrawCallæ•°é‡ä¼šå’Œç“¦ç‰‡ç±»å‹çš„æ•°é‡ä¸€æ ·å¤šã€‚å¯¹äºä¸€ç§ç“¦ç‰‡ï¼Œéœ€è¦æ¸²æŸ“çš„æ€»ç“¦ç‰‡æ•°ç›¸å½“äºæ˜¯è¿™ç±»ç“¦ç‰‡çš„å›¾å½¢å‘å¤–æ‰©å±•ä¸€ä¸ªç“¦ç‰‡çš„æ•°é‡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ¤æ–­å·¦ä¸Šå³ä¸Šå³ä¸‹å·¦ä¸‹çš„ç“¦ç‰‡ç±»å‹æ¥è½»æ˜“åœ°åˆ¤æ–­å½“å‰ç“¦ç‰‡æ˜¯å¦åº”è¯¥å’Œç›®æ ‡ç“¦ç‰‡ç±»å‹ä¸€èµ·æ¸²æŸ“ã€‚æˆ‘ä»¬ä¼šä½¿ç”¨ä¸€ä¸ªæ•°æ®æ•°é‡ä¸ºç“¦ç‰‡ç±»å‹æ•°é‡*(2*åœ°å›¾å®½é«˜+1)çš„StructuredBufferæ¥ç»Ÿè®¡æ‰€æœ‰åº”å½“ç»˜åˆ¶çš„ç“¦ç‰‡ï¼ˆå®é™…ä½¿ç”¨çš„å¤§å°ä¸ä¼šå¤§äº4*(2*åœ°å›¾å®½+1)*(2*åœ°å›¾é«˜+1)ï¼‰ã€‚åŒæ—¶æˆ‘ä»¬ä¼šä½¿ç”¨ä¸€ä¸ªæ•°æ®æ•°é‡ä¸ºç“¦ç‰‡ç±»å‹æ•°é‡*5çš„ByteAddressBufferæ¥ç»Ÿè®¡æ¯ç§ç“¦ç‰‡ç±»å‹Instancingæ—¶éœ€è¦çš„å‚æ•°ã€‚\næœ¬æ–‡ä¸­çš„å²©çŸ³çš„2Dæ— ç¼è´´å›¾æ¥è‡ªOpenGameArt.org\nå…·ä½“çš„ä»£ç å’Œç›¸å…³çš„è§£é‡Š ç”±äºä¼šç”¨åˆ°CommandBufferè¿›è¡Œç“¦ç‰‡çš„ç»˜åˆ¶ï¼Œæˆ‘å°±æŠŠç›¸å…³çš„ä»£ç æ”¾åˆ°Universal RPçš„Packageé‡Œäº†ã€‚CPUä»£ç ï¼ŒONITileRenderManager.csæ”¾åœ¨Packages/com.unity.render-pipelines.universal/Runtime/Overrides/ä¸‹ï¼ŒONITileRendererFeature.csæ”¾åœ¨Packages/com.unity.render-pipelines.universal/Runtime/RendererFeature/ä¸‹ï¼ŒONITileRenderPass.csæ”¾åœ¨Packages/com.unity.render-pipelines.universal/Runtime/Passes/ä¸‹ï¼›GPUä»£ç ï¼ŒONITileRender.hlslï¼ŒONITileComputeShader.computeå’ŒONITileRenderShader.shaderæ”¾åœ¨Packages/com.unity.render-pipelines.universal/Shaders/ONITile/ä¸‹ã€‚\nONITileRenderManagerç”¨äºåœ°å›¾çš„è®¾ç½®ã€è®¡ç®—å’ŒBufferçš„è·å–ã€‚ONITileRendererFeatureå’ŒONITileRenderPassç”¨äºåœ¨Unity URPä¸­æ¸²æŸ“ç“¦ç‰‡ï¼ŒONITileComputeShaderç”¨äºç“¦ç‰‡ç›¸å…³çš„è®¡ç®—ï¼ŒONITileRenderShaderç”¨äºç“¦ç‰‡çš„æ¸²æŸ“ã€‚\nONITileRenderManager.cs è¿™é‡Œå°¤å…¶éœ€è¦æ³¨æ„æ¯ä¸ªBufferçš„å¤§å°ã€‚åœ¨è¿™ä¸ªè„šæœ¬é‡Œä½¿ç”¨Compute Shaderåšäº†ä¸‰ä»¶äº‹ï¼š1. å¯¹åœ°å›¾æ¯ä¸€ä¸ªç‚¹ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ä½œä¸ºç“¦ç‰‡ç±»å‹ï¼›2. ä»åœ°å›¾ä¸­è®¡ç®—æ¯ä¸€ç§ç“¦ç‰‡ç±»å‹éœ€è¦ç»˜åˆ¶çš„æ•°é‡ã€ä½ç½®ã€è§£å°ç±»å‹ã€æ—‹è½¬å’Œåº”å½“é‡‡æ ·çš„é€šé“ï¼›3. æŠŠByteAddressBufferä¸­çš„æ•°æ®å¤åˆ¶åˆ°IndirectArgumentBufferé‡Œã€‚äº‹å®ä¸Šæˆ‘æ„Ÿè§‰ComputeShader.Dispatchåº”è¯¥åšæˆä¸€ä¸ªå¼‚æ­¥çš„æ–¹æ³•ï¼Œä¸è¿‡è¿™ä¸ªè°ƒç”¨é¢‘ç‡ä¸é«˜ï¼Œå°±è¿™æ ·å¥½äº†ã€‚\nusing UnityEngine; [ExecuteInEditMode] public class ONITileRenderManager : MonoBehaviour { [HideInInspector] public static ONITileRenderManager Instance { get; private set; } public ComputeShader oniTileComputeShader; public int tileTypeCount = 4; public Vector2Int tileCount = new Vector2Int(16, 16); public Vector2 tileSize = Vector2.one; public Vector3 tileStartPos; public Vector2 randomSeed; public Texture[] mainTextures = new Texture[] {}; public Vector4 mainTextureST = new Vector4(1.0f, 1.0f, 0.0f, 0.0f); private Vector2Int tileCountExt; public Vector2Int TileCountExt { get { return tileCountExt; } } private Vector4 textureSize; public Vector4 TextureSize { get { return textureSize; } } private Vector4 textureSizeExt; public Vector4 TextureSizeExt { get { return textureSizeExt; } } private ComputeBuffer computeBuffer; public ComputeBuffer ComputeBuffer { get { return computeBuffer; } } private ComputeBuffer argBuffer; public ComputeBuffer ArgBuffer { get { return argBuffer; } } private ComputeBuffer counterBuffer; public ComputeBuffer CounterBuffer { get { return counterBuffer; } } private RenderTexture tileRenderTexture; private RenderTexture tileRenderTextureExt; private bool hasValidBuffer = false; public bool HasValidBuffer { get { return hasValidBuffer; } } struct PerTileProperty { public Vector2Int coord; public uint mode; public uint rotation; public uint channel; } private void EnsureRenderTexture(ref RenderTexture rt, int width, int height) { if (rt == null || rt.width != width || rt.height != height) { if (rt != null) RenderTexture.ReleaseTemporary(rt); RenderTextureDescriptor desc = new RenderTextureDescriptor(width, height, RenderTextureFormat.ARGBInt); desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; rt = RenderTexture.GetTemporary(desc); if (!rt.IsCreated()) rt.Create(); } } private void EnsureComputeBuffer(ref ComputeBuffer cb, int count, int stride, ComputeBufferType cbt = ComputeBufferType.Append) { if (cb == null || cb.count != count || cb.stride != stride) { if (cb != null) cb.Release(); cb = new ComputeBuffer(count, stride, cbt); } } private void OnEnable() { if (Instance != null) { enabled = false; Debug.LogError(\"An instance of ONITileRenderManager already exists.\"); } else { Instance = this; } } private void OnDisable() { Instance = null; } private void OnValidate() { tileTypeCount = Mathf.Max(1, tileTypeCount); tileCount.x = Mathf.Max(1, tileCount.x); tileCount.y = Mathf.Max(1, tileCount.y); tileCountExt = new Vector2Int(tileCount.x * 2 + 1, tileCount.y * 2 + 1); textureSize = new Vector4(tileCount.x, tileCount.y, 1.0f / tileCount.x, 1.0f / tileCount.y); textureSizeExt = new Vector4(tileCountExt.x, tileCountExt.y, 1.0f / tileCountExt.x, 1.0f / tileCountExt.y); EnsureComputeBuffer(ref computeBuffer, tileTypeCount * tileCountExt.x * tileCountExt.y, System.Runtime.InteropServices.Marshal.SizeOf()); EnsureComputeBuffer(ref argBuffer, tileTypeCount * 5, 4, ComputeBufferType.IndirectArguments); EnsureComputeBuffer(ref counterBuffer, tileTypeCount * 5, 4, ComputeBufferType.Raw); EnsureRenderTexture(ref tileRenderTexture, tileCount.x, tileCount.y); EnsureRenderTexture(ref tileRenderTextureExt, tileCountExt.x, tileCountExt.y); GenerateRandomTiles(); hasValidBuffer = false; ExpandTileTexture(); CopyToArgBuffer(); hasValidBuffer = true; } private void GenerateRandomTiles() { if (!oniTileComputeShader) return; int kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_RANDOM_KERNEL_NAME); oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); oniTileComputeShader.SetVector(ONITileShaderConstants.I_RandomSeed, randomSeed); oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount); oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize); oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTiles, tileRenderTexture); oniTileComputeShader.Dispatch(kernelID, Mathf.CeilToInt((float)tileCount.x / x), Mathf.CeilToInt((float)tileCount.y / y), 1); } private void ExpandTileTexture() { if (!oniTileComputeShader) return; int[] data = new int[counterBuffer.count]; for (int i = 0; i if (i % 5 == 0) { data[i] = 6; } else { data[i] = 0; } } counterBuffer.SetData(data); int kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_EXPAND_KERNEL_NAME); oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize); oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSizeExt, textureSizeExt); oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RandomTiles, tileRenderTexture); oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTilesExt, tileRenderTextureExt); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_TileData, computeBuffer); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_CounterBuffer, counterBuffer); oniTileComputeShader.Dispatch(kernelID, Mathf.CeilToInt((float)tileCountExt.x / x), Mathf.CeilToInt((float)tileCountExt.y / y), 1); } private void CopyToArgBuffer() { if (!oniTileComputeShader) return; int kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_COPY_KERNEL_NAME); oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_CounterBuffer, counterBuffer); oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_ArgBuffer, ArgBuffer); oniTileComputeShader.Dispatch(kernelID, Mathf.CeilToInt((float)(5*tileTypeCount) / x), 1, 1); } public Bounds GetBounds() { Vector3 start = tileStartPos; Vector2 totalSize = tileSize * tileCountExt; Vector3 size3D = new Vector3(totalSize.x, 0.0f, totalSize.y) + Vector3.one; Vector3 center = start + 0.5f * size3D; return new Bounds(center, size3D); } private void OnDestroy() { if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } if (argBuffer != null) { argBuffer.Release(); argBuffer = null; } if (tileRenderTexture != null) { RenderTexture.ReleaseTemporary(tileRenderTexture); tileRenderTexture = null; } if (tileRenderTextureExt != null) { RenderTexture.ReleaseTemporary(tileRenderTextureExt); tileRenderTextureExt = null; } } public class ONITileShaderConstants { public static readonly string S_RANDOM_KERNEL_NAME = \"RandomMain\"; public static readonly string S_EXPAND_KERNEL_NAME = \"ExpandMain\"; public static readonly string S_COPY_KERNEL_NAME = \"CopyMain\"; public static readonly int I_TextureSize = Shader.PropertyToID(\"_TextureSize\"); public static readonly int I_TextureSizeExt = Shader.PropertyToID(\"_TextureSizeExt\"); public static readonly int I_TileTypeCount = Shader.PropertyToID(\"_TileTypeCount\"); public static readonly int I_RandomSeed = Shader.PropertyToID(\"_RandomSeed\"); public static readonly int I_RandomTiles = Shader.PropertyToID(\"_RandomTiles\"); public static readonly int I_RW_RandomTiles = Shader.PropertyToID(\"_RW_RandomTiles\"); public static readonly int I_RW_RandomTilesExt = Shader.PropertyToID(\"_RW_RandomTilesExt\"); public static readonly int I_RW_TileData = Shader.PropertyToID(\"_RW_TileData\"); public static readonly int I_RW_ArgBuffer = Shader.PropertyToID(\"_RW_ArgBuffer\"); public static readonly int I_CounterBuffer = Shader.PropertyToID(\"_CounterBuffer\"); public static readonly int I_RW_CounterBuffer = Shader.PropertyToID(\"_RW_CounterBuffer\"); public static readonly int I_TileTexture = Shader.PropertyToID(\"_TileTexture\"); public static readonly int I_TileData = Shader.PropertyToID(\"_TileData\"); public static readonly int I_TileSize = Shader.PropertyToID(\"_TileSize\"); public static readonly int I_TileStartPos = Shader.PropertyToID(\"_TileStartPos\"); public static readonly int I_TileType = Shader.PropertyToID(\"_TileType\"); public static readonly int I_MainTexture = Shader.PropertyToID(\"_MainTexture\"); public static readonly int I_MainTexture_ST = Shader.PropertyToID(\"_MainTexture_ST\"); } } ONITileRendererFeature.cs æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç…§æœ¬å®£ç§‘ç½¢äº†ã€‚\nnamespace UnityEngine.Rendering.Universal { public class ONITileRendererFeature : ScriptableRendererFeature { [System.Serializable] public class ONITileSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingTransparents; public Shader drawShader; public Texture tileTexture; public bool IsValid() { return drawShader != null \u0026\u0026 tileTexture != null; } } private ONITileRenderPass oniTileRenderPass; public ONITileSettings oniTileSettings = new ONITileSettings(); public override void Create() { oniTileRenderPass = new ONITileRenderPass(oniTileSettings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { if (ONITileRenderManager.Instance != null \u0026\u0026 oniTileSettings.IsValid()) { oniTileRenderPass.Setup(ONITileRenderManager.Instance); renderer.EnqueuePass(oniTileRenderPass); } } } } ONITileRenderPass.cs DrawProceduralIndirectéœ€è¦çš„argumentä¸€å…±äº”ä¸ªuintçš„æ•°æ®ï¼Œåˆ†åˆ«ä¸ºæ¯ä¸ªå®ä¾‹çš„é¡¶ç‚¹æ•°ï¼Œå®ä¾‹æ•°ï¼Œé¡¶ç‚¹èµ·å§‹ä½ç½®ï¼Œå®ä¾‹èµ·å§‹ä½ç½®å’Œä¸€ä¸ªé¢„ç•™ç»™OpenGLçš„ç©ºä½ã€‚å¦‚æœæˆ‘ä»¬éœ€è¦ç”»åä¸‰ä¸ªQuadï¼Œæˆ‘ä»¬åªéœ€è¦ä¼ å…¥{6, 13, 0, 0, 0}å³å¯ã€‚i * 5 * 4æ„å‘³ç€å¯¹ç¬¬iä¸ªç“¦ç‰‡ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦è¯»å–i*5+0åˆ°i*5+4è¿™äº”ä¸ªuintçš„æ•°æ®ä½œä¸ºIndirectDrawçš„argumentï¼Œè€Œuintçš„å¤§å°ä¸º4ã€‚\nnamespace UnityEngine.Rendering.Universal { public class ONITileRenderPass : ScriptableRenderPass { private const string profilerTag = \"ONI Tile Render Pass\"; private ProfilingSampler oniTileRenderSampler = new ProfilingSampler(profilerTag); private ONITileRendererFeature.ONITileSettings settings; private ONITileRenderManager oniTileRenderManager; private Material drawMaterial; public ONITileRenderPass(ONITileRendererFeature.ONITileSettings settings) { this.settings = settings; renderPassEvent = settings.renderPassEvent; if (settings.drawShader != null) { drawMaterial = new Material(settings.drawShader); } } public void Setup(ONITileRenderManager oniTileRenderManager) { this.oniTileRenderManager = oniTileRenderManager; } private void DoONITileRendering(CommandBuffer cmd, Material material) { if(oniTileRenderManager.HasValidBuffer) { MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetBuffer(ONITileRenderManager.ONITileShaderConstants.I_TileData, oniTileRenderManager.ComputeBuffer); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TextureSizeExt, oniTileRenderManager.TextureSizeExt); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileStartPos, oniTileRenderManager.tileStartPos); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileSize, oniTileRenderManager.tileSize); mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_TileTexture, settings.tileTexture); mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_MainTexture_ST, oniTileRenderManager.mainTextureST); int mainTextureLength = oniTileRenderManager.mainTextures.Length; for (int i = 0; i if(mainTextureLength  0) { int mainTextureIndex = i % mainTextureLength; mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_MainTexture, oniTileRenderManager.mainTextures[mainTextureIndex]); } mpb.SetInt(ONITileRenderManager.ONITileShaderConstants.I_TileType, i); cmd.DrawProceduralIndirect(Matrix4x4.identity, material, 0, MeshTopology.Triangles, oniTileRenderManager.ArgBuffer, i * 5 * 4, properties:mpb); } } } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, oniTileRenderSampler)) { DoONITileRendering(cmd, drawMaterial); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } } } ONITileRender.hlsl è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“PerTilePropertyï¼Œéœ€è¦å’ŒCPUä»£ç é‡Œç»“æ„ä½“çš„æ•°æ®å¸ƒå±€ä¿æŒä¸€è‡´ã€‚äº‹å®ä¸Šï¼Œchannelå’Œrotationéƒ½åªæ˜¯0-3çš„intç±»å‹ï¼Œå ä¸¤ä¸ªbitï¼Œå¯ä»¥åˆå¹¶åœ¨ä¸€èµ·ï¼Œè¿™æ ·ä¸€ä¸ªPerTilePropertyåˆšå¥½æ˜¯å››ä¸ªå­—èŠ‚ï¼Œè¿™é‡Œå°±ä¸è¿™ä¹ˆåšäº†ã€‚è‡³äºä¸­é—´çš„å‡½æ•°ï¼Œæˆ‘çœŸçš„ä¸å¤ªæ“…é•¿å‘½åã€‚SortAndReturnIndexåœ¨æ’åºçš„åŒæ—¶ï¼Œè¿˜è¿”å›äº†æ¯ä¸ªå…ƒç´ åœ¨æ’åºåçš„åºå·ï¼Œæ–¹ä¾¿åé¢çš„å¤„ç†ã€‚ProcessSortedArrayç”¨äºå¤„ç†æ’åºï¼Œç”Ÿæˆå¹¶åˆ—ç¬¬äºŒåç¬¬ä¸‰åã€‚RotateAccordingToMinimumæ˜¯æ—‹è½¬å¤„ç†å¥½çš„æ’åºï¼Œä»è€Œé€šè¿‡GetModeè·å–æ¥ç¼ç±»å‹ã€‚æˆ‘å°½å¯èƒ½åœ°å‡å°‘äº†GetModeçš„åˆ†æ”¯æ•°é‡ï¼ˆå…¶å®æ˜¯ä¸€ç§äºŒè¿›åˆ¶+ä¸‰è¿›åˆ¶+ç‰¹ä¾‹ï¼‰ã€‚\n#ifndef ONI_TILE_RENDER_HLSL\r#define ONI_TILE_RENDER_HLSL\r#define ONI_TILE_TEXTURE_SIZE 8u\rstruct PerTileProperty\r{\ruint2 coord;\ruint mode;\ruint rotation;\ruint channel;\r};\rSamplerState sampler_LinearClamp;\rSamplerState sampler_PointClamp;\ruint _TileTypeCount;\rfloat4 _TextureSize;\rfloat4 _TextureSizeExt;\rfloat3 _TileStartPos;\rfloat2 _TileSize;\r// https://www.shadertoy.com/view/4djSRW\rfloat hash12(float2 p)\r{\rfloat3 p3 = frac(float3(p.xyx) * .1031);\rp3 += dot(p3, p3.yzx + 33.33);\rreturn frac((p3.x + p3.y) * p3.z);\r}\r// A sort4 function with 6 compares.\r// output: sorted array of input;\r// return: sorted index of elements from input;\ruint4 SortAndReturnIndex(float4 input, out uint output[4])\r{ uint3 ab_ac_ad = input.xxx ONITileComputeShader.compute è¿™é‡Œå®šä¹‰äº†ä¸‰ä¸ªKernelï¼Œåˆ†åˆ«ç”¨äºç”Ÿæˆéšæœºæ•°ï¼Œæ‰¾åˆ°æ‰€æœ‰åº”æ¸²æŸ“çš„ç“¦ç‰‡åŠå…¶å±æ€§ï¼ŒæŠŠByteAddressBufferçš„å†…å®¹å¤åˆ¶åˆ°IndirectArgumentBufferã€‚å®é™…è¿ç”¨çš„è¯æˆ‘ä»¬ä¸ä¼šåœ¨GPUé‡Œç”Ÿæˆç“¦ç‰‡ï¼Œç†è®ºä¸Šä¹Ÿæ²¡å¿…è¦åšä¸€æ¬¡Bufferæ•°æ®çš„å¤åˆ¶ã€‚ä½¿ç”¨äº†ByteAddressBuffer.InterlockedAddæ¥è·å–å½“å‰ç±»å‹çš„ç“¦ç‰‡éœ€è¦Instancingçš„æ•°é‡ï¼ˆå¹¶æ ¹æ®è¿™ä¸ªæ•°é‡å‚¨å­˜å¯¹åº”çš„PerTilePropertyï¼‰ã€‚\n#pragma kernel RandomMain\r#pragma kernel ExpandMain\r#pragma kernel CopyMain\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"ONITileRender.hlsl\"\rfloat2 _RandomSeed;\rTexture2D _RandomTiles;\rRWTexture2D _RW_RandomTiles;\rRWTexture2D _RW_RandomTilesExt;\rByteAddressBuffer _CounterBuffer;\rRWStructuredBuffer _RW_TileData;\rRWStructuredBuffer _RW_ArgBuffer;\rRWByteAddressBuffer _RW_CounterBuffer;\r[numthreads(8,8,1)]\rvoid RandomMain (uint3 dispatchThreadID : SV_DispatchThreadID)\r{\rif(any((float2)dispatchThreadID.xy = _TextureSize.xy)) return;\rfloat randomVal = hash12(dispatchThreadID.xy + _RandomSeed);\rfloat val = floor(randomVal * _TileTypeCount);\rfloat4 returnColor = float4(val, val, val, val);\r_RW_RandomTiles[dispatchThreadID.xy] = returnColor;\r}\rfloat LoadFromRandomTiles(Texture2D tex, int2 coord, float2 textureSize)\r{\rfloat2 tempCoord = clamp(float2(0.0f, 0.0f), textureSize-1.0f, coord);\rreturn tex.Load(uint3(tempCoord, 0)).r;\r}\r[numthreads(8, 8, 1)]\rvoid ExpandMain (uint3 dispatchThreadID : SV_DispatchThreadID)\r{\rif(any((float2)dispatchThreadID.xy = _TextureSizeExt.xy)) return;\rfloat tr = LoadFromRandomTiles(_RandomTiles, dispatchThreadID.xy / 2, _TextureSize.xy);\rfloat tl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 0)) / 2) - int2(1, 0), _TextureSize.xy);\rfloat br = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(0, 1)) / 2) - int2(0, 1), _TextureSize.xy);\rfloat bl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 1)) / 2) - int2(1, 1), _TextureSize.xy);\r// x y\r// w z\rfloat4 packedColor = float4(tl, tr, br, bl);\ruint output[4];\ruint4 sortedIndex = SortAndReturnIndex(packedColor, output);\ruint4 tempOutput = int4(output[0], output[1], output[2], output[3]);\ruint processedArray[4] = {sortedIndex.x, sortedIndex.y, sortedIndex.z, sortedIndex.w};\rProcessSortedArray(packedColor, tempOutput, processedArray);\ruint4 rotatedIndex = RotateAccordingToMinimum(processedArray, output);\ruint mode = GetMode(rotatedIndex.y, rotatedIndex.z, rotatedIndex.w);\rfor (float i = 0; i = 5 * _TileTypeCount) return;\ruint status;\r_RW_ArgBuffer[dispatchThreadID.x] = _CounterBuffer.Load(4 * dispatchThreadID.x, status);\r}\rONITileRenderShader.shader ç”±äºæˆ‘ä»¬ç”»çš„TileTextureæ˜¯ä»å·¦ä¸Šè§’å¼€å§‹çš„ï¼Œé‡‡æ ·çš„æ—¶å€™ä¼šç”¨åˆ°ä¸€äº›ç”¨1å‡å»uvçš„yå€¼ï¼Œæ—‹è½¬ä¹Ÿä¸ä¼šä¹˜ä¸Š-1ã€‚å‰é¢ç»™ç¼éš™ç”»ä¸Šç°è‰²çš„å¥½å¤„ä¹Ÿåœ¨è¿™é‡Œä½“ç°å‡ºæ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ä¸ªsmoothstepæ¥æ‰¾åˆ°ä¸€å®šç¨‹åº¦ä¸ŠæŠ—é”¯é½¿çš„æ¸²æŸ“åŒºåŸŸå’Œç¼éš™åŒºåŸŸã€‚æ­¤å¤–åœ¨å¼€å¯MSAAçš„æ—¶å€™å¯èƒ½ä¼šéœ€è¦æ ¹æ®uvæ˜¯å¦åœ¨01ä¹‹é—´å‰”é™¤æ‰å½“å‰åƒç´ ï¼Œä¸ç„¶ä¼šæœ‰å¥‡æ€ªçš„è¾¹ç¼˜é”¯é½¿ã€‚\nShader \"zznewclear13/ONITileRenderShader\"\r{\rHLSLINCLUDE\r#pragma enable_d3d11_debug_symbols\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"ONITileRender.hlsl\"\rStructuredBuffer _TileData;\rsampler2D _TileTexture;\rsampler2D _MainTexture;\rfloat4 _MainTexture_ST;\ruint _TileType;\rstruct Attributes\r{\ruint vertexID : SV_VERTEXID;\ruint instanceID : SV_INSTANCEID;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat3 positionWS : TEXCOORD1;\ruint mode : TEXCOORD2;\ruint rotation : TEXCOORD3;\ruint channel : TEXCOORD4;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rPerTileProperty prop = _TileData[input.instanceID + _TileType * _TextureSizeExt.x * _TextureSizeExt.y];\ruint vertexIndex = input.vertexID % 3;\ruint triangleID = input.vertexID / 3;\ruint uvX = ((vertexIndex\u00262)1)^triangleID;\ruint uvY = ((vertexIndex+vertexIndex1)\u00261)^triangleID;\rfloat2 uv = float2(uvX, uvY);\rfloat2 tileCoord = (prop.coord + 0.5f) * _TileSize;\rfloat3 center = float3(tileCoord.x, 0.0f, tileCoord.y) + _TileStartPos;\rfloat2 positionWSOffset = (uv - 0.5f) * _TileSize;\rfloat3 positionWS = center + float3(positionWSOffset.x, 0.0f, positionWSOffset.y);\routput.positionCS = mul(UNITY_MATRIX_VP, float4(positionWS, 1.0f));\routput.uv = uv;\routput.positionWS = positionWS;\routput.mode = prop.mode;\routput.rotation = prop.rotation;\routput.channel = prop.channel;\rreturn output;\r}\rfloat4 frag(Varyings input) : SV_TARGET\r{\rfloat2 uv = input.uv;\ruv.y = 1.0f - uv.y;\rint2 startCoord = int2(input.mode % ONI_TILE_TEXTURE_SIZE, input.mode / ONI_TILE_TEXTURE_SIZE);\rfloat2 startUV = (float2)(startCoord) / ONI_TILE_TEXTURE_SIZE;\rfloat rotationVal = (float)(input.rotation) * PI * 0.5f;\rfloat sinVal, cosVal;\rsincos(rotationVal, sinVal, cosVal);\rfloat2x2 rotationMat = float2x2(cosVal, sinVal, -sinVal, cosVal);\rfloat2 rotatedCoord = saturate(mul(rotationMat, uv - 0.5f) + 0.5f);\rfloat2 sampleCoord = startUV + rotatedCoord / ONI_TILE_TEXTURE_SIZE;\rsampleCoord.y = 1.0f - sampleCoord.y;\rfloat4 tileTexture = tex2D(_TileTexture, sampleCoord);\rfloat visColor = tileTexture[input.channel];\rfloat textureMask = smoothstep(0.25f, 1.0f, visColor);\rfloat gapMask = smoothstep(0.0f, 0.25f, visColor);\rfloat3 mainTex = tex2D(_MainTexture, input.positionWS.xz * _MainTexture_ST.xy + _MainTexture_ST.zw).rgb;\rmainTex = lerp(0.0f, mainTex, textureMask);\rfloat4 returnColor = float4(mainTex, gapMask);\rreturn returnColor;\r}\rENDHLSL\rSubShader\r{\rpass\r{\rTags {\"Queue\"=\"Transparent\" \"RenderType\"=\"Transparent\"}\rBlend SrcAlpha OneMinusSrcAlpha\rZTest LEqual\rZWrite Off\rHLSLPROGRAM\r#pragma vertex vert\r#pragma fragment frag\rENDHLSL }\r}\r}\ræ€»ç»“ æ€»ä¹‹å°±æ˜¯å¾ˆçˆ½å¾ˆå¿«ä¹å¾ˆæœ‰æˆå°±æ„Ÿã€‚å› ä¸ºç”»å›¾æ°´å¹³ä¸è¡Œï¼Œæœ‰çš„åœ°æ–¹çš„æ¥ç¼å·®äº†ä¸€ç‚¹ç‚¹ï¼Œä¹Ÿæ— æ‰€è°“äº†ã€‚ç”±äºä¹‹å‰è¢«HLSLé‡Œçš„Arrayå‘äº†å¾ˆå¤šæ¬¡ï¼Œè¿™é‡Œåˆ»æ„åœ°å»é™åˆ¶äº†Arrayçš„æ•°é‡ï¼Œåœ¨åŠ ä¸Šä¹‹å‰ç©äº†ä¸€ä¼šå›¾çµå®Œå¤‡ï¼Œè®¡ç®—Procedural Quadçš„UVå’Œé¡¶ç‚¹åæ ‡ç®€ç›´ä¸åœ¨è¯ä¸‹ï¼Œè¦æ˜¯ä»¥å‰è‚¯å®šå°±å†™ä¸€ä¸ªé•¿åº¦ä¸º6çš„arrayè¿›è¡Œé‡‡æ ·äº†ã€‚å¯¹ByteAddressBufferä¹Ÿæœ‰äº†æ–°çš„ç†è§£ï¼Œå±…ç„¶èƒ½ç”¨æ¥è®¡æ•°ï¼Œä»è€ŒDrawIndirectæˆ–è€…DispatchIndirectï¼Œä»¥å‰çš„è¯æˆ‘åªä¼šCopyCounterValueã€‚æœ€åçš„æœ€åä¹Ÿå¤¸ä¸€ä¸‹ç¼ºæ°§ï¼Œç”»é¢ç¡®å®å¾ˆè®©äººæœ‰æ·±åˆ»çš„å°è±¡ï¼Œæ¶²ä½“çš„æ¸²æŸ“æ›´æ˜¯ç‹¬æ ‘ä¸€å¸œï¼Œå°±æ˜¯ä¸€ä¸ªäººç©å¤ªæ¯ç‡¥äº†ã€‚\n","wordCount":"2044","inLanguage":"en","image":"https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/posts/images/TileRendering.jpg","datePublished":"2023-02-20T12:00:00+08:00","dateModified":"2023-02-20T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•</h1><div class=post-description>ä½¿ç”¨Compute Bufferä¸€æ¬¡æ€§ç»˜åˆ¶å¤šä¸ªç“¦ç‰‡.</div><div class=post-meta><span title="2023-02-20 12:00:00 +0800 CST">February 20, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/mimic-oxygen-not-includeds-tile-rendering.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/TileRendering.jpg alt="Tile Rendering Cover"><p>Tile Rendering Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•</div></summary><div class=inner><ul><li><a href=#%e7%bc%ba%e6%b0%a7%e7%9a%84%e7%93%a6%e7%89%87%e6%b8%b2%e6%9f%93%e7%9a%84%e7%89%b9%e7%82%b9 aria-label=ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹>ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹</a></li><li><a href=#%e6%a8%a1%e4%bb%bf%e8%bf%99%e7%a7%8d%e6%b8%b2%e6%9f%93%e7%9a%84%e6%80%9d%e8%b7%af aria-label=æ¨¡ä»¿è¿™ç§æ¸²æŸ“çš„æ€è·¯>æ¨¡ä»¿è¿™ç§æ¸²æŸ“çš„æ€è·¯</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81%e5%92%8c%e7%9b%b8%e5%85%b3%e7%9a%84%e8%a7%a3%e9%87%8a aria-label=å…·ä½“çš„ä»£ç å’Œç›¸å…³çš„è§£é‡Š>å…·ä½“çš„ä»£ç å’Œç›¸å…³çš„è§£é‡Š</a><ul><li><a href=#onitilerendermanagercs aria-label=ONITileRenderManager.cs>ONITileRenderManager.cs</a></li><li><a href=#onitilerendererfeaturecs aria-label=ONITileRendererFeature.cs>ONITileRendererFeature.cs</a></li><li><a href=#onitilerenderpasscs aria-label=ONITileRenderPass.cs>ONITileRenderPass.cs</a></li><li><a href=#onitilerenderhlsl aria-label=ONITileRender.hlsl>ONITileRender.hlsl</a></li><li><a href=#onitilecomputeshadercompute aria-label=ONITileComputeShader.compute>ONITileComputeShader.compute</a></li><li><a href=#onitilerendershadershader aria-label=ONITileRenderShader.shader>ONITileRenderShader.shader</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=æ€»ç»“>æ€»ç»“</a></li></ul></div></details></div><div class=post-content><h2 id=ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹>ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹<a hidden class=anchor aria-hidden=true href=#ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹>#</a></h2><p>å¾ˆå¯æƒœæˆ‘æ²¡æœ‰åœ¨RenderDocé‡Œæˆªåˆ°ç¼ºæ°§çš„å¸§ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯èƒ½ä»æ¸²æŸ“è¡¨ç°ä¸Šæ¥åˆ†æä¸€ä¸‹ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“çš„ç‰¹ç‚¹ã€‚ç»è¿‡ä¸€æ®µæ—¶é—´çš„æ¸¸ç©å’Œä»ä¸‹é¢è¿™å¼ å›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œç¼ºæ°§çš„æ¸¸æˆé€»è¾‘æ˜¯æŠŠæ•´ä¸ª2Dçš„åœ°å›¾åˆ†æˆä¸€ä¸ªä¸€ä¸ªæ ¼å­ï¼Œæ¯ä¸ªæ ¼å­è®°å½•äº†æ°”ä½“ã€æ¶²ä½“ã€å›ºä½“å’Œå»ºç­‘ç‰©çš„ä¿¡æ¯ã€‚æ°”ä½“åªæ˜¯ä¸€ä¸ªæ‰­æ›²çš„Shaderï¼Œæ¶²ä½“æ¸²æŸ“å’Œè®¡ç®—æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œæš‚æ—¶ä¸è€ƒè™‘ï¼Œå»ºç­‘ç‰©ä¸­çš„å¢™å’Œç®¡çº¿è™½ç„¶ä¹Ÿæœ‰ç¨‹åºåŒ–ç”Ÿæˆå†æ¸²æŸ“çš„æ•ˆæœï¼Œä½†å’Œåœºæ™¯ä¸­èµ„æºç±»å‹çš„å›ºä½“æ ¼å­æ˜¯ç¡¬ç›¸æ¥çš„å…³ç³»ï¼Œè¿™é‡Œä¹Ÿä¸è€ƒè™‘ã€‚æœ¬æ–‡çš„ç ”ç©¶é‡ç‚¹æ”¾åœ¨èµ„æºç±»å‹çš„å›ºä½“æ ¼å­çš„æ¸²æŸ“ä¸Šï¼ˆä¸åŒ…æ‹¬è¿™äº›æ ¼å­çš„ç¨‹åºåŒ–ç”Ÿæˆï¼‰ã€‚</p><p><img loading=lazy src=../images/OxygenNotIncluded.jpg#center alt="Oxygen Not Included"></p><p>èµ„æºç±»å‹çš„å›ºä½“æ ¼å­ï¼ˆè¿™é‡Œå°±ç®€ç§°ç“¦ç‰‡äº†ï¼‰çš„ç‰¹ç‚¹å¦‚ä¸‹ï¼š</p><ol><li>æœ‰å¤šç§ç±»å‹çš„ç“¦ç‰‡</li><li>ä»…åœ¨ä¸åŒç±»å‹çš„ç“¦ç‰‡ç›¸æ¥æ—¶ä¼šæœ‰é»‘è‰²çš„æè¾¹</li><li>ç“¦ç‰‡ä¹‹é—´ä¼šæœ‰æ’åºï¼Œä¼˜å…ˆçº§é«˜çš„ç“¦ç‰‡ä¼šæ›´å¤šåœ°æ‰©å¼ </li><li>ç“¦ç‰‡ä¹‹é—´é»‘è‰²çš„æè¾¹å‘ˆç°å‘¨æœŸæ€§è§„å¾‹</li></ol><h2 id=æ¨¡ä»¿è¿™ç§æ¸²æŸ“çš„æ€è·¯>æ¨¡ä»¿è¿™ç§æ¸²æŸ“çš„æ€è·¯<a hidden class=anchor aria-hidden=true href=#æ¨¡ä»¿è¿™ç§æ¸²æŸ“çš„æ€è·¯>#</a></h2><p>æœ€ç®€å•çš„æ€è·¯è‚¯å®šå°±æ˜¯åœ¨CPUä¸­è®¡ç®—æ¯ä¸€ä¸ªç“¦ç‰‡åº”å½“æœ‰çš„å½¢æ€ï¼Œç„¶åæ‰¾åˆ°å¯¹åº”çš„è´´å›¾ï¼ŒæŠŠç“¦ç‰‡åœ¨GPUä¸­ç»˜åˆ¶å‡ºæ¥äº†ã€‚ä½†æ˜¯è¿™æ ·å­åšçš„è¯å°±å¤±å»äº†æœ¬æ–‡çš„æ„ä¹‰ï¼Œä¹Ÿå¤ªè¿‡æ— è¶£äº†ã€‚æˆ‘æƒ³çš„æ˜¯å°½é‡å¤šåœ°ç”¨GPUæ¥è®¡ç®—æ¯ä¸ªç“¦ç‰‡çš„å½¢æ€ï¼ŒåŒæ—¶ä½¿ç”¨Instancingçš„æ–¹å¼ï¼Œç»˜åˆ¶æ¯ä¸€ä¸ªç“¦ç‰‡ã€‚</p><p>ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œä¸è§„åˆ™çš„ç“¦ç‰‡åº”å½“å¦‚ä½•ç»˜åˆ¶ã€‚å¦‚æœæ˜¯æ­£æ–¹å½¢çš„ç“¦ç‰‡ï¼Œèƒ½å¤Ÿå¾ˆè½»æ˜“åœ°ä½¿ç”¨ä¸€ä¸ªQuadå’Œçº¹ç†æ¥ç»˜åˆ¶ï¼Œä½†æ˜¯ä¸è§„åˆ™çš„ç“¦ç‰‡ï¼ŒåŠ¿å¿…ä¼šä½¿ç”¨é€æ˜åº¦æ··åˆçš„æ–¹å¼æ¥ç»˜åˆ¶ï¼Œè¿™æ—¶å¯¹åº”çš„æ¨¡å‹å°±ä¼šè¶…å‡ºç“¦ç‰‡çš„æ¸¸æˆé€»è¾‘ä¸Šçš„ä½ç½®ã€‚å› æ­¤ï¼Œæˆ‘æƒ³çš„æ˜¯ç»˜åˆ¶çš„Quadçš„æ•°é‡æ˜¯ç“¦ç‰‡å®é™…æ•°é‡çš„ä¸¤å€åŠ ä¸€ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p><p><img loading=lazy src=../images/TileRenderingDiagram.jpg#center alt="Tile Rendering Diagram"></p><p>åœ¨è¿™å¼ å›¾ä¸­ï¼ŒABCä»£è¡¨äº†ä¸åŒç±»å‹çš„ç“¦ç‰‡ï¼Œå·¦è¾¹æ˜¯æ¸¸æˆæ¸¸ç©çš„æ—¶å€™é€»è¾‘ä¸Šçš„ç“¦ç‰‡åˆ†å¸ƒï¼ŒABCæ˜¯ç›¸æ¥çš„ï¼Œå³è¾¹æ˜¯åœ¨æ¸²æŸ“çš„æ—¶å€™çš„ç“¦ç‰‡çš„åˆ†å¸ƒï¼Œåœ¨åŸæœ‰ç“¦ç‰‡ä¸­é—´æ’å…¥æ–°çš„ç“¦ç‰‡ï¼Œä¸“é—¨ç”¨æ¥æ¸²æŸ“æ¥ç¼ã€‚å¯¹äº2å·ç“¦ç‰‡ï¼Œå…¶å·¦ä¸Šè§’å³ä¸Šè§’å³ä¸‹è§’å·¦ä¸‹è§’ï¼ˆé¡ºæ—¶é’ˆçš„é¡ºåºï¼‰åˆ†åˆ«æ˜¯ABCCï¼Œå†³å®šäº†è¿™æ˜¯ä¸€å—ä¸‰å—ç›¸æ¥çš„ç“¦ç‰‡ï¼›å¯¹äº1å·ç“¦ç‰‡ï¼Œå¯¹åº”çš„ç¼–å·æ˜¯AACCï¼ˆé€šè¿‡ä¸€äº›å¯¹2å–æ¨¡å–ä½™çš„è¿ç®—å¯ä»¥æ’é™¤æ‰Bï¼‰ï¼Œå†³å®šäº†è¿™æ˜¯ä¸€å—ä¸¤å—ç›¸æ¥çš„ç“¦ç‰‡ï¼›è€Œå¯¹äº3å’Œ4å·ç“¦ç‰‡ï¼Œå…¶ç¼–å·ä¸ºCCCCï¼Œå†³å®šäº†è¿™ä¸¤å—æ˜¯æ²¡æœ‰æ¥ç¼çš„ç“¦ç‰‡ã€‚è¿™æ—¶æˆ‘ä»¬åˆè€ƒè™‘åˆ°äº†ç“¦ç‰‡ä¹‹é—´ä¼˜å…ˆçº§çš„å…³ç³»ï¼Œå‡è®¾C>B>Aï¼Œåˆ™AACCå’ŒAABBçš„æ¥ç¼åº”å½“æ˜¯ç›¸åŒçš„ï¼ŒABCCå’ŒBCCAæ˜¯æ—‹è½¬äº†ä¹ååº¦çš„å…³ç³»ã€‚è€ƒè™‘åˆ°å¿…å®šä¼šæœ‰ä¸€ä¸ªç“¦ç‰‡å¤„äºæœ€ä½ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬åªéœ€è¦å°†æœ€ä½ä¼˜å…ˆçº§çš„ç“¦ç‰‡å›ºå®šåˆ°å·¦ä¸Šè§’ï¼Œè®¨è®ºå‰©ä¸‹ä¸‰ä¸ªç“¦ç‰‡çš„ä¼˜å…ˆçº§ä¸é¡ºåºå³å¯ã€‚å¾ªç€è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰å¯èƒ½çš„æ¥ç¼ç”»åœ¨ä¸€å¼ å›¾ä¸Šï¼Œè¿™å¼ å›¾çš„RGBAé€šé“è®°å½•äº†ç“¦ç‰‡çš„ä¼˜å…ˆçº§ï¼ˆRä¼˜å…ˆçº§æœ€ä½ï¼ŒAä¼˜å…ˆçº§æœ€é«˜ï¼Œæ¥ç¼æˆ‘ä½¿ç”¨äº†ä¸€ä¸ªç»Ÿä¸€çš„ç°è‰²ä»¥ä¾¿åç»­æ¸²æŸ“ï¼‰ï¼Œå›¾ç‰‡å¦‚ä¸‹æ‰€ç¤ºï¼Œä¸ºäº†æ¯”è¾ƒå®¹æ˜“è§‚å¯Ÿï¼Œæˆ‘å¯¹Aé€šé“åšäº†åå‘ï¼Œä¸”å¯¹åº”çš„åœ¨ä¸‹æ–¹æ ‡æ³¨äº†ä¼˜å…ˆçº§é¡ºåºã€‚åŒæ—¶æˆ‘ä»¬è¿˜å¯¹åº”çš„å†™å¥½ä¸€ä¸ªå‡½æ•°ç”¨äºæ ¹æ®ä¼˜å…ˆçº§é¡ºåºæ‰¾åˆ°å¯¹åº”çš„æ¥ç¼ç±»å‹ä»è€Œåœ¨æ¸²æŸ“æ—¶æ‰¾åˆ°æ¥ç¼åœ¨å›¾ä¸Šçš„ä½ç½®ï¼ˆè§<a href=#ONITileRender.hlsl>ONITileRender.hlsl</a>ä¸­çš„<code>GetMode(uint a, uint b, uint c)</code>ï¼‰ã€‚</p><figure><img loading=lazy src=../images/TileTexture.png#center width=500px></figure><p>ç”±äºä¼šæœ‰ä¼˜å…ˆçº§çš„æ¯”è¾ƒï¼Œä¸å¯é¿å…åœ°ä¼šåœ¨GPUä¸­è¿›è¡Œæ’åºï¼Œä½¿ç”¨MergeSortçš„è¯ï¼Œ4ä¸ªå…ƒç´ ä¼šæœ‰5æ¬¡æ¯”è¾ƒï¼Œç”±äºæˆ‘ä»¬è¿˜éœ€è¦è·å¾—æ¯ä¸ªç“¦ç‰‡åœ¨å››ä¸ªç“¦ç‰‡ä¸­æ’åºçš„åºå·ï¼Œè¿™é‡Œå°±ç¡¬å†™äº†æ‰‹åŠ¨æ¯”è¾ƒï¼Œ6æ¬¡æ¯”è¾ƒå’ŒMergeSortçš„5æ¬¡ä¹Ÿå·®ä¸å¤ªå¤šã€‚æˆ‘ä»¬ç»˜åˆ¶çš„å›¾ä¸Šä»…æœ‰æœ€ä½ä¼˜å…ˆçº§ç“¦ç‰‡åœ¨å·¦ä¸Šè§’çš„æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦æ‰¾åˆ°æœ€ä½ä¼˜å…ˆçº§ç“¦ç‰‡åˆå§‹çš„åºå·ï¼Œä»è€Œåœ¨æ¸²æŸ“æ—¶æ—‹è½¬æˆ‘ä»¬çš„æ¥ç¼å›¾ï¼ˆè¿™é‡Œå°±ä½“ç°äº†æˆ‘ä»¬ä½¿ç”¨é¡ºæ—¶é’ˆç¼–å·çš„ä¼˜åŠ¿ï¼Œæ–¹ä¾¿äº†æ—‹è½¬çš„æ“ä½œï¼Œå¦‚æœæ˜¯å·¦ä¸Šè§’å³ä¸Šè§’å·¦ä¸‹è§’å³ä¸‹è§’çš„é¡ºåºï¼Œå°±ä¸å¤ªå¥½æ—‹è½¬äº†ï¼‰ã€‚</p><p>çŸ¥é“äº†æ¯ä¸€ä¸ªæ¥ç¼å›¾çš„æ—‹è½¬ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸ºå…¶æ¯ä¸€ä¸ªéƒ¨åˆ†ï¼ˆé€šé“ï¼‰æ¸²æŸ“ä¸åŒçš„è´´å›¾ã€‚è¿™é‡Œä½¿ç”¨äº†<code>DrawProceduralIndirect</code>æ¥è¿›è¡ŒInstancingçš„æ¸²æŸ“ï¼ŒDrawCallæ•°é‡ä¼šå’Œç“¦ç‰‡ç±»å‹çš„æ•°é‡ä¸€æ ·å¤šã€‚å¯¹äºä¸€ç§ç“¦ç‰‡ï¼Œéœ€è¦æ¸²æŸ“çš„æ€»ç“¦ç‰‡æ•°ç›¸å½“äºæ˜¯è¿™ç±»ç“¦ç‰‡çš„å›¾å½¢å‘å¤–æ‰©å±•ä¸€ä¸ªç“¦ç‰‡çš„æ•°é‡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ¤æ–­å·¦ä¸Šå³ä¸Šå³ä¸‹å·¦ä¸‹çš„ç“¦ç‰‡ç±»å‹æ¥è½»æ˜“åœ°åˆ¤æ–­å½“å‰ç“¦ç‰‡æ˜¯å¦åº”è¯¥å’Œç›®æ ‡ç“¦ç‰‡ç±»å‹ä¸€èµ·æ¸²æŸ“ã€‚æˆ‘ä»¬ä¼šä½¿ç”¨ä¸€ä¸ªæ•°æ®æ•°é‡ä¸º<code>ç“¦ç‰‡ç±»å‹æ•°é‡*(2*åœ°å›¾å®½é«˜+1)</code>çš„StructuredBufferæ¥ç»Ÿè®¡æ‰€æœ‰åº”å½“ç»˜åˆ¶çš„ç“¦ç‰‡ï¼ˆå®é™…ä½¿ç”¨çš„å¤§å°ä¸ä¼šå¤§äº<code>4*(2*åœ°å›¾å®½+1)*(2*åœ°å›¾é«˜+1)</code>ï¼‰ã€‚åŒæ—¶æˆ‘ä»¬ä¼šä½¿ç”¨ä¸€ä¸ªæ•°æ®æ•°é‡ä¸º<code>ç“¦ç‰‡ç±»å‹æ•°é‡*5</code>çš„ByteAddressBufferæ¥ç»Ÿè®¡æ¯ç§ç“¦ç‰‡ç±»å‹Instancingæ—¶éœ€è¦çš„å‚æ•°ã€‚</p><p>æœ¬æ–‡ä¸­çš„å²©çŸ³çš„2Dæ— ç¼è´´å›¾æ¥è‡ª<a href=https://opengameart.org/content/wall-grass-rock-stone-wood-and-dirt-480>OpenGameArt.org</a></p><h2 id=å…·ä½“çš„ä»£ç å’Œç›¸å…³çš„è§£é‡Š>å…·ä½“çš„ä»£ç å’Œç›¸å…³çš„è§£é‡Š<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„ä»£ç å’Œç›¸å…³çš„è§£é‡Š>#</a></h2><p>ç”±äºä¼šç”¨åˆ°CommandBufferè¿›è¡Œç“¦ç‰‡çš„ç»˜åˆ¶ï¼Œæˆ‘å°±æŠŠç›¸å…³çš„ä»£ç æ”¾åˆ°Universal RPçš„Packageé‡Œäº†ã€‚CPUä»£ç ï¼Œ<code>ONITileRenderManager.cs</code>æ”¾åœ¨<code>Packages/com.unity.render-pipelines.universal/Runtime/Overrides/</code>ä¸‹ï¼Œ<code>ONITileRendererFeature.cs</code>æ”¾åœ¨<code>Packages/com.unity.render-pipelines.universal/Runtime/RendererFeature/</code>ä¸‹ï¼Œ<code>ONITileRenderPass.cs</code>æ”¾åœ¨<code>Packages/com.unity.render-pipelines.universal/Runtime/Passes/</code>ä¸‹ï¼›GPUä»£ç ï¼Œ<code>ONITileRender.hlsl</code>ï¼Œ<code>ONITileComputeShader.compute</code>å’Œ<code>ONITileRenderShader.shader</code>æ”¾åœ¨<code>Packages/com.unity.render-pipelines.universal/Shaders/ONITile/</code>ä¸‹ã€‚</p><p><code>ONITileRenderManager</code>ç”¨äºåœ°å›¾çš„è®¾ç½®ã€è®¡ç®—å’ŒBufferçš„è·å–ã€‚<code>ONITileRendererFeature</code>å’Œ<code>ONITileRenderPass</code>ç”¨äºåœ¨Unity URPä¸­æ¸²æŸ“ç“¦ç‰‡ï¼Œ<code>ONITileComputeShader</code>ç”¨äºç“¦ç‰‡ç›¸å…³çš„è®¡ç®—ï¼Œ<code>ONITileRenderShader</code>ç”¨äºç“¦ç‰‡çš„æ¸²æŸ“ã€‚</p><h3 id=onitilerendermanagercs>ONITileRenderManager.cs<a hidden class=anchor aria-hidden=true href=#onitilerendermanagercs>#</a></h3><p>è¿™é‡Œå°¤å…¶éœ€è¦æ³¨æ„æ¯ä¸ªBufferçš„å¤§å°ã€‚åœ¨è¿™ä¸ªè„šæœ¬é‡Œä½¿ç”¨Compute Shaderåšäº†ä¸‰ä»¶äº‹ï¼š1. å¯¹åœ°å›¾æ¯ä¸€ä¸ªç‚¹ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ä½œä¸ºç“¦ç‰‡ç±»å‹ï¼›2. ä»åœ°å›¾ä¸­è®¡ç®—æ¯ä¸€ç§ç“¦ç‰‡ç±»å‹éœ€è¦ç»˜åˆ¶çš„æ•°é‡ã€ä½ç½®ã€è§£å°ç±»å‹ã€æ—‹è½¬å’Œåº”å½“é‡‡æ ·çš„é€šé“ï¼›3. æŠŠByteAddressBufferä¸­çš„æ•°æ®å¤åˆ¶åˆ°IndirectArgumentBufferé‡Œã€‚äº‹å®ä¸Šæˆ‘æ„Ÿè§‰<code>ComputeShader.Dispatch</code>åº”è¯¥åšæˆä¸€ä¸ªå¼‚æ­¥çš„æ–¹æ³•ï¼Œä¸è¿‡è¿™ä¸ªè°ƒç”¨é¢‘ç‡ä¸é«˜ï¼Œå°±è¿™æ ·å¥½äº†ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[ExecuteInEditMode]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileRenderManager</span> : MonoBehaviour
{
<span style=color:#a6e22e>    [HideInInspector]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ONITileRenderManager Instance { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }

    <span style=color:#66d9ef>public</span> ComputeShader oniTileComputeShader;
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> tileTypeCount = <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>public</span> Vector2Int tileCount = <span style=color:#66d9ef>new</span> Vector2Int(<span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>16</span>);
    <span style=color:#66d9ef>public</span> Vector2 tileSize = Vector2.one;
    <span style=color:#66d9ef>public</span> Vector3 tileStartPos;
    <span style=color:#66d9ef>public</span> Vector2 randomSeed;
    <span style=color:#66d9ef>public</span> Texture[] mainTextures = <span style=color:#66d9ef>new</span> Texture[] {};
    <span style=color:#66d9ef>public</span> Vector4 mainTextureST = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>);

    <span style=color:#66d9ef>private</span> Vector2Int tileCountExt;
    <span style=color:#66d9ef>public</span> Vector2Int TileCountExt { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> tileCountExt; } }
    <span style=color:#66d9ef>private</span> Vector4 textureSize;
    <span style=color:#66d9ef>public</span> Vector4 TextureSize { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> textureSize; } }
    <span style=color:#66d9ef>private</span> Vector4 textureSizeExt;
    <span style=color:#66d9ef>public</span> Vector4 TextureSizeExt { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> textureSizeExt; } }

    <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
    <span style=color:#66d9ef>public</span> ComputeBuffer ComputeBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> computeBuffer; } }
    <span style=color:#66d9ef>private</span> ComputeBuffer argBuffer;
    <span style=color:#66d9ef>public</span> ComputeBuffer ArgBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> argBuffer; } }
    <span style=color:#66d9ef>private</span> ComputeBuffer counterBuffer;
    <span style=color:#66d9ef>public</span> ComputeBuffer CounterBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> counterBuffer; } }
    <span style=color:#66d9ef>private</span> RenderTexture tileRenderTexture;
    <span style=color:#66d9ef>private</span> RenderTexture tileRenderTextureExt;

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> hasValidBuffer = <span style=color:#66d9ef>false</span>;
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> HasValidBuffer { <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> hasValidBuffer; } }

    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PerTileProperty</span>
    {
        <span style=color:#66d9ef>public</span> Vector2Int coord;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>uint</span> mode;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>uint</span> rotation;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>uint</span> channel;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRenderTexture(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height)
    {
        <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span> || rt.width != width || rt.height != height)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) RenderTexture.ReleaseTemporary(rt);

            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor(width, height, RenderTextureFormat.ARGBInt);
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
            rt = RenderTexture.GetTemporary(desc);
            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer cb, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride, ComputeBufferType cbt = ComputeBufferType.Append)
    {
        <span style=color:#66d9ef>if</span> (cb == <span style=color:#66d9ef>null</span> || cb.count != count || cb.stride != stride)
        {
            <span style=color:#66d9ef>if</span> (cb != <span style=color:#66d9ef>null</span>) cb.Release();

            cb = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, cbt);
        }
    }


    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
    {
        <span style=color:#66d9ef>if</span> (Instance != <span style=color:#66d9ef>null</span>)
        {
            enabled = <span style=color:#66d9ef>false</span>;
            Debug.LogError(<span style=color:#e6db74>&#34;An instance of ONITileRenderManager already exists.&#34;</span>);
        }
        <span style=color:#66d9ef>else</span>
        {
            Instance = <span style=color:#66d9ef>this</span>;
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
    {
        Instance = <span style=color:#66d9ef>null</span>;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnValidate()
    {
        tileTypeCount = Mathf.Max(<span style=color:#ae81ff>1</span>, tileTypeCount);
        tileCount.x = Mathf.Max(<span style=color:#ae81ff>1</span>, tileCount.x);
        tileCount.y = Mathf.Max(<span style=color:#ae81ff>1</span>, tileCount.y);
        tileCountExt = <span style=color:#66d9ef>new</span> Vector2Int(tileCount.x * <span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>, tileCount.y * <span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>);
        textureSize = <span style=color:#66d9ef>new</span> Vector4(tileCount.x, tileCount.y, <span style=color:#ae81ff>1.0f</span> / tileCount.x, <span style=color:#ae81ff>1.0f</span> / tileCount.y);
        textureSizeExt = <span style=color:#66d9ef>new</span> Vector4(tileCountExt.x, tileCountExt.y, <span style=color:#ae81ff>1.0f</span> / tileCountExt.x, <span style=color:#ae81ff>1.0f</span> / tileCountExt.y);

        EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> computeBuffer, tileTypeCount * tileCountExt.x * tileCountExt.y, System.Runtime.InteropServices.Marshal.SizeOf&lt;PerTileProperty&gt;());
        EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> argBuffer, tileTypeCount * <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, ComputeBufferType.IndirectArguments);
        EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> counterBuffer, tileTypeCount * <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, ComputeBufferType.Raw);
        EnsureRenderTexture(<span style=color:#66d9ef>ref</span> tileRenderTexture, tileCount.x, tileCount.y);
        EnsureRenderTexture(<span style=color:#66d9ef>ref</span> tileRenderTextureExt, tileCountExt.x, tileCountExt.y);

        GenerateRandomTiles();
        hasValidBuffer = <span style=color:#66d9ef>false</span>;
        ExpandTileTexture();
        CopyToArgBuffer();
        hasValidBuffer = <span style=color:#66d9ef>true</span>;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateRandomTiles()
    {
        <span style=color:#66d9ef>if</span> (!oniTileComputeShader) <span style=color:#66d9ef>return</span>;

        <span style=color:#66d9ef>int</span> kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_RANDOM_KERNEL_NAME);
        oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_RandomSeed, randomSeed);
        oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize);
        oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTiles, tileRenderTexture);
        oniTileComputeShader.Dispatch(kernelID,
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCount.x / x),
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCount.y / y),
                <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ExpandTileTexture()
    {
        <span style=color:#66d9ef>if</span> (!oniTileComputeShader) <span style=color:#66d9ef>return</span>;

        <span style=color:#66d9ef>int</span>[] data = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[counterBuffer.count];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; data.Length; i++)
        {
            <span style=color:#66d9ef>if</span> (i % <span style=color:#ae81ff>5</span> == <span style=color:#ae81ff>0</span>)
            {
                data[i] = <span style=color:#ae81ff>6</span>;
            }
            <span style=color:#66d9ef>else</span>
            {
                data[i] = <span style=color:#ae81ff>0</span>;
            }
        }
        counterBuffer.SetData(data);

        <span style=color:#66d9ef>int</span> kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_EXPAND_KERNEL_NAME);
        oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSize, textureSize);
        oniTileComputeShader.SetVector(ONITileShaderConstants.I_TextureSizeExt, textureSizeExt);
        oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RandomTiles, tileRenderTexture);
        oniTileComputeShader.SetTexture(kernelID, ONITileShaderConstants.I_RW_RandomTilesExt, tileRenderTextureExt);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_TileData, computeBuffer);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_CounterBuffer, counterBuffer);
        oniTileComputeShader.Dispatch(kernelID,
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCountExt.x / x),
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)tileCountExt.y / y),
                <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CopyToArgBuffer()
    {
        <span style=color:#66d9ef>if</span> (!oniTileComputeShader) <span style=color:#66d9ef>return</span>;

        <span style=color:#66d9ef>int</span> kernelID = oniTileComputeShader.FindKernel(ONITileShaderConstants.S_COPY_KERNEL_NAME);
        oniTileComputeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        oniTileComputeShader.SetInt(ONITileShaderConstants.I_TileTypeCount, tileTypeCount);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_CounterBuffer, counterBuffer);
        oniTileComputeShader.SetBuffer(kernelID, ONITileShaderConstants.I_RW_ArgBuffer, ArgBuffer);
        oniTileComputeShader.Dispatch(kernelID,
                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)(<span style=color:#ae81ff>5</span>*tileTypeCount) / x),
                <span style=color:#ae81ff>1</span>,
                <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>public</span> Bounds GetBounds()
    {
        Vector3 start = tileStartPos;
        Vector2 totalSize = tileSize * tileCountExt;
        Vector3 size3D = <span style=color:#66d9ef>new</span> Vector3(totalSize.x, <span style=color:#ae81ff>0.0f</span>, totalSize.y) + Vector3.one;
        Vector3 center = start + <span style=color:#ae81ff>0.5f</span> * size3D;
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Bounds(center, size3D);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
    {
        <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
        {
            computeBuffer.Release();
            computeBuffer = <span style=color:#66d9ef>null</span>;
        }

        <span style=color:#66d9ef>if</span> (argBuffer != <span style=color:#66d9ef>null</span>)
        {
            argBuffer.Release();
            argBuffer = <span style=color:#66d9ef>null</span>;
        }

        <span style=color:#66d9ef>if</span> (tileRenderTexture != <span style=color:#66d9ef>null</span>)
        {
            RenderTexture.ReleaseTemporary(tileRenderTexture);
            tileRenderTexture = <span style=color:#66d9ef>null</span>;
        }

        <span style=color:#66d9ef>if</span> (tileRenderTextureExt != <span style=color:#66d9ef>null</span>)
        {
            RenderTexture.ReleaseTemporary(tileRenderTextureExt);
            tileRenderTextureExt = <span style=color:#66d9ef>null</span>;
        }
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileShaderConstants</span>
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> S_RANDOM_KERNEL_NAME = <span style=color:#e6db74>&#34;RandomMain&#34;</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> S_EXPAND_KERNEL_NAME = <span style=color:#e6db74>&#34;ExpandMain&#34;</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> S_COPY_KERNEL_NAME = <span style=color:#e6db74>&#34;CopyMain&#34;</span>;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TextureSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TextureSizeExt = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSizeExt&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileTypeCount = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileTypeCount&#34;</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RandomSeed = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RandomSeed&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RandomTiles = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RandomTiles&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_RandomTiles = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_RandomTiles&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_RandomTilesExt = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_RandomTilesExt&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_TileData = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_TileData&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_ArgBuffer = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_ArgBuffer&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_CounterBuffer = Shader.PropertyToID(<span style=color:#e6db74>&#34;_CounterBuffer&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_RW_CounterBuffer = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_CounterBuffer&#34;</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileTexture&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileData = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileData&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileSize&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileStartPos = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileStartPos&#34;</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_TileType = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TileType&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_MainTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_MainTexture&#34;</span>);
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> I_MainTexture_ST = Shader.PropertyToID(<span style=color:#e6db74>&#34;_MainTexture_ST&#34;</span>);
    }
}
</code></pre></div><h3 id=onitilerendererfeaturecs>ONITileRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#onitilerendererfeaturecs>#</a></h3><p>æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç…§æœ¬å®£ç§‘ç½¢äº†ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingTransparents;
            <span style=color:#66d9ef>public</span> Shader drawShader;
            <span style=color:#66d9ef>public</span> Texture tileTexture;

            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsValid()
            {
                <span style=color:#66d9ef>return</span> drawShader != <span style=color:#66d9ef>null</span> &amp;&amp; tileTexture != <span style=color:#66d9ef>null</span>;
            }
        }

        <span style=color:#66d9ef>private</span> ONITileRenderPass oniTileRenderPass;
        <span style=color:#66d9ef>public</span> ONITileSettings oniTileSettings = <span style=color:#66d9ef>new</span> ONITileSettings();

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            oniTileRenderPass = <span style=color:#66d9ef>new</span> ONITileRenderPass(oniTileSettings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            <span style=color:#66d9ef>if</span> (ONITileRenderManager.Instance != <span style=color:#66d9ef>null</span>
                &amp;&amp; oniTileSettings.IsValid())
            {
                oniTileRenderPass.Setup(ONITileRenderManager.Instance);
                renderer.EnqueuePass(oniTileRenderPass);
            }
        }
    }
}
</code></pre></div><h3 id=onitilerenderpasscs>ONITileRenderPass.cs<a hidden class=anchor aria-hidden=true href=#onitilerenderpasscs>#</a></h3><p><code>DrawProceduralIndirect</code>éœ€è¦çš„argumentä¸€å…±äº”ä¸ªuintçš„æ•°æ®ï¼Œåˆ†åˆ«ä¸ºæ¯ä¸ªå®ä¾‹çš„é¡¶ç‚¹æ•°ï¼Œå®ä¾‹æ•°ï¼Œé¡¶ç‚¹èµ·å§‹ä½ç½®ï¼Œå®ä¾‹èµ·å§‹ä½ç½®å’Œä¸€ä¸ªé¢„ç•™ç»™OpenGLçš„ç©ºä½ã€‚å¦‚æœæˆ‘ä»¬éœ€è¦ç”»åä¸‰ä¸ªQuadï¼Œæˆ‘ä»¬åªéœ€è¦ä¼ å…¥<code>{6, 13, 0, 0, 0}</code>å³å¯ã€‚<code>i * 5 * 4</code>æ„å‘³ç€å¯¹ç¬¬iä¸ªç“¦ç‰‡ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦è¯»å–<code>i*5+0</code>åˆ°<code>i*5+4</code>è¿™äº”ä¸ªuintçš„æ•°æ®ä½œä¸ºIndirectDrawçš„argumentï¼Œè€Œuintçš„å¤§å°ä¸º4ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ONITileRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;ONI Tile Render Pass&#34;</span>;
        <span style=color:#66d9ef>private</span> ProfilingSampler oniTileRenderSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
        <span style=color:#66d9ef>private</span> ONITileRendererFeature.ONITileSettings settings;
        <span style=color:#66d9ef>private</span> ONITileRenderManager oniTileRenderManager;
        <span style=color:#66d9ef>private</span> Material drawMaterial;

        <span style=color:#66d9ef>public</span> ONITileRenderPass(ONITileRendererFeature.ONITileSettings settings)
        {
            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            <span style=color:#66d9ef>if</span> (settings.drawShader != <span style=color:#66d9ef>null</span>)
            {
                drawMaterial = <span style=color:#66d9ef>new</span> Material(settings.drawShader);
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(ONITileRenderManager oniTileRenderManager)
        {
            <span style=color:#66d9ef>this</span>.oniTileRenderManager = oniTileRenderManager;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoONITileRendering(CommandBuffer cmd, Material material)
        {
            <span style=color:#66d9ef>if</span>(oniTileRenderManager.HasValidBuffer)
            {
                MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
                mpb.SetBuffer(ONITileRenderManager.ONITileShaderConstants.I_TileData, oniTileRenderManager.ComputeBuffer);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TextureSizeExt, oniTileRenderManager.TextureSizeExt);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileStartPos, oniTileRenderManager.tileStartPos);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_TileSize, oniTileRenderManager.tileSize);
                mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_TileTexture, settings.tileTexture);
                mpb.SetVector(ONITileRenderManager.ONITileShaderConstants.I_MainTexture_ST, oniTileRenderManager.mainTextureST);

                <span style=color:#66d9ef>int</span> mainTextureLength = oniTileRenderManager.mainTextures.Length;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; oniTileRenderManager.tileTypeCount; i++)
                {
                    <span style=color:#66d9ef>if</span>(mainTextureLength &gt; <span style=color:#ae81ff>0</span>)
                    {
                        <span style=color:#66d9ef>int</span> mainTextureIndex = i % mainTextureLength;
                        mpb.SetTexture(ONITileRenderManager.ONITileShaderConstants.I_MainTexture, oniTileRenderManager.mainTextures[mainTextureIndex]);
                    }

                    mpb.SetInt(ONITileRenderManager.ONITileShaderConstants.I_TileType, i);
                    cmd.DrawProceduralIndirect(Matrix4x4.identity, material, <span style=color:#ae81ff>0</span>, MeshTopology.Triangles,
                                                oniTileRenderManager.ArgBuffer, i * <span style=color:#ae81ff>5</span> * <span style=color:#ae81ff>4</span>, properties:mpb);
                }   
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, oniTileRenderSampler))
            {
                DoONITileRendering(cmd, drawMaterial);
            }

            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=onitilerenderhlsl>ONITileRender.hlsl<a hidden class=anchor aria-hidden=true href=#onitilerenderhlsl>#</a></h3><p>è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“<code>PerTileProperty</code>ï¼Œéœ€è¦å’ŒCPUä»£ç é‡Œç»“æ„ä½“çš„æ•°æ®å¸ƒå±€ä¿æŒä¸€è‡´ã€‚äº‹å®ä¸Šï¼Œchannelå’Œrotationéƒ½åªæ˜¯0-3çš„intç±»å‹ï¼Œå ä¸¤ä¸ªbitï¼Œå¯ä»¥åˆå¹¶åœ¨ä¸€èµ·ï¼Œè¿™æ ·ä¸€ä¸ªPerTilePropertyåˆšå¥½æ˜¯å››ä¸ªå­—èŠ‚ï¼Œè¿™é‡Œå°±ä¸è¿™ä¹ˆåšäº†ã€‚è‡³äºä¸­é—´çš„å‡½æ•°ï¼Œæˆ‘çœŸçš„ä¸å¤ªæ“…é•¿å‘½åã€‚<code>SortAndReturnIndex</code>åœ¨æ’åºçš„åŒæ—¶ï¼Œè¿˜è¿”å›äº†æ¯ä¸ªå…ƒç´ åœ¨æ’åºåçš„åºå·ï¼Œæ–¹ä¾¿åé¢çš„å¤„ç†ã€‚<code>ProcessSortedArray</code>ç”¨äºå¤„ç†æ’åºï¼Œç”Ÿæˆå¹¶åˆ—ç¬¬äºŒåç¬¬ä¸‰åã€‚<code>RotateAccordingToMinimum</code>æ˜¯æ—‹è½¬å¤„ç†å¥½çš„æ’åºï¼Œä»è€Œé€šè¿‡<code>GetMode</code>è·å–æ¥ç¼ç±»å‹ã€‚æˆ‘å°½å¯èƒ½åœ°å‡å°‘äº†<code>GetMode</code>çš„åˆ†æ”¯æ•°é‡ï¼ˆå…¶å®æ˜¯ä¸€ç§äºŒè¿›åˆ¶+ä¸‰è¿›åˆ¶+ç‰¹ä¾‹ï¼‰ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#ifndef ONI_TILE_RENDER_HLSL
#define ONI_TILE_RENDER_HLSL

#define ONI_TILE_TEXTURE_SIZE 8u

struct PerTileProperty
{
    uint2 coord;
    uint mode;
    uint rotation;
    uint channel;
};

SamplerState sampler_LinearClamp;
SamplerState sampler_PointClamp;
uint _TileTypeCount;
float4 _TextureSize;
float4 _TextureSizeExt;
float3 _TileStartPos;
float2 _TileSize;

// https://www.shadertoy.com/view/4djSRW
float hash12(float2 p)
{
    float3 p3  = frac(float3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

// A sort4 function with 6 compares.
// output: sorted array of input;
// return: sorted index of elements from input;
uint4 SortAndReturnIndex(float4 input, out uint output[4])
{  
    uint3 ab_ac_ad = input.xxx &lt;= input.yzw ? 0 : 1;
    uint3 bc_bd_cd = input.yyz &lt;= input.zww ? 0 : 1;
    uint indexA = ab_ac_ad.x + ab_ac_ad.y + ab_ac_ad.z;
    uint indexB = 1 - ab_ac_ad.x + bc_bd_cd.x + bc_bd_cd.y;
    uint indexC = 2 - ab_ac_ad.y - bc_bd_cd.x + bc_bd_cd.z;
    uint indexD = 3 - ab_ac_ad.z - bc_bd_cd.y - bc_bd_cd.z;
    
    output[indexA] = 0;
    output[indexB] = 1;
    output[indexC] = 2;
    output[indexD] = 3;

    return uint4(indexA, indexB, indexC, indexD);
}

// Input numbers might have equal elements, adjust sorted index based on that.
void ProcessSortedArray(float4 input, uint4 output, inout uint processedArray[4])
{
    if(input[output.x] == input[output.y])
    {
        processedArray[output.y] -= 1;
        processedArray[output.z] -= 1;
        processedArray[output.w] -= 1;
    }
    if(input[output.y] == input[output.z])
    {
        processedArray[output.z] -= 1;
        processedArray[output.w] -= 1;
    }
    if(input[output.z] == input[output.w])
    {
        processedArray[output.w] -= 1;
    }
}

// Rotate processed array according to the index of minimum element.
uint4 RotateAccordingToMinimum(uint processedArray[4], uint sortedArray[4])
{
    uint minIndex = sortedArray[0];
    uint rotateX = processedArray[(0+minIndex)%4];
    uint rotateY = processedArray[(1+minIndex)%4];
    uint rotateZ = processedArray[(2+minIndex)%4];
    uint rotateW = processedArray[(3+minIndex)%4];
    return uint4(rotateX, rotateY, rotateZ, rotateW);
}

// Get mode based on &quot;sorted-processed-rotated&quot; result, mode is used to sample tile texture later.
// 0 a
// c b
uint GetMode(uint a, uint b, uint c)
{
    if(a==0)
    {
        if(b==0) return c==0 ? 0 : 1;
        if(b==1) return c+2;
        if(b==2) return 5;
    }

    if(a==1)
    {
        return b==3 ? 16 : c+b*3+6;
    }

    if(a==2)
    {
        if(b==0) return 17;
        if(b==1) return c+18;
        if(b==2) return 22;
        if(b==3) return 23;
    }

    if(a==3)
    {
        return b==1 ? 24 : 25;
    }

    return 0;
}

#endif
</code></pre><h3 id=onitilecomputeshadercompute>ONITileComputeShader.compute<a hidden class=anchor aria-hidden=true href=#onitilecomputeshadercompute>#</a></h3><p>è¿™é‡Œå®šä¹‰äº†ä¸‰ä¸ªKernelï¼Œåˆ†åˆ«ç”¨äºç”Ÿæˆéšæœºæ•°ï¼Œæ‰¾åˆ°æ‰€æœ‰åº”æ¸²æŸ“çš„ç“¦ç‰‡åŠå…¶å±æ€§ï¼ŒæŠŠByteAddressBufferçš„å†…å®¹å¤åˆ¶åˆ°IndirectArgumentBufferã€‚å®é™…è¿ç”¨çš„è¯æˆ‘ä»¬ä¸ä¼šåœ¨GPUé‡Œç”Ÿæˆç“¦ç‰‡ï¼Œç†è®ºä¸Šä¹Ÿæ²¡å¿…è¦åšä¸€æ¬¡Bufferæ•°æ®çš„å¤åˆ¶ã€‚ä½¿ç”¨äº†<code>ByteAddressBuffer.InterlockedAdd</code>æ¥è·å–å½“å‰ç±»å‹çš„ç“¦ç‰‡éœ€è¦Instancingçš„æ•°é‡ï¼ˆå¹¶æ ¹æ®è¿™ä¸ªæ•°é‡å‚¨å­˜å¯¹åº”çš„PerTilePropertyï¼‰ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel RandomMain
#pragma kernel ExpandMain
#pragma kernel CopyMain

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
#include &quot;ONITileRender.hlsl&quot;

float2 _RandomSeed;

Texture2D&lt;float4&gt; _RandomTiles;
RWTexture2D&lt;float4&gt; _RW_RandomTiles;
RWTexture2D&lt;float4&gt; _RW_RandomTilesExt;

ByteAddressBuffer _CounterBuffer;
RWStructuredBuffer&lt;PerTileProperty&gt; _RW_TileData;
RWStructuredBuffer&lt;uint&gt; _RW_ArgBuffer;
RWByteAddressBuffer _RW_CounterBuffer;

[numthreads(8,8,1)]
void RandomMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if(any((float2)dispatchThreadID.xy &gt;= _TextureSize.xy)) return;

    float randomVal = hash12(dispatchThreadID.xy + _RandomSeed);
    float val = floor(randomVal * _TileTypeCount);

    float4 returnColor = float4(val, val, val, val);
    _RW_RandomTiles[dispatchThreadID.xy] = returnColor;
}

float LoadFromRandomTiles(Texture2D&lt;float4&gt; tex, int2 coord, float2 textureSize)
{
    float2 tempCoord = clamp(float2(0.0f, 0.0f), textureSize-1.0f, coord);
    return tex.Load(uint3(tempCoord, 0)).r;
}

[numthreads(8, 8, 1)]
void ExpandMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if(any((float2)dispatchThreadID.xy &gt;= _TextureSizeExt.xy)) return;

    float tr = LoadFromRandomTiles(_RandomTiles, dispatchThreadID.xy / 2, _TextureSize.xy);
    float tl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 0)) / 2) - int2(1, 0), _TextureSize.xy);
    float br = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(0, 1)) / 2) - int2(0, 1), _TextureSize.xy);
    float bl = LoadFromRandomTiles(_RandomTiles, (int2)((dispatchThreadID.xy+uint2(1, 1)) / 2) - int2(1, 1), _TextureSize.xy);
    
    // x y
    // w z
    float4 packedColor = float4(tl, tr, br, bl);
    uint output[4];
    uint4 sortedIndex = SortAndReturnIndex(packedColor, output);
    uint4 tempOutput = int4(output[0], output[1], output[2], output[3]);

    uint processedArray[4] = {sortedIndex.x, sortedIndex.y, sortedIndex.z, sortedIndex.w};
    ProcessSortedArray(packedColor, tempOutput, processedArray);
    uint4 rotatedIndex = RotateAccordingToMinimum(processedArray, output);
    uint mode = GetMode(rotatedIndex.y, rotatedIndex.z, rotatedIndex.w);

    for (float i = 0; i &lt; (float)_TileTypeCount; i++)
    {
        bool shouldRender = false;
        int channel = 3;
        if(bl == i)
        {
            shouldRender = true;
            channel = processedArray[3];
        }

        if(br == i)
        {
            shouldRender = true;
            channel = processedArray[2];
        }

        if(tr == i)
        {
            shouldRender = true;
            channel = processedArray[1];
        }

        if(tl == i)
        {
            shouldRender = true;
            channel = processedArray[0];
        }

        if(shouldRender)
        {
            uint totalCount;
            _RW_CounterBuffer.InterlockedAdd(4 + i * 5 * 4, 1, totalCount);
            PerTileProperty prop = (PerTileProperty)0;
            prop.coord = dispatchThreadID.xy;
            prop.mode = mode;
            prop.rotation = tempOutput.x;
            prop.channel = channel;
            _RW_TileData[totalCount + i * _TextureSizeExt.x * _TextureSizeExt.y] = prop;
        }
    }

    _RW_RandomTilesExt[dispatchThreadID.xy] = float4(mode, tempOutput.x, 0.0f, 1.0f);
}

[numthreads(16, 1, 1)]
void CopyMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    if(dispatchThreadID.x &gt;= 5 * _TileTypeCount) return;
    uint status;
    _RW_ArgBuffer[dispatchThreadID.x] = _CounterBuffer.Load(4 * dispatchThreadID.x, status);
}
</code></pre><h3 id=onitilerendershadershader>ONITileRenderShader.shader<a hidden class=anchor aria-hidden=true href=#onitilerendershadershader>#</a></h3><p>ç”±äºæˆ‘ä»¬ç”»çš„TileTextureæ˜¯ä»å·¦ä¸Šè§’å¼€å§‹çš„ï¼Œé‡‡æ ·çš„æ—¶å€™ä¼šç”¨åˆ°ä¸€äº›ç”¨1å‡å»uvçš„yå€¼ï¼Œæ—‹è½¬ä¹Ÿä¸ä¼šä¹˜ä¸Š-1ã€‚å‰é¢ç»™ç¼éš™ç”»ä¸Šç°è‰²çš„å¥½å¤„ä¹Ÿåœ¨è¿™é‡Œä½“ç°å‡ºæ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸¤ä¸ª<code>smoothstep</code>æ¥æ‰¾åˆ°ä¸€å®šç¨‹åº¦ä¸ŠæŠ—é”¯é½¿çš„æ¸²æŸ“åŒºåŸŸå’Œç¼éš™åŒºåŸŸã€‚æ­¤å¤–åœ¨å¼€å¯MSAAçš„æ—¶å€™å¯èƒ½ä¼šéœ€è¦æ ¹æ®uvæ˜¯å¦åœ¨01ä¹‹é—´å‰”é™¤æ‰å½“å‰åƒç´ ï¼Œä¸ç„¶ä¼šæœ‰å¥‡æ€ªçš„è¾¹ç¼˜é”¯é½¿ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/ONITileRenderShader&quot;
{
    HLSLINCLUDE

    #pragma enable_d3d11_debug_symbols
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;ONITileRender.hlsl&quot;

    StructuredBuffer&lt;PerTileProperty&gt; _TileData;
    sampler2D _TileTexture;
    sampler2D _MainTexture;
    float4 _MainTexture_ST;
    uint _TileType;

    struct Attributes
    {
        uint vertexID       : SV_VERTEXID;
        uint instanceID     : SV_INSTANCEID;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float3 positionWS   : TEXCOORD1;
        uint mode           : TEXCOORD2;
        uint rotation       : TEXCOORD3;
        uint channel        : TEXCOORD4;
    };

    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;

        PerTileProperty prop = _TileData[input.instanceID + _TileType * _TextureSizeExt.x * _TextureSizeExt.y];

        uint vertexIndex = input.vertexID % 3;
        uint triangleID = input.vertexID / 3;
        uint uvX = ((vertexIndex&amp;2)&gt;&gt;1)^triangleID;
        uint uvY = ((vertexIndex+vertexIndex&gt;&gt;1)&amp;1)^triangleID;
        float2 uv = float2(uvX, uvY);

        float2 tileCoord = (prop.coord + 0.5f) * _TileSize;
        float3 center = float3(tileCoord.x, 0.0f, tileCoord.y) + _TileStartPos;
        float2 positionWSOffset = (uv - 0.5f) * _TileSize;
        float3 positionWS = center + float3(positionWSOffset.x, 0.0f, positionWSOffset.y);

        output.positionCS = mul(UNITY_MATRIX_VP, float4(positionWS, 1.0f));
        output.uv = uv;
        output.positionWS = positionWS;
        output.mode = prop.mode;
        output.rotation = prop.rotation;
        output.channel = prop.channel;
        return output;
    }

    float4 frag(Varyings input) : SV_TARGET
    {
        float2 uv = input.uv;
        uv.y = 1.0f - uv.y;

        int2 startCoord = int2(input.mode % ONI_TILE_TEXTURE_SIZE, input.mode / ONI_TILE_TEXTURE_SIZE);
        float2 startUV = (float2)(startCoord) / ONI_TILE_TEXTURE_SIZE;

        float rotationVal = (float)(input.rotation) * PI * 0.5f;
        float sinVal, cosVal;
        sincos(rotationVal, sinVal, cosVal);
        float2x2 rotationMat = float2x2(cosVal, sinVal, -sinVal, cosVal);
        float2 rotatedCoord = saturate(mul(rotationMat, uv - 0.5f) + 0.5f);
        float2 sampleCoord = startUV + rotatedCoord / ONI_TILE_TEXTURE_SIZE;
        sampleCoord.y = 1.0f - sampleCoord.y;

        float4 tileTexture = tex2D(_TileTexture, sampleCoord);
        float visColor = tileTexture[input.channel];

        float textureMask = smoothstep(0.25f, 1.0f, visColor);
        float gapMask = smoothstep(0.0f, 0.25f, visColor);

        float3 mainTex = tex2D(_MainTexture, input.positionWS.xz * _MainTexture_ST.xy + _MainTexture_ST.zw).rgb;
        mainTex = lerp(0.0f, mainTex, textureMask);
        float4 returnColor = float4(mainTex, gapMask);

        return returnColor;
    }

    ENDHLSL

    SubShader
    {
        pass
        {
            Tags {&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot;}
            Blend SrcAlpha OneMinusSrcAlpha
            ZTest LEqual
            ZWrite Off
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL       
        }
    }
}
</code></pre><h2 id=æ€»ç»“>æ€»ç»“<a hidden class=anchor aria-hidden=true href=#æ€»ç»“>#</a></h2><p>æ€»ä¹‹å°±æ˜¯å¾ˆçˆ½å¾ˆå¿«ä¹å¾ˆæœ‰æˆå°±æ„Ÿã€‚å› ä¸ºç”»å›¾æ°´å¹³ä¸è¡Œï¼Œæœ‰çš„åœ°æ–¹çš„æ¥ç¼å·®äº†ä¸€ç‚¹ç‚¹ï¼Œä¹Ÿæ— æ‰€è°“äº†ã€‚ç”±äºä¹‹å‰è¢«HLSLé‡Œçš„Arrayå‘äº†å¾ˆå¤šæ¬¡ï¼Œè¿™é‡Œåˆ»æ„åœ°å»é™åˆ¶äº†Arrayçš„æ•°é‡ï¼Œåœ¨åŠ ä¸Šä¹‹å‰ç©äº†ä¸€ä¼šå›¾çµå®Œå¤‡ï¼Œè®¡ç®—Procedural Quadçš„UVå’Œé¡¶ç‚¹åæ ‡ç®€ç›´ä¸åœ¨è¯ä¸‹ï¼Œè¦æ˜¯ä»¥å‰è‚¯å®šå°±å†™ä¸€ä¸ªé•¿åº¦ä¸º6çš„arrayè¿›è¡Œé‡‡æ ·äº†ã€‚å¯¹ByteAddressBufferä¹Ÿæœ‰äº†æ–°çš„ç†è§£ï¼Œå±…ç„¶èƒ½ç”¨æ¥è®¡æ•°ï¼Œä»è€ŒDrawIndirectæˆ–è€…DispatchIndirectï¼Œä»¥å‰çš„è¯æˆ‘åªä¼šCopyCounterValueã€‚æœ€åçš„æœ€åä¹Ÿå¤¸ä¸€ä¸‹ç¼ºæ°§ï¼Œç”»é¢ç¡®å®å¾ˆè®©äººæœ‰æ·±åˆ»çš„å°è±¡ï¼Œæ¶²ä½“çš„æ¸²æŸ“æ›´æ˜¯ç‹¬æ ‘ä¸€å¸œï¼Œå°±æ˜¯ä¸€ä¸ªäººç©å¤ªæ¯ç‡¥äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/tile-rendering/>Tile Rendering</a></li><li><a href=https://zznewclear13.github.io/tags/procedural/>Procedural</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><span class=title>Â« Prev</span><br><span>å†è®®é«˜æ–¯æ¨¡ç³Š</span></a>
<a class=next href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-ray-marching/><span class=title>Next Â»</span><br><span>ä½¿ç”¨Ray Marchingæ¥æ¸²æŸ“ä½“ç§¯é›¾</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>