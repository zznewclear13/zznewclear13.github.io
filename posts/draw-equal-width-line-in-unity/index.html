<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在Unity中绘制等宽线条 | ZZNEWCLEAR13</title>
<meta name=keywords content="Space Transformation,Anti-Aliasing"><meta name=description content="在Unity世界空间中画一条等宽且抗锯齿的直线."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="在Unity中绘制等宽线条"><meta property="og:description" content="在Unity世界空间中画一条等宽且抗锯齿的直线."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/posts/images/EqualWidthLine.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-02T17:00:00+08:00"><meta property="article:modified_time" content="2021-12-02T17:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/posts/images/EqualWidthLine.jpg"><meta name=twitter:title content="在Unity中绘制等宽线条"><meta name=twitter:description content="在Unity世界空间中画一条等宽且抗锯齿的直线."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在Unity中绘制等宽线条","item":"https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在Unity中绘制等宽线条","name":"在Unity中绘制等宽线条","description":"在Unity世界空间中画一条等宽且抗锯齿的直线.","keywords":["Space Transformation","Anti-Aliasing"],"articleBody":"动机 直接动机是想要在unity中制作一个描边效果。对于卡通渲染的描边效果，已经有很多很多的案例了，但是我觉得这些案例不一定能完全满足我的需求，于是想要从画直线开始研究。\n从普通绘画的角度来看，很重要的一点就是描边的宽度基本上是一致的：考虑一下远景的物体，画家在绘画的时候使用和近景相同粗细的笔（用一样或者稍弱的力），绘制一个较不精细的物体，而不是使用很细的笔去绘制一个精细的物体，结论就是远处的描边可能稍细一些，但最好是相同粗细，其颜色可能会变浅。\n从另一个角度来看，描边往往需要能够控制其宽度，对于较细的线，则会有较明显的锯齿（事实上只要角度不太好的描边，就会有很明显的边缘锯齿），那么控制粗细和进行一定程度的抗锯齿也是一个研究的方向。\n从第三个角度，碰巧看到了Freya Holmér制作的Shapes插件，能够绘制高质量的线条画，看上去渲染的效果很好。但是价格过于高昂，于是想要研究一个能够做到差不多效果的工具。\n抗锯齿和宽度的思考 在Unity中画直线有蛮多办法，Debug.DrawLine或者Gizmos.DrawLine都能绘制等宽的直线，不过只能固定一个像素宽，而且因为只有一个像素宽，所以会有明显的锯齿。使用LineRenderer可以绘制任意宽度的直线，写特定的shader通过透明度混合能够防止锯齿的出现（不过线段两端不太好做抗锯齿），但是不能保证在不同角度下直线的宽度相等。那么答案就很明显了，通过线段的顶点的数据，生成两个三角面（一个Quad），在GPU中计算出三角面每个顶点的屏幕空间的位置，确保线段的宽度一致。也由于有宽度的存在，给后续的透明度混合抗锯齿留下了操作的空间。\n具体的绘制线条的操作 首先看一张图（完了三角形顶点顺序画反了，已经积重难返了，代码表现对就当做对的吧） 我们将使用Graphics.DrawProcedural这个方法来绘制我们的直线，每一段直线由两个三角形组成（这里要注意在unity中三角形顶点顺序是顺时针的），也就是说要绘制N条直线的话，要传入N+1个节点位置数据，而实际绘制时会绘制6N个顶点。这样传入Shader的是一个表示线段节点位置的长度是N+1的Vector3数据_VerticesBuffer，和一个表示顶点序号的从0到6N-1的uint数据，也就是在绘制时图形API自动传输的SV_VERTEXID。\n这也就导致了我们的顶点着色器输入数据和普通的Shader有所区别，只有一个uint数据：\nstruct Attributes { uint vertexID : SV_VERTEXID; }; 在顶点着色器获取到SV_VERTEXID之后，我们可以以此来计算出线段的序号lineID和每个顶点在绘制线段时的序号vertexID。在绘制时我们又要知道当前线段的两个节点的位置，在传入_VerticesBuffer之后，我们需要对每个顶点确定其对应的线段节点的序号，即lineID + 0或者lineID + 1，我们可以将这个可以通过vertexID确定的0或者1储存到一个数组vertexIndexes中，方便使用vertexID读取。\n为了让线段取得较好的抗锯齿效果，我们把线段整体外扩了_OutlineWidth个像素宽（实际线段宽度是这个的两倍）。此时对于每一个顶点，我们需要知道外扩之后的屏幕空间的顶点位置.由于我们需要使用从LineStart到LineEnd的方向offset（对于1, 2, 4这几个顶点来说，offset是从LineEnd到LineStart的方向）和与其相垂直的方向来做外扩，我们需要把每个顶点的两个方向值储存到数组vertexOffsets中。可以看到顶点永远是往远离较远节点的方向移动的，因此vertexOffset的x值都是-1。而我们选取offset逆时针旋转90°的方向作为相垂直的方向，因此vertexOffset的y值会有正负之分。\n最后是uv的数值，我们还需要给每个顶点传入uv的数值，就比较简单了，储存到数组vertexUVs中。\n此外还要注意一点，在片元着色器中，我们需要知道LineStart和LineEnd对应的uv位置来做线段的圆形端点，因此我们还需要把这个长方体的高宽比ratio传给片元着色器。\n这样，我们片元着色器的输入数据就是positionCS，uv和ratio了：\nstruct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float ratio : TEXCOORD1; }; 绘制线条的流程 C#脚本获取要绘制线条的节点数据，传入_VerticesBuffer，调用Graphics.DrawProcedural方法进行绘制。 Shader的顶点着色器根据SV_VERTEXID计算出每个顶点对应的线段序号lineID和顶点序号vertexID。 通过线段序号、顶点序号和vertexIndexes从_VerticesBuffer中找到较近的线段节点的世界坐标，和较远的线段节点的世界坐标。 将两个世界坐标转换到屏幕空间，得到屏幕空间两点对应的向量和与之相垂直的向量，进行归一化。 将每个顶点根据vertexOffsets和描边宽度进行外扩。 将外扩后的裁剪空间的坐标，从vertexUVs中获得的uv和高宽比ratio传给片元着色器。 片元着色器根据ratio和uv，绘制出一个两头圆形的线段。 DrawEqualWidthLine.cs C#脚本比较简单了，没什么特别需要注意的地方。\nusing UnityEngine; public class DrawEqualWidthLine : MonoBehaviour { public Vector3[] vertices; private int vertexCount; public Material equalWidthMaterial; ComputeBuffer verticesBuffer; private void EnsureBuffer(ref ComputeBuffer buffer, int count, int stride) { if (buffer == null) { buffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } else if (buffer.count != count || buffer.stride != stride) { buffer.Release(); buffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } private void Awake() { vertexCount = vertices.Length; EnsureBuffer(ref verticesBuffer, vertexCount, 3 * 4); } private void Update() { if(vertexCount != vertices.Length) { vertexCount = vertices.Length; EnsureBuffer(ref verticesBuffer, vertexCount, 3 * 4); } Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 100.0f); verticesBuffer.SetData(vertices); MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetBuffer(\"_VerticesBuffer\", verticesBuffer); Graphics.DrawProcedural(equalWidthMaterial, bounds, MeshTopology.Triangles, (vertexCount - 1) * 6, properties: mpb); } void OnDestroy() { verticesBuffer.Dispose(); } } EqualWidthLineShader.shader 基本上需要注意的都写在shader的注释里面了，使用_OutlineColor来控制线段的颜色，_OutlineWidth来控制线段的宽度，_Sharpness来控制锐利程度以达到抗锯齿的效果。\n特别要注意的就是屏幕比例的问题，要确保在屏幕中两个偏移方向是互相垂直的，这样才能获得正确的新的裁剪空间的坐标，也才能获得正确的线段节点的uv值。还有要注意仿射变换和透视变换的区别，参考维基百科上的说明，决定了uv在屏幕空间中是不是线性的。\n当然三个数组可以合并成一个，不过也没那个必要就是了。\nShader \"zznewclear13/EqualWidthLineShader\" { Properties { _OutlineColor (\"Outline Color\", color) = (1.0, 1.0, 1.0, 1.0) _OutlineWidth(\"Outline Width\", float) = 10.0 _Sharpness(\"Sharpness\", range(0, 0.99)) = 0.5 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" StructuredBuffer\u003cfloat3\u003e _VerticesBuffer; float4 _OutlineColor; float _OutlineWidth; float _Sharpness; static int vertexIndexes[] = { 0, 1, 1, 0, 1, 0 }; static float2 vertexOffsets[] = { float2(-1, -1), float2(-1, 1), float2(-1, -1), float2(-1, -1), float2(-1, -1), float2(-1, 1), }; static float2 vertexUVs[] = { float2(0, 0), float2(1, 0), float2(1, 1), float2(0, 0), float2(1, 1), float2(0, 1), }; struct Attributes { uint vertexID : SV_VERTEXID; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float ratio : TEXCOORD1; }; Varyings Vert(Attributes input) { Varyings output = (Varyings)0; int vertexID = input.vertexID % 6; int lineID = input.vertexID / 6; //获取较近的线段节点的世界坐标，和较远的线段节点的世界坐标 float3 vertexPos = _VerticesBuffer[lineID + vertexIndexes[vertexID]]; float3 anotherVert = _VerticesBuffer[lineID + 1 - vertexIndexes[vertexID]]; //转换到裁剪空间 float4 positionCS = mul(UNITY_MATRIX_VP, float4(vertexPos, 1.0)); float4 anotherCS = mul(UNITY_MATRIX_VP, float4(anotherVert, 1.0)); //Unity相机是看向Z轴负方向的，所以裁剪空间w分量小于0 //这里就不需要用从远的节点减去近的节点了 float2 offset = positionCS.xy / positionCS.w - anotherCS.xy / anotherCS.w; //得到长方形宽度 float lengthOffset = length(offset); //要考虑到屏幕的比例 float2 normalizedOffset = normalize(offset * (_ScreenParams.wz - 1.0)); float2 pointOffset = vertexOffsets[vertexID]; float2 pointOffsetX = float2(normalizedOffset.x, normalizedOffset.y) * pointOffset.x; float2 pointOffsetY = float2(-normalizedOffset.y, normalizedOffset.x) * pointOffset.y; //考虑到屏幕的比例，根据上面的两个Offset，得到新的裁剪空间的坐标 float4 newClipPos = float4(-positionCS.w * (pointOffsetX + pointOffsetY) * (_ScreenParams.zw - 1.0) * _OutlineWidth, 0, 0) + positionCS; //算的不一定对，不过也大差不差了。。 float lengthRadius = _OutlineWidth * length(pointOffsetX * (_ScreenParams.zw - 1.0)); output.positionCS = newClipPos; //如果不乘上深度的话，会有透视变形的问题 //https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping output.uv = vertexUVs[vertexID] * (-newClipPos.w); output.ratio = 2.0 * lengthRadius / (2.0 * lengthRadius + lengthOffset); return output; } float GetDist(float2 uv, float ratio) { uv.x = 0.5 - abs(0.5 - uv.x); float2 coord = float2(uv.x * rcp(ratio), uv.y); float2 center = float2(0.5, 0.5); float distToCenter = length(coord - center); float distToLine = abs(uv.y - 0.5); return coord.x \u003c 0.5 ? distToCenter : distToLine; } float4 Frag(Varyings input) : SV_TARGET { float2 uv = input.uv / (-input.positionCS.w); float distValue = GetDist(uv, input.ratio); //用smoothstep进行抗锯齿 distValue = smoothstep(0.5, _Sharpness * 0.5, distValue); return float4(_OutlineColor.rgb, distValue * _OutlineColor.a); } ENDHLSL SubShader { Tags {\"Queue\"=\"Transparent\" \"RenderType\"=\"Transparent\" } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Pass { HLSLPROGRAM #pragma vertex Vert #pragma fragment Frag ENDHLSL } } } 结语 我对目前的效果还是很满意的！也没看到有什么人做这个画线的操作（除了Shapes，当然我也没去搜索别的案例就是了）。感觉对绘制顶点时的处理和空间变换的理解又大大加深了！下一个目标就是描边的计算了，目前感觉上会和原始模型有深度测试的问题，只能走一步看一步了。\n这段时间一直在思考景深和写ShaderToy，也算收获不少，不过没能写出博客来，拿这个等宽且抗锯齿的世界坐标直线来弥补一下。\n","wordCount":"547","inLanguage":"en","image":"https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/posts/images/EqualWidthLine.jpg","datePublished":"2021-12-02T17:00:00+08:00","dateModified":"2021-12-02T17:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">在Unity中绘制等宽线条</h1><div class=post-description>在Unity世界空间中画一条等宽且抗锯齿的直线.</div><div class=post-meta><span title='2021-12-02 17:00:00 +0800 CST'>December 2, 2021</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/draw-equal-width-line-in-unity.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/EqualWidthLine.jpg alt="Equal Width Line Cover"><p>Equal Width Lines</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在Unity中绘制等宽线条</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba aria-label=动机>动机</a></li><li><a href=#%e6%8a%97%e9%94%af%e9%bd%bf%e5%92%8c%e5%ae%bd%e5%ba%a6%e7%9a%84%e6%80%9d%e8%80%83 aria-label=抗锯齿和宽度的思考>抗锯齿和宽度的思考</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e7%bb%98%e5%88%b6%e7%ba%bf%e6%9d%a1%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=具体的绘制线条的操作>具体的绘制线条的操作</a></li><li><a href=#%e7%bb%98%e5%88%b6%e7%ba%bf%e6%9d%a1%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=绘制线条的流程>绘制线条的流程</a><ul><li><a href=#drawequalwidthlinecs aria-label=DrawEqualWidthLine.cs>DrawEqualWidthLine.cs</a></li><li><a href=#equalwidthlineshadershader aria-label=EqualWidthLineShader.shader>EqualWidthLineShader.shader</a></li></ul></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li></ul></div></details></div><div class=post-content><h2 id=动机>动机<a hidden class=anchor aria-hidden=true href=#动机>#</a></h2><p>直接动机是想要在unity中制作一个描边效果。对于卡通渲染的描边效果，已经有很多很多的案例了，但是我觉得这些案例不一定能完全满足我的需求，于是想要从画直线开始研究。</p><p>从普通绘画的角度来看，很重要的一点就是描边的宽度基本上是一致的：考虑一下远景的物体，画家在绘画的时候使用和近景相同粗细的笔（用一样或者稍弱的力），绘制一个较不精细的物体，而不是使用很细的笔去绘制一个精细的物体，结论就是远处的描边可能稍细一些，但最好是相同粗细，其颜色可能会变浅。</p><p>从另一个角度来看，描边往往需要能够控制其宽度，对于较细的线，则会有较明显的锯齿（事实上只要角度不太好的描边，就会有很明显的边缘锯齿），那么控制粗细和进行一定程度的抗锯齿也是一个研究的方向。</p><p>从第三个角度，碰巧看到了Freya Holmér制作的<a href=https://assetstore.unity.com/packages/tools/particles-effects/shapes-173167>Shapes</a>插件，能够绘制高质量的线条画，看上去渲染的效果很好。但是价格过于高昂，于是想要研究一个能够做到差不多效果的工具。</p><h2 id=抗锯齿和宽度的思考>抗锯齿和宽度的思考<a hidden class=anchor aria-hidden=true href=#抗锯齿和宽度的思考>#</a></h2><p>在Unity中画直线有蛮多办法，<code>Debug.DrawLine</code>或者<code>Gizmos.DrawLine</code>都能绘制等宽的直线，不过只能固定一个像素宽，而且因为只有一个像素宽，所以会有明显的锯齿。使用<code>LineRenderer</code>可以绘制任意宽度的直线，写特定的shader通过透明度混合能够防止锯齿的出现（不过线段两端不太好做抗锯齿），但是不能保证在不同角度下直线的宽度相等。那么答案就很明显了，通过线段的顶点的数据，生成两个三角面（一个Quad），在GPU中计算出三角面每个顶点的屏幕空间的位置，确保线段的宽度一致。也由于有宽度的存在，给后续的透明度混合抗锯齿留下了操作的空间。</p><h2 id=具体的绘制线条的操作>具体的绘制线条的操作<a hidden class=anchor aria-hidden=true href=#具体的绘制线条的操作>#</a></h2><p>首先看一张图（完了三角形顶点顺序画反了，已经积重难返了，代码表现对就当做对的吧）
<img loading=lazy src=../images/EqualWidthLineDiagram.jpg alt="Equal Width Line Diagram"></p><p>我们将使用<code>Graphics.DrawProcedural</code>这个方法来绘制我们的直线，每一段直线由两个三角形组成（这里要注意在unity中三角形顶点顺序是顺时针的），也就是说要绘制N条直线的话，要传入N+1个节点位置数据，而实际绘制时会绘制6N个顶点。这样传入Shader的是一个表示线段节点位置的长度是N+1的Vector3数据<code>_VerticesBuffer</code>，和一个表示顶点序号的从0到6N-1的uint数据，也就是在绘制时图形API自动传输的<code>SV_VERTEXID</code>。</p><p>这也就导致了我们的顶点着色器输入数据和普通的Shader有所区别，只有一个uint数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> vertexID    <span style=color:#f92672>:</span> SV_VERTEXID;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在顶点着色器获取到<code>SV_VERTEXID</code>之后，我们可以以此来计算出线段的序号<code>lineID</code>和每个顶点在绘制线段时的序号<code>vertexID</code>。在绘制时我们又要知道当前线段的两个节点的位置，在传入<code>_VerticesBuffer</code>之后，我们需要对每个顶点确定其对应的线段节点的序号，即<code>lineID + 0</code>或者<code>lineID + 1</code>，我们可以将这个可以通过<code>vertexID</code>确定的0或者1储存到一个数组<code>vertexIndexes</code>中，方便使用<code>vertexID</code>读取。</p><p>为了让线段取得较好的抗锯齿效果，我们把线段整体外扩了<code>_OutlineWidth</code>个像素宽（实际线段宽度是这个的两倍）。此时对于每一个顶点，我们需要知道外扩之后的屏幕空间的顶点位置.由于我们需要使用从<code>LineStart</code>到<code>LineEnd</code>的方向<code>offset</code>（对于1, 2, 4这几个顶点来说，<code>offset</code>是从<code>LineEnd</code>到<code>LineStart</code>的方向）和与其相垂直的方向来做外扩，我们需要把每个顶点的两个方向值储存到数组<code>vertexOffsets</code>中。可以看到顶点永远是往远离较远节点的方向移动的，因此<code>vertexOffset</code>的x值都是-1。而我们选取<code>offset</code>逆时针旋转90°的方向作为相垂直的方向，因此<code>vertexOffset</code>的y值会有正负之分。</p><p>最后是uv的数值，我们还需要给每个顶点传入uv的数值，就比较简单了，储存到数组<code>vertexUVs</code>中。</p><p>此外还要注意一点，在片元着色器中，我们需要知道<code>LineStart</code>和<code>LineEnd</code>对应的uv位置来做线段的圆形端点，因此我们还需要把这个长方体的高宽比<code>ratio</code>传给片元着色器。</p><p>这样，我们片元着色器的输入数据就是<code>positionCS</code>，<code>uv</code>和<code>ratio</code>了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio         <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=绘制线条的流程>绘制线条的流程<a hidden class=anchor aria-hidden=true href=#绘制线条的流程>#</a></h2><ol><li>C#脚本获取要绘制线条的节点数据，传入<code>_VerticesBuffer</code>，调用<code>Graphics.DrawProcedural</code>方法进行绘制。</li><li>Shader的顶点着色器根据<code>SV_VERTEXID</code>计算出每个顶点对应的线段序号<code>lineID</code>和顶点序号<code>vertexID</code>。</li><li>通过线段序号、顶点序号和<code>vertexIndexes</code>从<code>_VerticesBuffer</code>中找到较近的线段节点的世界坐标，和较远的线段节点的世界坐标。</li><li>将两个世界坐标转换到屏幕空间，得到屏幕空间两点对应的向量和与之相垂直的向量，进行归一化。</li><li>将每个顶点根据<code>vertexOffsets</code>和描边宽度进行外扩。</li><li>将外扩后的裁剪空间的坐标，从<code>vertexUVs</code>中获得的uv和高宽比<code>ratio</code>传给片元着色器。</li><li>片元着色器根据<code>ratio</code>和<code>uv</code>，绘制出一个两头圆形的线段。</li></ol><h3 id=drawequalwidthlinecs>DrawEqualWidthLine.cs<a hidden class=anchor aria-hidden=true href=#drawequalwidthlinecs>#</a></h3><p>C#脚本比较简单了，没什么特别需要注意的地方。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DrawEqualWidthLine</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Vector3[] vertices;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> vertexCount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Material equalWidthMaterial;
</span></span><span style=display:flex><span>    ComputeBuffer verticesBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (buffer == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (buffer.count != count || buffer.stride != stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            buffer.Release();
</span></span><span style=display:flex><span>            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Awake()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vertexCount = vertices.Length;
</span></span><span style=display:flex><span>        EnsureBuffer(<span style=color:#66d9ef>ref</span> verticesBuffer, vertexCount, <span style=color:#ae81ff>3</span> * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(vertexCount != vertices.Length)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            vertexCount = vertices.Length;
</span></span><span style=display:flex><span>            EnsureBuffer(<span style=color:#66d9ef>ref</span> verticesBuffer, vertexCount, <span style=color:#ae81ff>3</span> * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Bounds bounds = <span style=color:#66d9ef>new</span> Bounds(Vector3.zero, Vector3.one * <span style=color:#ae81ff>100.0f</span>);
</span></span><span style=display:flex><span>        verticesBuffer.SetData(vertices);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
</span></span><span style=display:flex><span>        mpb.SetBuffer(<span style=color:#e6db74>&#34;_VerticesBuffer&#34;</span>, verticesBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Graphics.DrawProcedural(equalWidthMaterial, bounds, MeshTopology.Triangles, (vertexCount - <span style=color:#ae81ff>1</span>) * <span style=color:#ae81ff>6</span>, properties: mpb);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        verticesBuffer.Dispose();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=equalwidthlineshadershader>EqualWidthLineShader.shader<a hidden class=anchor aria-hidden=true href=#equalwidthlineshadershader>#</a></h3><p>基本上需要注意的都写在shader的注释里面了，使用<code>_OutlineColor</code>来控制线段的颜色，<code>_OutlineWidth</code>来控制线段的宽度，<code>_Sharpness</code>来控制锐利程度以达到抗锯齿的效果。</p><p>特别要注意的就是屏幕比例的问题，要确保在屏幕中两个偏移方向是互相垂直的，这样才能获得正确的新的裁剪空间的坐标，也才能获得正确的线段节点的uv值。还有要注意仿射变换和透视变换的区别，参考维基百科上的<a href=https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping>说明</a>，决定了uv在屏幕空间中是不是线性的。</p><p>当然三个数组可以合并成一个，不过也没那个必要就是了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/EqualWidthLineShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _OutlineColor (<span style=color:#e6db74>&#34;Outline Color&#34;</span>, color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span>        _OutlineWidth(<span style=color:#e6db74>&#34;Outline Width&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>
</span></span><span style=display:flex><span>        _Sharpness(<span style=color:#e6db74>&#34;Sharpness&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.99</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float3</span><span style=color:#f92672>&gt;</span> _VerticesBuffer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _OutlineColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _OutlineWidth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _Sharpness;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> vertexIndexes[] <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float2</span> vertexOffsets[] <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float2</span> vertexUVs[] <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> vertexID    <span style=color:#f92672>:</span> SV_VERTEXID;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ratio         <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings Vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> vertexID <span style=color:#f92672>=</span> input.vertexID <span style=color:#f92672>%</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> lineID <span style=color:#f92672>=</span> input.vertexID <span style=color:#f92672>/</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//获取较近的线段节点的世界坐标，和较远的线段节点的世界坐标</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> vertexPos <span style=color:#f92672>=</span> _VerticesBuffer[lineID <span style=color:#f92672>+</span> vertexIndexes[vertexID]];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> anotherVert <span style=color:#f92672>=</span> _VerticesBuffer[lineID <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> vertexIndexes[vertexID]];
</span></span><span style=display:flex><span>        <span style=color:#75715e>//转换到裁剪空间</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(vertexPos, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> anotherCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(anotherVert, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Unity相机是看向Z轴负方向的，所以裁剪空间w分量小于0</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//这里就不需要用从远的节点减去近的节点了</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> offset <span style=color:#f92672>=</span> positionCS.xy <span style=color:#f92672>/</span> positionCS.w <span style=color:#f92672>-</span> anotherCS.xy <span style=color:#f92672>/</span> anotherCS.w;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//得到长方形宽度</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lengthOffset <span style=color:#f92672>=</span> length(offset);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//要考虑到屏幕的比例</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> normalizedOffset <span style=color:#f92672>=</span> normalize(offset <span style=color:#f92672>*</span> (_ScreenParams.wz <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> pointOffset <span style=color:#f92672>=</span> vertexOffsets[vertexID];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> pointOffsetX <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(normalizedOffset.x, normalizedOffset.y) <span style=color:#f92672>*</span> pointOffset.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> pointOffsetY <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span>normalizedOffset.y, normalizedOffset.x) <span style=color:#f92672>*</span> pointOffset.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//考虑到屏幕的比例，根据上面的两个Offset，得到新的裁剪空间的坐标</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> newClipPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#f92672>-</span>positionCS.w <span style=color:#f92672>*</span> (pointOffsetX <span style=color:#f92672>+</span> pointOffsetY) <span style=color:#f92672>*</span> (_ScreenParams.zw <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> _OutlineWidth, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> positionCS;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//算的不一定对，不过也大差不差了。。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lengthRadius <span style=color:#f92672>=</span> _OutlineWidth <span style=color:#f92672>*</span> length(pointOffsetX <span style=color:#f92672>*</span> (_ScreenParams.zw <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> newClipPos;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果不乘上深度的话，会有透视变形的问题</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping</span>
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> vertexUVs[vertexID] <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span>newClipPos.w);
</span></span><span style=display:flex><span>        output.ratio <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> lengthRadius <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> lengthRadius <span style=color:#f92672>+</span> lengthOffset);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> GetDist(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float</span> ratio)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        uv.x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>-</span> abs(<span style=color:#ae81ff>0.5</span> <span style=color:#f92672>-</span> uv.x);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> coord <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(uv.x <span style=color:#f92672>*</span> rcp(ratio), uv.y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> center <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> distToCenter <span style=color:#f92672>=</span> length(coord <span style=color:#f92672>-</span> center);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> distToLine <span style=color:#f92672>=</span> abs(uv.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> coord.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>?</span> distToCenter <span style=color:#f92672>:</span> distToLine;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> Frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> input.uv <span style=color:#f92672>/</span> (<span style=color:#f92672>-</span>input.positionCS.w);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> distValue <span style=color:#f92672>=</span> GetDist(uv, input.ratio);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//用smoothstep进行抗锯齿</span>
</span></span><span style=display:flex><span>        distValue <span style=color:#f92672>=</span> smoothstep(<span style=color:#ae81ff>0.5</span>, _Sharpness <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>, distValue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(_OutlineColor.rgb, distValue <span style=color:#f92672>*</span> _OutlineColor.a);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags {<span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> }
</span></span><span style=display:flex><span>        ZWrite Off
</span></span><span style=display:flex><span>        Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex Vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment Frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>我对目前的效果还是很满意的！也没看到有什么人做这个画线的操作（除了Shapes，当然我也没去搜索别的案例就是了）。感觉对绘制顶点时的处理和空间变换的理解又大大加深了！下一个目标就是描边的计算了，目前感觉上会和原始模型有深度测试的问题，只能走一步看一步了。</p><p>这段时间一直在思考景深和写ShaderToy，也算收获不少，不过没能写出博客来，拿这个等宽且抗锯齿的世界坐标直线来弥补一下。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><span class=title>« Prev</span><br><span>在Unity中绘制等宽的描边</span>
</a><a class=next href=https://zznewclear13.github.io/posts/gpu-color-inspector/><span class=title>Next »</span><br><span>GPU颜色查看器</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>