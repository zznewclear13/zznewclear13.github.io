<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在Unity中绘制等宽线条 | ZZNEWCLEAR13</title><meta name=keywords content="Space Transformation,Anti-Aliasing"><meta name=description content="在Unity世界空间中画一条等宽且抗锯齿的直线."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="在Unity中绘制等宽线条"><meta property="og:description" content="在Unity世界空间中画一条等宽且抗锯齿的直线."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/posts/images/EqualWidthLine.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-02T17:00:00+08:00"><meta property="article:modified_time" content="2021-12-02T17:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/posts/images/EqualWidthLine.jpg"><meta name=twitter:title content="在Unity中绘制等宽线条"><meta name=twitter:description content="在Unity世界空间中画一条等宽且抗锯齿的直线."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在Unity中绘制等宽线条","item":"https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在Unity中绘制等宽线条","name":"在Unity中绘制等宽线条","description":"在Unity世界空间中画一条等宽且抗锯齿的直线.","keywords":["Space Transformation","Anti-Aliasing"],"articleBody":"动机 直接动机是想要在unity中制作一个描边效果。对于卡通渲染的描边效果，已经有很多很多的案例了，但是我觉得这些案例不一定能完全满足我的需求，于是想要从画直线开始研究。\n从普通绘画的角度来看，很重要的一点就是描边的宽度基本上是一致的：考虑一下远景的物体，画家在绘画的时候使用和近景相同粗细的笔（用一样或者稍弱的力），绘制一个较不精细的物体，而不是使用很细的笔去绘制一个精细的物体，结论就是远处的描边可能稍细一些，但最好是相同粗细，其颜色可能会变浅。\n从另一个角度来看，描边往往需要能够控制其宽度，对于较细的线，则会有较明显的锯齿（事实上只要角度不太好的描边，就会有很明显的边缘锯齿），那么控制粗细和进行一定程度的抗锯齿也是一个研究的方向。\n从第三个角度，碰巧看到了Freya Holmér制作的Shapes插件，能够绘制高质量的线条画，看上去渲染的效果很好。但是价格过于高昂，于是想要研究一个能够做到差不多效果的工具。\n抗锯齿和宽度的思考 在Unity中画直线有蛮多办法，Debug.DrawLine或者Gizmos.DrawLine都能绘制等宽的直线，不过只能固定一个像素宽，而且因为只有一个像素宽，所以会有明显的锯齿。使用LineRenderer可以绘制任意宽度的直线，写特定的shader通过透明度混合能够防止锯齿的出现（不过线段两端不太好做抗锯齿），但是不能保证在不同角度下直线的宽度相等。那么答案就很明显了，通过线段的顶点的数据，生成两个三角面（一个Quad），在GPU中计算出三角面每个顶点的屏幕空间的位置，确保线段的宽度一致。也由于有宽度的存在，给后续的透明度混合抗锯齿留下了操作的空间。\n具体的绘制线条的操作 首先看一张图（完了三角形顶点顺序画反了，已经积重难返了，代码表现对就当做对的吧） 我们将使用Graphics.DrawProcedural这个方法来绘制我们的直线，每一段直线由两个三角形组成（这里要注意在unity中三角形顶点顺序是顺时针的），也就是说要绘制N条直线的话，要传入N+1个节点位置数据，而实际绘制时会绘制6N个顶点。这样传入Shader的是一个表示线段节点位置的长度是N+1的Vector3数据_VerticesBuffer，和一个表示顶点序号的从0到6N-1的uint数据，也就是在绘制时图形API自动传输的SV_VERTEXID。\n这也就导致了我们的顶点着色器输入数据和普通的Shader有所区别，只有一个uint数据：\nstruct Attributes\r{\ruint vertexID : SV_VERTEXID;\r};\r在顶点着色器获取到SV_VERTEXID之后，我们可以以此来计算出线段的序号lineID和每个顶点在绘制线段时的序号vertexID。在绘制时我们又要知道当前线段的两个节点的位置，在传入_VerticesBuffer之后，我们需要对每个顶点确定其对应的线段节点的序号，即lineID + 0或者lineID + 1，我们可以将这个可以通过vertexID确定的0或者1储存到一个数组vertexIndexes中，方便使用vertexID读取。\n为了让线段取得较好的抗锯齿效果，我们把线段整体外扩了_OutlineWidth个像素宽（实际线段宽度是这个的两倍）。此时对于每一个顶点，我们需要知道外扩之后的屏幕空间的顶点位置.由于我们需要使用从LineStart到LineEnd的方向offset（对于1, 2, 4这几个顶点来说，offset是从LineEnd到LineStart的方向）和与其相垂直的方向来做外扩，我们需要把每个顶点的两个方向值储存到数组vertexOffsets中。可以看到顶点永远是往远离较远节点的方向移动的，因此vertexOffset的x值都是-1。而我们选取offset逆时针旋转90°的方向作为相垂直的方向，因此vertexOffset的y值会有正负之分。\n最后是uv的数值，我们还需要给每个顶点传入uv的数值，就比较简单了，储存到数组vertexUVs中。\n此外还要注意一点，在片元着色器中，我们需要知道LineStart和LineEnd对应的uv位置来做线段的圆形端点，因此我们还需要把这个长方体的高宽比ratio传给片元着色器。\n这样，我们片元着色器的输入数据就是positionCS，uv和ratio了：\nstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat ratio : TEXCOORD1;\r};\r绘制线条的流程  C#脚本获取要绘制线条的节点数据，传入_VerticesBuffer，调用Graphics.DrawProcedural方法进行绘制。 Shader的顶点着色器根据SV_VERTEXID计算出每个顶点对应的线段序号lineID和顶点序号vertexID。 通过线段序号、顶点序号和vertexIndexes从_VerticesBuffer中找到较近的线段节点的世界坐标，和较远的线段节点的世界坐标。 将两个世界坐标转换到屏幕空间，得到屏幕空间两点对应的向量和与之相垂直的向量，进行归一化。 将每个顶点根据vertexOffsets和描边宽度进行外扩。 将外扩后的裁剪空间的坐标，从vertexUVs中获得的uv和高宽比ratio传给片元着色器。 片元着色器根据ratio和uv，绘制出一个两头圆形的线段。  DrawEqualWidthLine.cs C#脚本比较简单了，没什么特别需要注意的地方。\nusing UnityEngine; public class DrawEqualWidthLine : MonoBehaviour { public Vector3[] vertices; private int vertexCount; public Material equalWidthMaterial; ComputeBuffer verticesBuffer; private void EnsureBuffer(ref ComputeBuffer buffer, int count, int stride) { if (buffer == null) { buffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } else if (buffer.count != count || buffer.stride != stride) { buffer.Release(); buffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } private void Awake() { vertexCount = vertices.Length; EnsureBuffer(ref verticesBuffer, vertexCount, 3 * 4); } private void Update() { if(vertexCount != vertices.Length) { vertexCount = vertices.Length; EnsureBuffer(ref verticesBuffer, vertexCount, 3 * 4); } Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 100.0f); verticesBuffer.SetData(vertices); MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetBuffer(\"_VerticesBuffer\", verticesBuffer); Graphics.DrawProcedural(equalWidthMaterial, bounds, MeshTopology.Triangles, (vertexCount - 1) * 6, properties: mpb); } void OnDestroy() { verticesBuffer.Dispose(); } } EqualWidthLineShader.shader 基本上需要注意的都写在shader的注释里面了，使用_OutlineColor来控制线段的颜色，_OutlineWidth来控制线段的宽度，_Sharpness来控制锐利程度以达到抗锯齿的效果。\n特别要注意的就是屏幕比例的问题，要确保在屏幕中两个偏移方向是互相垂直的，这样才能获得正确的新的裁剪空间的坐标，也才能获得正确的线段节点的uv值。还有要注意仿射变换和透视变换的区别，参考维基百科上的说明，决定了uv在屏幕空间中是不是线性的。\n当然三个数组可以合并成一个，不过也没那个必要就是了。\nShader \"zznewclear13/EqualWidthLineShader\"\r{\rProperties\r{\r_OutlineColor (\"Outline Color\", color) = (1.0, 1.0, 1.0, 1.0)\r_OutlineWidth(\"Outline Width\", float) = 10.0\r_Sharpness(\"Sharpness\", range(0, 0.99)) = 0.5\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\rStructuredBuffer _VerticesBuffer;\rfloat4 _OutlineColor;\rfloat _OutlineWidth;\rfloat _Sharpness;\rstatic int vertexIndexes[] = {\r0, 1, 1, 0, 1, 0\r};\rstatic float2 vertexOffsets[] = {\rfloat2(-1, -1),\rfloat2(-1, 1),\rfloat2(-1, -1),\rfloat2(-1, -1),\rfloat2(-1, -1),\rfloat2(-1, 1),\r};\rstatic float2 vertexUVs[] = {\rfloat2(0, 0),\rfloat2(1, 0),\rfloat2(1, 1),\rfloat2(0, 0),\rfloat2(1, 1),\rfloat2(0, 1),\r};\rstruct Attributes\r{\ruint vertexID : SV_VERTEXID;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat ratio : TEXCOORD1;\r};\rVaryings Vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rint vertexID = input.vertexID % 6;\rint lineID = input.vertexID / 6;\r//获取较近的线段节点的世界坐标，和较远的线段节点的世界坐标\rfloat3 vertexPos = _VerticesBuffer[lineID + vertexIndexes[vertexID]];\rfloat3 anotherVert = _VerticesBuffer[lineID + 1 - vertexIndexes[vertexID]];\r//转换到裁剪空间\rfloat4 positionCS = mul(UNITY_MATRIX_VP, float4(vertexPos, 1.0));\rfloat4 anotherCS = mul(UNITY_MATRIX_VP, float4(anotherVert, 1.0));\r//Unity相机是看向Z轴负方向的，所以裁剪空间w分量小于0\r//这里就不需要用从远的节点减去近的节点了\rfloat2 offset = positionCS.xy / positionCS.w - anotherCS.xy / anotherCS.w;\r//得到长方形宽度\rfloat lengthOffset = length(offset);\r//要考虑到屏幕的比例\rfloat2 normalizedOffset = normalize(offset * (_ScreenParams.wz - 1.0));\rfloat2 pointOffset = vertexOffsets[vertexID];\rfloat2 pointOffsetX = float2(normalizedOffset.x, normalizedOffset.y) * pointOffset.x;\rfloat2 pointOffsetY = float2(-normalizedOffset.y, normalizedOffset.x) * pointOffset.y;\r//考虑到屏幕的比例，根据上面的两个Offset，得到新的裁剪空间的坐标\rfloat4 newClipPos = float4(-positionCS.w * (pointOffsetX + pointOffsetY) * (_ScreenParams.zw - 1.0) * _OutlineWidth, 0, 0) + positionCS;\r//算的不一定对，不过也大差不差了。。\rfloat lengthRadius = _OutlineWidth * length(pointOffsetX * (_ScreenParams.zw - 1.0));\routput.positionCS = newClipPos;\r//如果不乘上深度的话，会有透视变形的问题\r//https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping\routput.uv = vertexUVs[vertexID] * (-newClipPos.w);\routput.ratio = 2.0 * lengthRadius / (2.0 * lengthRadius + lengthOffset);\rreturn output;\r}\rfloat GetDist(float2 uv, float ratio)\r{\ruv.x = 0.5 - abs(0.5 - uv.x);\rfloat2 coord = float2(uv.x * rcp(ratio), uv.y);\rfloat2 center = float2(0.5, 0.5);\rfloat distToCenter = length(coord - center);\rfloat distToLine = abs(uv.y - 0.5);\rreturn coord.x 结语 我对目前的效果还是很满意的！也没看到有什么人做这个画线的操作（除了Shapes，当然我也没去搜索别的案例就是了）。感觉对绘制顶点时的处理和空间变换的理解又大大加深了！下一个目标就是描边的计算了，目前感觉上会和原始模型有深度测试的问题，只能走一步看一步了。\n这段时间一直在思考景深和写ShaderToy，也算收获不少，不过没能写出博客来，拿这个等宽且抗锯齿的世界坐标直线来弥补一下。\n","wordCount":"547","inLanguage":"en","image":"https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/posts/images/EqualWidthLine.jpg","datePublished":"2021-12-02T17:00:00+08:00","dateModified":"2021-12-02T17:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">在Unity中绘制等宽线条</h1><div class=post-description>在Unity世界空间中画一条等宽且抗锯齿的直线.</div><div class=post-meta><span title="2021-12-02 17:00:00 +0800 CST">December 2, 2021</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/draw-equal-width-line-in-unity.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/EqualWidthLine.jpg alt="Equal Width Line Cover"><p>Equal Width Lines</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在Unity中绘制等宽线条</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba aria-label=动机>动机</a></li><li><a href=#%e6%8a%97%e9%94%af%e9%bd%bf%e5%92%8c%e5%ae%bd%e5%ba%a6%e7%9a%84%e6%80%9d%e8%80%83 aria-label=抗锯齿和宽度的思考>抗锯齿和宽度的思考</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e7%bb%98%e5%88%b6%e7%ba%bf%e6%9d%a1%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=具体的绘制线条的操作>具体的绘制线条的操作</a></li><li><a href=#%e7%bb%98%e5%88%b6%e7%ba%bf%e6%9d%a1%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=绘制线条的流程>绘制线条的流程</a><ul><li><a href=#drawequalwidthlinecs aria-label=DrawEqualWidthLine.cs>DrawEqualWidthLine.cs</a></li><li><a href=#equalwidthlineshadershader aria-label=EqualWidthLineShader.shader>EqualWidthLineShader.shader</a></li></ul></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li></ul></div></details></div><div class=post-content><h2 id=动机>动机<a hidden class=anchor aria-hidden=true href=#动机>#</a></h2><p>直接动机是想要在unity中制作一个描边效果。对于卡通渲染的描边效果，已经有很多很多的案例了，但是我觉得这些案例不一定能完全满足我的需求，于是想要从画直线开始研究。</p><p>从普通绘画的角度来看，很重要的一点就是描边的宽度基本上是一致的：考虑一下远景的物体，画家在绘画的时候使用和近景相同粗细的笔（用一样或者稍弱的力），绘制一个较不精细的物体，而不是使用很细的笔去绘制一个精细的物体，结论就是远处的描边可能稍细一些，但最好是相同粗细，其颜色可能会变浅。</p><p>从另一个角度来看，描边往往需要能够控制其宽度，对于较细的线，则会有较明显的锯齿（事实上只要角度不太好的描边，就会有很明显的边缘锯齿），那么控制粗细和进行一定程度的抗锯齿也是一个研究的方向。</p><p>从第三个角度，碰巧看到了Freya Holmér制作的<a href=https://assetstore.unity.com/packages/tools/particles-effects/shapes-173167>Shapes</a>插件，能够绘制高质量的线条画，看上去渲染的效果很好。但是价格过于高昂，于是想要研究一个能够做到差不多效果的工具。</p><h2 id=抗锯齿和宽度的思考>抗锯齿和宽度的思考<a hidden class=anchor aria-hidden=true href=#抗锯齿和宽度的思考>#</a></h2><p>在Unity中画直线有蛮多办法，<code>Debug.DrawLine</code>或者<code>Gizmos.DrawLine</code>都能绘制等宽的直线，不过只能固定一个像素宽，而且因为只有一个像素宽，所以会有明显的锯齿。使用<code>LineRenderer</code>可以绘制任意宽度的直线，写特定的shader通过透明度混合能够防止锯齿的出现（不过线段两端不太好做抗锯齿），但是不能保证在不同角度下直线的宽度相等。那么答案就很明显了，通过线段的顶点的数据，生成两个三角面（一个Quad），在GPU中计算出三角面每个顶点的屏幕空间的位置，确保线段的宽度一致。也由于有宽度的存在，给后续的透明度混合抗锯齿留下了操作的空间。</p><h2 id=具体的绘制线条的操作>具体的绘制线条的操作<a hidden class=anchor aria-hidden=true href=#具体的绘制线条的操作>#</a></h2><p>首先看一张图（完了三角形顶点顺序画反了，已经积重难返了，代码表现对就当做对的吧）
<img loading=lazy src=../images/EqualWidthLineDiagram.jpg alt="Equal Width Line Diagram"></p><p>我们将使用<code>Graphics.DrawProcedural</code>这个方法来绘制我们的直线，每一段直线由两个三角形组成（这里要注意在unity中三角形顶点顺序是顺时针的），也就是说要绘制N条直线的话，要传入N+1个节点位置数据，而实际绘制时会绘制6N个顶点。这样传入Shader的是一个表示线段节点位置的长度是N+1的Vector3数据<code>_VerticesBuffer</code>，和一个表示顶点序号的从0到6N-1的uint数据，也就是在绘制时图形API自动传输的<code>SV_VERTEXID</code>。</p><p>这也就导致了我们的顶点着色器输入数据和普通的Shader有所区别，只有一个uint数据：</p><pre><code class=language-HLSL data-lang=HLSL>struct Attributes
{
    uint vertexID    : SV_VERTEXID;
};
</code></pre><p>在顶点着色器获取到<code>SV_VERTEXID</code>之后，我们可以以此来计算出线段的序号<code>lineID</code>和每个顶点在绘制线段时的序号<code>vertexID</code>。在绘制时我们又要知道当前线段的两个节点的位置，在传入<code>_VerticesBuffer</code>之后，我们需要对每个顶点确定其对应的线段节点的序号，即<code>lineID + 0</code>或者<code>lineID + 1</code>，我们可以将这个可以通过<code>vertexID</code>确定的0或者1储存到一个数组<code>vertexIndexes</code>中，方便使用<code>vertexID</code>读取。</p><p>为了让线段取得较好的抗锯齿效果，我们把线段整体外扩了<code>_OutlineWidth</code>个像素宽（实际线段宽度是这个的两倍）。此时对于每一个顶点，我们需要知道外扩之后的屏幕空间的顶点位置.由于我们需要使用从<code>LineStart</code>到<code>LineEnd</code>的方向<code>offset</code>（对于1, 2, 4这几个顶点来说，<code>offset</code>是从<code>LineEnd</code>到<code>LineStart</code>的方向）和与其相垂直的方向来做外扩，我们需要把每个顶点的两个方向值储存到数组<code>vertexOffsets</code>中。可以看到顶点永远是往远离较远节点的方向移动的，因此<code>vertexOffset</code>的x值都是-1。而我们选取<code>offset</code>逆时针旋转90°的方向作为相垂直的方向，因此<code>vertexOffset</code>的y值会有正负之分。</p><p>最后是uv的数值，我们还需要给每个顶点传入uv的数值，就比较简单了，储存到数组<code>vertexUVs</code>中。</p><p>此外还要注意一点，在片元着色器中，我们需要知道<code>LineStart</code>和<code>LineEnd</code>对应的uv位置来做线段的圆形端点，因此我们还需要把这个长方体的高宽比<code>ratio</code>传给片元着色器。</p><p>这样，我们片元着色器的输入数据就是<code>positionCS</code>，<code>uv</code>和<code>ratio</code>了：</p><pre><code class=language-HLSL data-lang=HLSL>struct Varyings
{
    float4 positionCS   : SV_POSITION;
    float2 uv           : TEXCOORD0;
    float ratio         : TEXCOORD1;
};
</code></pre><h2 id=绘制线条的流程>绘制线条的流程<a hidden class=anchor aria-hidden=true href=#绘制线条的流程>#</a></h2><ol><li>C#脚本获取要绘制线条的节点数据，传入<code>_VerticesBuffer</code>，调用<code>Graphics.DrawProcedural</code>方法进行绘制。</li><li>Shader的顶点着色器根据<code>SV_VERTEXID</code>计算出每个顶点对应的线段序号<code>lineID</code>和顶点序号<code>vertexID</code>。</li><li>通过线段序号、顶点序号和<code>vertexIndexes</code>从<code>_VerticesBuffer</code>中找到较近的线段节点的世界坐标，和较远的线段节点的世界坐标。</li><li>将两个世界坐标转换到屏幕空间，得到屏幕空间两点对应的向量和与之相垂直的向量，进行归一化。</li><li>将每个顶点根据<code>vertexOffsets</code>和描边宽度进行外扩。</li><li>将外扩后的裁剪空间的坐标，从<code>vertexUVs</code>中获得的uv和高宽比<code>ratio</code>传给片元着色器。</li><li>片元着色器根据<code>ratio</code>和<code>uv</code>，绘制出一个两头圆形的线段。</li></ol><h3 id=drawequalwidthlinecs>DrawEqualWidthLine.cs<a hidden class=anchor aria-hidden=true href=#drawequalwidthlinecs>#</a></h3><p>C#脚本比较简单了，没什么特别需要注意的地方。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> UnityEngine;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DrawEqualWidthLine</span> : MonoBehaviour
{
    <span style=color:#66d9ef>public</span> Vector3[] vertices;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> vertexCount;

    <span style=color:#66d9ef>public</span> Material equalWidthMaterial;
    ComputeBuffer verticesBuffer;

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
    {
        <span style=color:#66d9ef>if</span> (buffer == <span style=color:#66d9ef>null</span>)
        {
            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
        }
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (buffer.count != count || buffer.stride != stride)
        {
            buffer.Release();
            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Awake()
    {
        vertexCount = vertices.Length;
        EnsureBuffer(<span style=color:#66d9ef>ref</span> verticesBuffer, vertexCount, <span style=color:#ae81ff>3</span> * <span style=color:#ae81ff>4</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
    {
        <span style=color:#66d9ef>if</span>(vertexCount != vertices.Length)
        {
            vertexCount = vertices.Length;
            EnsureBuffer(<span style=color:#66d9ef>ref</span> verticesBuffer, vertexCount, <span style=color:#ae81ff>3</span> * <span style=color:#ae81ff>4</span>);
        }

        Bounds bounds = <span style=color:#66d9ef>new</span> Bounds(Vector3.zero, Vector3.one * <span style=color:#ae81ff>100.0f</span>);
        verticesBuffer.SetData(vertices);

        MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
        mpb.SetBuffer(<span style=color:#e6db74>&#34;_VerticesBuffer&#34;</span>, verticesBuffer);

        Graphics.DrawProcedural(equalWidthMaterial, bounds, MeshTopology.Triangles, (vertexCount - <span style=color:#ae81ff>1</span>) * <span style=color:#ae81ff>6</span>, properties: mpb);
    }

    <span style=color:#66d9ef>void</span> OnDestroy()
    {
        verticesBuffer.Dispose();
    }
}
</code></pre></div><h3 id=equalwidthlineshadershader>EqualWidthLineShader.shader<a hidden class=anchor aria-hidden=true href=#equalwidthlineshadershader>#</a></h3><p>基本上需要注意的都写在shader的注释里面了，使用<code>_OutlineColor</code>来控制线段的颜色，<code>_OutlineWidth</code>来控制线段的宽度，<code>_Sharpness</code>来控制锐利程度以达到抗锯齿的效果。</p><p>特别要注意的就是屏幕比例的问题，要确保在屏幕中两个偏移方向是互相垂直的，这样才能获得正确的新的裁剪空间的坐标，也才能获得正确的线段节点的uv值。还有要注意仿射变换和透视变换的区别，参考维基百科上的<a href=https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping>说明</a>，决定了uv在屏幕空间中是不是线性的。</p><p>当然三个数组可以合并成一个，不过也没那个必要就是了。</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/EqualWidthLineShader&quot;
{
    Properties
    {
        _OutlineColor (&quot;Outline Color&quot;, color) = (1.0, 1.0, 1.0, 1.0)
        _OutlineWidth(&quot;Outline Width&quot;, float) = 10.0
        _Sharpness(&quot;Sharpness&quot;, range(0, 0.99)) = 0.5
    }
    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

    StructuredBuffer&lt;float3&gt; _VerticesBuffer;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _Sharpness;

    static int vertexIndexes[] = 
    {
        0, 1, 1, 0, 1, 0
    };

    static float2 vertexOffsets[] = 
    {
        float2(-1, -1),
        float2(-1, 1),
        float2(-1, -1),
        float2(-1, -1),
        float2(-1, -1),
        float2(-1, 1),
    };

    static float2 vertexUVs[] = 
    {
        float2(0, 0),
        float2(1, 0),
        float2(1, 1),
        float2(0, 0),
        float2(1, 1),
        float2(0, 1),
    };

    struct Attributes
    {
        uint vertexID    : SV_VERTEXID;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float ratio         : TEXCOORD1;
    };

    Varyings Vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        int vertexID = input.vertexID % 6;
        int lineID = input.vertexID / 6;

        //获取较近的线段节点的世界坐标，和较远的线段节点的世界坐标
        float3 vertexPos = _VerticesBuffer[lineID + vertexIndexes[vertexID]];
        float3 anotherVert = _VerticesBuffer[lineID + 1 - vertexIndexes[vertexID]];
        //转换到裁剪空间
        float4 positionCS = mul(UNITY_MATRIX_VP, float4(vertexPos, 1.0));
        float4 anotherCS = mul(UNITY_MATRIX_VP, float4(anotherVert, 1.0));

        //Unity相机是看向Z轴负方向的，所以裁剪空间w分量小于0
        //这里就不需要用从远的节点减去近的节点了
        float2 offset = positionCS.xy / positionCS.w - anotherCS.xy / anotherCS.w;
        //得到长方形宽度
        float lengthOffset = length(offset);
        //要考虑到屏幕的比例
        float2 normalizedOffset = normalize(offset * (_ScreenParams.wz - 1.0));
        float2 pointOffset = vertexOffsets[vertexID];
        float2 pointOffsetX = float2(normalizedOffset.x, normalizedOffset.y) * pointOffset.x;
        float2 pointOffsetY = float2(-normalizedOffset.y, normalizedOffset.x) * pointOffset.y;

        //考虑到屏幕的比例，根据上面的两个Offset，得到新的裁剪空间的坐标
        float4 newClipPos = float4(-positionCS.w * (pointOffsetX + pointOffsetY) * (_ScreenParams.zw - 1.0) * _OutlineWidth, 0, 0) + positionCS;
        //算的不一定对，不过也大差不差了。。
        float lengthRadius = _OutlineWidth * length(pointOffsetX * (_ScreenParams.zw - 1.0));
        output.positionCS = newClipPos;
        //如果不乘上深度的话，会有透视变形的问题
        //https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping
        output.uv = vertexUVs[vertexID] * (-newClipPos.w);
        output.ratio = 2.0 * lengthRadius / (2.0 * lengthRadius + lengthOffset);
        return output;
    }

    float GetDist(float2 uv, float ratio)
    {
        uv.x = 0.5 - abs(0.5 - uv.x);
        float2 coord = float2(uv.x * rcp(ratio), uv.y);
        float2 center = float2(0.5, 0.5);
        float distToCenter = length(coord - center);
        float distToLine = abs(uv.y - 0.5);

        return coord.x &lt; 0.5 ? distToCenter : distToLine;
    }

    float4 Frag(Varyings input) : SV_TARGET
    {
        float2 uv = input.uv / (-input.positionCS.w);
        float distValue = GetDist(uv, input.ratio);
        //用smoothstep进行抗锯齿
        distValue = smoothstep(0.5, _Sharpness * 0.5, distValue);

        return float4(_OutlineColor.rgb, distValue * _OutlineColor.a);
    }

    ENDHLSL

    SubShader
    {
        Tags {&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot; }
        ZWrite Off
        Blend SrcAlpha OneMinusSrcAlpha
        
        Pass
        {
            HLSLPROGRAM
            #pragma vertex Vert
            #pragma fragment Frag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>我对目前的效果还是很满意的！也没看到有什么人做这个画线的操作（除了Shapes，当然我也没去搜索别的案例就是了）。感觉对绘制顶点时的处理和空间变换的理解又大大加深了！下一个目标就是描边的计算了，目前感觉上会和原始模型有深度测试的问题，只能走一步看一步了。</p><p>这段时间一直在思考景深和写ShaderToy，也算收获不少，不过没能写出博客来，拿这个等宽且抗锯齿的世界坐标直线来弥补一下。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><span class=title>« Prev</span><br><span>在Unity中绘制等宽的描边</span></a>
<a class=next href=https://zznewclear13.github.io/posts/gpu-color-inspector/><span class=title>Next »</span><br><span>GPU颜色查看器</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const b=document.getElementById('comments');let c=currentHugoTheme=='dark'?'photon-dark':'github-light',a=document.createElement('script');a.src='https://utteranc.es/client.js',a.setAttribute('repo','zznewclear13/zznewclear13.github.io'),a.setAttribute('issue-term','pathname'),a.setAttribute('label','utterances'),a.setAttribute('theme',c),a.setAttribute('crossorigin','anonymous'),a.setAttribute('async',''),b.innerHTML='',b.appendChild(a)}loadComment(),document.getElementById('theme-toggle').onclick=async()=>{await new Promise(a=>setTimeout(a,200));let a=window.localStorage.getItem('pref-theme');a!=currentHugoTheme&&(currentHugoTheme=a,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>