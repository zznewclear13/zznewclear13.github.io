<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š | ZZNEWCLEAR13</title>
<meta name=keywords content="Blur,Post-Process"><meta name=description content="ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š"><meta property="og:description" content="ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"><meta property="og:image" content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-29T12:00:00+08:00"><meta property="article:modified_time" content="2023-05-29T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png"><meta name=twitter:title content="å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š"><meta name=twitter:description content="ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š","item":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š","name":"å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š","description":"ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š.","keywords":["Blur","Post-Process"],"articleBody":"2023å¹´6æœˆ3æ—¥ä¿®è®¢ å‘ç°è¿˜æ˜¯åœ¨é™é‡‡æ ·å‡é‡‡æ ·åè¿›è¡Œçº¿æ€§æ’å€¼æ¥è·å–ä¸­é—´ç¨‹åº¦çš„æ¨¡ç³Šæ•ˆæœæ¯”è¾ƒå¥½ï¼Œæ‰€ä»¥åé¢çš„ä»£ç ä¹Ÿéƒ½æ”¹è¿‡æ¥äº†ï¼Œä¸è¿‡ç†è®ºä¸Šçš„éƒ¨åˆ†å€’æ˜¯æ²¡å¿…è¦æ”¹ã€‚é¡ºä¾¿ä¹ŸèŠ±äº†ç‚¹æ—¶é—´å†™äº†ä¸€ä¸ªShadertoyä½œä¸ºæ¼”ç¤ºï¼š\nDual Kawase Blur\nå†™è¿™ç¯‡æ–‡ç« çš„åŸå›  ç½‘ä¸Šå·²ç»æœ‰äº†å¾ˆå¤šå¾ˆå¤šçš„åŒKawaseæ¨¡ç³Šçš„ç°æˆçš„æ¡ˆä¾‹ï¼Œä½†æ˜¯å­˜åœ¨ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š1. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« éƒ½åªç»™äº†ä»£ç ï¼Œæ²¡æœ‰ç›¸åº”çš„è§£é‡Šï¼Œè‡³å¤šä¼šç»™ä¸€å¼ ç›´æ¥ä»Armçš„pdfæˆªå–çš„å›¾ç¤ºï¼Œè€Œè¿™å¼ å›¾ç¤ºç”»äº†ä¸€å †æ–¹æ¡†å’Œç¬¦å·ï¼Œå´æ²¡æœ‰è¯´æ˜è¿™äº›å›¾æ¡ˆä»£è¡¨çš„å«ä¹‰ã€‚2. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« é€šè¿‡ä¿®æ”¹é‡‡æ ·çš„è·ç¦»æ¥æ§åˆ¶æ¨¡ç³Šçš„ç¨‹åº¦ï¼Œè¿™ä¸ªçš„ç¼ºç‚¹æˆ‘ä»¬åç»­å†è°ˆã€‚3. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« å¹¶æ²¡æœ‰è€ƒè™‘æ¨¡ç³Šç¨‹åº¦ä»0å¼€å§‹é€æ¸å¢å¤§çš„åŠ¨æ€è¿‡ç¨‹ï¼Œä½¿ç”¨é™é‡‡æ ·å’Œå‡é‡‡æ ·å¾€å¾€ä¼šç ´åæ•´ä¸ªç”»é¢çš„è¿ç»­æ€§ã€‚\nå¦‚æœåªæ˜¯æƒ³è¦è·å¾—ä¸€ä¸ªæ¨¡ç³Šçš„ç”»é¢ï¼Œåªéœ€è¦åšå‡ æ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·å°±èƒ½å®Œæˆäº†ï¼Œä½†æˆ‘å¸Œæœ›èƒ½æœ‰ä¸€ä¸ªè¿ç»­åœ°é€æ¸åœ°å˜æ¨¡ç³Šçš„è¿‡ç¨‹ï¼Œå› æ­¤æˆ‘å¼€å§‹äº†é‡åŒ–åŒKawaseæ¨¡ç³Šçš„æƒ³æ³•ã€‚\nåŒKawaseæ¨¡ç³Š(Dual Kawase Blur) åŒKawaseæ¨¡ç³Šæ˜¯2015å¹´Armåœ¨Kawaseæ¨¡ç³Šçš„åŸºç¡€ä¸Šæå‡ºçš„ä¸€ç§é€šè¿‡é™é‡‡æ ·å’Œå‡é‡‡æ ·æ¥å¿«é€Ÿä¸”é«˜æ•ˆåœ°è¿›è¡Œé«˜è´¨é‡å¤§åŠå¾„æ¨¡ç³Šçš„ä¸€ç§æ–¹æ³•ï¼Œå…·ä½“çš„pdfå¯ä»¥ä»è¿™é‡Œæ‰¾åˆ°ã€‚\nè¿™é‡Œæ˜¯ä¸€å¼ åŒKawaseæ¨¡ç³Šçš„å›¾ç¤ºï¼Œè¡¨ç¤ºäº†åŒKawaseæ¨¡ç³Šåœ¨é™é‡‡æ ·å’Œå‡é‡‡æ ·æ—¶çš„æ“ä½œã€‚ç»†çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯åŸå§‹çš„åƒç´ ï¼ˆæˆ–æ˜¯å‡é‡‡æ ·åçš„åƒç´ ï¼‰ï¼Œç²—çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯é™é‡‡æ ·åçš„åƒç´ ã€‚å‰å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ ï¼Œåœ†å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ æ‰€éœ€è¦é‡‡æ ·ç‚¹ã€‚ç²‰è‰²å¯¹åº”çš„æ˜¯é™é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ï¼Œç»¿è‰²å¯¹åº”çš„æ˜¯å‡é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ã€‚\nä»è¿™å¼ å›¾ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°åŒKawaseæ¨¡ç³Šåˆ©ç”¨åŒçº¿æ€§é‡‡æ ·æ¥èŠ‚çœé‡‡æ ·æ•°çš„æ“ä½œã€‚åœ¨é™é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åå…­ä¸ªåƒç´ çš„é¢œè‰²ï¼›åœ¨å‡é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åä¸‰ä¸ªåƒç´ çš„é¢œè‰²ã€‚è€Œå¦‚æœåœ¨åšé™é‡‡æ ·æ—¶ï¼Œå¯¹äºå¥‡æ•°ä¸ªåƒç´ é™¤ä»¥äºŒå‘ä¸‹å–æ•´ï¼Œæˆ–è€…æ˜¯åœ¨é™é‡‡æ ·æ—¶ä½¿ç”¨äº†ä¸æ°å½“çš„åç§»ï¼ˆæ¯”å¦‚1.5å€çš„åç§»ï¼‰ï¼Œä¼šå¯¼è‡´é™é‡‡æ ·çš„é‡‡æ ·ç‚¹è½åœ¨åŸå§‹åƒç´ çš„ä¸­å¿ƒï¼Œè¿™æ—¶å³ä½¿ä½¿ç”¨äº†åŒçº¿æ€§é‡‡æ ·ï¼Œä¹Ÿåªç­‰ä»·äºé‡‡æ ·ä¸€ä¸ªåƒç´ ã€‚\nå› æ­¤ä¸ºäº†è®©æ¯ä¸€ä¸ªåƒç´ éƒ½èƒ½å¯¹æ¨¡ç³Šåšåˆ°åº”ç”¨çš„è´¡çŒ®ï¼Œä¸ºäº†è¾¾åˆ°æ¯”è¾ƒå¥½çš„æ¨¡ç³Šæ•ˆæœï¼Œæˆ‘ä»¬è¿™é‡Œé™åˆ¶åŒKawaseæ¨¡ç³Šçš„é‡‡æ ·åç§»ä¸ºä¸€å€ï¼ˆä¹Ÿå°±æ˜¯ä¸¥æ ¼æŒ‰ç…§é‡‡æ ·ç‚¹è¿›è¡Œæœ€ä¼˜çš„åŒçº¿æ€§é‡‡æ ·ï¼‰ã€‚è€Œé€šè¿‡å¤šæ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·è¾¾åˆ°åˆé€‚çš„æ¨¡ç³ŠåŠå¾„ã€‚\né‡åŒ–åŒKawaseæ¨¡ç³Š é™é‡‡æ ·å’Œå‡é‡‡æ ·æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œå°±æ˜¯åªè¦å‘ç”Ÿäº†é™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œå°±å¿…ç„¶ä¼šå¸¦æ¥æ¨¡ç³Šã€‚è¿™æ—¶æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯åœ¨åŸå§‹åˆ†è¾¨ç‡ä¸‹é€šè¿‡æ¶ˆè€—æ›´å¤§çš„æ–¹å¼è¿›è¡ŒåŠ æƒæ¨¡ç³Šæ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šé…åˆé™é‡‡æ ·å¸¦æ¥çš„æ¨¡ç³Šï¼›å¦ä¸€ç§æ˜¯åœ¨é›¶æ¬¡å’Œä¸€æ¬¡åŒKawaseä¹‹é—´çº¿æ€§æ’å€¼å¾—åˆ°ä¸€å¼ ä»‹äºä¸¤è€…ä¹‹é—´æ¨¡ç³Šç¨‹åº¦çš„å›¾åƒã€‚ç»¼åˆä¸¤è€…æ¥çœ‹ï¼Œçº¿æ€§æ’å€¼å¾—åˆ°çš„æ•ˆæœæ›´ä¸ºå¹³æ»‘ï¼Œæ•ˆæœä¸Šç¨â€œé”™è¯¯â€ä¸€äº›ï¼Œä½†å®Œå…¨åœ¨å¯æ¥å—çš„èŒƒå›´å†…ã€‚\næˆ‘è¿™è¾¹å†™äº†ä¸€ä¸ªå°å°çš„è„šæœ¬ï¼Œå»è®¡ç®—åŸå§‹åˆ†è¾¨ç‡ä¸‹å€¼ä¸º1çš„åƒç´ ç‚¹ï¼Œåœ¨ç»è¿‡ä¸€æ¬¡åŒKawaseæ¨¡ç³Šåï¼Œå…¶ä»–åƒç´ çš„å€¼ã€‚é€šè¿‡å¤šé¡¹å¼æ‹Ÿåˆè¿™äº›æ¨¡ç³Šåçš„å€¼ï¼Œå°±èƒ½åˆ©ç”¨è¿™äº›å€¼æ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šçš„æ•ˆæœäº†ã€‚æˆ‘è¿™è¾¹å¯¹8x8çš„åƒç´ åšäº†è®¡ç®—ï¼ˆå®é™…ä¸Šæ¨¡ç³Šçš„æ ¸å¿ƒåº”è¯¥æ›´å¤§ä¸€äº›ï¼Œä¸è¿‡æˆ‘æ‡’å¾—æ”¹ä¹‹å‰çš„ä»£ç äº†ï¼‰ã€‚è®¡ç®—å‡ºçš„æƒé‡å¦‚ä¸‹ï¼š\n0.0003255208\t0.001464844\t0.003092448\t0.004231771\t0.004231771\t0.003092448\t0.001464844\t0.0003255208\t0.001464844\t0.004882813\t0.009440104\t0.01204427\t0.01074219\t0.007486979\t0.004231771\t0.001464844\t0.004394531\t0.01334635\t0.02311198\t0.02701823\t0.0218099\t0.01334635\t0.007486979\t0.003092448\t0.01009115\t0.02571615\t0.03808594\t0.04329427\t0.03678386\t0.0218099\t0.01074219\t0.004231771\t0.01529948\t0.03222656\t0.04069011\t0.04589844\t0.04329427\t0.02701823\t0.01204427\t0.004231771\t0.01416016\t0.0296224\t0.03678386\t0.04069011\t0.03808594\t0.02311198\t0.009440104\t0.003092448\t0.007324219\t0.01985677\t0.0296224\t0.03222656\t0.02571615\t0.01334635\t0.004882813\t0.001464844\t0.001627604\t0.007324219\t0.01416016\t0.01529948\t0.01009115\t0.004394531\t0.001464844\t0.0003255208\tç„¶åæˆ‘æŠŠå®ƒä¸¢è¿›äº†Excelå¼ºè¡Œè¿›è¡Œäº†ä¸€æ³¢è¿ç®—å¹¶æ‰‹åŠ¨è°ƒæ•´äº†ä¸€ä¸‹ï¼Œå¾—å‡ºäº†ä¸‹é¢è¿™ä¸ªæ‹Ÿåˆçš„å…¬å¼ï¼ˆxèŒƒå›´å¤§è‡´åœ¨[-4, 4]ä¹‹é—´ï¼Œå€¼å¹¶æœªå½’ä¸€åŒ–ï¼‰ï¼š\n// Approximate dual kawase blur with 4th degree polynomial. // -3.5 \u003c= x \u003c= 3.5 (idealy) float getWeight(float x) { return 0.1356f * x * x * x * x - 0.06748 * x * x * x - 4.693656 * x * x + 0.9954208 * x + 45.57338; } å…·ä½“çš„æ“ä½œ æ¥ä¸‹æ¥æˆ‘ä»¬å°±èƒ½æ ¹æ®æ‹Ÿåˆçš„å…¬å¼æ¥è¿›è¡Œå‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Šäº†ã€‚é€šè¿‡è®¡ç®—ä»¥äºŒä¸ºåº•çš„å¯¹æ•°ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬éœ€è¦è¿›è¡Œå¤šå°‘æ¬¡é™é‡‡æ ·ï¼Œè€Œå…¶å°æ•°éƒ¨åˆ†åˆ™ä»£è¡¨ç€è¿›è¡Œé€¼è¿‘ä¸‹ä¸€æ¬¡åŒKawaseæ¨¡ç³Šçš„ç¨‹åº¦ï¼Œå¯¹åº”æ¨¡ç³Šçš„offsetå€¼ã€‚\nDualKawaseBlurComputeShader.compute è¿™é‡Œå°±æ‡’å¾—å¯¹åŒKawaseæ¨¡ç³Šé‚£ä¸€éƒ¨åˆ†å†™group shared memoryçš„ä¼˜åŒ–äº†ã€‚THREAD_GROUP_SIZEéœ€è¦æ˜¯BLUR_RADIUSçš„å››å€ä»¥ä¸Šï¼Œä¸ç„¶ç¼“å­˜çš„æ—¶å€™æ¯ä¸ªåƒç´ éœ€è¦é‡‡æ›´å¤šçš„æ ·ã€‚BLUR_RADIUSå®é™…ä¸Šæ˜¯4ä½†è¿™è¾¹å†™äº†5ï¼Œæ˜¯å› ä¸ºéœ€è¦é¢å¤–é¢„ç•™ä¸€ä¸ªåƒç´ è¿›è¡Œæ‰‹åŠ¨çš„åŒçº¿æ€§é‡‡æ ·ã€‚\n#pragma kernel KawaseDownSample #pragma kernel KawaseUpSample #pragma kernel KawaseLinear Texture2D\u003cfloat4\u003e _SourceTexture; RWTexture2D\u003cfloat4\u003e _RW_TargetTexture; SamplerState sampler_LinearClamp; float4 _SourceSize; float4 _TargetSize; float _Offset; float3 sampleSource(float2 center, float2 offset) { return _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset * _Offset, 0.0f).rgb; } [numthreads(8,8,1)] void KawaseDownSample(uint3 id : SV_DispatchThreadID) { float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw; float2 halfPixel = 0.5f * _TargetSize.zw; float3 c = sampleSource(uv, float2(0.0f, 0.0f)); float3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f)); float3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f)); float3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f)); float3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f)); float3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f; _RW_TargetTexture[id.xy] = float4(color, 1.0f); } [numthreads(8, 8, 1)] void KawaseUpSample(uint3 id : SV_DispatchThreadID) { float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw; float2 onePixel = 1.0f * _TargetSize.zw; // float3 c = sampleSource(uv, float2(0.0f, 0.0f)); float3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f)); float3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f)); float3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f)); float3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f)); float3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f)); float3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f)); float3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f)); float3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f)); float3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f; _RW_TargetTexture[id.xy] = float4(color, 1.0f); } [numthreads(8, 8, 1)] void KawaseLinear(uint3 id : SV_DispatchThreadID) { half3 sourceTex = _SourceTexture.Load(uint3(id.xy, 0)).rgb; half3 blurredTex = _RW_TargetTexture.Load(uint3(id.xy, 0)).rgb; half3 color = lerp(sourceTex, blurredTex, _Offset); _RW_TargetTexture[id.xy] = float4(color, 1.0f); } DualKawaseBlurRenderPass.cs è¿™é‡Œéœ€è¦å¯¹æœ€åä¸€æ¬¡é™é‡‡æ ·åšä¸€æ¬¡æ‹Ÿåˆçš„æ“ä½œï¼Œç„¶åè¿˜è¦æ³¨æ„ä¸€æ¬¡éƒ½ä¸è¿›è¡Œé™é‡‡æ ·æ—¶ä¹Ÿéœ€è¦è¿›è¡Œæ‹Ÿåˆã€‚ä½¿ç”¨çš„Unityç‰ˆæœ¬æ˜¯2021.3.19f1c1ï¼ŒURPç‰ˆæœ¬æ˜¯12.1.10ï¼Œå› æ­¤ä¼šæœ‰_CameraColorAttachmentAè¿™æ ·å¥‡æ€ªçš„åå­—ã€‚\nusing System.Collections.Generic; namespace UnityEngine.Rendering.Universal { public class DualKawaseBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Circular Blur Render Pass\"; private DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings; private DualKawaseBlur dualKawaseBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); private RenderTargetIdentifier cameraColorIden; private Vector2Int textureSize; private RenderTextureDescriptor desc; public DualKawaseBlurRenderPass(DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); } public void Setup(DualKawaseBlur dualKawaseBlur) { this.dualKawaseBlur = dualKawaseBlur; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoKawaseSample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, Vector2Int targetSize, float offset, bool downSample, ComputeShader computeShader) { if (!computeShader) return; string kernelName = downSample ? \"KawaseDownSample\" : \"KawaseUpSample\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeVectorParam(computeShader, \"_TargetSize\", GetTextureSizeParams(targetSize)); cmd.SetComputeFloatParam(computeShader, \"_Offset\", offset); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)targetSize.x / x), Mathf.CeilToInt((float)targetSize.y / y), 1); } private void DoKawaseLinear(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, float offset, ComputeShader computeShader) { if (!computeShader) return; string kernelName = \"KawaseLinear\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeFloatParam(computeShader, \"_Offset\", offset); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)sourceSize.x / x), Mathf.CeilToInt((float)sourceSize.y / y), 1); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { List\u003cint\u003e rtIDs = new List\u003cint\u003e(); List rtSizes = new List(); RenderTextureDescriptor tempDesc = desc; string kawaseRT = \"_KawaseRT\"; int kawaseRTID = Shader.PropertyToID(kawaseRT); cmd.GetTemporaryRT(kawaseRTID, tempDesc); rtIDs.Add(kawaseRTID); rtSizes.Add(textureSize); float downSampleAmount = Mathf.Log(dualKawaseBlur.GetRadius() + 1.0f) / 0.693147181f; int downSampleCount = Mathf.FloorToInt(downSampleAmount); float offsetRatio = downSampleAmount - (float)downSampleCount; Vector2Int lastSize = textureSize; int lastID = cameraColorTextureID; for (int i = 0; i \u003c= downSampleCount; i++) { string rtName = \"_KawaseRT\" + i.ToString(); int rtID = Shader.PropertyToID(rtName); Vector2Int rtSize = new Vector2Int((lastSize.x + 1) / 2, (lastSize.y + 1) / 2); tempDesc.width = rtSize.x; tempDesc.height = rtSize.y; cmd.GetTemporaryRT(rtID, tempDesc); rtIDs.Add(rtID); rtSizes.Add(rtSize); DoKawaseSample(cmd, lastID, rtID, lastSize, rtSize, 1.0f, true, computeShader); lastSize = rtSize; lastID = rtID; } if(downSampleCount == 0) { DoKawaseSample(cmd, rtIDs[1], rtIDs[0], rtSizes[1], rtSizes[0], 1.0f, false, computeShader); DoKawaseLinear(cmd, cameraColorIden, rtIDs[0], rtSizes[0], offsetRatio, computeShader); } else { string intermediateRTName = \"_KawaseRT\" + (downSampleCount + 1).ToString(); int intermediateRTID = Shader.PropertyToID(intermediateRTName); Vector2Int intermediateRTSize = rtSizes[downSampleCount]; tempDesc.width = intermediateRTSize.x; tempDesc.height = intermediateRTSize.y; cmd.GetTemporaryRT(intermediateRTID, tempDesc); for (int i = downSampleCount+1; i \u003e= 1; i--) { int sourceID = rtIDs[i]; Vector2Int sourceSize = rtSizes[i]; int targetID = i == (downSampleCount + 1) ? intermediateRTID : rtIDs[i - 1]; Vector2Int targetSize = rtSizes[i - 1]; DoKawaseSample(cmd, sourceID, targetID, sourceSize, targetSize, 1.0f, false, computeShader); if (i == (downSampleCount + 1)) { DoKawaseLinear(cmd, rtIDs[i - 1], intermediateRTID, targetSize, offsetRatio, computeShader); int tempID = intermediateRTID; intermediateRTID = rtIDs[i - 1]; rtIDs[i - 1] = tempID; } cmd.ReleaseTemporaryRT(sourceID); } cmd.ReleaseTemporaryRT(intermediateRTID); } cmd.Blit(kawaseRTID, cameraColorIden); cmd.ReleaseTemporaryRT(kawaseRTID); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } } } DualKawaseBlur.cs æ²¡å•¥å¥½è¯´çš„\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Dual Kawase Blur\", typeof(UniversalRenderPipeline))] public class DualKawaseBlur : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter maxRadius = new ClampedFloatParameter(32.0f, 0.0f, 255.0f); public ClampedFloatParameter intensity = new ClampedFloatParameter(0.0f, 0.0f, 1.0f); public float GetRadius() { return maxRadius.value * intensity.value; } public bool IsActive() { return isEnabled.value \u0026\u0026 intensity.value \u003e 0.0f; } public bool IsTileCompatible() { return false; } } } DualKawaseBlurRendererFeature.cs ä¹Ÿæ²¡å•¥å¥½è¯´çš„ã€‚\nusing System.Collections; namespace UnityEngine.Rendering.Universal { public class DualKawaseBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class DualKawaseBlurSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader computeShader; } public DualKawaseBlurSettings settings = new DualKawaseBlurSettings(); private DualKawaseBlurRenderPass dualKawaseBlurRenderPass; public override void Create() { dualKawaseBlurRenderPass = new DualKawaseBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { DualKawaseBlur dualKawaseBlur = VolumeManager.instance.stack.GetComponent(); if (dualKawaseBlur != null \u0026\u0026 dualKawaseBlur.IsActive()) { dualKawaseBlurRenderPass.Setup(dualKawaseBlur); renderer.EnqueuePass(dualKawaseBlurRenderPass); } } } } åè®° è¿…é€Ÿåœ°å†™å®Œäº†è¿™ç¯‡åšå®¢ï¼Œå…¶å®æœ‰ä»·å€¼çš„ä¸œè¥¿å¹¶ä¸æ˜¯å¤ªå¤šã€‚ä¸»è¦æ˜¯åœ¨ç½‘ä¸Šæœç´¢äº†åŠå¤©ï¼Œåªæœ‰å‡ ä¹åƒç¯‡ä¸€å¾‹çš„ä»£ç å’Œåƒç¯‡ä¸€å¾‹çš„ç¤ºæ„å›¾ï¼Œå¹¶æ²¡æœ‰å¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå› æ­¤è‡ªå·±åšäº†ä¸€äº›ç ”ç©¶ã€‚ä¸å¾—ä¸è¯´Dual Kawase Bluråšå¾—è¿˜æ˜¯å¾ˆèªæ˜çš„ï¼Œæœ€åæ¨¡ç³Šçš„æ•ˆæœä¹Ÿçœ‹ä¸å‡ºä»€ä¹ˆæ˜æ˜¾çš„æ–¹å½¢çš„ç—•è¿¹ã€‚\n","wordCount":"1077","inLanguage":"en","image":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png","datePublished":"2023-05-29T12:00:00+08:00","dateModified":"2023-05-29T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</h1><div class=post-description>ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š.</div><div class=post-meta><span title='2023-05-29 12:00:00 +0800 CST'>May 29, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/almost-continuous-dual-kawase-blur.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/DualKawaseBlur.png alt="Dual Kawase Blur Cover"><p>Dual Kawase Blur Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</div></summary><div class=inner><ul><li><a href=#2023%e5%b9%b46%e6%9c%883%e6%97%a5%e4%bf%ae%e8%ae%a2 aria-label=2023å¹´6æœˆ3æ—¥ä¿®è®¢>2023å¹´6æœˆ3æ—¥ä¿®è®¢</a></li><li><a href=#%e5%86%99%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=å†™è¿™ç¯‡æ–‡ç« çš„åŸå› >å†™è¿™ç¯‡æ–‡ç« çš„åŸå› </a></li><li><a href=#%e5%8f%8ckawase%e6%a8%a1%e7%b3%8adual-kawase-blur aria-label="åŒKawaseæ¨¡ç³Š(Dual Kawase Blur)">åŒKawaseæ¨¡ç³Š(Dual Kawase Blur)</a></li><li><a href=#%e9%87%8f%e5%8c%96%e5%8f%8ckawase%e6%a8%a1%e7%b3%8a aria-label=é‡åŒ–åŒKawaseæ¨¡ç³Š>é‡åŒ–åŒKawaseæ¨¡ç³Š</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=å…·ä½“çš„æ“ä½œ>å…·ä½“çš„æ“ä½œ</a><ul><li><a href=#dualkawaseblurcomputeshadercompute aria-label=DualKawaseBlurComputeShader.compute>DualKawaseBlurComputeShader.compute</a></li><li><a href=#dualkawaseblurrenderpasscs aria-label=DualKawaseBlurRenderPass.cs>DualKawaseBlurRenderPass.cs</a></li><li><a href=#dualkawaseblurcs aria-label=DualKawaseBlur.cs>DualKawaseBlur.cs</a></li><li><a href=#dualkawaseblurrendererfeaturecs aria-label=DualKawaseBlurRendererFeature.cs>DualKawaseBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=2023å¹´6æœˆ3æ—¥ä¿®è®¢>2023å¹´6æœˆ3æ—¥ä¿®è®¢<a hidden class=anchor aria-hidden=true href=#2023å¹´6æœˆ3æ—¥ä¿®è®¢>#</a></h2><p>å‘ç°è¿˜æ˜¯åœ¨é™é‡‡æ ·å‡é‡‡æ ·åè¿›è¡Œçº¿æ€§æ’å€¼æ¥è·å–ä¸­é—´ç¨‹åº¦çš„æ¨¡ç³Šæ•ˆæœæ¯”è¾ƒå¥½ï¼Œæ‰€ä»¥åé¢çš„ä»£ç ä¹Ÿéƒ½æ”¹è¿‡æ¥äº†ï¼Œä¸è¿‡ç†è®ºä¸Šçš„éƒ¨åˆ†å€’æ˜¯æ²¡å¿…è¦æ”¹ã€‚é¡ºä¾¿ä¹ŸèŠ±äº†ç‚¹æ—¶é—´å†™äº†ä¸€ä¸ªShadertoyä½œä¸ºæ¼”ç¤ºï¼š</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/ct3Szl?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Dual Kawase Blur</p></figure><h2 id=å†™è¿™ç¯‡æ–‡ç« çš„åŸå› >å†™è¿™ç¯‡æ–‡ç« çš„åŸå› <a hidden class=anchor aria-hidden=true href=#å†™è¿™ç¯‡æ–‡ç« çš„åŸå› >#</a></h2><p>ç½‘ä¸Šå·²ç»æœ‰äº†å¾ˆå¤šå¾ˆå¤šçš„åŒKawaseæ¨¡ç³Šçš„ç°æˆçš„æ¡ˆä¾‹ï¼Œä½†æ˜¯å­˜åœ¨ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š1. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« éƒ½åªç»™äº†ä»£ç ï¼Œæ²¡æœ‰ç›¸åº”çš„è§£é‡Šï¼Œè‡³å¤šä¼šç»™ä¸€å¼ ç›´æ¥ä»Armçš„pdfæˆªå–çš„å›¾ç¤ºï¼Œè€Œè¿™å¼ å›¾ç¤ºç”»äº†ä¸€å †æ–¹æ¡†å’Œç¬¦å·ï¼Œå´æ²¡æœ‰è¯´æ˜è¿™äº›å›¾æ¡ˆä»£è¡¨çš„å«ä¹‰ã€‚2. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« é€šè¿‡ä¿®æ”¹é‡‡æ ·çš„è·ç¦»æ¥æ§åˆ¶æ¨¡ç³Šçš„ç¨‹åº¦ï¼Œè¿™ä¸ªçš„ç¼ºç‚¹æˆ‘ä»¬åç»­å†è°ˆã€‚3. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« å¹¶æ²¡æœ‰è€ƒè™‘æ¨¡ç³Šç¨‹åº¦ä»0å¼€å§‹é€æ¸å¢å¤§çš„åŠ¨æ€è¿‡ç¨‹ï¼Œä½¿ç”¨é™é‡‡æ ·å’Œå‡é‡‡æ ·å¾€å¾€ä¼šç ´åæ•´ä¸ªç”»é¢çš„è¿ç»­æ€§ã€‚</p><p>å¦‚æœåªæ˜¯æƒ³è¦è·å¾—ä¸€ä¸ªæ¨¡ç³Šçš„ç”»é¢ï¼Œåªéœ€è¦åšå‡ æ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·å°±èƒ½å®Œæˆäº†ï¼Œä½†æˆ‘å¸Œæœ›èƒ½æœ‰ä¸€ä¸ªè¿ç»­åœ°é€æ¸åœ°å˜æ¨¡ç³Šçš„è¿‡ç¨‹ï¼Œå› æ­¤æˆ‘å¼€å§‹äº†é‡åŒ–åŒKawaseæ¨¡ç³Šçš„æƒ³æ³•ã€‚</p><h2 id=åŒkawaseæ¨¡ç³Šdual-kawase-blur>åŒKawaseæ¨¡ç³Š(Dual Kawase Blur)<a hidden class=anchor aria-hidden=true href=#åŒkawaseæ¨¡ç³Šdual-kawase-blur>#</a></h2><p>åŒKawaseæ¨¡ç³Šæ˜¯2015å¹´Armåœ¨Kawaseæ¨¡ç³Šçš„åŸºç¡€ä¸Šæå‡ºçš„ä¸€ç§é€šè¿‡é™é‡‡æ ·å’Œå‡é‡‡æ ·æ¥å¿«é€Ÿä¸”é«˜æ•ˆåœ°è¿›è¡Œé«˜è´¨é‡å¤§åŠå¾„æ¨¡ç³Šçš„ä¸€ç§æ–¹æ³•ï¼Œå…·ä½“çš„pdfå¯ä»¥ä»<a href=https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_slides.pdf>è¿™é‡Œ</a>æ‰¾åˆ°ã€‚</p><p><img loading=lazy src=../images/DualKawaseBlurDiagram.jpg#center alt="Dual Kawase Blur Diagram"></p><p>è¿™é‡Œæ˜¯ä¸€å¼ åŒKawaseæ¨¡ç³Šçš„å›¾ç¤ºï¼Œè¡¨ç¤ºäº†åŒKawaseæ¨¡ç³Šåœ¨é™é‡‡æ ·å’Œå‡é‡‡æ ·æ—¶çš„æ“ä½œã€‚ç»†çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯åŸå§‹çš„åƒç´ ï¼ˆæˆ–æ˜¯å‡é‡‡æ ·åçš„åƒç´ ï¼‰ï¼Œç²—çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯é™é‡‡æ ·åçš„åƒç´ ã€‚å‰å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ ï¼Œåœ†å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ æ‰€éœ€è¦é‡‡æ ·ç‚¹ã€‚ç²‰è‰²å¯¹åº”çš„æ˜¯é™é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ï¼Œç»¿è‰²å¯¹åº”çš„æ˜¯å‡é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ã€‚</p><p>ä»è¿™å¼ å›¾ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°åŒKawaseæ¨¡ç³Šåˆ©ç”¨åŒçº¿æ€§é‡‡æ ·æ¥èŠ‚çœé‡‡æ ·æ•°çš„æ“ä½œã€‚åœ¨é™é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åå…­ä¸ªåƒç´ çš„é¢œè‰²ï¼›åœ¨å‡é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åä¸‰ä¸ªåƒç´ çš„é¢œè‰²ã€‚è€Œå¦‚æœåœ¨åšé™é‡‡æ ·æ—¶ï¼Œå¯¹äºå¥‡æ•°ä¸ªåƒç´ é™¤ä»¥äºŒå‘ä¸‹å–æ•´ï¼Œæˆ–è€…æ˜¯åœ¨é™é‡‡æ ·æ—¶ä½¿ç”¨äº†ä¸æ°å½“çš„åç§»ï¼ˆæ¯”å¦‚1.5å€çš„åç§»ï¼‰ï¼Œä¼šå¯¼è‡´é™é‡‡æ ·çš„é‡‡æ ·ç‚¹è½åœ¨åŸå§‹åƒç´ çš„ä¸­å¿ƒï¼Œè¿™æ—¶å³ä½¿ä½¿ç”¨äº†åŒçº¿æ€§é‡‡æ ·ï¼Œä¹Ÿåªç­‰ä»·äºé‡‡æ ·ä¸€ä¸ªåƒç´ ã€‚</p><p>å› æ­¤ä¸ºäº†è®©æ¯ä¸€ä¸ªåƒç´ éƒ½èƒ½å¯¹æ¨¡ç³Šåšåˆ°åº”ç”¨çš„è´¡çŒ®ï¼Œä¸ºäº†è¾¾åˆ°æ¯”è¾ƒå¥½çš„æ¨¡ç³Šæ•ˆæœï¼Œæˆ‘ä»¬è¿™é‡Œé™åˆ¶åŒKawaseæ¨¡ç³Šçš„é‡‡æ ·åç§»ä¸ºä¸€å€ï¼ˆä¹Ÿå°±æ˜¯ä¸¥æ ¼æŒ‰ç…§é‡‡æ ·ç‚¹è¿›è¡Œæœ€ä¼˜çš„åŒçº¿æ€§é‡‡æ ·ï¼‰ã€‚è€Œé€šè¿‡å¤šæ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·è¾¾åˆ°åˆé€‚çš„æ¨¡ç³ŠåŠå¾„ã€‚</p><h2 id=é‡åŒ–åŒkawaseæ¨¡ç³Š>é‡åŒ–åŒKawaseæ¨¡ç³Š<a hidden class=anchor aria-hidden=true href=#é‡åŒ–åŒkawaseæ¨¡ç³Š>#</a></h2><p>é™é‡‡æ ·å’Œå‡é‡‡æ ·æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œå°±æ˜¯åªè¦å‘ç”Ÿäº†é™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œå°±å¿…ç„¶ä¼šå¸¦æ¥æ¨¡ç³Šã€‚è¿™æ—¶æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯åœ¨åŸå§‹åˆ†è¾¨ç‡ä¸‹é€šè¿‡æ¶ˆè€—æ›´å¤§çš„æ–¹å¼è¿›è¡ŒåŠ æƒæ¨¡ç³Šæ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šé…åˆé™é‡‡æ ·å¸¦æ¥çš„æ¨¡ç³Šï¼›å¦ä¸€ç§æ˜¯åœ¨é›¶æ¬¡å’Œä¸€æ¬¡åŒKawaseä¹‹é—´çº¿æ€§æ’å€¼å¾—åˆ°ä¸€å¼ ä»‹äºä¸¤è€…ä¹‹é—´æ¨¡ç³Šç¨‹åº¦çš„å›¾åƒã€‚ç»¼åˆä¸¤è€…æ¥çœ‹ï¼Œçº¿æ€§æ’å€¼å¾—åˆ°çš„æ•ˆæœæ›´ä¸ºå¹³æ»‘ï¼Œæ•ˆæœä¸Šç¨â€œé”™è¯¯â€ä¸€äº›ï¼Œä½†å®Œå…¨åœ¨å¯æ¥å—çš„èŒƒå›´å†…ã€‚</p><p>æˆ‘è¿™è¾¹å†™äº†ä¸€ä¸ªå°å°çš„è„šæœ¬ï¼Œå»è®¡ç®—åŸå§‹åˆ†è¾¨ç‡ä¸‹å€¼ä¸º1çš„åƒç´ ç‚¹ï¼Œåœ¨ç»è¿‡ä¸€æ¬¡åŒKawaseæ¨¡ç³Šåï¼Œå…¶ä»–åƒç´ çš„å€¼ã€‚é€šè¿‡å¤šé¡¹å¼æ‹Ÿåˆè¿™äº›æ¨¡ç³Šåçš„å€¼ï¼Œå°±èƒ½åˆ©ç”¨è¿™äº›å€¼æ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šçš„æ•ˆæœäº†ã€‚æˆ‘è¿™è¾¹å¯¹8x8çš„åƒç´ åšäº†è®¡ç®—ï¼ˆå®é™…ä¸Šæ¨¡ç³Šçš„æ ¸å¿ƒåº”è¯¥æ›´å¤§ä¸€äº›ï¼Œä¸è¿‡æˆ‘æ‡’å¾—æ”¹ä¹‹å‰çš„ä»£ç äº†ï¼‰ã€‚è®¡ç®—å‡ºçš„æƒé‡å¦‚ä¸‹ï¼š</p><pre tabindex=0><code>0.0003255208	0.001464844	0.003092448	0.004231771	0.004231771	0.003092448	0.001464844	0.0003255208	
0.001464844	0.004882813	0.009440104	0.01204427	0.01074219	0.007486979	0.004231771	0.001464844	
0.004394531	0.01334635	0.02311198	0.02701823	0.0218099	0.01334635	0.007486979	0.003092448	
0.01009115	0.02571615	0.03808594	0.04329427	0.03678386	0.0218099	0.01074219	0.004231771	
0.01529948	0.03222656	0.04069011	0.04589844	0.04329427	0.02701823	0.01204427	0.004231771	
0.01416016	0.0296224	0.03678386	0.04069011	0.03808594	0.02311198	0.009440104	0.003092448	
0.007324219	0.01985677	0.0296224	0.03222656	0.02571615	0.01334635	0.004882813	0.001464844	
0.001627604	0.007324219	0.01416016	0.01529948	0.01009115	0.004394531	0.001464844	0.0003255208	
</code></pre><p>ç„¶åæˆ‘æŠŠå®ƒä¸¢è¿›äº†Excelå¼ºè¡Œè¿›è¡Œäº†ä¸€æ³¢è¿ç®—å¹¶æ‰‹åŠ¨è°ƒæ•´äº†ä¸€ä¸‹ï¼Œå¾—å‡ºäº†ä¸‹é¢è¿™ä¸ªæ‹Ÿåˆçš„å…¬å¼ï¼ˆxèŒƒå›´å¤§è‡´åœ¨[-4, 4]ä¹‹é—´ï¼Œå€¼å¹¶æœªå½’ä¸€åŒ–ï¼‰ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>// Approximate dual kawase blur with 4th degree polynomial.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -3.5 &lt;= x &lt;= 3.5 (idealy)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> getWeight(<span style=color:#66d9ef>float</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.1356f</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.06748</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>-</span> <span style=color:#ae81ff>4.693656</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.9954208</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>45.57338</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=å…·ä½“çš„æ“ä½œ>å…·ä½“çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„æ“ä½œ>#</a></h2><p>æ¥ä¸‹æ¥æˆ‘ä»¬å°±èƒ½æ ¹æ®æ‹Ÿåˆçš„å…¬å¼æ¥è¿›è¡Œå‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Šäº†ã€‚é€šè¿‡è®¡ç®—ä»¥äºŒä¸ºåº•çš„å¯¹æ•°ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬éœ€è¦è¿›è¡Œå¤šå°‘æ¬¡é™é‡‡æ ·ï¼Œè€Œå…¶å°æ•°éƒ¨åˆ†åˆ™ä»£è¡¨ç€è¿›è¡Œé€¼è¿‘ä¸‹ä¸€æ¬¡åŒKawaseæ¨¡ç³Šçš„ç¨‹åº¦ï¼Œå¯¹åº”æ¨¡ç³Šçš„offsetå€¼ã€‚</p><h3 id=dualkawaseblurcomputeshadercompute>DualKawaseBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#dualkawaseblurcomputeshadercompute>#</a></h3><p>è¿™é‡Œå°±æ‡’å¾—å¯¹åŒKawaseæ¨¡ç³Šé‚£ä¸€éƒ¨åˆ†å†™group shared memoryçš„ä¼˜åŒ–äº†ã€‚<code>THREAD_GROUP_SIZE</code>éœ€è¦æ˜¯<code>BLUR_RADIUS</code>çš„å››å€ä»¥ä¸Šï¼Œä¸ç„¶ç¼“å­˜çš„æ—¶å€™æ¯ä¸ªåƒç´ éœ€è¦é‡‡æ›´å¤šçš„æ ·ã€‚<code>BLUR_RADIUS</code>å®é™…ä¸Šæ˜¯4ä½†è¿™è¾¹å†™äº†5ï¼Œæ˜¯å› ä¸ºéœ€è¦é¢å¤–é¢„ç•™ä¸€ä¸ªåƒç´ è¿›è¡Œæ‰‹åŠ¨çš„åŒçº¿æ€§é‡‡æ ·ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel KawaseDownSample</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel KawaseUpSample</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel KawaseLinear</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _SourceTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_TargetTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_LinearClamp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _SourceSize;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TargetSize;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _Offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> sampleSource(<span style=color:#66d9ef>float2</span> center, <span style=color:#66d9ef>float2</span> offset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> _SourceTexture.SampleLevel(sampler_LinearClamp, center <span style=color:#f92672>+</span> offset <span style=color:#f92672>*</span> _Offset, <span style=color:#ae81ff>0.0f</span>).rgb;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> KawaseDownSample(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float2</span>(id.xy) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> _TargetSize.zw;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float2</span> halfPixel <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> _TargetSize.zw;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> c <span style=color:#f92672>=</span> sampleSource(uv, <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> tl <span style=color:#f92672>=</span> sampleSource(uv, halfPixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> tr <span style=color:#f92672>=</span> sampleSource(uv, halfPixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> bl <span style=color:#f92672>=</span> sampleSource(uv, halfPixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> br <span style=color:#f92672>=</span> sampleSource(uv, halfPixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> (tl <span style=color:#f92672>+</span> tr <span style=color:#f92672>+</span> bl <span style=color:#f92672>+</span> br <span style=color:#f92672>+</span> c <span style=color:#f92672>*</span> <span style=color:#ae81ff>4.0f</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>8.0f</span>;
</span></span><span style=display:flex><span>	_RW_TargetTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> KawaseUpSample(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float2</span>(id.xy) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> _TargetSize.zw;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float2</span> onePixel <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>*</span> _TargetSize.zw;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// float3 c = sampleSource(uv, float2(0.0f, 0.0f));</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> t2 <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>0.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>2.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> b2 <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>0.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> l2 <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> r2 <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>2.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> tl <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> tr <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> bl <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> br <span style=color:#f92672>=</span> sampleSource(uv, onePixel <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> (t2 <span style=color:#f92672>+</span> b2 <span style=color:#f92672>+</span> l2 <span style=color:#f92672>+</span> r2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>2.0f</span> <span style=color:#f92672>*</span> (tl <span style=color:#f92672>+</span> tr <span style=color:#f92672>+</span> bl <span style=color:#f92672>+</span> br)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>12.0f</span>;
</span></span><span style=display:flex><span>	_RW_TargetTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> KawaseLinear(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>half3</span> sourceTex <span style=color:#f92672>=</span> _SourceTexture.Load(<span style=color:#66d9ef>uint3</span>(id.xy, <span style=color:#ae81ff>0</span>)).rgb;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>half3</span> blurredTex <span style=color:#f92672>=</span> _RW_TargetTexture.Load(<span style=color:#66d9ef>uint3</span>(id.xy, <span style=color:#ae81ff>0</span>)).rgb;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> lerp(sourceTex, blurredTex, _Offset);
</span></span><span style=display:flex><span>	_RW_TargetTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dualkawaseblurrenderpasscs>DualKawaseBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurrenderpasscs>#</a></h3><p>è¿™é‡Œéœ€è¦å¯¹æœ€åä¸€æ¬¡é™é‡‡æ ·åšä¸€æ¬¡æ‹Ÿåˆçš„æ“ä½œï¼Œç„¶åè¿˜è¦æ³¨æ„ä¸€æ¬¡éƒ½ä¸è¿›è¡Œé™é‡‡æ ·æ—¶ä¹Ÿéœ€è¦è¿›è¡Œæ‹Ÿåˆã€‚ä½¿ç”¨çš„Unityç‰ˆæœ¬æ˜¯2021.3.19f1c1ï¼ŒURPç‰ˆæœ¬æ˜¯12.1.10ï¼Œå› æ­¤ä¼šæœ‰<code>_CameraColorAttachmentA</code>è¿™æ ·å¥‡æ€ªçš„åå­—ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Circular Blur Render Pass&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DualKawaseBlur dualKawaseBlur;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTextureDescriptor desc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> DualKawaseBlurRenderPass(DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            computeShader = settings.computeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(DualKawaseBlur dualKawaseBlur)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.dualKawaseBlur = dualKawaseBlur;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
</span></span><span style=display:flex><span>            desc = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoKawaseSample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
</span></span><span style=display:flex><span>                                        Vector2Int sourceSize, Vector2Int targetSize,
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>float</span> offset, <span style=color:#66d9ef>bool</span> downSample, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> kernelName = downSample ? <span style=color:#e6db74>&#34;KawaseDownSample&#34;</span> : <span style=color:#e6db74>&#34;KawaseUpSample&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TargetSize&#34;</span>, GetTextureSizeParams(targetSize));
</span></span><span style=display:flex><span>            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Offset&#34;</span>, offset);
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.x / x),
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.y / y),
</span></span><span style=display:flex><span>                                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoKawaseLinear(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
</span></span><span style=display:flex><span>            Vector2Int sourceSize, <span style=color:#66d9ef>float</span> offset, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> kernelName = <span style=color:#e6db74>&#34;KawaseLinear&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
</span></span><span style=display:flex><span>            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Offset&#34;</span>, offset);
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)sourceSize.x / x),
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)sourceSize.y / y),
</span></span><span style=display:flex><span>                                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                List&lt;<span style=color:#66d9ef>int</span>&gt; rtIDs = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt;();
</span></span><span style=display:flex><span>                List&lt;Vector2Int&gt; rtSizes = <span style=color:#66d9ef>new</span> List&lt;Vector2Int&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                RenderTextureDescriptor tempDesc = desc;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>string</span> kawaseRT = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> kawaseRTID = Shader.PropertyToID(kawaseRT);
</span></span><span style=display:flex><span>                cmd.GetTemporaryRT(kawaseRTID, tempDesc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                rtIDs.Add(kawaseRTID);
</span></span><span style=display:flex><span>                rtSizes.Add(textureSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> downSampleAmount = Mathf.Log(dualKawaseBlur.GetRadius() + <span style=color:#ae81ff>1.0f</span>) / <span style=color:#ae81ff>0.693147181f</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> downSampleCount = Mathf.FloorToInt(downSampleAmount);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> offsetRatio = downSampleAmount - (<span style=color:#66d9ef>float</span>)downSampleCount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Vector2Int lastSize = textureSize;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> lastID = cameraColorTextureID;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt;= downSampleCount; i++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>string</span> rtName = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span> + i.ToString();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> rtID = Shader.PropertyToID(rtName);
</span></span><span style=display:flex><span>                    Vector2Int rtSize = <span style=color:#66d9ef>new</span> Vector2Int((lastSize.x + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>, (lastSize.y + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                    tempDesc.width = rtSize.x;
</span></span><span style=display:flex><span>                    tempDesc.height = rtSize.y;
</span></span><span style=display:flex><span>                    cmd.GetTemporaryRT(rtID, tempDesc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    rtIDs.Add(rtID);
</span></span><span style=display:flex><span>                    rtSizes.Add(rtSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    DoKawaseSample(cmd, lastID, rtID, lastSize, rtSize, <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>true</span>, computeShader);
</span></span><span style=display:flex><span>                    lastSize = rtSize;
</span></span><span style=display:flex><span>                    lastID = rtID;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(downSampleCount == <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    DoKawaseSample(cmd, rtIDs[<span style=color:#ae81ff>1</span>], rtIDs[<span style=color:#ae81ff>0</span>], rtSizes[<span style=color:#ae81ff>1</span>], rtSizes[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>false</span>, computeShader);
</span></span><span style=display:flex><span>                    DoKawaseLinear(cmd, cameraColorIden, rtIDs[<span style=color:#ae81ff>0</span>], rtSizes[<span style=color:#ae81ff>0</span>], offsetRatio, computeShader);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>string</span> intermediateRTName = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span> + (downSampleCount + <span style=color:#ae81ff>1</span>).ToString();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> intermediateRTID = Shader.PropertyToID(intermediateRTName);
</span></span><span style=display:flex><span>                    Vector2Int intermediateRTSize = rtSizes[downSampleCount];
</span></span><span style=display:flex><span>                    tempDesc.width = intermediateRTSize.x;
</span></span><span style=display:flex><span>                    tempDesc.height = intermediateRTSize.y;
</span></span><span style=display:flex><span>                    cmd.GetTemporaryRT(intermediateRTID, tempDesc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = downSampleCount+<span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>1</span>; i--)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> sourceID = rtIDs[i];
</span></span><span style=display:flex><span>                        Vector2Int sourceSize = rtSizes[i];
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> targetID = i == (downSampleCount + <span style=color:#ae81ff>1</span>) ? intermediateRTID : rtIDs[i - <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                        Vector2Int targetSize = rtSizes[i - <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        DoKawaseSample(cmd, sourceID, targetID, sourceSize, targetSize, <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>false</span>, computeShader);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (i == (downSampleCount + <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            DoKawaseLinear(cmd, rtIDs[i - <span style=color:#ae81ff>1</span>], intermediateRTID, targetSize, offsetRatio, computeShader);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>int</span> tempID = intermediateRTID;
</span></span><span style=display:flex><span>                            intermediateRTID = rtIDs[i - <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                            rtIDs[i - <span style=color:#ae81ff>1</span>] = tempID;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        cmd.ReleaseTemporaryRT(sourceID);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    cmd.ReleaseTemporaryRT(intermediateRTID);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                cmd.Blit(kawaseRTID, cameraColorIden);
</span></span><span style=display:flex><span>                cmd.ReleaseTemporaryRT(kawaseRTID);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dualkawaseblurcs>DualKawaseBlur.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurcs>#</a></h3><p>æ²¡å•¥å¥½è¯´çš„</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Dual Kawase Blur&#34;, typeof(UniversalRenderPipeline))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlur</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter maxRadius = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>32.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>255.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> GetRadius()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> maxRadius.<span style=color:#66d9ef>value</span> * intensity.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dualkawaseblurrendererfeaturecs>DualKawaseBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurrendererfeaturecs>#</a></h3><p>ä¹Ÿæ²¡å•¥å¥½è¯´çš„ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> DualKawaseBlurSettings settings = <span style=color:#66d9ef>new</span> DualKawaseBlurSettings();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> DualKawaseBlurRenderPass dualKawaseBlurRenderPass;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dualKawaseBlurRenderPass = <span style=color:#66d9ef>new</span> DualKawaseBlurRenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            DualKawaseBlur dualKawaseBlur = VolumeManager.instance.stack.GetComponent&lt;DualKawaseBlur&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (dualKawaseBlur != <span style=color:#66d9ef>null</span> &amp;&amp; dualKawaseBlur.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dualKawaseBlurRenderPass.Setup(dualKawaseBlur);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(dualKawaseBlurRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>è¿…é€Ÿåœ°å†™å®Œäº†è¿™ç¯‡åšå®¢ï¼Œå…¶å®æœ‰ä»·å€¼çš„ä¸œè¥¿å¹¶ä¸æ˜¯å¤ªå¤šã€‚ä¸»è¦æ˜¯åœ¨ç½‘ä¸Šæœç´¢äº†åŠå¤©ï¼Œåªæœ‰å‡ ä¹åƒç¯‡ä¸€å¾‹çš„ä»£ç å’Œåƒç¯‡ä¸€å¾‹çš„ç¤ºæ„å›¾ï¼Œå¹¶æ²¡æœ‰å¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå› æ­¤è‡ªå·±åšäº†ä¸€äº›ç ”ç©¶ã€‚ä¸å¾—ä¸è¯´Dual Kawase Bluråšå¾—è¿˜æ˜¯å¾ˆèªæ˜çš„ï¼Œæœ€åæ¨¡ç³Šçš„æ•ˆæœä¹Ÿçœ‹ä¸å‡ºä»€ä¹ˆæ˜æ˜¾çš„æ–¹å½¢çš„ç—•è¿¹ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/blur/>Blur</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><span class=title>Â« Prev</span><br><span>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</span>
</a><a class=next href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><span class=title>Next Â»</span><br><span>Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>