<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>几乎连续的双Kawase模糊 | ZZNEWCLEAR13</title><meta name=keywords content="Dual Kawase Blur,Post-Process"><meta name=description content="使用线性插值来获得渐变的模糊."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><link crossorigin=anonymous href=/assets/css/stylesheet.min.50ec5873d43aafdb2c832cfa897c60d6e146a48ba3bacc322156221e9661fdc6.css integrity="sha256-UOxYc9Q6r9ssgyz6iXxg1uFGpIujuswyIVYiHpZh/cY=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="几乎连续的双Kawase模糊"><meta property="og:description" content="使用线性插值来获得渐变的模糊."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"><meta property="og:image" content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-29T12:00:00+08:00"><meta property="article:modified_time" content="2023-05-29T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png"><meta name=twitter:title content="几乎连续的双Kawase模糊"><meta name=twitter:description content="使用线性插值来获得渐变的模糊."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"几乎连续的双Kawase模糊","item":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"几乎连续的双Kawase模糊","name":"几乎连续的双Kawase模糊","description":"使用线性插值来获得渐变的模糊.","keywords":["Dual Kawase Blur","Post-Process"],"articleBody":"2023年6月3日修订 发现还是在降采样升采样后进行线性插值来获取中间程度的模糊效果比较好，所以后面的代码也都改过来了，不过理论上的部分倒是没必要改。顺便也花了点时间写了一个Shadertoy作为演示：\n\rDual Kawase Blur\n\r写这篇文章的原因 网上已经有了很多很多的双Kawase模糊的现成的案例，但是存在以下几个问题：1. 绝大部分的文章都只给了代码，没有相应的解释，至多会给一张直接从Arm的pdf截取的图示，而这张图示画了一堆方框和符号，却没有说明这些图案代表的含义。2. 绝大部分的文章通过修改采样的距离来控制模糊的程度，这个的缺点我们后续再谈。3. 绝大部分的文章并没有考虑模糊程度从0开始逐渐增大的动态过程，使用降采样和升采样往往会破坏整个画面的连续性。\n如果只是想要获得一个模糊的画面，只需要做几次降采样和升采样就能完成了，但我希望能有一个连续地逐渐地变模糊的过程，因此我开始了量化双Kawase模糊的想法。\n双Kawase模糊(Dual Kawase Blur) 双Kawase模糊是2015年Arm在Kawase模糊的基础上提出的一种通过降采样和升采样来快速且高效地进行高质量大半径模糊的一种方法，具体的pdf可以从这里找到。\n这里是一张双Kawase模糊的图示，表示了双Kawase模糊在降采样和升采样时的操作。细的黑线对应的格子是原始的像素（或是升采样后的像素），粗的黑线对应的格子是降采样后的像素。叉对应的是当前模糊的像素，圆对应的是当前模糊的像素所需要采样点。粉色对应的是降采样时的模糊的像素和采样点，绿色对应的是升采样时的模糊的像素和采样点。\n从这张图中也可以看到双Kawase模糊利用双线性采样来节省采样数的操作。在降采样时实际采样了当前像素周围一共十六个像素的颜色；在升采样时实际采样了当前像素周围一共十三个像素的颜色。而如果在做降采样时，对于奇数个像素除以二向下取整，或者是在降采样时使用了不恰当的偏移（比如1.5倍的偏移），会导致降采样的采样点落在原始像素的中心，这时即使使用了双线性采样，也只等价于采样一个像素。\n因此为了让每一个像素都能对模糊做到应用的贡献，为了达到比较好的模糊效果，我们这里限制双Kawase模糊的采样偏移为一倍（也就是严格按照采样点进行最优的双线性采样）。而通过多次降采样和升采样达到合适的模糊半径。\n量化双Kawase模糊 降采样和升采样有一个缺点，就是只要发生了降采样和升采样，就必然会带来模糊。这时有两种方法，一种是在原始分辨率下通过消耗更大的方式进行加权模糊来逼近双Kawase模糊配合降采样带来的模糊；另一种是在零次和一次双Kawase之间线性插值得到一张介于两者之间模糊程度的图像。综合两者来看，线性插值得到的效果更为平滑，效果上稍“错误”一些，但完全在可接受的范围内。\n我这边写了一个小小的脚本，去计算原始分辨率下值为1的像素点，在经过一次双Kawase模糊后，其他像素的值。通过多项式拟合这些模糊后的值，就能利用这些值来逼近双Kawase模糊的效果了。我这边对8x8的像素做了计算（实际上模糊的核心应该更大一些，不过我懒得改之前的代码了）。计算出的权重如下：\n0.0003255208\t0.001464844\t0.003092448\t0.004231771\t0.004231771\t0.003092448\t0.001464844\t0.0003255208\t0.001464844\t0.004882813\t0.009440104\t0.01204427\t0.01074219\t0.007486979\t0.004231771\t0.001464844\t0.004394531\t0.01334635\t0.02311198\t0.02701823\t0.0218099\t0.01334635\t0.007486979\t0.003092448\t0.01009115\t0.02571615\t0.03808594\t0.04329427\t0.03678386\t0.0218099\t0.01074219\t0.004231771\t0.01529948\t0.03222656\t0.04069011\t0.04589844\t0.04329427\t0.02701823\t0.01204427\t0.004231771\t0.01416016\t0.0296224\t0.03678386\t0.04069011\t0.03808594\t0.02311198\t0.009440104\t0.003092448\t0.007324219\t0.01985677\t0.0296224\t0.03222656\t0.02571615\t0.01334635\t0.004882813\t0.001464844\t0.001627604\t0.007324219\t0.01416016\t0.01529948\t0.01009115\t0.004394531\t0.001464844\t0.0003255208\t然后我把它丢进了Excel强行进行了一波运算并手动调整了一下，得出了下面这个拟合的公式（x范围大致在[-4, 4]之间，值并未归一化）：\n// Approximate dual kawase blur with 4th degree polynomial.\r// -3.5 具体的操作 接下来我们就能根据拟合的公式来进行几乎连续的双Kawase模糊了。通过计算以二为底的对数，可以知道我们需要进行多少次降采样，而其小数部分则代表着进行逼近下一次双Kawase模糊的程度，对应模糊的offset值。\nDualKawaseBlurComputeShader.compute 这里就懒得对双Kawase模糊那一部分写group shared memory的优化了。THREAD_GROUP_SIZE需要是BLUR_RADIUS的四倍以上，不然缓存的时候每个像素需要采更多的样。BLUR_RADIUS实际上是4但这边写了5，是因为需要额外预留一个像素进行手动的双线性采样。\n#pragma kernel KawaseDownSample\r#pragma kernel KawaseUpSample\r#pragma kernel KawaseLinear\rTexture2D _SourceTexture;\rRWTexture2D _RW_TargetTexture;\rSamplerState sampler_LinearClamp;\rfloat4 _SourceSize;\rfloat4 _TargetSize;\rfloat _Offset;\rfloat3 sampleSource(float2 center, float2 offset)\r{\rreturn _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset * _Offset, 0.0f).rgb;\r}\r[numthreads(8,8,1)]\rvoid KawaseDownSample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 halfPixel = 0.5f * _TargetSize.zw;\rfloat3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f));\rfloat3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f;\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid KawaseUpSample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 onePixel = 1.0f * _TargetSize.zw;\r// float3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));\rfloat3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));\rfloat3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));\rfloat3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));\rfloat3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));\rfloat3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid KawaseLinear(uint3 id : SV_DispatchThreadID)\r{\rhalf3 sourceTex = _SourceTexture.Load(uint3(id.xy, 0)).rgb;\rhalf3 blurredTex = _RW_TargetTexture.Load(uint3(id.xy, 0)).rgb;\rhalf3 color = lerp(sourceTex, blurredTex, _Offset);\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\rDualKawaseBlurRenderPass.cs 这里需要对最后一次降采样做一次拟合的操作，然后还要注意一次都不进行降采样时也需要进行拟合。使用的Unity版本是2021.3.19f1c1，URP版本是12.1.10，因此会有_CameraColorAttachmentA这样奇怪的名字。\nusing System.Collections.Generic; namespace UnityEngine.Rendering.Universal { public class DualKawaseBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Circular Blur Render Pass\"; private DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings; private DualKawaseBlur dualKawaseBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); private RenderTargetIdentifier cameraColorIden; private Vector2Int textureSize; private RenderTextureDescriptor desc; public DualKawaseBlurRenderPass(DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); } public void Setup(DualKawaseBlur dualKawaseBlur) { this.dualKawaseBlur = dualKawaseBlur; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoKawaseSample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, Vector2Int targetSize, float offset, bool downSample, ComputeShader computeShader) { if (!computeShader) return; string kernelName = downSample ? \"KawaseDownSample\" : \"KawaseUpSample\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeVectorParam(computeShader, \"_TargetSize\", GetTextureSizeParams(targetSize)); cmd.SetComputeFloatParam(computeShader, \"_Offset\", offset); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)targetSize.x / x), Mathf.CeilToInt((float)targetSize.y / y), 1); } private void DoKawaseLinear(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, float offset, ComputeShader computeShader) { if (!computeShader) return; string kernelName = \"KawaseLinear\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeFloatParam(computeShader, \"_Offset\", offset); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)sourceSize.x / x), Mathf.CeilToInt((float)sourceSize.y / y), 1); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { Listint rtIDs = new Listint(); List rtSizes = new List(); RenderTextureDescriptor tempDesc = desc; string kawaseRT = \"_KawaseRT\"; int kawaseRTID = Shader.PropertyToID(kawaseRT); cmd.GetTemporaryRT(kawaseRTID, tempDesc); rtIDs.Add(kawaseRTID); rtSizes.Add(textureSize); float downSampleAmount = Mathf.Log(dualKawaseBlur.GetRadius() + 1.0f) / 0.693147181f; int downSampleCount = Mathf.FloorToInt(downSampleAmount); float offsetRatio = downSampleAmount - (float)downSampleCount; Vector2Int lastSize = textureSize; int lastID = cameraColorTextureID; for (int i = 0; i string rtName = \"_KawaseRT\" + i.ToString(); int rtID = Shader.PropertyToID(rtName); Vector2Int rtSize = new Vector2Int((lastSize.x + 1) / 2, (lastSize.y + 1) / 2); tempDesc.width = rtSize.x; tempDesc.height = rtSize.y; cmd.GetTemporaryRT(rtID, tempDesc); rtIDs.Add(rtID); rtSizes.Add(rtSize); DoKawaseSample(cmd, lastID, rtID, lastSize, rtSize, 1.0f, true, computeShader); lastSize = rtSize; lastID = rtID; } if(downSampleCount == 0) { DoKawaseSample(cmd, rtIDs[1], rtIDs[0], rtSizes[1], rtSizes[0], 1.0f, false, computeShader); DoKawaseLinear(cmd, cameraColorIden, rtIDs[0], rtSizes[0], offsetRatio, computeShader); } else { string intermediateRTName = \"_KawaseRT\" + (downSampleCount + 1).ToString(); int intermediateRTID = Shader.PropertyToID(intermediateRTName); Vector2Int intermediateRTSize = rtSizes[downSampleCount]; tempDesc.width = intermediateRTSize.x; tempDesc.height = intermediateRTSize.y; cmd.GetTemporaryRT(intermediateRTID, tempDesc); for (int i = downSampleCount+1; i = 1; i--) { int sourceID = rtIDs[i]; Vector2Int sourceSize = rtSizes[i]; int targetID = i == (downSampleCount + 1) ? intermediateRTID : rtIDs[i - 1]; Vector2Int targetSize = rtSizes[i - 1]; DoKawaseSample(cmd, sourceID, targetID, sourceSize, targetSize, 1.0f, false, computeShader); if (i == (downSampleCount + 1)) { DoKawaseLinear(cmd, rtIDs[i - 1], intermediateRTID, targetSize, offsetRatio, computeShader); int tempID = intermediateRTID; intermediateRTID = rtIDs[i - 1]; rtIDs[i - 1] = tempID; } cmd.ReleaseTemporaryRT(sourceID); } cmd.ReleaseTemporaryRT(intermediateRTID); } cmd.Blit(kawaseRTID, cameraColorIden); cmd.ReleaseTemporaryRT(kawaseRTID); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } } } DualKawaseBlur.cs 没啥好说的\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Dual Kawase Blur\", typeof(UniversalRenderPipeline))] public class DualKawaseBlur : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter maxRadius = new ClampedFloatParameter(32.0f, 0.0f, 255.0f); public ClampedFloatParameter intensity = new ClampedFloatParameter(0.0f, 0.0f, 1.0f); public float GetRadius() { return maxRadius.value * intensity.value; } public bool IsActive() { return isEnabled.value \u0026\u0026 intensity.value  0.0f; } public bool IsTileCompatible() { return false; } } } DualKawaseBlurRendererFeature.cs 也没啥好说的。\nusing System.Collections; namespace UnityEngine.Rendering.Universal { public class DualKawaseBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class DualKawaseBlurSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader computeShader; } public DualKawaseBlurSettings settings = new DualKawaseBlurSettings(); private DualKawaseBlurRenderPass dualKawaseBlurRenderPass; public override void Create() { dualKawaseBlurRenderPass = new DualKawaseBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { DualKawaseBlur dualKawaseBlur = VolumeManager.instance.stack.GetComponent(); if (dualKawaseBlur != null \u0026\u0026 dualKawaseBlur.IsActive()) { dualKawaseBlurRenderPass.Setup(dualKawaseBlur); renderer.EnqueuePass(dualKawaseBlurRenderPass); } } } } 后记 迅速地写完了这篇博客，其实有价值的东西并不是太多。主要是在网上搜索了半天，只有几乎千篇一律的代码和千篇一律的示意图，并没有很详细的解释，因此自己做了一些研究。不得不说Dual Kawase Blur做得还是很聪明的，最后模糊的效果也看不出什么明显的方形的痕迹。\n","wordCount":"1077","inLanguage":"en","image":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png","datePublished":"2023-05-29T12:00:00+08:00","dateModified":"2023-05-29T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>几乎连续的双Kawase模糊</h1><div class=post-description>使用线性插值来获得渐变的模糊.</div><div class=post-meta>May 29, 2023&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/almost-continuous-dual-kawase-blur.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/DualKawaseBlur.png alt="Dual Kawase Blur Cover"><p>Dual Kawase Blur Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>几乎连续的双Kawase模糊</div></summary><div class=inner><ul><li><a href=#2023%e5%b9%b46%e6%9c%883%e6%97%a5%e4%bf%ae%e8%ae%a2 aria-label=2023年6月3日修订>2023年6月3日修订</a></li><li><a href=#%e5%86%99%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=写这篇文章的原因>写这篇文章的原因</a></li><li><a href=#%e5%8f%8ckawase%e6%a8%a1%e7%b3%8adual-kawase-blur aria-label="双Kawase模糊(Dual Kawase Blur)">双Kawase模糊(Dual Kawase Blur)</a></li><li><a href=#%e9%87%8f%e5%8c%96%e5%8f%8ckawase%e6%a8%a1%e7%b3%8a aria-label=量化双Kawase模糊>量化双Kawase模糊</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=具体的操作>具体的操作</a><ul><li><a href=#dualkawaseblurcomputeshadercompute aria-label=DualKawaseBlurComputeShader.compute>DualKawaseBlurComputeShader.compute</a></li><li><a href=#dualkawaseblurrenderpasscs aria-label=DualKawaseBlurRenderPass.cs>DualKawaseBlurRenderPass.cs</a></li><li><a href=#dualkawaseblurcs aria-label=DualKawaseBlur.cs>DualKawaseBlur.cs</a></li><li><a href=#dualkawaseblurrendererfeaturecs aria-label=DualKawaseBlurRendererFeature.cs>DualKawaseBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=2023年6月3日修订>2023年6月3日修订<a hidden class=anchor aria-hidden=true href=#2023年6月3日修订>#</a></h2><p>发现还是在降采样升采样后进行线性插值来获取中间程度的模糊效果比较好，所以后面的代码也都改过来了，不过理论上的部分倒是没必要改。顺便也花了点时间写了一个Shadertoy作为演示：</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/ct3Szl?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Dual Kawase Blur</p></figure><h2 id=写这篇文章的原因>写这篇文章的原因<a hidden class=anchor aria-hidden=true href=#写这篇文章的原因>#</a></h2><p>网上已经有了很多很多的双Kawase模糊的现成的案例，但是存在以下几个问题：1. 绝大部分的文章都只给了代码，没有相应的解释，至多会给一张直接从Arm的pdf截取的图示，而这张图示画了一堆方框和符号，却没有说明这些图案代表的含义。2. 绝大部分的文章通过修改采样的距离来控制模糊的程度，这个的缺点我们后续再谈。3. 绝大部分的文章并没有考虑模糊程度从0开始逐渐增大的动态过程，使用降采样和升采样往往会破坏整个画面的连续性。</p><p>如果只是想要获得一个模糊的画面，只需要做几次降采样和升采样就能完成了，但我希望能有一个连续地逐渐地变模糊的过程，因此我开始了量化双Kawase模糊的想法。</p><h2 id=双kawase模糊dual-kawase-blur>双Kawase模糊(Dual Kawase Blur)<a hidden class=anchor aria-hidden=true href=#双kawase模糊dual-kawase-blur>#</a></h2><p>双Kawase模糊是2015年Arm在Kawase模糊的基础上提出的一种通过降采样和升采样来快速且高效地进行高质量大半径模糊的一种方法，具体的pdf可以从<a href=https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_slides.pdf>这里</a>找到。</p><p><img loading=lazy src=../images/DualKawaseBlurDiagram.jpg#center alt="Dual Kawase Blur Diagram"></p><p>这里是一张双Kawase模糊的图示，表示了双Kawase模糊在降采样和升采样时的操作。细的黑线对应的格子是原始的像素（或是升采样后的像素），粗的黑线对应的格子是降采样后的像素。叉对应的是当前模糊的像素，圆对应的是当前模糊的像素所需要采样点。粉色对应的是降采样时的模糊的像素和采样点，绿色对应的是升采样时的模糊的像素和采样点。</p><p>从这张图中也可以看到双Kawase模糊利用双线性采样来节省采样数的操作。在降采样时实际采样了当前像素周围一共十六个像素的颜色；在升采样时实际采样了当前像素周围一共十三个像素的颜色。而如果在做降采样时，对于奇数个像素除以二向下取整，或者是在降采样时使用了不恰当的偏移（比如1.5倍的偏移），会导致降采样的采样点落在原始像素的中心，这时即使使用了双线性采样，也只等价于采样一个像素。</p><p>因此为了让每一个像素都能对模糊做到应用的贡献，为了达到比较好的模糊效果，我们这里限制双Kawase模糊的采样偏移为一倍（也就是严格按照采样点进行最优的双线性采样）。而通过多次降采样和升采样达到合适的模糊半径。</p><h2 id=量化双kawase模糊>量化双Kawase模糊<a hidden class=anchor aria-hidden=true href=#量化双kawase模糊>#</a></h2><p>降采样和升采样有一个缺点，就是只要发生了降采样和升采样，就必然会带来模糊。这时有两种方法，一种是在原始分辨率下通过消耗更大的方式进行加权模糊来逼近双Kawase模糊配合降采样带来的模糊；另一种是在零次和一次双Kawase之间线性插值得到一张介于两者之间模糊程度的图像。综合两者来看，线性插值得到的效果更为平滑，效果上稍“错误”一些，但完全在可接受的范围内。</p><p>我这边写了一个小小的脚本，去计算原始分辨率下值为1的像素点，在经过一次双Kawase模糊后，其他像素的值。通过多项式拟合这些模糊后的值，就能利用这些值来逼近双Kawase模糊的效果了。我这边对8x8的像素做了计算（实际上模糊的核心应该更大一些，不过我懒得改之前的代码了）。计算出的权重如下：</p><pre><code>0.0003255208	0.001464844	0.003092448	0.004231771	0.004231771	0.003092448	0.001464844	0.0003255208	
0.001464844	0.004882813	0.009440104	0.01204427	0.01074219	0.007486979	0.004231771	0.001464844	
0.004394531	0.01334635	0.02311198	0.02701823	0.0218099	0.01334635	0.007486979	0.003092448	
0.01009115	0.02571615	0.03808594	0.04329427	0.03678386	0.0218099	0.01074219	0.004231771	
0.01529948	0.03222656	0.04069011	0.04589844	0.04329427	0.02701823	0.01204427	0.004231771	
0.01416016	0.0296224	0.03678386	0.04069011	0.03808594	0.02311198	0.009440104	0.003092448	
0.007324219	0.01985677	0.0296224	0.03222656	0.02571615	0.01334635	0.004882813	0.001464844	
0.001627604	0.007324219	0.01416016	0.01529948	0.01009115	0.004394531	0.001464844	0.0003255208	
</code></pre><p>然后我把它丢进了Excel强行进行了一波运算并手动调整了一下，得出了下面这个拟合的公式（x范围大致在[-4, 4]之间，值并未归一化）：</p><pre><code class=language-HLSL data-lang=HLSL>// Approximate dual kawase blur with 4th degree polynomial.
// -3.5 &lt;= x &lt;= 3.5 (idealy)
float getWeight(float x)
{
	return 0.1356f * x * x * x * x - 0.06748 * x * x * x - 4.693656 * x * x + 0.9954208 * x + 45.57338;
}
</code></pre><h2 id=具体的操作>具体的操作<a hidden class=anchor aria-hidden=true href=#具体的操作>#</a></h2><p>接下来我们就能根据拟合的公式来进行几乎连续的双Kawase模糊了。通过计算以二为底的对数，可以知道我们需要进行多少次降采样，而其小数部分则代表着进行逼近下一次双Kawase模糊的程度，对应模糊的offset值。</p><h3 id=dualkawaseblurcomputeshadercompute>DualKawaseBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#dualkawaseblurcomputeshadercompute>#</a></h3><p>这里就懒得对双Kawase模糊那一部分写group shared memory的优化了。<code>THREAD_GROUP_SIZE</code>需要是<code>BLUR_RADIUS</code>的四倍以上，不然缓存的时候每个像素需要采更多的样。<code>BLUR_RADIUS</code>实际上是4但这边写了5，是因为需要额外预留一个像素进行手动的双线性采样。</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel KawaseDownSample
#pragma kernel KawaseUpSample
#pragma kernel KawaseLinear

Texture2D&lt;float4&gt; _SourceTexture;
RWTexture2D&lt;float4&gt; _RW_TargetTexture;
SamplerState sampler_LinearClamp;
float4 _SourceSize;
float4 _TargetSize;
float _Offset;

float3 sampleSource(float2 center, float2 offset)
{
	return _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset * _Offset, 0.0f).rgb;
}

[numthreads(8,8,1)]
void KawaseDownSample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 halfPixel = 0.5f * _TargetSize.zw;

	float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f));

	float3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f;
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void KawaseUpSample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 onePixel = 1.0f * _TargetSize.zw;

	// float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));
	float3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));
	float3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));
	float3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));
	float3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));

	float3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void KawaseLinear(uint3 id : SV_DispatchThreadID)
{
	half3 sourceTex = _SourceTexture.Load(uint3(id.xy, 0)).rgb;
	half3 blurredTex = _RW_TargetTexture.Load(uint3(id.xy, 0)).rgb;
	half3 color = lerp(sourceTex, blurredTex, _Offset);
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}
</code></pre><h3 id=dualkawaseblurrenderpasscs>DualKawaseBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurrenderpasscs>#</a></h3><p>这里需要对最后一次降采样做一次拟合的操作，然后还要注意一次都不进行降采样时也需要进行拟合。使用的Unity版本是2021.3.19f1c1，URP版本是12.1.10，因此会有<code>_CameraColorAttachmentA</code>这样奇怪的名字。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Circular Blur Render Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings;
        <span style=color:#66d9ef>private</span> DualKawaseBlur dualKawaseBlur;
        <span style=color:#66d9ef>private</span> ComputeShader computeShader;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;

        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
        <span style=color:#66d9ef>private</span> RenderTextureDescriptor desc;

        <span style=color:#66d9ef>public</span> DualKawaseBlurRenderPass(DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);

            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            computeShader = settings.computeShader;

            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(DualKawaseBlur dualKawaseBlur)
        {
            <span style=color:#66d9ef>this</span>.dualKawaseBlur = dualKawaseBlur;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
            desc = cameraTextureDescriptor;
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
        }

        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoKawaseSample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
                                        Vector2Int sourceSize, Vector2Int targetSize,
                                        <span style=color:#66d9ef>float</span> offset, <span style=color:#66d9ef>bool</span> downSample, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = downSample ? <span style=color:#e6db74>&#34;KawaseDownSample&#34;</span> : <span style=color:#e6db74>&#34;KawaseUpSample&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TargetSize&#34;</span>, GetTextureSizeParams(targetSize));
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Offset&#34;</span>, offset);
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoKawaseLinear(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
            Vector2Int sourceSize, <span style=color:#66d9ef>float</span> offset, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = <span style=color:#e6db74>&#34;KawaseLinear&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Offset&#34;</span>, offset);
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)sourceSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)sourceSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get();
            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                List&lt;<span style=color:#66d9ef>int</span>&gt; rtIDs = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt;();
                List&lt;Vector2Int&gt; rtSizes = <span style=color:#66d9ef>new</span> List&lt;Vector2Int&gt;();

                RenderTextureDescriptor tempDesc = desc;
                <span style=color:#66d9ef>string</span> kawaseRT = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span>;
                <span style=color:#66d9ef>int</span> kawaseRTID = Shader.PropertyToID(kawaseRT);
                cmd.GetTemporaryRT(kawaseRTID, tempDesc);

                rtIDs.Add(kawaseRTID);
                rtSizes.Add(textureSize);

                <span style=color:#66d9ef>float</span> downSampleAmount = Mathf.Log(dualKawaseBlur.GetRadius() + <span style=color:#ae81ff>1.0f</span>) / <span style=color:#ae81ff>0.693147181f</span>;
                <span style=color:#66d9ef>int</span> downSampleCount = Mathf.FloorToInt(downSampleAmount);
                <span style=color:#66d9ef>float</span> offsetRatio = downSampleAmount - (<span style=color:#66d9ef>float</span>)downSampleCount;

                Vector2Int lastSize = textureSize;
                <span style=color:#66d9ef>int</span> lastID = cameraColorTextureID;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt;= downSampleCount; i++)
                {
                    <span style=color:#66d9ef>string</span> rtName = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span> + i.ToString();
                    <span style=color:#66d9ef>int</span> rtID = Shader.PropertyToID(rtName);
                    Vector2Int rtSize = <span style=color:#66d9ef>new</span> Vector2Int((lastSize.x + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>, (lastSize.y + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>);
                    tempDesc.width = rtSize.x;
                    tempDesc.height = rtSize.y;
                    cmd.GetTemporaryRT(rtID, tempDesc);

                    rtIDs.Add(rtID);
                    rtSizes.Add(rtSize);

                    DoKawaseSample(cmd, lastID, rtID, lastSize, rtSize, <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>true</span>, computeShader);
                    lastSize = rtSize;
                    lastID = rtID;
                }

                <span style=color:#66d9ef>if</span>(downSampleCount == <span style=color:#ae81ff>0</span>)
                {
                    DoKawaseSample(cmd, rtIDs[<span style=color:#ae81ff>1</span>], rtIDs[<span style=color:#ae81ff>0</span>], rtSizes[<span style=color:#ae81ff>1</span>], rtSizes[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>false</span>, computeShader);
                    DoKawaseLinear(cmd, cameraColorIden, rtIDs[<span style=color:#ae81ff>0</span>], rtSizes[<span style=color:#ae81ff>0</span>], offsetRatio, computeShader);
                }
                <span style=color:#66d9ef>else</span>
                {
                    <span style=color:#66d9ef>string</span> intermediateRTName = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span> + (downSampleCount + <span style=color:#ae81ff>1</span>).ToString();
                    <span style=color:#66d9ef>int</span> intermediateRTID = Shader.PropertyToID(intermediateRTName);
                    Vector2Int intermediateRTSize = rtSizes[downSampleCount];
                    tempDesc.width = intermediateRTSize.x;
                    tempDesc.height = intermediateRTSize.y;
                    cmd.GetTemporaryRT(intermediateRTID, tempDesc);

                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = downSampleCount+<span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>1</span>; i--)
                    {
                        <span style=color:#66d9ef>int</span> sourceID = rtIDs[i];
                        Vector2Int sourceSize = rtSizes[i];
                        <span style=color:#66d9ef>int</span> targetID = i == (downSampleCount + <span style=color:#ae81ff>1</span>) ? intermediateRTID : rtIDs[i - <span style=color:#ae81ff>1</span>];
                        Vector2Int targetSize = rtSizes[i - <span style=color:#ae81ff>1</span>];

                        DoKawaseSample(cmd, sourceID, targetID, sourceSize, targetSize, <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>false</span>, computeShader);

                        <span style=color:#66d9ef>if</span> (i == (downSampleCount + <span style=color:#ae81ff>1</span>))
                        {
                            DoKawaseLinear(cmd, rtIDs[i - <span style=color:#ae81ff>1</span>], intermediateRTID, targetSize, offsetRatio, computeShader);
                            <span style=color:#66d9ef>int</span> tempID = intermediateRTID;
                            intermediateRTID = rtIDs[i - <span style=color:#ae81ff>1</span>];
                            rtIDs[i - <span style=color:#ae81ff>1</span>] = tempID;
                        }
                        cmd.ReleaseTemporaryRT(sourceID);
                    }
                    cmd.ReleaseTemporaryRT(intermediateRTID);
                }

                cmd.Blit(kawaseRTID, cameraColorIden);
                cmd.ReleaseTemporaryRT(kawaseRTID);
            }
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=dualkawaseblurcs>DualKawaseBlur.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurcs>#</a></h3><p>没啥好说的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Dual Kawase Blur&#34;, typeof(UniversalRenderPipeline))]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlur</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter maxRadius = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>32.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>255.0f</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> GetRadius()
        {
            <span style=color:#66d9ef>return</span> maxRadius.<span style=color:#66d9ef>value</span> * intensity.<span style=color:#66d9ef>value</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }
    }
}
</code></pre></div><h3 id=dualkawaseblurrendererfeaturecs>DualKawaseBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurrendererfeaturecs>#</a></h3><p>也没啥好说的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections;
<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        }

        <span style=color:#66d9ef>public</span> DualKawaseBlurSettings settings = <span style=color:#66d9ef>new</span> DualKawaseBlurSettings();
        <span style=color:#66d9ef>private</span> DualKawaseBlurRenderPass dualKawaseBlurRenderPass;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            dualKawaseBlurRenderPass = <span style=color:#66d9ef>new</span> DualKawaseBlurRenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            DualKawaseBlur dualKawaseBlur = VolumeManager.instance.stack.GetComponent&lt;DualKawaseBlur&gt;();
            <span style=color:#66d9ef>if</span> (dualKawaseBlur != <span style=color:#66d9ef>null</span> &amp;&amp; dualKawaseBlur.IsActive())
            {
                dualKawaseBlurRenderPass.Setup(dualKawaseBlur);
                renderer.EnqueuePass(dualKawaseBlurRenderPass);
            }
        }
    }
}
</code></pre></div><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>迅速地写完了这篇博客，其实有价值的东西并不是太多。主要是在网上搜索了半天，只有几乎千篇一律的代码和千篇一律的示意图，并没有很详细的解释，因此自己做了一些研究。不得不说Dual Kawase Blur做得还是很聪明的，最后模糊的效果也看不出什么明显的方形的痕迹。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/dual-kawase-blur/>Dual Kawase Blur</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><span class=title>« Prev Page</span><br><span>在Unity里实现松散圆锥步进Relaxed Cone Step Mapping</span></a>
<a class=next href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><span class=title>Next Page »</span><br><span>Unity两个Pass的圆形模糊</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>