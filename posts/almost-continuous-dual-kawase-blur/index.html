<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š | ZZNEWCLEAR13</title><meta name=keywords content="Dual Kawase Blur,Post-Process"><meta name=description content="ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><link crossorigin=anonymous href=/assets/css/stylesheet.a6fe470bfe70eb4fad7ee3efc590e817f121cf0f6d66fa91de327cf6bfbad62d.css integrity="sha256-pv5HC/5w60+tfuPvxZDoF/Ehzw9tZvqR3jJ89r+61i0=" rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š"><meta property="og:description" content="ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"><meta property="og:image" content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-29T12:00:00+08:00"><meta property="article:modified_time" content="2023-05-29T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png"><meta name=twitter:title content="å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š"><meta name=twitter:description content="ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š","item":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š","name":"å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š","description":"ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š.","keywords":["Dual Kawase Blur","Post-Process"],"articleBody":"2023å¹´6æœˆ3æ—¥ä¿®è®¢ å‘ç°è¿˜æ˜¯åœ¨é™é‡‡æ ·å‡é‡‡æ ·åè¿›è¡Œçº¿æ€§æ’å€¼æ¥è·å–ä¸­é—´ç¨‹åº¦çš„æ¨¡ç³Šæ•ˆæœæ¯”è¾ƒå¥½ï¼Œæ‰€ä»¥åé¢çš„ä»£ç ä¹Ÿéƒ½æ”¹è¿‡æ¥äº†ï¼Œä¸è¿‡ç†è®ºä¸Šçš„éƒ¨åˆ†å€’æ˜¯æ²¡å¿…è¦æ”¹ã€‚é¡ºä¾¿ä¹ŸèŠ±äº†ç‚¹æ—¶é—´å†™äº†ä¸€ä¸ªShadertoyä½œä¸ºæ¼”ç¤ºï¼š\n\rDual Kawase Blur\n\rå†™è¿™ç¯‡æ–‡ç« çš„åŸå›  ç½‘ä¸Šå·²ç»æœ‰äº†å¾ˆå¤šå¾ˆå¤šçš„åŒKawaseæ¨¡ç³Šçš„ç°æˆçš„æ¡ˆä¾‹ï¼Œä½†æ˜¯å­˜åœ¨ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š1. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« éƒ½åªç»™äº†ä»£ç ï¼Œæ²¡æœ‰ç›¸åº”çš„è§£é‡Šï¼Œè‡³å¤šä¼šç»™ä¸€å¼ ç›´æ¥ä»Armçš„pdfæˆªå–çš„å›¾ç¤ºï¼Œè€Œè¿™å¼ å›¾ç¤ºç”»äº†ä¸€å †æ–¹æ¡†å’Œç¬¦å·ï¼Œå´æ²¡æœ‰è¯´æ˜è¿™äº›å›¾æ¡ˆä»£è¡¨çš„å«ä¹‰ã€‚2. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« é€šè¿‡ä¿®æ”¹é‡‡æ ·çš„è·ç¦»æ¥æ§åˆ¶æ¨¡ç³Šçš„ç¨‹åº¦ï¼Œè¿™ä¸ªçš„ç¼ºç‚¹æˆ‘ä»¬åç»­å†è°ˆã€‚3. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« å¹¶æ²¡æœ‰è€ƒè™‘æ¨¡ç³Šç¨‹åº¦ä»0å¼€å§‹é€æ¸å¢å¤§çš„åŠ¨æ€è¿‡ç¨‹ï¼Œä½¿ç”¨é™é‡‡æ ·å’Œå‡é‡‡æ ·å¾€å¾€ä¼šç ´åæ•´ä¸ªç”»é¢çš„è¿ç»­æ€§ã€‚\nå¦‚æœåªæ˜¯æƒ³è¦è·å¾—ä¸€ä¸ªæ¨¡ç³Šçš„ç”»é¢ï¼Œåªéœ€è¦åšå‡ æ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·å°±èƒ½å®Œæˆäº†ï¼Œä½†æˆ‘å¸Œæœ›èƒ½æœ‰ä¸€ä¸ªè¿ç»­åœ°é€æ¸åœ°å˜æ¨¡ç³Šçš„è¿‡ç¨‹ï¼Œå› æ­¤æˆ‘å¼€å§‹äº†é‡åŒ–åŒKawaseæ¨¡ç³Šçš„æƒ³æ³•ã€‚\nåŒKawaseæ¨¡ç³Š(Dual Kawase Blur) åŒKawaseæ¨¡ç³Šæ˜¯2015å¹´Armåœ¨Kawaseæ¨¡ç³Šçš„åŸºç¡€ä¸Šæå‡ºçš„ä¸€ç§é€šè¿‡é™é‡‡æ ·å’Œå‡é‡‡æ ·æ¥å¿«é€Ÿä¸”é«˜æ•ˆåœ°è¿›è¡Œé«˜è´¨é‡å¤§åŠå¾„æ¨¡ç³Šçš„ä¸€ç§æ–¹æ³•ï¼Œå…·ä½“çš„pdfå¯ä»¥ä»è¿™é‡Œæ‰¾åˆ°ã€‚\nè¿™é‡Œæ˜¯ä¸€å¼ åŒKawaseæ¨¡ç³Šçš„å›¾ç¤ºï¼Œè¡¨ç¤ºäº†åŒKawaseæ¨¡ç³Šåœ¨é™é‡‡æ ·å’Œå‡é‡‡æ ·æ—¶çš„æ“ä½œã€‚ç»†çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯åŸå§‹çš„åƒç´ ï¼ˆæˆ–æ˜¯å‡é‡‡æ ·åçš„åƒç´ ï¼‰ï¼Œç²—çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯é™é‡‡æ ·åçš„åƒç´ ã€‚å‰å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ ï¼Œåœ†å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ æ‰€éœ€è¦é‡‡æ ·ç‚¹ã€‚ç²‰è‰²å¯¹åº”çš„æ˜¯é™é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ï¼Œç»¿è‰²å¯¹åº”çš„æ˜¯å‡é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ã€‚\nä»è¿™å¼ å›¾ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°åŒKawaseæ¨¡ç³Šåˆ©ç”¨åŒçº¿æ€§é‡‡æ ·æ¥èŠ‚çœé‡‡æ ·æ•°çš„æ“ä½œã€‚åœ¨é™é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åå…­ä¸ªåƒç´ çš„é¢œè‰²ï¼›åœ¨å‡é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åä¸‰ä¸ªåƒç´ çš„é¢œè‰²ã€‚è€Œå¦‚æœåœ¨åšé™é‡‡æ ·æ—¶ï¼Œå¯¹äºå¥‡æ•°ä¸ªåƒç´ é™¤ä»¥äºŒå‘ä¸‹å–æ•´ï¼Œæˆ–è€…æ˜¯åœ¨é™é‡‡æ ·æ—¶ä½¿ç”¨äº†ä¸æ°å½“çš„åç§»ï¼ˆæ¯”å¦‚1.5å€çš„åç§»ï¼‰ï¼Œä¼šå¯¼è‡´é™é‡‡æ ·çš„é‡‡æ ·ç‚¹è½åœ¨åŸå§‹åƒç´ çš„ä¸­å¿ƒï¼Œè¿™æ—¶å³ä½¿ä½¿ç”¨äº†åŒçº¿æ€§é‡‡æ ·ï¼Œä¹Ÿåªç­‰ä»·äºé‡‡æ ·ä¸€ä¸ªåƒç´ ã€‚\nå› æ­¤ä¸ºäº†è®©æ¯ä¸€ä¸ªåƒç´ éƒ½èƒ½å¯¹æ¨¡ç³Šåšåˆ°åº”ç”¨çš„è´¡çŒ®ï¼Œä¸ºäº†è¾¾åˆ°æ¯”è¾ƒå¥½çš„æ¨¡ç³Šæ•ˆæœï¼Œæˆ‘ä»¬è¿™é‡Œé™åˆ¶åŒKawaseæ¨¡ç³Šçš„é‡‡æ ·åç§»ä¸ºä¸€å€ï¼ˆä¹Ÿå°±æ˜¯ä¸¥æ ¼æŒ‰ç…§é‡‡æ ·ç‚¹è¿›è¡Œæœ€ä¼˜çš„åŒçº¿æ€§é‡‡æ ·ï¼‰ã€‚è€Œé€šè¿‡å¤šæ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·è¾¾åˆ°åˆé€‚çš„æ¨¡ç³ŠåŠå¾„ã€‚\né‡åŒ–åŒKawaseæ¨¡ç³Š é™é‡‡æ ·å’Œå‡é‡‡æ ·æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œå°±æ˜¯åªè¦å‘ç”Ÿäº†é™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œå°±å¿…ç„¶ä¼šå¸¦æ¥æ¨¡ç³Šã€‚è¿™æ—¶æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯åœ¨åŸå§‹åˆ†è¾¨ç‡ä¸‹é€šè¿‡æ¶ˆè€—æ›´å¤§çš„æ–¹å¼è¿›è¡ŒåŠ æƒæ¨¡ç³Šæ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šé…åˆé™é‡‡æ ·å¸¦æ¥çš„æ¨¡ç³Šï¼›å¦ä¸€ç§æ˜¯åœ¨é›¶æ¬¡å’Œä¸€æ¬¡åŒKawaseä¹‹é—´çº¿æ€§æ’å€¼å¾—åˆ°ä¸€å¼ ä»‹äºä¸¤è€…ä¹‹é—´æ¨¡ç³Šç¨‹åº¦çš„å›¾åƒã€‚ç»¼åˆä¸¤è€…æ¥çœ‹ï¼Œçº¿æ€§æ’å€¼å¾—åˆ°çš„æ•ˆæœæ›´ä¸ºå¹³æ»‘ï¼Œæ•ˆæœä¸Šç¨â€œé”™è¯¯â€ä¸€äº›ï¼Œä½†å®Œå…¨åœ¨å¯æ¥å—çš„èŒƒå›´å†…ã€‚\næˆ‘è¿™è¾¹å†™äº†ä¸€ä¸ªå°å°çš„è„šæœ¬ï¼Œå»è®¡ç®—åŸå§‹åˆ†è¾¨ç‡ä¸‹å€¼ä¸º1çš„åƒç´ ç‚¹ï¼Œåœ¨ç»è¿‡ä¸€æ¬¡åŒKawaseæ¨¡ç³Šåï¼Œå…¶ä»–åƒç´ çš„å€¼ã€‚é€šè¿‡å¤šé¡¹å¼æ‹Ÿåˆè¿™äº›æ¨¡ç³Šåçš„å€¼ï¼Œå°±èƒ½åˆ©ç”¨è¿™äº›å€¼æ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šçš„æ•ˆæœäº†ã€‚æˆ‘è¿™è¾¹å¯¹8x8çš„åƒç´ åšäº†è®¡ç®—ï¼ˆå®é™…ä¸Šæ¨¡ç³Šçš„æ ¸å¿ƒåº”è¯¥æ›´å¤§ä¸€äº›ï¼Œä¸è¿‡æˆ‘æ‡’å¾—æ”¹ä¹‹å‰çš„ä»£ç äº†ï¼‰ã€‚è®¡ç®—å‡ºçš„æƒé‡å¦‚ä¸‹ï¼š\n0.0003255208\t0.001464844\t0.003092448\t0.004231771\t0.004231771\t0.003092448\t0.001464844\t0.0003255208\t0.001464844\t0.004882813\t0.009440104\t0.01204427\t0.01074219\t0.007486979\t0.004231771\t0.001464844\t0.004394531\t0.01334635\t0.02311198\t0.02701823\t0.0218099\t0.01334635\t0.007486979\t0.003092448\t0.01009115\t0.02571615\t0.03808594\t0.04329427\t0.03678386\t0.0218099\t0.01074219\t0.004231771\t0.01529948\t0.03222656\t0.04069011\t0.04589844\t0.04329427\t0.02701823\t0.01204427\t0.004231771\t0.01416016\t0.0296224\t0.03678386\t0.04069011\t0.03808594\t0.02311198\t0.009440104\t0.003092448\t0.007324219\t0.01985677\t0.0296224\t0.03222656\t0.02571615\t0.01334635\t0.004882813\t0.001464844\t0.001627604\t0.007324219\t0.01416016\t0.01529948\t0.01009115\t0.004394531\t0.001464844\t0.0003255208\tç„¶åæˆ‘æŠŠå®ƒä¸¢è¿›äº†Excelå¼ºè¡Œè¿›è¡Œäº†ä¸€æ³¢è¿ç®—å¹¶æ‰‹åŠ¨è°ƒæ•´äº†ä¸€ä¸‹ï¼Œå¾—å‡ºäº†ä¸‹é¢è¿™ä¸ªæ‹Ÿåˆçš„å…¬å¼ï¼ˆxèŒƒå›´å¤§è‡´åœ¨[-4, 4]ä¹‹é—´ï¼Œå€¼å¹¶æœªå½’ä¸€åŒ–ï¼‰ï¼š\n// Approximate dual kawase blur with 4th degree polynomial.\r// -3.5 å…·ä½“çš„æ“ä½œ æ¥ä¸‹æ¥æˆ‘ä»¬å°±èƒ½æ ¹æ®æ‹Ÿåˆçš„å…¬å¼æ¥è¿›è¡Œå‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Šäº†ã€‚é€šè¿‡è®¡ç®—ä»¥äºŒä¸ºåº•çš„å¯¹æ•°ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬éœ€è¦è¿›è¡Œå¤šå°‘æ¬¡é™é‡‡æ ·ï¼Œè€Œå…¶å°æ•°éƒ¨åˆ†åˆ™ä»£è¡¨ç€è¿›è¡Œé€¼è¿‘ä¸‹ä¸€æ¬¡åŒKawaseæ¨¡ç³Šçš„ç¨‹åº¦ï¼Œå¯¹åº”æ¨¡ç³Šçš„offsetå€¼ã€‚\nDualKawaseBlurComputeShader.compute è¿™é‡Œå°±æ‡’å¾—å¯¹åŒKawaseæ¨¡ç³Šé‚£ä¸€éƒ¨åˆ†å†™group shared memoryçš„ä¼˜åŒ–äº†ã€‚THREAD_GROUP_SIZEéœ€è¦æ˜¯BLUR_RADIUSçš„å››å€ä»¥ä¸Šï¼Œä¸ç„¶ç¼“å­˜çš„æ—¶å€™æ¯ä¸ªåƒç´ éœ€è¦é‡‡æ›´å¤šçš„æ ·ã€‚BLUR_RADIUSå®é™…ä¸Šæ˜¯4ä½†è¿™è¾¹å†™äº†5ï¼Œæ˜¯å› ä¸ºéœ€è¦é¢å¤–é¢„ç•™ä¸€ä¸ªåƒç´ è¿›è¡Œæ‰‹åŠ¨çš„åŒçº¿æ€§é‡‡æ ·ã€‚\n#pragma kernel KawaseDownSample\r#pragma kernel KawaseUpSample\r#pragma kernel KawaseLinear\rTexture2D _SourceTexture;\rRWTexture2D _RW_TargetTexture;\rSamplerState sampler_LinearClamp;\rfloat4 _SourceSize;\rfloat4 _TargetSize;\rfloat _Offset;\rfloat3 sampleSource(float2 center, float2 offset)\r{\rreturn _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset * _Offset, 0.0f).rgb;\r}\r[numthreads(8,8,1)]\rvoid KawaseDownSample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 halfPixel = 0.5f * _TargetSize.zw;\rfloat3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f));\rfloat3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f;\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid KawaseUpSample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 onePixel = 1.0f * _TargetSize.zw;\r// float3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));\rfloat3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));\rfloat3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));\rfloat3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));\rfloat3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));\rfloat3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid KawaseLinear(uint3 id : SV_DispatchThreadID)\r{\rhalf3 sourceTex = _SourceTexture.Load(uint3(id.xy, 0)).rgb;\rhalf3 blurredTex = _RW_TargetTexture.Load(uint3(id.xy, 0)).rgb;\rhalf3 color = lerp(sourceTex, blurredTex, _Offset);\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\rDualKawaseBlurRenderPass.cs è¿™é‡Œéœ€è¦å¯¹æœ€åä¸€æ¬¡é™é‡‡æ ·åšä¸€æ¬¡æ‹Ÿåˆçš„æ“ä½œï¼Œç„¶åè¿˜è¦æ³¨æ„ä¸€æ¬¡éƒ½ä¸è¿›è¡Œé™é‡‡æ ·æ—¶ä¹Ÿéœ€è¦è¿›è¡Œæ‹Ÿåˆã€‚ä½¿ç”¨çš„Unityç‰ˆæœ¬æ˜¯2021.3.19f1c1ï¼ŒURPç‰ˆæœ¬æ˜¯12.1.10ï¼Œå› æ­¤ä¼šæœ‰_CameraColorAttachmentAè¿™æ ·å¥‡æ€ªçš„åå­—ã€‚\nusing System.Collections.Generic; namespace UnityEngine.Rendering.Universal { public class DualKawaseBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Circular Blur Render Pass\"; private DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings; private DualKawaseBlur dualKawaseBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); private RenderTargetIdentifier cameraColorIden; private Vector2Int textureSize; private RenderTextureDescriptor desc; public DualKawaseBlurRenderPass(DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); } public void Setup(DualKawaseBlur dualKawaseBlur) { this.dualKawaseBlur = dualKawaseBlur; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoKawaseSample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, Vector2Int targetSize, float offset, bool downSample, ComputeShader computeShader) { if (!computeShader) return; string kernelName = downSample ? \"KawaseDownSample\" : \"KawaseUpSample\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeVectorParam(computeShader, \"_TargetSize\", GetTextureSizeParams(targetSize)); cmd.SetComputeFloatParam(computeShader, \"_Offset\", offset); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)targetSize.x / x), Mathf.CeilToInt((float)targetSize.y / y), 1); } private void DoKawaseLinear(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, float offset, ComputeShader computeShader) { if (!computeShader) return; string kernelName = \"KawaseLinear\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeFloatParam(computeShader, \"_Offset\", offset); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)sourceSize.x / x), Mathf.CeilToInt((float)sourceSize.y / y), 1); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { Listint rtIDs = new Listint(); List rtSizes = new List(); RenderTextureDescriptor tempDesc = desc; string kawaseRT = \"_KawaseRT\"; int kawaseRTID = Shader.PropertyToID(kawaseRT); cmd.GetTemporaryRT(kawaseRTID, tempDesc); rtIDs.Add(kawaseRTID); rtSizes.Add(textureSize); float downSampleAmount = Mathf.Log(dualKawaseBlur.GetRadius() + 1.0f) / 0.693147181f; int downSampleCount = Mathf.FloorToInt(downSampleAmount); float offsetRatio = downSampleAmount - (float)downSampleCount; Vector2Int lastSize = textureSize; int lastID = cameraColorTextureID; for (int i = 0; i string rtName = \"_KawaseRT\" + i.ToString(); int rtID = Shader.PropertyToID(rtName); Vector2Int rtSize = new Vector2Int((lastSize.x + 1) / 2, (lastSize.y + 1) / 2); tempDesc.width = rtSize.x; tempDesc.height = rtSize.y; cmd.GetTemporaryRT(rtID, tempDesc); rtIDs.Add(rtID); rtSizes.Add(rtSize); DoKawaseSample(cmd, lastID, rtID, lastSize, rtSize, 1.0f, true, computeShader); lastSize = rtSize; lastID = rtID; } if(downSampleCount == 0) { DoKawaseSample(cmd, rtIDs[1], rtIDs[0], rtSizes[1], rtSizes[0], 1.0f, false, computeShader); DoKawaseLinear(cmd, cameraColorIden, rtIDs[0], rtSizes[0], offsetRatio, computeShader); } else { string intermediateRTName = \"_KawaseRT\" + (downSampleCount + 1).ToString(); int intermediateRTID = Shader.PropertyToID(intermediateRTName); Vector2Int intermediateRTSize = rtSizes[downSampleCount]; tempDesc.width = intermediateRTSize.x; tempDesc.height = intermediateRTSize.y; cmd.GetTemporaryRT(intermediateRTID, tempDesc); for (int i = downSampleCount+1; i = 1; i--) { int sourceID = rtIDs[i]; Vector2Int sourceSize = rtSizes[i]; int targetID = i == (downSampleCount + 1) ? intermediateRTID : rtIDs[i - 1]; Vector2Int targetSize = rtSizes[i - 1]; DoKawaseSample(cmd, sourceID, targetID, sourceSize, targetSize, 1.0f, false, computeShader); if (i == (downSampleCount + 1)) { DoKawaseLinear(cmd, rtIDs[i - 1], intermediateRTID, targetSize, offsetRatio, computeShader); int tempID = intermediateRTID; intermediateRTID = rtIDs[i - 1]; rtIDs[i - 1] = tempID; } cmd.ReleaseTemporaryRT(sourceID); } cmd.ReleaseTemporaryRT(intermediateRTID); } cmd.Blit(kawaseRTID, cameraColorIden); cmd.ReleaseTemporaryRT(kawaseRTID); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } } } DualKawaseBlur.cs æ²¡å•¥å¥½è¯´çš„\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Dual Kawase Blur\", typeof(UniversalRenderPipeline))] public class DualKawaseBlur : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter maxRadius = new ClampedFloatParameter(32.0f, 0.0f, 255.0f); public ClampedFloatParameter intensity = new ClampedFloatParameter(0.0f, 0.0f, 1.0f); public float GetRadius() { return maxRadius.value * intensity.value; } public bool IsActive() { return isEnabled.value \u0026\u0026 intensity.value  0.0f; } public bool IsTileCompatible() { return false; } } } DualKawaseBlurRendererFeature.cs ä¹Ÿæ²¡å•¥å¥½è¯´çš„ã€‚\nusing System.Collections; namespace UnityEngine.Rendering.Universal { public class DualKawaseBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class DualKawaseBlurSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader computeShader; } public DualKawaseBlurSettings settings = new DualKawaseBlurSettings(); private DualKawaseBlurRenderPass dualKawaseBlurRenderPass; public override void Create() { dualKawaseBlurRenderPass = new DualKawaseBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { DualKawaseBlur dualKawaseBlur = VolumeManager.instance.stack.GetComponent(); if (dualKawaseBlur != null \u0026\u0026 dualKawaseBlur.IsActive()) { dualKawaseBlurRenderPass.Setup(dualKawaseBlur); renderer.EnqueuePass(dualKawaseBlurRenderPass); } } } } åè®° è¿…é€Ÿåœ°å†™å®Œäº†è¿™ç¯‡åšå®¢ï¼Œå…¶å®æœ‰ä»·å€¼çš„ä¸œè¥¿å¹¶ä¸æ˜¯å¤ªå¤šã€‚ä¸»è¦æ˜¯åœ¨ç½‘ä¸Šæœç´¢äº†åŠå¤©ï¼Œåªæœ‰å‡ ä¹åƒç¯‡ä¸€å¾‹çš„ä»£ç å’Œåƒç¯‡ä¸€å¾‹çš„ç¤ºæ„å›¾ï¼Œå¹¶æ²¡æœ‰å¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå› æ­¤è‡ªå·±åšäº†ä¸€äº›ç ”ç©¶ã€‚ä¸å¾—ä¸è¯´Dual Kawase Bluråšå¾—è¿˜æ˜¯å¾ˆèªæ˜çš„ï¼Œæœ€åæ¨¡ç³Šçš„æ•ˆæœä¹Ÿçœ‹ä¸å‡ºä»€ä¹ˆæ˜æ˜¾çš„æ–¹å½¢çš„ç—•è¿¹ã€‚\n","wordCount":"1077","inLanguage":"en","image":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/posts/images/DualKawaseBlur.png","datePublished":"2023-05-29T12:00:00+08:00","dateModified":"2023-05-29T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</h1><div class=post-description>ä½¿ç”¨çº¿æ€§æ’å€¼æ¥è·å¾—æ¸å˜çš„æ¨¡ç³Š.</div><div class=post-meta><span title="2023-05-29 12:00:00 +0800 CST">May 29, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/almost-continuous-dual-kawase-blur.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/DualKawaseBlur.png alt="Dual Kawase Blur Cover"><p>Dual Kawase Blur Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</div></summary><div class=inner><ul><li><a href=#2023%e5%b9%b46%e6%9c%883%e6%97%a5%e4%bf%ae%e8%ae%a2 aria-label=2023å¹´6æœˆ3æ—¥ä¿®è®¢>2023å¹´6æœˆ3æ—¥ä¿®è®¢</a></li><li><a href=#%e5%86%99%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=å†™è¿™ç¯‡æ–‡ç« çš„åŸå› >å†™è¿™ç¯‡æ–‡ç« çš„åŸå› </a></li><li><a href=#%e5%8f%8ckawase%e6%a8%a1%e7%b3%8adual-kawase-blur aria-label="åŒKawaseæ¨¡ç³Š(Dual Kawase Blur)">åŒKawaseæ¨¡ç³Š(Dual Kawase Blur)</a></li><li><a href=#%e9%87%8f%e5%8c%96%e5%8f%8ckawase%e6%a8%a1%e7%b3%8a aria-label=é‡åŒ–åŒKawaseæ¨¡ç³Š>é‡åŒ–åŒKawaseæ¨¡ç³Š</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=å…·ä½“çš„æ“ä½œ>å…·ä½“çš„æ“ä½œ</a><ul><li><a href=#dualkawaseblurcomputeshadercompute aria-label=DualKawaseBlurComputeShader.compute>DualKawaseBlurComputeShader.compute</a></li><li><a href=#dualkawaseblurrenderpasscs aria-label=DualKawaseBlurRenderPass.cs>DualKawaseBlurRenderPass.cs</a></li><li><a href=#dualkawaseblurcs aria-label=DualKawaseBlur.cs>DualKawaseBlur.cs</a></li><li><a href=#dualkawaseblurrendererfeaturecs aria-label=DualKawaseBlurRendererFeature.cs>DualKawaseBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=2023å¹´6æœˆ3æ—¥ä¿®è®¢>2023å¹´6æœˆ3æ—¥ä¿®è®¢<a hidden class=anchor aria-hidden=true href=#2023å¹´6æœˆ3æ—¥ä¿®è®¢>#</a></h2><p>å‘ç°è¿˜æ˜¯åœ¨é™é‡‡æ ·å‡é‡‡æ ·åè¿›è¡Œçº¿æ€§æ’å€¼æ¥è·å–ä¸­é—´ç¨‹åº¦çš„æ¨¡ç³Šæ•ˆæœæ¯”è¾ƒå¥½ï¼Œæ‰€ä»¥åé¢çš„ä»£ç ä¹Ÿéƒ½æ”¹è¿‡æ¥äº†ï¼Œä¸è¿‡ç†è®ºä¸Šçš„éƒ¨åˆ†å€’æ˜¯æ²¡å¿…è¦æ”¹ã€‚é¡ºä¾¿ä¹ŸèŠ±äº†ç‚¹æ—¶é—´å†™äº†ä¸€ä¸ªShadertoyä½œä¸ºæ¼”ç¤ºï¼š</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/ct3Szl?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Dual Kawase Blur</p></figure><h2 id=å†™è¿™ç¯‡æ–‡ç« çš„åŸå› >å†™è¿™ç¯‡æ–‡ç« çš„åŸå› <a hidden class=anchor aria-hidden=true href=#å†™è¿™ç¯‡æ–‡ç« çš„åŸå› >#</a></h2><p>ç½‘ä¸Šå·²ç»æœ‰äº†å¾ˆå¤šå¾ˆå¤šçš„åŒKawaseæ¨¡ç³Šçš„ç°æˆçš„æ¡ˆä¾‹ï¼Œä½†æ˜¯å­˜åœ¨ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š1. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« éƒ½åªç»™äº†ä»£ç ï¼Œæ²¡æœ‰ç›¸åº”çš„è§£é‡Šï¼Œè‡³å¤šä¼šç»™ä¸€å¼ ç›´æ¥ä»Armçš„pdfæˆªå–çš„å›¾ç¤ºï¼Œè€Œè¿™å¼ å›¾ç¤ºç”»äº†ä¸€å †æ–¹æ¡†å’Œç¬¦å·ï¼Œå´æ²¡æœ‰è¯´æ˜è¿™äº›å›¾æ¡ˆä»£è¡¨çš„å«ä¹‰ã€‚2. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« é€šè¿‡ä¿®æ”¹é‡‡æ ·çš„è·ç¦»æ¥æ§åˆ¶æ¨¡ç³Šçš„ç¨‹åº¦ï¼Œè¿™ä¸ªçš„ç¼ºç‚¹æˆ‘ä»¬åç»­å†è°ˆã€‚3. ç»å¤§éƒ¨åˆ†çš„æ–‡ç« å¹¶æ²¡æœ‰è€ƒè™‘æ¨¡ç³Šç¨‹åº¦ä»0å¼€å§‹é€æ¸å¢å¤§çš„åŠ¨æ€è¿‡ç¨‹ï¼Œä½¿ç”¨é™é‡‡æ ·å’Œå‡é‡‡æ ·å¾€å¾€ä¼šç ´åæ•´ä¸ªç”»é¢çš„è¿ç»­æ€§ã€‚</p><p>å¦‚æœåªæ˜¯æƒ³è¦è·å¾—ä¸€ä¸ªæ¨¡ç³Šçš„ç”»é¢ï¼Œåªéœ€è¦åšå‡ æ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·å°±èƒ½å®Œæˆäº†ï¼Œä½†æˆ‘å¸Œæœ›èƒ½æœ‰ä¸€ä¸ªè¿ç»­åœ°é€æ¸åœ°å˜æ¨¡ç³Šçš„è¿‡ç¨‹ï¼Œå› æ­¤æˆ‘å¼€å§‹äº†é‡åŒ–åŒKawaseæ¨¡ç³Šçš„æƒ³æ³•ã€‚</p><h2 id=åŒkawaseæ¨¡ç³Šdual-kawase-blur>åŒKawaseæ¨¡ç³Š(Dual Kawase Blur)<a hidden class=anchor aria-hidden=true href=#åŒkawaseæ¨¡ç³Šdual-kawase-blur>#</a></h2><p>åŒKawaseæ¨¡ç³Šæ˜¯2015å¹´Armåœ¨Kawaseæ¨¡ç³Šçš„åŸºç¡€ä¸Šæå‡ºçš„ä¸€ç§é€šè¿‡é™é‡‡æ ·å’Œå‡é‡‡æ ·æ¥å¿«é€Ÿä¸”é«˜æ•ˆåœ°è¿›è¡Œé«˜è´¨é‡å¤§åŠå¾„æ¨¡ç³Šçš„ä¸€ç§æ–¹æ³•ï¼Œå…·ä½“çš„pdfå¯ä»¥ä»<a href=https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_slides.pdf>è¿™é‡Œ</a>æ‰¾åˆ°ã€‚</p><p><img loading=lazy src=../images/DualKawaseBlurDiagram.jpg#center alt="Dual Kawase Blur Diagram"></p><p>è¿™é‡Œæ˜¯ä¸€å¼ åŒKawaseæ¨¡ç³Šçš„å›¾ç¤ºï¼Œè¡¨ç¤ºäº†åŒKawaseæ¨¡ç³Šåœ¨é™é‡‡æ ·å’Œå‡é‡‡æ ·æ—¶çš„æ“ä½œã€‚ç»†çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯åŸå§‹çš„åƒç´ ï¼ˆæˆ–æ˜¯å‡é‡‡æ ·åçš„åƒç´ ï¼‰ï¼Œç²—çš„é»‘çº¿å¯¹åº”çš„æ ¼å­æ˜¯é™é‡‡æ ·åçš„åƒç´ ã€‚å‰å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ ï¼Œåœ†å¯¹åº”çš„æ˜¯å½“å‰æ¨¡ç³Šçš„åƒç´ æ‰€éœ€è¦é‡‡æ ·ç‚¹ã€‚ç²‰è‰²å¯¹åº”çš„æ˜¯é™é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ï¼Œç»¿è‰²å¯¹åº”çš„æ˜¯å‡é‡‡æ ·æ—¶çš„æ¨¡ç³Šçš„åƒç´ å’Œé‡‡æ ·ç‚¹ã€‚</p><p>ä»è¿™å¼ å›¾ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°åŒKawaseæ¨¡ç³Šåˆ©ç”¨åŒçº¿æ€§é‡‡æ ·æ¥èŠ‚çœé‡‡æ ·æ•°çš„æ“ä½œã€‚åœ¨é™é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åå…­ä¸ªåƒç´ çš„é¢œè‰²ï¼›åœ¨å‡é‡‡æ ·æ—¶å®é™…é‡‡æ ·äº†å½“å‰åƒç´ å‘¨å›´ä¸€å…±åä¸‰ä¸ªåƒç´ çš„é¢œè‰²ã€‚è€Œå¦‚æœåœ¨åšé™é‡‡æ ·æ—¶ï¼Œå¯¹äºå¥‡æ•°ä¸ªåƒç´ é™¤ä»¥äºŒå‘ä¸‹å–æ•´ï¼Œæˆ–è€…æ˜¯åœ¨é™é‡‡æ ·æ—¶ä½¿ç”¨äº†ä¸æ°å½“çš„åç§»ï¼ˆæ¯”å¦‚1.5å€çš„åç§»ï¼‰ï¼Œä¼šå¯¼è‡´é™é‡‡æ ·çš„é‡‡æ ·ç‚¹è½åœ¨åŸå§‹åƒç´ çš„ä¸­å¿ƒï¼Œè¿™æ—¶å³ä½¿ä½¿ç”¨äº†åŒçº¿æ€§é‡‡æ ·ï¼Œä¹Ÿåªç­‰ä»·äºé‡‡æ ·ä¸€ä¸ªåƒç´ ã€‚</p><p>å› æ­¤ä¸ºäº†è®©æ¯ä¸€ä¸ªåƒç´ éƒ½èƒ½å¯¹æ¨¡ç³Šåšåˆ°åº”ç”¨çš„è´¡çŒ®ï¼Œä¸ºäº†è¾¾åˆ°æ¯”è¾ƒå¥½çš„æ¨¡ç³Šæ•ˆæœï¼Œæˆ‘ä»¬è¿™é‡Œé™åˆ¶åŒKawaseæ¨¡ç³Šçš„é‡‡æ ·åç§»ä¸ºä¸€å€ï¼ˆä¹Ÿå°±æ˜¯ä¸¥æ ¼æŒ‰ç…§é‡‡æ ·ç‚¹è¿›è¡Œæœ€ä¼˜çš„åŒçº¿æ€§é‡‡æ ·ï¼‰ã€‚è€Œé€šè¿‡å¤šæ¬¡é™é‡‡æ ·å’Œå‡é‡‡æ ·è¾¾åˆ°åˆé€‚çš„æ¨¡ç³ŠåŠå¾„ã€‚</p><h2 id=é‡åŒ–åŒkawaseæ¨¡ç³Š>é‡åŒ–åŒKawaseæ¨¡ç³Š<a hidden class=anchor aria-hidden=true href=#é‡åŒ–åŒkawaseæ¨¡ç³Š>#</a></h2><p>é™é‡‡æ ·å’Œå‡é‡‡æ ·æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œå°±æ˜¯åªè¦å‘ç”Ÿäº†é™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œå°±å¿…ç„¶ä¼šå¸¦æ¥æ¨¡ç³Šã€‚è¿™æ—¶æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯åœ¨åŸå§‹åˆ†è¾¨ç‡ä¸‹é€šè¿‡æ¶ˆè€—æ›´å¤§çš„æ–¹å¼è¿›è¡ŒåŠ æƒæ¨¡ç³Šæ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šé…åˆé™é‡‡æ ·å¸¦æ¥çš„æ¨¡ç³Šï¼›å¦ä¸€ç§æ˜¯åœ¨é›¶æ¬¡å’Œä¸€æ¬¡åŒKawaseä¹‹é—´çº¿æ€§æ’å€¼å¾—åˆ°ä¸€å¼ ä»‹äºä¸¤è€…ä¹‹é—´æ¨¡ç³Šç¨‹åº¦çš„å›¾åƒã€‚ç»¼åˆä¸¤è€…æ¥çœ‹ï¼Œçº¿æ€§æ’å€¼å¾—åˆ°çš„æ•ˆæœæ›´ä¸ºå¹³æ»‘ï¼Œæ•ˆæœä¸Šç¨â€œé”™è¯¯â€ä¸€äº›ï¼Œä½†å®Œå…¨åœ¨å¯æ¥å—çš„èŒƒå›´å†…ã€‚</p><p>æˆ‘è¿™è¾¹å†™äº†ä¸€ä¸ªå°å°çš„è„šæœ¬ï¼Œå»è®¡ç®—åŸå§‹åˆ†è¾¨ç‡ä¸‹å€¼ä¸º1çš„åƒç´ ç‚¹ï¼Œåœ¨ç»è¿‡ä¸€æ¬¡åŒKawaseæ¨¡ç³Šåï¼Œå…¶ä»–åƒç´ çš„å€¼ã€‚é€šè¿‡å¤šé¡¹å¼æ‹Ÿåˆè¿™äº›æ¨¡ç³Šåçš„å€¼ï¼Œå°±èƒ½åˆ©ç”¨è¿™äº›å€¼æ¥é€¼è¿‘åŒKawaseæ¨¡ç³Šçš„æ•ˆæœäº†ã€‚æˆ‘è¿™è¾¹å¯¹8x8çš„åƒç´ åšäº†è®¡ç®—ï¼ˆå®é™…ä¸Šæ¨¡ç³Šçš„æ ¸å¿ƒåº”è¯¥æ›´å¤§ä¸€äº›ï¼Œä¸è¿‡æˆ‘æ‡’å¾—æ”¹ä¹‹å‰çš„ä»£ç äº†ï¼‰ã€‚è®¡ç®—å‡ºçš„æƒé‡å¦‚ä¸‹ï¼š</p><pre><code>0.0003255208	0.001464844	0.003092448	0.004231771	0.004231771	0.003092448	0.001464844	0.0003255208	
0.001464844	0.004882813	0.009440104	0.01204427	0.01074219	0.007486979	0.004231771	0.001464844	
0.004394531	0.01334635	0.02311198	0.02701823	0.0218099	0.01334635	0.007486979	0.003092448	
0.01009115	0.02571615	0.03808594	0.04329427	0.03678386	0.0218099	0.01074219	0.004231771	
0.01529948	0.03222656	0.04069011	0.04589844	0.04329427	0.02701823	0.01204427	0.004231771	
0.01416016	0.0296224	0.03678386	0.04069011	0.03808594	0.02311198	0.009440104	0.003092448	
0.007324219	0.01985677	0.0296224	0.03222656	0.02571615	0.01334635	0.004882813	0.001464844	
0.001627604	0.007324219	0.01416016	0.01529948	0.01009115	0.004394531	0.001464844	0.0003255208	
</code></pre><p>ç„¶åæˆ‘æŠŠå®ƒä¸¢è¿›äº†Excelå¼ºè¡Œè¿›è¡Œäº†ä¸€æ³¢è¿ç®—å¹¶æ‰‹åŠ¨è°ƒæ•´äº†ä¸€ä¸‹ï¼Œå¾—å‡ºäº†ä¸‹é¢è¿™ä¸ªæ‹Ÿåˆçš„å…¬å¼ï¼ˆxèŒƒå›´å¤§è‡´åœ¨[-4, 4]ä¹‹é—´ï¼Œå€¼å¹¶æœªå½’ä¸€åŒ–ï¼‰ï¼š</p><pre><code class=language-HLSL data-lang=HLSL>// Approximate dual kawase blur with 4th degree polynomial.
// -3.5 &lt;= x &lt;= 3.5 (idealy)
float getWeight(float x)
{
	return 0.1356f * x * x * x * x - 0.06748 * x * x * x - 4.693656 * x * x + 0.9954208 * x + 45.57338;
}
</code></pre><h2 id=å…·ä½“çš„æ“ä½œ>å…·ä½“çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„æ“ä½œ>#</a></h2><p>æ¥ä¸‹æ¥æˆ‘ä»¬å°±èƒ½æ ¹æ®æ‹Ÿåˆçš„å…¬å¼æ¥è¿›è¡Œå‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Šäº†ã€‚é€šè¿‡è®¡ç®—ä»¥äºŒä¸ºåº•çš„å¯¹æ•°ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬éœ€è¦è¿›è¡Œå¤šå°‘æ¬¡é™é‡‡æ ·ï¼Œè€Œå…¶å°æ•°éƒ¨åˆ†åˆ™ä»£è¡¨ç€è¿›è¡Œé€¼è¿‘ä¸‹ä¸€æ¬¡åŒKawaseæ¨¡ç³Šçš„ç¨‹åº¦ï¼Œå¯¹åº”æ¨¡ç³Šçš„offsetå€¼ã€‚</p><h3 id=dualkawaseblurcomputeshadercompute>DualKawaseBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#dualkawaseblurcomputeshadercompute>#</a></h3><p>è¿™é‡Œå°±æ‡’å¾—å¯¹åŒKawaseæ¨¡ç³Šé‚£ä¸€éƒ¨åˆ†å†™group shared memoryçš„ä¼˜åŒ–äº†ã€‚<code>THREAD_GROUP_SIZE</code>éœ€è¦æ˜¯<code>BLUR_RADIUS</code>çš„å››å€ä»¥ä¸Šï¼Œä¸ç„¶ç¼“å­˜çš„æ—¶å€™æ¯ä¸ªåƒç´ éœ€è¦é‡‡æ›´å¤šçš„æ ·ã€‚<code>BLUR_RADIUS</code>å®é™…ä¸Šæ˜¯4ä½†è¿™è¾¹å†™äº†5ï¼Œæ˜¯å› ä¸ºéœ€è¦é¢å¤–é¢„ç•™ä¸€ä¸ªåƒç´ è¿›è¡Œæ‰‹åŠ¨çš„åŒçº¿æ€§é‡‡æ ·ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel KawaseDownSample
#pragma kernel KawaseUpSample
#pragma kernel KawaseLinear

Texture2D&lt;float4&gt; _SourceTexture;
RWTexture2D&lt;float4&gt; _RW_TargetTexture;
SamplerState sampler_LinearClamp;
float4 _SourceSize;
float4 _TargetSize;
float _Offset;

float3 sampleSource(float2 center, float2 offset)
{
	return _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset * _Offset, 0.0f).rgb;
}

[numthreads(8,8,1)]
void KawaseDownSample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 halfPixel = 0.5f * _TargetSize.zw;

	float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f));

	float3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f;
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void KawaseUpSample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 onePixel = 1.0f * _TargetSize.zw;

	// float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));
	float3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));
	float3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));
	float3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));
	float3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));

	float3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void KawaseLinear(uint3 id : SV_DispatchThreadID)
{
	half3 sourceTex = _SourceTexture.Load(uint3(id.xy, 0)).rgb;
	half3 blurredTex = _RW_TargetTexture.Load(uint3(id.xy, 0)).rgb;
	half3 color = lerp(sourceTex, blurredTex, _Offset);
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}
</code></pre><h3 id=dualkawaseblurrenderpasscs>DualKawaseBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurrenderpasscs>#</a></h3><p>è¿™é‡Œéœ€è¦å¯¹æœ€åä¸€æ¬¡é™é‡‡æ ·åšä¸€æ¬¡æ‹Ÿåˆçš„æ“ä½œï¼Œç„¶åè¿˜è¦æ³¨æ„ä¸€æ¬¡éƒ½ä¸è¿›è¡Œé™é‡‡æ ·æ—¶ä¹Ÿéœ€è¦è¿›è¡Œæ‹Ÿåˆã€‚ä½¿ç”¨çš„Unityç‰ˆæœ¬æ˜¯2021.3.19f1c1ï¼ŒURPç‰ˆæœ¬æ˜¯12.1.10ï¼Œå› æ­¤ä¼šæœ‰<code>_CameraColorAttachmentA</code>è¿™æ ·å¥‡æ€ªçš„åå­—ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Circular Blur Render Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings;
        <span style=color:#66d9ef>private</span> DualKawaseBlur dualKawaseBlur;
        <span style=color:#66d9ef>private</span> ComputeShader computeShader;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;

        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
        <span style=color:#66d9ef>private</span> RenderTextureDescriptor desc;

        <span style=color:#66d9ef>public</span> DualKawaseBlurRenderPass(DualKawaseBlurRendererFeature.DualKawaseBlurSettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);

            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            computeShader = settings.computeShader;

            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(DualKawaseBlur dualKawaseBlur)
        {
            <span style=color:#66d9ef>this</span>.dualKawaseBlur = dualKawaseBlur;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
            desc = cameraTextureDescriptor;
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
        }

        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoKawaseSample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
                                        Vector2Int sourceSize, Vector2Int targetSize,
                                        <span style=color:#66d9ef>float</span> offset, <span style=color:#66d9ef>bool</span> downSample, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = downSample ? <span style=color:#e6db74>&#34;KawaseDownSample&#34;</span> : <span style=color:#e6db74>&#34;KawaseUpSample&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TargetSize&#34;</span>, GetTextureSizeParams(targetSize));
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Offset&#34;</span>, offset);
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoKawaseLinear(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
            Vector2Int sourceSize, <span style=color:#66d9ef>float</span> offset, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = <span style=color:#e6db74>&#34;KawaseLinear&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Offset&#34;</span>, offset);
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)sourceSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)sourceSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get();
            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                List&lt;<span style=color:#66d9ef>int</span>&gt; rtIDs = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt;();
                List&lt;Vector2Int&gt; rtSizes = <span style=color:#66d9ef>new</span> List&lt;Vector2Int&gt;();

                RenderTextureDescriptor tempDesc = desc;
                <span style=color:#66d9ef>string</span> kawaseRT = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span>;
                <span style=color:#66d9ef>int</span> kawaseRTID = Shader.PropertyToID(kawaseRT);
                cmd.GetTemporaryRT(kawaseRTID, tempDesc);

                rtIDs.Add(kawaseRTID);
                rtSizes.Add(textureSize);

                <span style=color:#66d9ef>float</span> downSampleAmount = Mathf.Log(dualKawaseBlur.GetRadius() + <span style=color:#ae81ff>1.0f</span>) / <span style=color:#ae81ff>0.693147181f</span>;
                <span style=color:#66d9ef>int</span> downSampleCount = Mathf.FloorToInt(downSampleAmount);
                <span style=color:#66d9ef>float</span> offsetRatio = downSampleAmount - (<span style=color:#66d9ef>float</span>)downSampleCount;

                Vector2Int lastSize = textureSize;
                <span style=color:#66d9ef>int</span> lastID = cameraColorTextureID;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt;= downSampleCount; i++)
                {
                    <span style=color:#66d9ef>string</span> rtName = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span> + i.ToString();
                    <span style=color:#66d9ef>int</span> rtID = Shader.PropertyToID(rtName);
                    Vector2Int rtSize = <span style=color:#66d9ef>new</span> Vector2Int((lastSize.x + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>, (lastSize.y + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>);
                    tempDesc.width = rtSize.x;
                    tempDesc.height = rtSize.y;
                    cmd.GetTemporaryRT(rtID, tempDesc);

                    rtIDs.Add(rtID);
                    rtSizes.Add(rtSize);

                    DoKawaseSample(cmd, lastID, rtID, lastSize, rtSize, <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>true</span>, computeShader);
                    lastSize = rtSize;
                    lastID = rtID;
                }

                <span style=color:#66d9ef>if</span>(downSampleCount == <span style=color:#ae81ff>0</span>)
                {
                    DoKawaseSample(cmd, rtIDs[<span style=color:#ae81ff>1</span>], rtIDs[<span style=color:#ae81ff>0</span>], rtSizes[<span style=color:#ae81ff>1</span>], rtSizes[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>false</span>, computeShader);
                    DoKawaseLinear(cmd, cameraColorIden, rtIDs[<span style=color:#ae81ff>0</span>], rtSizes[<span style=color:#ae81ff>0</span>], offsetRatio, computeShader);
                }
                <span style=color:#66d9ef>else</span>
                {
                    <span style=color:#66d9ef>string</span> intermediateRTName = <span style=color:#e6db74>&#34;_KawaseRT&#34;</span> + (downSampleCount + <span style=color:#ae81ff>1</span>).ToString();
                    <span style=color:#66d9ef>int</span> intermediateRTID = Shader.PropertyToID(intermediateRTName);
                    Vector2Int intermediateRTSize = rtSizes[downSampleCount];
                    tempDesc.width = intermediateRTSize.x;
                    tempDesc.height = intermediateRTSize.y;
                    cmd.GetTemporaryRT(intermediateRTID, tempDesc);

                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = downSampleCount+<span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>1</span>; i--)
                    {
                        <span style=color:#66d9ef>int</span> sourceID = rtIDs[i];
                        Vector2Int sourceSize = rtSizes[i];
                        <span style=color:#66d9ef>int</span> targetID = i == (downSampleCount + <span style=color:#ae81ff>1</span>) ? intermediateRTID : rtIDs[i - <span style=color:#ae81ff>1</span>];
                        Vector2Int targetSize = rtSizes[i - <span style=color:#ae81ff>1</span>];

                        DoKawaseSample(cmd, sourceID, targetID, sourceSize, targetSize, <span style=color:#ae81ff>1.0f</span>, <span style=color:#66d9ef>false</span>, computeShader);

                        <span style=color:#66d9ef>if</span> (i == (downSampleCount + <span style=color:#ae81ff>1</span>))
                        {
                            DoKawaseLinear(cmd, rtIDs[i - <span style=color:#ae81ff>1</span>], intermediateRTID, targetSize, offsetRatio, computeShader);
                            <span style=color:#66d9ef>int</span> tempID = intermediateRTID;
                            intermediateRTID = rtIDs[i - <span style=color:#ae81ff>1</span>];
                            rtIDs[i - <span style=color:#ae81ff>1</span>] = tempID;
                        }
                        cmd.ReleaseTemporaryRT(sourceID);
                    }
                    cmd.ReleaseTemporaryRT(intermediateRTID);
                }

                cmd.Blit(kawaseRTID, cameraColorIden);
                cmd.ReleaseTemporaryRT(kawaseRTID);
            }
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=dualkawaseblurcs>DualKawaseBlur.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurcs>#</a></h3><p>æ²¡å•¥å¥½è¯´çš„</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Dual Kawase Blur&#34;, typeof(UniversalRenderPipeline))]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlur</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter maxRadius = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>32.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>255.0f</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> GetRadius()
        {
            <span style=color:#66d9ef>return</span> maxRadius.<span style=color:#66d9ef>value</span> * intensity.<span style=color:#66d9ef>value</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }
    }
}
</code></pre></div><h3 id=dualkawaseblurrendererfeaturecs>DualKawaseBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#dualkawaseblurrendererfeaturecs>#</a></h3><p>ä¹Ÿæ²¡å•¥å¥½è¯´çš„ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections;
<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DualKawaseBlurSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        }

        <span style=color:#66d9ef>public</span> DualKawaseBlurSettings settings = <span style=color:#66d9ef>new</span> DualKawaseBlurSettings();
        <span style=color:#66d9ef>private</span> DualKawaseBlurRenderPass dualKawaseBlurRenderPass;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            dualKawaseBlurRenderPass = <span style=color:#66d9ef>new</span> DualKawaseBlurRenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            DualKawaseBlur dualKawaseBlur = VolumeManager.instance.stack.GetComponent&lt;DualKawaseBlur&gt;();
            <span style=color:#66d9ef>if</span> (dualKawaseBlur != <span style=color:#66d9ef>null</span> &amp;&amp; dualKawaseBlur.IsActive())
            {
                dualKawaseBlurRenderPass.Setup(dualKawaseBlur);
                renderer.EnqueuePass(dualKawaseBlurRenderPass);
            }
        }
    }
}
</code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>è¿…é€Ÿåœ°å†™å®Œäº†è¿™ç¯‡åšå®¢ï¼Œå…¶å®æœ‰ä»·å€¼çš„ä¸œè¥¿å¹¶ä¸æ˜¯å¤ªå¤šã€‚ä¸»è¦æ˜¯åœ¨ç½‘ä¸Šæœç´¢äº†åŠå¤©ï¼Œåªæœ‰å‡ ä¹åƒç¯‡ä¸€å¾‹çš„ä»£ç å’Œåƒç¯‡ä¸€å¾‹çš„ç¤ºæ„å›¾ï¼Œå¹¶æ²¡æœ‰å¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå› æ­¤è‡ªå·±åšäº†ä¸€äº›ç ”ç©¶ã€‚ä¸å¾—ä¸è¯´Dual Kawase Bluråšå¾—è¿˜æ˜¯å¾ˆèªæ˜çš„ï¼Œæœ€åæ¨¡ç³Šçš„æ•ˆæœä¹Ÿçœ‹ä¸å‡ºä»€ä¹ˆæ˜æ˜¾çš„æ–¹å½¢çš„ç—•è¿¹ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/dual-kawase-blur/>Dual Kawase Blur</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><span class=title>Â« Prev</span><br><span>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</span></a>
<a class=next href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><span class=title>Next Â»</span><br><span>Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>