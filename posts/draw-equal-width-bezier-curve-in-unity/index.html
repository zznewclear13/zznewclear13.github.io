<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在Unity的UI中绘制等宽的贝赛尔曲线 | ZZNEWCLEAR13</title><meta name=keywords content="Anti-Aliasing,Bezier Curve"><meta name=description content="在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.min.271a60922b24f96a1ee45097f47002c4807a7a7c107386422099ac8c8af51f93.css integrity="sha256-Jxpgkisk+Woe5FCX9HACxIB6enwQc4ZCIJmsjIr1H5M=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="在Unity的UI中绘制等宽的贝赛尔曲线"><meta property="og:description" content="在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/posts/images/EqualWidthBezierCurve.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-15T12:00:00+08:00"><meta property="article:modified_time" content="2021-12-15T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/posts/images/EqualWidthBezierCurve.jpg"><meta name=twitter:title content="在Unity的UI中绘制等宽的贝赛尔曲线"><meta name=twitter:description content="在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在Unity的UI中绘制等宽的贝赛尔曲线","item":"https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在Unity的UI中绘制等宽的贝赛尔曲线","name":"在Unity的UI中绘制等宽的贝赛尔曲线","description":"在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数.","keywords":["Anti-Aliasing","Bezier Curve"],"articleBody":"动机和贝塞尔曲线相关的背景知识 动机当然是要在UI上绘制一个贝塞尔曲线的形状了，想做的效果大概就和虚幻引擎蓝图连接节点的线差不多了。这里要绘制的是一种较为特殊的贝塞尔曲线，它的两个端点的切线是水平的，且拥有旋转对称的特性。\n我们想要绘制的S形曲线是三阶的贝塞尔曲线。三阶贝塞尔曲线有四个控制点\\(P_0, P_1, P_2, P_3\\)，对于一个从0到1的变量\\(t\\)，贝塞尔曲线的做法是对这四个点按照顺序以\\(t\\)做插值生成三个新的点，然后对这三个点按照顺序以\\(t\\)做插值生成新的两个点，再对这两个点以t做插值生成最后的点，当t在0到1中变化时，这个点的轨迹就构成了贝塞尔曲线。贝塞尔曲线上的点可以用四个控制点和\\(t\\)来表示： $$ P_{bezier} = P_0 \\cdot (1 - t)^3 + 3 P_1 \\cdot (1 - t)^2 \\cdot t + 3 P_2 \\cdot (1 - t) \\cdot t^2 + P_3 \\cdot t^3 $$\n如果初始四个点分别是(0.0, 1.0), (d, 1.0), (1.0 - d, 0.0)，和(1.0, 0.0)的话，也就是我们所要绘制的特殊的贝塞尔曲线，可以算出贝塞尔曲线的坐标为 $$ P_{bezier} = ((3 t - 9t ^ 2 + 6t^3) \\cdot d + 3t^2 - 2t^3, 1 - 3t^2 + 2t^3) $$ 但是即使得到了贝塞尔曲线的参数方程，想要将其表达成\\(f(x)\\)的形式仍然是相当困难的。Alan Wolfe在他的博客中提到了一种一维贝塞尔曲线，也是一种贝塞尔曲线的特殊情况，四个控制点在水平方向上等距排开，这样子贝塞尔曲线的参数方程的水平分量就刚好是\\(t\\)，它的竖直分量也就是我们需要的\\(f(x)\\)。唯一美中不足的是，能轻易得到\\(f(x)\\)的一维贝赛尔曲线，往往是一个“躺倒”的贝赛尔曲线，感官上看上去是横着的，Shadertoy上有相关的演示。但这种一维贝塞尔曲线又有一种特殊情况，也就是前两个控制点的竖直高度相等，后两个控制点的竖直高度也相等，这时这种特殊的一维贝塞尔曲线就是我们耳熟能详的smoothstep曲线了（数学真奇妙啊）。可惜smoothstep不能满足我们随意控制曲线形状的需求，只能另求他法。\n事实上我们想要确保绘制出的贝塞尔曲线是等宽的，也不能只使用曲线的\\(f(x)\\)，这样只能确保其在竖直方向是等宽的。需要整体等宽，等价于需要知道平面上每一个点到贝塞尔曲线的最近距离（也就是我们之前提到过的距离场Distance Field了。要求任意贝塞尔曲线的距离场，不是一个特别简单的事情，需要牛顿迭代法等数学方法，但是好在Shadertoy上的用户NinjaKoala已经帮我们把这个问题解决了，而且无私的把源代码分享给了我们。本博客中使用的距离场是NinjaKoala给出的一种大致的距离场，在距离贝塞尔曲线较远时会有一些偏差，但较近的距离基本上没什么问题。\n一些其他的需求 已经基本知道该怎么绘制贝塞尔曲线了，但是我们还需要考虑到在使用Shader时候的一些需求。我们要考虑的不仅仅是调整颜色、宽度、阴影等参数，而是这个Shader将要如何放到屏幕上。\n正常来说策划会指定两个顶点，说在这两个顶点之间画一条贝赛尔曲线，这时程序会给我们两个屏幕空间坐标（在Unity中就是RectTransform的坐标了），根据这两个坐标使用Image这个组件，在屏幕上用我们写的Shader的材质渲染一个Quad。\n但是事情并没有这么简单，Quad的顶点是贝塞尔曲线的两个端点的话，一个等宽的贝赛尔曲线就会超出Quad的范围，更不要说还有一段偏移和模糊的阴影了。因此我们要做是在绘制给定四个顶点的Quad时，在顶点着色器中将其顶点向外偏移一定的数量，让整条贝塞尔曲线和其阴影都能落在扩大后的Quad的范围中。\n值得一提的是，本来消耗很高的软阴影（需要很多次采样），在获得了距离场之后，可以通过普通的lerp或者Smoothstep直接生成，也是可喜可贺的一件事。\n具体的实施步骤  在Canvas中创建一个Image组件，挂上我们的材质球和DrawBezierCurve脚本。 在DrawBezierCurve脚本中获取Image组件的像素单位的宽和高（其实只要高就行了），将这个值传给Shader。 顶点着色器中，首先需要将Quad上方的两个顶点往上移半个贝塞尔曲线的宽度个像素heightA = _Width * 0.5，然后要将Quad下方的两个顶点往下移阴影偏移加半个阴影宽度个像素heightC = _ShadowOffset + _ShadowWidth * 0.5。在uv的时候要确保偏移之后的uv在原Quad范围内仍是0-1之间的。这一步对最终的效果至关重要！ 片元着色器中，使用ddx(uv.x)和ddy(uv.y)，可以计算出贝塞尔曲线的以像素为单位的距离场（也能用C#脚本传入的Quad的高和宽来算，不过应该是ddx比较方便）。使用smoothstep就能绘制出抗锯齿的贝塞尔曲线，或是模糊的阴影了。  DrawBezierCurve.cs Update的时候要记得拿到对应的材质的引用。\nusing UnityEngine; using UnityEngine.UI; [ExecuteInEditMode] [RequireComponent(typeof(Image))] [RequireComponent(typeof(RectTransform))] public class DrawBezierCurve : MonoBehaviour { public Image image; public RectTransform rectTransform; private Material material; private void OnEnable() { image = GetComponent(); material = new Material(image.material); image.material = material; rectTransform = GetComponent(); } private void Update() { Vector2 bottomLeftCorner = rectTransform.anchoredPosition + rectTransform.rect.min; Vector2 topRightCorner = rectTransform.anchoredPosition + rectTransform.rect.max; Vector4 anchorPos = new Vector4(bottomLeftCorner.x, bottomLeftCorner.y, topRightCorner.x, topRightCorner.y); material.SetVector(\"_AnchorPos\", anchorPos); } } BezierShader.shader 贝塞尔的距离场来自Cubic bezier approx distance 2。\n我还增加了选项，在显示一条横线时关闭BEZIERCURVE就能使用效率更高的横线的距离场了（要注意绘制横线时，RectTransform中Height的值不能设置成0，最好设置成一个如0.01的小数），同时也添加了水平翻转的选项。\n贝塞尔曲线和阴影混合之后再参加透明度混合，会给贝塞尔曲线带上一条浅浅的阴影颜色的描边，效果还算不错，这里就暂时不修改了。但是如果不想要这个描边的话。需要预先计算出混合后的颜色值和透明度值。如果用\\((c_1, a_1)\\)、\\((c_2, a_2)\\)、\\((c_0)\\)来分别表示曲线和阴影的颜色值、透明度值和透明度混合时目标的颜色的话（从前往后的顺序应该是曲线\\((c_1, a_1)\\)，阴影\\((c_2, a_2)\\)和透明度混合目标\\((c_0)\\)），正确的透明度混合的颜色应该是\\(c_1 a_1 + c_2 a_2 (1 - a_1) + c_0 (1 - a_1) (1 - a_2)\\)，所以可以设置透明度混合模式为Blend One SrcAlpha，然后将输出的颜色设置成float4(c1 * a1 + c2 * a2 * (1 - a1), (1 - a1) * (1 - a2))，这样混合后的颜色就是完美的正常的透明度混合了。\n//Based on https://www.shadertoy.com/view/3lsSzS Shader \"zznewclear13/BezierShader\" { Properties { [HideInInspector] _MainTex (\"Main Texture\", 2D) = \"white\" {} [Header(Marcos)] [Toggle(BEZIERCURVE)] _BezierCurve(\"Bezier Curve\", float) = 1 [Toggle(FLIP)] _Flip (\"Flip\", float) = 0 [Header(Curve Settings)] _Color (\"Color\", Color) = (1.0, 1.0, 1.0, 1.0) _Curve (\"Curve\", range(0, 1)) = 0.2 _Width (\"Pixel Width\", float) = 5 [Header(Shadow Settings)] _ShadowColor (\"Shadow Color\", color) = (0.0, 0.0, 0.0, 0.5) _ShadowOffset (\"Shadow Offset\", float) = 30 _ShadowWidth (\"Shadow Width\", float) = 20 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #pragma multi_compile_local _ FLIP #pragma multi_compile_local _ BEZIERCURVE sampler2D _MainTex; CBUFFER_START(UnityPerMaterial) float4 _Color; float _Curve; float _Width; float4 _ShadowColor; float _ShadowOffset; float _ShadowWidth; CBUFFER_END float4 _AnchorPos; static float2 VertexOffsets[] = { float2(0, -1), float2(1, 0), float2(1, 0), float2(0, -1), }; struct Attributes { uint vertexID : SV_VERTEXID; float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; }; Varyings Vert(Attributes input) { Varyings output = (Varyings)0; float4 positionOS = input.positionOS; float heightA = _Width * 0.5; float heightB = _AnchorPos.w - _AnchorPos.y; float heightC = _ShadowOffset + _ShadowWidth * 0.5; positionOS.y += VertexOffsets[input.vertexID].x * heightA + VertexOffsets[input.vertexID].y * heightC; VertexPositionInputs vertexInput = GetVertexPositionInputs(positionOS); output.positionCS = vertexInput.positionCS; //0-1 - -(heightC) / heightB, (heightA + heightB + heightC) / heightB float newCoordY = (heightA + heightB + heightC) / heightB * input.texcoord.y - (heightC) / heightB ; output.uv = float2(input.texcoord.x, newCoordY); return output; } float cubic_bezier_normal_iteration(float t, float2 a0, float2 a1, float2 a2, float2 a3) { //factor should be positive //it decreases the step size when lowered. //Lowering the factor and increasing iterations increases the area in which //the iteration converges, but this is quite costly const float factor=1.; //horner's method float2 a_2=a2+t*a3; float2 a_1=a1+t*a_2; float2 b_2=a_2+t*a3; float2 uv_to_p=a0+t*a_1; float2 tang=a_1+t*b_2; float l_tang=dot(tang,tang); return t-factor*dot(tang,uv_to_p)/l_tang; } float cubic_bezier_dis_approx_sq(float2 uv, float2 p0, float2 p1, float2 p2, float2 p3) { float2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3); float2 a2 = (3. * p0 - 6. * p1 + 3. * p2); float2 a1 = (-3. * p0 + 3. * p1); float2 a0 = p0 - uv; float d0 = 1e38; float t0=0.; float t; const int num_iterations=3; const int num_start_params=3; for(int i=0;i最后的思考 数学真奇妙啊！也很感谢Shadertoy上用户们的无私的奉献！但是微积分对我来说还是太难了，是不是应该找个机会补一补呢。。。最后就是我感觉对fwidth抗锯齿的理解又加深了！\n","wordCount":"817","inLanguage":"en","image":"https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/posts/images/EqualWidthBezierCurve.jpg","datePublished":"2021-12-15T12:00:00+08:00","dateModified":"2021-12-15T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>在Unity的UI中绘制等宽的贝赛尔曲线</h1><div class=post-description>在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数.</div><div class=post-meta>December 15, 2021&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/draw-equal-width-bezier-curve-in-unity.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/EqualWidthBezierCurve.jpg alt="Equal Width Bezier Curve"><p>带阴影的可控制各种参数的等宽的贝塞尔曲线</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在Unity的UI中绘制等宽的贝赛尔曲线</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba%e5%92%8c%e8%b4%9d%e5%a1%9e%e5%b0%94%e6%9b%b2%e7%ba%bf%e7%9b%b8%e5%85%b3%e7%9a%84%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86 aria-label=动机和贝塞尔曲线相关的背景知识>动机和贝塞尔曲线相关的背景知识</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e5%85%b6%e4%bb%96%e7%9a%84%e9%9c%80%e6%b1%82 aria-label=一些其他的需求>一些其他的需求</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e6%96%bd%e6%ad%a5%e9%aa%a4 aria-label=具体的实施步骤>具体的实施步骤</a><ul><li><a href=#drawbeziercurvecs aria-label=DrawBezierCurve.cs>DrawBezierCurve.cs</a></li><li><a href=#beziershadershader aria-label=BezierShader.shader>BezierShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=最后的思考>最后的思考</a></li></ul></div></details></div><div class=post-content><h2 id=动机和贝塞尔曲线相关的背景知识>动机和贝塞尔曲线相关的背景知识<a hidden class=anchor aria-hidden=true href=#动机和贝塞尔曲线相关的背景知识>#</a></h2><p>动机当然是要在UI上绘制一个贝塞尔曲线的形状了，想做的效果大概就和虚幻引擎蓝图连接节点的线差不多了。这里要绘制的是一种较为特殊的贝塞尔曲线，它的两个端点的切线是水平的，且拥有旋转对称的特性。</p><p>我们想要绘制的S形曲线是三阶的贝塞尔曲线。三阶贝塞尔曲线有四个控制点\(P_0, P_1, P_2, P_3\)，对于一个从0到1的变量\(t\)，贝塞尔曲线的做法是对这四个点按照顺序以\(t\)做插值生成三个新的点，然后对这三个点按照顺序以\(t\)做插值生成新的两个点，再对这两个点以t做插值生成最后的点，当t在0到1中变化时，这个点的轨迹就构成了贝塞尔曲线。贝塞尔曲线上的点可以用四个控制点和\(t\)来表示：
$$
P_{bezier} = P_0 \cdot (1 - t)^3 + 3 P_1 \cdot (1 - t)^2 \cdot t + 3 P_2 \cdot (1 - t) \cdot t^2 + P_3 \cdot t^3
$$</p><p>如果初始四个点分别是(0.0, 1.0), (d, 1.0), (1.0 - d, 0.0)，和(1.0, 0.0)的话，也就是我们所要绘制的特殊的贝塞尔曲线，可以算出贝塞尔曲线的坐标为
$$
P_{bezier} = ((3 t - 9t ^ 2 + 6t^3) \cdot d + 3t^2 - 2t^3, 1 - 3t^2 + 2t^3)
$$
但是即使得到了贝塞尔曲线的参数方程，想要将其表达成\(f(x)\)的形式仍然是相当困难的。Alan Wolfe在他的博客中提到了一种<a href=https://blog.demofox.org/2014/08/28/one-dimensional-bezier-curves/>一维贝塞尔曲线</a>，也是一种贝塞尔曲线的特殊情况，四个控制点在水平方向上等距排开，这样子贝塞尔曲线的参数方程的水平分量就刚好是\(t\)，它的竖直分量也就是我们需要的\(f(x)\)。唯一美中不足的是，能轻易得到\(f(x)\)的一维贝赛尔曲线，往往是一个“躺倒”的贝赛尔曲线，感官上看上去是横着的，Shadertoy上有相关的<a href=https://www.shadertoy.com/view/lsV3Wd>演示</a>。但这种一维贝塞尔曲线又有一种特殊情况，也就是前两个控制点的竖直高度相等，后两个控制点的竖直高度也相等，这时这种特殊的一维贝塞尔曲线就是我们耳熟能详的<code>smoothstep</code>曲线了（数学真奇妙啊）。可惜<code>smoothstep</code>不能满足我们随意控制曲线形状的需求，只能另求他法。</p><p>事实上我们想要确保绘制出的贝塞尔曲线是等宽的，也不能只使用曲线的\(f(x)\)，这样只能确保其在竖直方向是等宽的。需要整体等宽，等价于需要知道平面上每一个点到贝塞尔曲线的最近距离（也就是我们之前提到过的距离场Distance Field了。要求任意贝塞尔曲线的距离场，不是一个特别简单的事情，需要牛顿迭代法等数学方法，但是好在Shadertoy上的用户<a href=https://www.shadertoy.com/user/NinjaKoala>NinjaKoala</a>已经帮我们把这个问题解决了，而且无私的把<a href=https://www.shadertoy.com/view/4sKyzW>源代码</a>分享给了我们。本博客中使用的距离场是NinjaKoala给出的一种<a href=https://www.shadertoy.com/view/3lsSzS>大致的距离场</a>，在距离贝塞尔曲线较远时会有一些偏差，但较近的距离基本上没什么问题。</p><h2 id=一些其他的需求>一些其他的需求<a hidden class=anchor aria-hidden=true href=#一些其他的需求>#</a></h2><p>已经基本知道该怎么绘制贝塞尔曲线了，但是我们还需要考虑到在使用Shader时候的一些需求。我们要考虑的不仅仅是调整颜色、宽度、阴影等参数，而是这个Shader将要如何放到屏幕上。</p><p>正常来说策划会指定两个顶点，说在这两个顶点之间画一条贝赛尔曲线，这时程序会给我们两个屏幕空间坐标（在Unity中就是RectTransform的坐标了），根据这两个坐标使用<code>Image</code>这个组件，在屏幕上用我们写的Shader的材质渲染一个Quad。</p><p>但是事情并没有这么简单，Quad的顶点是贝塞尔曲线的两个端点的话，一个等宽的贝赛尔曲线就会超出Quad的范围，更不要说还有一段偏移和模糊的阴影了。因此我们要做是在绘制给定四个顶点的Quad时，在顶点着色器中将其顶点向外偏移一定的数量，让整条贝塞尔曲线和其阴影都能落在扩大后的Quad的范围中。</p><p>值得一提的是，本来消耗很高的软阴影（需要很多次采样），在获得了距离场之后，可以通过普通的<code>lerp</code>或者<code>Smoothstep</code>直接生成，也是可喜可贺的一件事。</p><h2 id=具体的实施步骤>具体的实施步骤<a hidden class=anchor aria-hidden=true href=#具体的实施步骤>#</a></h2><ol><li>在<code>Canvas</code>中创建一个<code>Image</code>组件，挂上我们的材质球和<code>DrawBezierCurve</code>脚本。</li><li>在<code>DrawBezierCurve</code>脚本中获取<code>Image</code>组件的像素单位的宽和高（其实只要高就行了），将这个值传给Shader。</li><li>顶点着色器中，首先需要将Quad上方的两个顶点往上移半个贝塞尔曲线的宽度个像素<code>heightA = _Width * 0.5</code>，然后要将Quad下方的两个顶点往下移阴影偏移加半个阴影宽度个像素<code>heightC = _ShadowOffset + _ShadowWidth * 0.5</code>。在uv的时候要确保偏移之后的uv在原Quad范围内仍是0-1之间的。这一步对最终的效果至关重要！</li><li>片元着色器中，使用<code>ddx(uv.x)</code>和<code>ddy(uv.y)</code>，可以计算出贝塞尔曲线的以像素为单位的距离场（也能用C#脚本传入的Quad的高和宽来算，不过应该是ddx比较方便）。使用<code>smoothstep</code>就能绘制出抗锯齿的贝塞尔曲线，或是模糊的阴影了。</li></ol><h3 id=drawbeziercurvecs>DrawBezierCurve.cs<a hidden class=anchor aria-hidden=true href=#drawbeziercurvecs>#</a></h3><p>Update的时候要记得拿到对应的材质的引用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> UnityEngine.UI;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[ExecuteInEditMode]</span>
<span style=color:#a6e22e>[RequireComponent(typeof(Image))]</span>
<span style=color:#a6e22e>[RequireComponent(typeof(RectTransform))]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DrawBezierCurve</span> : MonoBehaviour
{
    <span style=color:#66d9ef>public</span> Image image;
    <span style=color:#66d9ef>public</span> RectTransform rectTransform;

    <span style=color:#66d9ef>private</span> Material material;

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
    {
        image = GetComponent&lt;Image&gt;();
        material = <span style=color:#66d9ef>new</span> Material(image.material);
        image.material = material;
        rectTransform = GetComponent&lt;RectTransform&gt;();
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
    {
        Vector2 bottomLeftCorner = rectTransform.anchoredPosition + rectTransform.rect.min;
        Vector2 topRightCorner = rectTransform.anchoredPosition + rectTransform.rect.max;
        Vector4 anchorPos = <span style=color:#66d9ef>new</span> Vector4(bottomLeftCorner.x, bottomLeftCorner.y, topRightCorner.x, topRightCorner.y);
        material.SetVector(<span style=color:#e6db74>&#34;_AnchorPos&#34;</span>, anchorPos);
    }
}
</code></pre></div><h3 id=beziershadershader>BezierShader.shader<a hidden class=anchor aria-hidden=true href=#beziershadershader>#</a></h3><p>贝塞尔的距离场来自<a href=https://www.shadertoy.com/view/3lsSzS>Cubic bezier approx distance 2</a>。</p><p>我还增加了选项，在显示一条横线时关闭<code>BEZIERCURVE</code>就能使用效率更高的横线的距离场了（要注意绘制横线时，<code>RectTransform</code>中<code>Height</code>的值不能设置成0，最好设置成一个如0.01的小数），同时也添加了水平翻转的选项。</p><p>贝塞尔曲线和阴影混合之后再参加透明度混合，会给贝塞尔曲线带上一条浅浅的阴影颜色的描边，效果还算不错，这里就暂时不修改了。但是如果不想要这个描边的话。需要预先计算出混合后的颜色值和透明度值。如果用\((c_1, a_1)\)、\((c_2, a_2)\)、\((c_0)\)来分别表示曲线和阴影的颜色值、透明度值和透明度混合时目标的颜色的话（从前往后的顺序应该是曲线\((c_1, a_1)\)，阴影\((c_2, a_2)\)和透明度混合目标\((c_0)\)），正确的透明度混合的颜色应该是\(c_1 a_1 + c_2 a_2 (1 - a_1) + c_0 (1 - a_1) (1 - a_2)\)，所以可以设置透明度混合模式为<code>Blend One SrcAlpha</code>，然后将输出的颜色设置成<code>float4(c1 * a1 + c2 * a2 * (1 - a1), (1 - a1) * (1 - a2))</code>，这样混合后的颜色就是完美的正常的透明度混合了。</p><pre><code class=language-HLSL data-lang=HLSL>//Based on https://www.shadertoy.com/view/3lsSzS

Shader &quot;zznewclear13/BezierShader&quot;
{
    Properties
    {
        [HideInInspector] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; {}
        [Header(Marcos)]
        [Toggle(BEZIERCURVE)] _BezierCurve(&quot;Bezier Curve&quot;, float) = 1
        [Toggle(FLIP)] _Flip (&quot;Flip&quot;, float) = 0

        [Header(Curve Settings)]
        _Color (&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)
        _Curve (&quot;Curve&quot;, range(0, 1)) = 0.2
        _Width (&quot;Pixel Width&quot;, float) = 5
        [Header(Shadow Settings)]
        _ShadowColor (&quot;Shadow Color&quot;, color) = (0.0, 0.0, 0.0, 0.5)
        _ShadowOffset (&quot;Shadow Offset&quot;, float) = 30
        _ShadowWidth (&quot;Shadow Width&quot;, float) = 20
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

    #pragma multi_compile_local _ FLIP
    #pragma multi_compile_local _ BEZIERCURVE

    sampler2D _MainTex;
    CBUFFER_START(UnityPerMaterial)
        float4 _Color;
        float _Curve;
        float _Width;

        float4 _ShadowColor;
        float _ShadowOffset;
        float _ShadowWidth;
    CBUFFER_END
    float4 _AnchorPos;

    static float2 VertexOffsets[] = 
    {
        float2(0, -1),
        float2(1, 0),
        float2(1, 0),
        float2(0, -1),
    };

    struct Attributes
    {
        uint vertexID       : SV_VERTEXID;
        float4 positionOS   : POSITION;
        float2 texcoord     : TEXCOORD0;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
    };

    Varyings Vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        float4 positionOS = input.positionOS;
        float heightA = _Width * 0.5;
        float heightB = _AnchorPos.w - _AnchorPos.y;
        float heightC = _ShadowOffset + _ShadowWidth * 0.5;

        positionOS.y += VertexOffsets[input.vertexID].x * heightA + VertexOffsets[input.vertexID].y * heightC;
        VertexPositionInputs vertexInput = GetVertexPositionInputs(positionOS);
        output.positionCS = vertexInput.positionCS;

        //0-1 -&gt; -(heightC) / heightB, (heightA + heightB + heightC) / heightB
        float newCoordY = (heightA + heightB + heightC) / heightB * input.texcoord.y - (heightC) / heightB ;
        output.uv = float2(input.texcoord.x, newCoordY);
        return output;
    }

    float cubic_bezier_normal_iteration(float t, float2 a0, float2 a1, float2 a2, float2 a3)
    {
        //factor should be positive
        //it decreases the step size when lowered.
        //Lowering the factor and increasing iterations increases the area in which
        //the iteration converges, but this is quite costly
        const float factor=1.;
        
        //horner's method
        float2 a_2=a2+t*a3;
        float2 a_1=a1+t*a_2;
        float2 b_2=a_2+t*a3;

        float2 uv_to_p=a0+t*a_1;
        float2 tang=a_1+t*b_2;

        float l_tang=dot(tang,tang);
        return t-factor*dot(tang,uv_to_p)/l_tang;
    }

    float cubic_bezier_dis_approx_sq(float2 uv, float2 p0, float2 p1, float2 p2, float2 p3)
    {
        float2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);
        float2 a2 = (3. * p0 - 6. * p1 + 3. * p2);
        float2 a1 = (-3. * p0 + 3. * p1);
        float2 a0 = p0 - uv;

        float d0 = 1e38;

        float t0=0.;
        float t;

        const int num_iterations=3;
        const int num_start_params=3;

        for(int i=0;i&lt;num_start_params;i++)
        {
            t=t0;
            for(int j=0;j&lt;num_iterations;j++)
            {
                t=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);
            }
            t=clamp(t,0.,1.);
            float2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;
            d0=min(d0,dot(uv_to_p,uv_to_p));

            t0+=1./float(num_start_params-1);
        }

        return d0;
    }

    float cubic_bezier_dis_approx(float2 uv, float2 p0, float2 p1, float2 p2, float2 p3)
    {
        return sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3));
    }

    float4 Frag(Varyings input) : SV_TARGET
    {
        float ddxX = ddx(input.uv.x);
        float ddyY = ddy(input.uv.y);
        float2 scale = float2(rcp(ddxX), rcp(ddyY));

        float2 coord = input.uv;
#if FLIP
        coord.x = 1.0 - coord.x;
#endif

#if BEZIERCURVE
        float2 p0=float2(0.0, 1.0) * scale;
        float2 p1=float2(_Curve, 1.0) * scale;
        float2 p2=float2(1.0 - _Curve, 0.0) * scale;
        float2 p3=float2(1.0, 0.0) * scale;

        float dist = cubic_bezier_dis_approx(coord * scale,p0,p1,p2,p3);
        float widthVal = _Width * 0.5;
        float alpha = smoothstep(widthVal + 1.0, widthVal, dist);

        float shadowDist = cubic_bezier_dis_approx(coord * scale + float2(0.0, _ShadowOffset),p0,p1,p2,p3);
        float shadowWidthVal = _ShadowWidth * 0.5;
        float shadowAlpha = smoothstep(shadowWidthVal + 1.0, 0.0, shadowDist);

#else
        float dist = abs((1.0 - coord.y) * scale.y);
        float widthVal = _Width * 0.5;
        float alpha = smoothstep(widthVal + 1.0, widthVal, dist);

        float shadowDist = abs((1.0 - coord.y) * scale.y - _ShadowOffset);
        float shadowWidthVal = _ShadowWidth * 0.5;
        float shadowAlpha = smoothstep(shadowWidthVal + 1.0, 0.0, shadowDist);
#endif

        float3 color = lerp(_ShadowColor.rgb, _Color.rgb, alpha * _Color.a);
        float finalAlpha = max(alpha * _Color.a, shadowAlpha * _ShadowColor.a);

        float4 returnColor = float4(color, finalAlpha);
        //returnColor = float4(input.uv, 0.0, 1.0);
        return returnColor;
    }

    ENDHLSL

    SubShader
    {
        Tags{ &quot;Queue&quot; = &quot;Transparent&quot; &quot;RenderType&quot; = &quot;Transparent&quot; }

        pass
        {
            Cull Back
            ZTest LEqual
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
            HLSLPROGRAM
            #pragma vertex Vert
            #pragma fragment Frag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=最后的思考>最后的思考<a hidden class=anchor aria-hidden=true href=#最后的思考>#</a></h2><p>数学真奇妙啊！也很感谢Shadertoy上用户们的无私的奉献！但是微积分对我来说还是太难了，是不是应该找个机会补一补呢。。。最后就是我感觉对<code>fwidth</code>抗锯齿的理解又加深了！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li><li><a href=https://zznewclear13.github.io/tags/bezier-curve/>Bezier Curve</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/><span class=title>« Prev Page</span><br><span>使用顶点动画制作随风飘动的植物</span></a>
<a class=next href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><span class=title>Next Page »</span><br><span>在Unity中绘制等宽的描边</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>