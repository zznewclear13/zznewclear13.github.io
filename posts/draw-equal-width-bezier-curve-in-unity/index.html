<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在Unity的UI中绘制等宽的贝赛尔曲线 | ZZNEWCLEAR13</title>
<meta name=keywords content="Anti-Aliasing,Bezier Curve,Signed Distance Field"><meta name=description content="在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="在Unity的UI中绘制等宽的贝赛尔曲线"><meta property="og:description" content="在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/posts/images/EqualWidthBezierCurve.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-15T12:00:00+08:00"><meta property="article:modified_time" content="2021-12-15T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/posts/images/EqualWidthBezierCurve.jpg"><meta name=twitter:title content="在Unity的UI中绘制等宽的贝赛尔曲线"><meta name=twitter:description content="在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在Unity的UI中绘制等宽的贝赛尔曲线","item":"https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在Unity的UI中绘制等宽的贝赛尔曲线","name":"在Unity的UI中绘制等宽的贝赛尔曲线","description":"在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数.","keywords":["Anti-Aliasing","Bezier Curve","Signed Distance Field"],"articleBody":"动机和贝塞尔曲线相关的背景知识 动机当然是要在UI上绘制一个贝塞尔曲线的形状了，想做的效果大概就和虚幻引擎蓝图连接节点的线差不多了。这里要绘制的是一种较为特殊的贝塞尔曲线，它的两个端点的切线是水平的，且拥有旋转对称的特性。\n我们想要绘制的S形曲线是三阶的贝塞尔曲线。三阶贝塞尔曲线有四个控制点\\(P_0, P_1, P_2, P_3\\)，对于一个从0到1的变量\\(t\\)，贝塞尔曲线的做法是对这四个点按照顺序以\\(t\\)做插值生成三个新的点，然后对这三个点按照顺序以\\(t\\)做插值生成新的两个点，再对这两个点以t做插值生成最后的点，当t在0到1中变化时，这个点的轨迹就构成了贝塞尔曲线。贝塞尔曲线上的点可以用四个控制点和\\(t\\)来表示： $$ P_{bezier} = P_0 \\cdot (1 - t)^3 + 3 P_1 \\cdot (1 - t)^2 \\cdot t + 3 P_2 \\cdot (1 - t) \\cdot t^2 + P_3 \\cdot t^3 $$\n如果初始四个点分别是(0.0, 1.0), (d, 1.0), (1.0 - d, 0.0)，和(1.0, 0.0)的话，也就是我们所要绘制的特殊的贝塞尔曲线，可以算出贝塞尔曲线的坐标为 $$ P_{bezier} = ((3 t - 9t ^ 2 + 6t^3) \\cdot d + 3t^2 - 2t^3, 1 - 3t^2 + 2t^3) $$ 但是即使得到了贝塞尔曲线的参数方程，想要将其表达成\\(f(x)\\)的形式仍然是相当困难的。Alan Wolfe在他的博客中提到了一种一维贝塞尔曲线，也是一种贝塞尔曲线的特殊情况，四个控制点在水平方向上等距排开，这样子贝塞尔曲线的参数方程的水平分量就刚好是\\(t\\)，它的竖直分量也就是我们需要的\\(f(x)\\)。唯一美中不足的是，能轻易得到\\(f(x)\\)的一维贝赛尔曲线，往往是一个“躺倒”的贝赛尔曲线，感官上看上去是横着的，Shadertoy上有相关的演示。但这种一维贝塞尔曲线又有一种特殊情况，也就是前两个控制点的竖直高度相等，后两个控制点的竖直高度也相等，这时这种特殊的一维贝塞尔曲线就是我们耳熟能详的smoothstep曲线了（数学真奇妙啊）。可惜smoothstep不能满足我们随意控制曲线形状的需求，只能另求他法。\n事实上我们想要确保绘制出的贝塞尔曲线是等宽的，也不能只使用曲线的\\(f(x)\\)，这样只能确保其在竖直方向是等宽的。需要整体等宽，等价于需要知道平面上每一个点到贝塞尔曲线的最近距离（也就是我们之前提到过的距离场Distance Field了。要求任意贝塞尔曲线的距离场，不是一个特别简单的事情，需要牛顿迭代法等数学方法，但是好在Shadertoy上的用户NinjaKoala已经帮我们把这个问题解决了，而且无私的把源代码分享给了我们。本博客中使用的距离场是NinjaKoala给出的一种大致的距离场，在距离贝塞尔曲线较远时会有一些偏差，但较近的距离基本上没什么问题。\n一些其他的需求 已经基本知道该怎么绘制贝塞尔曲线了，但是我们还需要考虑到在使用Shader时候的一些需求。我们要考虑的不仅仅是调整颜色、宽度、阴影等参数，而是这个Shader将要如何放到屏幕上。\n正常来说策划会指定两个顶点，说在这两个顶点之间画一条贝赛尔曲线，这时程序会给我们两个屏幕空间坐标（在Unity中就是RectTransform的坐标了），根据这两个坐标使用Image这个组件，在屏幕上用我们写的Shader的材质渲染一个Quad。\n但是事情并没有这么简单，Quad的顶点是贝塞尔曲线的两个端点的话，一个等宽的贝赛尔曲线就会超出Quad的范围，更不要说还有一段偏移和模糊的阴影了。因此我们要做是在绘制给定四个顶点的Quad时，在顶点着色器中将其顶点向外偏移一定的数量，让整条贝塞尔曲线和其阴影都能落在扩大后的Quad的范围中。\n值得一提的是，本来消耗很高的软阴影（需要很多次采样），在获得了距离场之后，可以通过普通的lerp或者Smoothstep直接生成，也是可喜可贺的一件事。\n具体的实施步骤 在Canvas中创建一个Image组件，挂上我们的材质球和DrawBezierCurve脚本。 在DrawBezierCurve脚本中获取Image组件的像素单位的宽和高（其实只要高就行了），将这个值传给Shader。 顶点着色器中，首先需要将Quad上方的两个顶点往上移半个贝塞尔曲线的宽度个像素heightA = _Width * 0.5，然后要将Quad下方的两个顶点往下移阴影偏移加半个阴影宽度个像素heightC = _ShadowOffset + _ShadowWidth * 0.5。在uv的时候要确保偏移之后的uv在原Quad范围内仍是0-1之间的。这一步对最终的效果至关重要！ 片元着色器中，使用ddx(uv.x)和ddy(uv.y)，可以计算出贝塞尔曲线的以像素为单位的距离场（也能用C#脚本传入的Quad的高和宽来算，不过应该是ddx比较方便）。使用smoothstep就能绘制出抗锯齿的贝塞尔曲线，或是模糊的阴影了。 DrawBezierCurve.cs Update的时候要记得拿到对应的材质的引用。\nusing UnityEngine; using UnityEngine.UI; [ExecuteInEditMode] [RequireComponent(typeof(Image))] [RequireComponent(typeof(RectTransform))] public class DrawBezierCurve : MonoBehaviour { public Image image; public RectTransform rectTransform; private Material material; private void OnEnable() { image = GetComponent(); material = new Material(image.material); image.material = material; rectTransform = GetComponent(); } private void Update() { Vector2 bottomLeftCorner = rectTransform.anchoredPosition + rectTransform.rect.min; Vector2 topRightCorner = rectTransform.anchoredPosition + rectTransform.rect.max; Vector4 anchorPos = new Vector4(bottomLeftCorner.x, bottomLeftCorner.y, topRightCorner.x, topRightCorner.y); material.SetVector(\"_AnchorPos\", anchorPos); } } BezierShader.shader 贝塞尔的距离场来自Cubic bezier approx distance 2。\n我还增加了选项，在显示一条横线时关闭BEZIERCURVE就能使用效率更高的横线的距离场了（要注意绘制横线时，RectTransform中Height的值不能设置成0，最好设置成一个如0.01的小数），同时也添加了水平翻转的选项。\n贝塞尔曲线和阴影混合之后再参加透明度混合，会给贝塞尔曲线带上一条浅浅的阴影颜色的描边，效果还算不错，这里就暂时不修改了。但是如果不想要这个描边的话。需要预先计算出混合后的颜色值和透明度值。如果用\\((c_1, a_1)\\)、\\((c_2, a_2)\\)、\\((c_0)\\)来分别表示曲线和阴影的颜色值、透明度值和透明度混合时目标的颜色的话（从前往后的顺序应该是曲线\\((c_1, a_1)\\)，阴影\\((c_2, a_2)\\)和透明度混合目标\\((c_0)\\)），正确的透明度混合的颜色应该是\\(c_1 a_1 + c_2 a_2 (1 - a_1) + c_0 (1 - a_1) (1 - a_2)\\)，所以可以设置透明度混合模式为Blend One SrcAlpha，然后将输出的颜色设置成float4(c1 * a1 + c2 * a2 * (1 - a1), (1 - a1) * (1 - a2))，这样混合后的颜色就是完美的正常的透明度混合了。\n//Based on https://www.shadertoy.com/view/3lsSzS Shader \"zznewclear13/BezierShader\" { Properties { [HideInInspector] _MainTex (\"Main Texture\", 2D) = \"white\" {} [Header(Marcos)] [Toggle(BEZIERCURVE)] _BezierCurve(\"Bezier Curve\", float) = 1 [Toggle(FLIP)] _Flip (\"Flip\", float) = 0 [Header(Curve Settings)] _Color (\"Color\", Color) = (1.0, 1.0, 1.0, 1.0) _Curve (\"Curve\", range(0, 1)) = 0.2 _Width (\"Pixel Width\", float) = 5 [Header(Shadow Settings)] _ShadowColor (\"Shadow Color\", color) = (0.0, 0.0, 0.0, 0.5) _ShadowOffset (\"Shadow Offset\", float) = 30 _ShadowWidth (\"Shadow Width\", float) = 20 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #pragma multi_compile_local _ FLIP #pragma multi_compile_local _ BEZIERCURVE sampler2D _MainTex; CBUFFER_START(UnityPerMaterial) float4 _Color; float _Curve; float _Width; float4 _ShadowColor; float _ShadowOffset; float _ShadowWidth; CBUFFER_END float4 _AnchorPos; static float2 VertexOffsets[] = { float2(0, -1), float2(1, 0), float2(1, 0), float2(0, -1), }; struct Attributes { uint vertexID : SV_VERTEXID; float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; }; Varyings Vert(Attributes input) { Varyings output = (Varyings)0; float4 positionOS = input.positionOS; float heightA = _Width * 0.5; float heightB = _AnchorPos.w - _AnchorPos.y; float heightC = _ShadowOffset + _ShadowWidth * 0.5; positionOS.y += VertexOffsets[input.vertexID].x * heightA + VertexOffsets[input.vertexID].y * heightC; VertexPositionInputs vertexInput = GetVertexPositionInputs(positionOS); output.positionCS = vertexInput.positionCS; //0-1 -\u003e -(heightC) / heightB, (heightA + heightB + heightC) / heightB float newCoordY = (heightA + heightB + heightC) / heightB * input.texcoord.y - (heightC) / heightB ; output.uv = float2(input.texcoord.x, newCoordY); return output; } float cubic_bezier_normal_iteration(float t, float2 a0, float2 a1, float2 a2, float2 a3) { //factor should be positive //it decreases the step size when lowered. //Lowering the factor and increasing iterations increases the area in which //the iteration converges, but this is quite costly const float factor=1.; //horner's method float2 a_2=a2+t*a3; float2 a_1=a1+t*a_2; float2 b_2=a_2+t*a3; float2 uv_to_p=a0+t*a_1; float2 tang=a_1+t*b_2; float l_tang=dot(tang,tang); return t-factor*dot(tang,uv_to_p)/l_tang; } float cubic_bezier_dis_approx_sq(float2 uv, float2 p0, float2 p1, float2 p2, float2 p3) { float2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3); float2 a2 = (3. * p0 - 6. * p1 + 3. * p2); float2 a1 = (-3. * p0 + 3. * p1); float2 a0 = p0 - uv; float d0 = 1e38; float t0=0.; float t; const int num_iterations=3; const int num_start_params=3; for(int i=0;i\u003cnum_start_params;i++) { t=t0; for(int j=0;j\u003cnum_iterations;j++) { t=cubic_bezier_normal_iteration(t,a0,a1,a2,a3); } t=clamp(t,0.,1.); float2 uv_to_p=((a3*t+a2)*t+a1)*t+a0; d0=min(d0,dot(uv_to_p,uv_to_p)); t0+=1./float(num_start_params-1); } return d0; } float cubic_bezier_dis_approx(float2 uv, float2 p0, float2 p1, float2 p2, float2 p3) { return sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3)); } float4 Frag(Varyings input) : SV_TARGET { float ddxX = ddx(input.uv.x); float ddyY = ddy(input.uv.y); float2 scale = float2(rcp(ddxX), rcp(ddyY)); float2 coord = input.uv; #if FLIP coord.x = 1.0 - coord.x; #endif #if BEZIERCURVE float2 p0=float2(0.0, 1.0) * scale; float2 p1=float2(_Curve, 1.0) * scale; float2 p2=float2(1.0 - _Curve, 0.0) * scale; float2 p3=float2(1.0, 0.0) * scale; float dist = cubic_bezier_dis_approx(coord * scale,p0,p1,p2,p3); float widthVal = _Width * 0.5; float alpha = smoothstep(widthVal + 1.0, widthVal, dist); float shadowDist = cubic_bezier_dis_approx(coord * scale + float2(0.0, _ShadowOffset),p0,p1,p2,p3); float shadowWidthVal = _ShadowWidth * 0.5; float shadowAlpha = smoothstep(shadowWidthVal + 1.0, 0.0, shadowDist); #else float dist = abs((1.0 - coord.y) * scale.y); float widthVal = _Width * 0.5; float alpha = smoothstep(widthVal + 1.0, widthVal, dist); float shadowDist = abs((1.0 - coord.y) * scale.y - _ShadowOffset); float shadowWidthVal = _ShadowWidth * 0.5; float shadowAlpha = smoothstep(shadowWidthVal + 1.0, 0.0, shadowDist); #endif float3 color = lerp(_ShadowColor.rgb, _Color.rgb, alpha * _Color.a); float finalAlpha = max(alpha * _Color.a, shadowAlpha * _ShadowColor.a); float4 returnColor = float4(color, finalAlpha); //returnColor = float4(input.uv, 0.0, 1.0); return returnColor; } ENDHLSL SubShader { Tags{ \"Queue\" = \"Transparent\" \"RenderType\" = \"Transparent\" } pass { Cull Back ZTest LEqual ZWrite Off Blend SrcAlpha OneMinusSrcAlpha HLSLPROGRAM #pragma vertex Vert #pragma fragment Frag ENDHLSL } } } 最后的思考 数学真奇妙啊！也很感谢Shadertoy上用户们的无私的奉献！但是微积分对我来说还是太难了，是不是应该找个机会补一补呢。。。最后就是我感觉对fwidth抗锯齿的理解又加深了！\n","wordCount":"817","inLanguage":"en","image":"https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/posts/images/EqualWidthBezierCurve.jpg","datePublished":"2021-12-15T12:00:00+08:00","dateModified":"2021-12-15T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">在Unity的UI中绘制等宽的贝赛尔曲线</h1><div class=post-description>在Unity的UI中绘制等宽的贝赛尔曲线，可实时控制长宽、弯曲程度和阴影等参数.</div><div class=post-meta><span title='2021-12-15 12:00:00 +0800 CST'>December 15, 2021</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/draw-equal-width-bezier-curve-in-unity.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/EqualWidthBezierCurve.jpg alt="Equal Width Bezier Curve"><p>带阴影的可控制各种参数的等宽的贝塞尔曲线</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在Unity的UI中绘制等宽的贝赛尔曲线</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba%e5%92%8c%e8%b4%9d%e5%a1%9e%e5%b0%94%e6%9b%b2%e7%ba%bf%e7%9b%b8%e5%85%b3%e7%9a%84%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86 aria-label=动机和贝塞尔曲线相关的背景知识>动机和贝塞尔曲线相关的背景知识</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e5%85%b6%e4%bb%96%e7%9a%84%e9%9c%80%e6%b1%82 aria-label=一些其他的需求>一些其他的需求</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e6%96%bd%e6%ad%a5%e9%aa%a4 aria-label=具体的实施步骤>具体的实施步骤</a><ul><li><a href=#drawbeziercurvecs aria-label=DrawBezierCurve.cs>DrawBezierCurve.cs</a></li><li><a href=#beziershadershader aria-label=BezierShader.shader>BezierShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=最后的思考>最后的思考</a></li></ul></div></details></div><div class=post-content><h2 id=动机和贝塞尔曲线相关的背景知识>动机和贝塞尔曲线相关的背景知识<a hidden class=anchor aria-hidden=true href=#动机和贝塞尔曲线相关的背景知识>#</a></h2><p>动机当然是要在UI上绘制一个贝塞尔曲线的形状了，想做的效果大概就和虚幻引擎蓝图连接节点的线差不多了。这里要绘制的是一种较为特殊的贝塞尔曲线，它的两个端点的切线是水平的，且拥有旋转对称的特性。</p><p>我们想要绘制的S形曲线是三阶的贝塞尔曲线。三阶贝塞尔曲线有四个控制点\(P_0, P_1, P_2, P_3\)，对于一个从0到1的变量\(t\)，贝塞尔曲线的做法是对这四个点按照顺序以\(t\)做插值生成三个新的点，然后对这三个点按照顺序以\(t\)做插值生成新的两个点，再对这两个点以t做插值生成最后的点，当t在0到1中变化时，这个点的轨迹就构成了贝塞尔曲线。贝塞尔曲线上的点可以用四个控制点和\(t\)来表示：
$$
P_{bezier} = P_0 \cdot (1 - t)^3 + 3 P_1 \cdot (1 - t)^2 \cdot t + 3 P_2 \cdot (1 - t) \cdot t^2 + P_3 \cdot t^3
$$</p><p>如果初始四个点分别是(0.0, 1.0), (d, 1.0), (1.0 - d, 0.0)，和(1.0, 0.0)的话，也就是我们所要绘制的特殊的贝塞尔曲线，可以算出贝塞尔曲线的坐标为
$$
P_{bezier} = ((3 t - 9t ^ 2 + 6t^3) \cdot d + 3t^2 - 2t^3, 1 - 3t^2 + 2t^3)
$$
但是即使得到了贝塞尔曲线的参数方程，想要将其表达成\(f(x)\)的形式仍然是相当困难的。Alan Wolfe在他的博客中提到了一种<a href=https://blog.demofox.org/2014/08/28/one-dimensional-bezier-curves/>一维贝塞尔曲线</a>，也是一种贝塞尔曲线的特殊情况，四个控制点在水平方向上等距排开，这样子贝塞尔曲线的参数方程的水平分量就刚好是\(t\)，它的竖直分量也就是我们需要的\(f(x)\)。唯一美中不足的是，能轻易得到\(f(x)\)的一维贝赛尔曲线，往往是一个“躺倒”的贝赛尔曲线，感官上看上去是横着的，Shadertoy上有相关的<a href=https://www.shadertoy.com/view/lsV3Wd>演示</a>。但这种一维贝塞尔曲线又有一种特殊情况，也就是前两个控制点的竖直高度相等，后两个控制点的竖直高度也相等，这时这种特殊的一维贝塞尔曲线就是我们耳熟能详的<code>smoothstep</code>曲线了（数学真奇妙啊）。可惜<code>smoothstep</code>不能满足我们随意控制曲线形状的需求，只能另求他法。</p><p>事实上我们想要确保绘制出的贝塞尔曲线是等宽的，也不能只使用曲线的\(f(x)\)，这样只能确保其在竖直方向是等宽的。需要整体等宽，等价于需要知道平面上每一个点到贝塞尔曲线的最近距离（也就是我们之前提到过的距离场Distance Field了。要求任意贝塞尔曲线的距离场，不是一个特别简单的事情，需要牛顿迭代法等数学方法，但是好在Shadertoy上的用户<a href=https://www.shadertoy.com/user/NinjaKoala>NinjaKoala</a>已经帮我们把这个问题解决了，而且无私的把<a href=https://www.shadertoy.com/view/4sKyzW>源代码</a>分享给了我们。本博客中使用的距离场是NinjaKoala给出的一种<a href=https://www.shadertoy.com/view/3lsSzS>大致的距离场</a>，在距离贝塞尔曲线较远时会有一些偏差，但较近的距离基本上没什么问题。</p><h2 id=一些其他的需求>一些其他的需求<a hidden class=anchor aria-hidden=true href=#一些其他的需求>#</a></h2><p>已经基本知道该怎么绘制贝塞尔曲线了，但是我们还需要考虑到在使用Shader时候的一些需求。我们要考虑的不仅仅是调整颜色、宽度、阴影等参数，而是这个Shader将要如何放到屏幕上。</p><p>正常来说策划会指定两个顶点，说在这两个顶点之间画一条贝赛尔曲线，这时程序会给我们两个屏幕空间坐标（在Unity中就是RectTransform的坐标了），根据这两个坐标使用<code>Image</code>这个组件，在屏幕上用我们写的Shader的材质渲染一个Quad。</p><p>但是事情并没有这么简单，Quad的顶点是贝塞尔曲线的两个端点的话，一个等宽的贝赛尔曲线就会超出Quad的范围，更不要说还有一段偏移和模糊的阴影了。因此我们要做是在绘制给定四个顶点的Quad时，在顶点着色器中将其顶点向外偏移一定的数量，让整条贝塞尔曲线和其阴影都能落在扩大后的Quad的范围中。</p><p>值得一提的是，本来消耗很高的软阴影（需要很多次采样），在获得了距离场之后，可以通过普通的<code>lerp</code>或者<code>Smoothstep</code>直接生成，也是可喜可贺的一件事。</p><h2 id=具体的实施步骤>具体的实施步骤<a hidden class=anchor aria-hidden=true href=#具体的实施步骤>#</a></h2><ol><li>在<code>Canvas</code>中创建一个<code>Image</code>组件，挂上我们的材质球和<code>DrawBezierCurve</code>脚本。</li><li>在<code>DrawBezierCurve</code>脚本中获取<code>Image</code>组件的像素单位的宽和高（其实只要高就行了），将这个值传给Shader。</li><li>顶点着色器中，首先需要将Quad上方的两个顶点往上移半个贝塞尔曲线的宽度个像素<code>heightA = _Width * 0.5</code>，然后要将Quad下方的两个顶点往下移阴影偏移加半个阴影宽度个像素<code>heightC = _ShadowOffset + _ShadowWidth * 0.5</code>。在uv的时候要确保偏移之后的uv在原Quad范围内仍是0-1之间的。这一步对最终的效果至关重要！</li><li>片元着色器中，使用<code>ddx(uv.x)</code>和<code>ddy(uv.y)</code>，可以计算出贝塞尔曲线的以像素为单位的距离场（也能用C#脚本传入的Quad的高和宽来算，不过应该是ddx比较方便）。使用<code>smoothstep</code>就能绘制出抗锯齿的贝塞尔曲线，或是模糊的阴影了。</li></ol><h3 id=drawbeziercurvecs>DrawBezierCurve.cs<a hidden class=anchor aria-hidden=true href=#drawbeziercurvecs>#</a></h3><p>Update的时候要记得拿到对应的材质的引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UI;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[ExecuteInEditMode]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[RequireComponent(typeof(Image))]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[RequireComponent(typeof(RectTransform))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DrawBezierCurve</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Image image;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> RectTransform rectTransform;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Material material;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        image = GetComponent&lt;Image&gt;();
</span></span><span style=display:flex><span>        material = <span style=color:#66d9ef>new</span> Material(image.material);
</span></span><span style=display:flex><span>        image.material = material;
</span></span><span style=display:flex><span>        rectTransform = GetComponent&lt;RectTransform&gt;();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Vector2 bottomLeftCorner = rectTransform.anchoredPosition + rectTransform.rect.min;
</span></span><span style=display:flex><span>        Vector2 topRightCorner = rectTransform.anchoredPosition + rectTransform.rect.max;
</span></span><span style=display:flex><span>        Vector4 anchorPos = <span style=color:#66d9ef>new</span> Vector4(bottomLeftCorner.x, bottomLeftCorner.y, topRightCorner.x, topRightCorner.y);
</span></span><span style=display:flex><span>        material.SetVector(<span style=color:#e6db74>&#34;_AnchorPos&#34;</span>, anchorPos);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=beziershadershader>BezierShader.shader<a hidden class=anchor aria-hidden=true href=#beziershadershader>#</a></h3><p>贝塞尔的距离场来自<a href=https://www.shadertoy.com/view/3lsSzS>Cubic bezier approx distance 2</a>。</p><p>我还增加了选项，在显示一条横线时关闭<code>BEZIERCURVE</code>就能使用效率更高的横线的距离场了（要注意绘制横线时，<code>RectTransform</code>中<code>Height</code>的值不能设置成0，最好设置成一个如0.01的小数），同时也添加了水平翻转的选项。</p><p>贝塞尔曲线和阴影混合之后再参加透明度混合，会给贝塞尔曲线带上一条浅浅的阴影颜色的描边，效果还算不错，这里就暂时不修改了。但是如果不想要这个描边的话。需要预先计算出混合后的颜色值和透明度值。如果用\((c_1, a_1)\)、\((c_2, a_2)\)、\((c_0)\)来分别表示曲线和阴影的颜色值、透明度值和透明度混合时目标的颜色的话（从前往后的顺序应该是曲线\((c_1, a_1)\)，阴影\((c_2, a_2)\)和透明度混合目标\((c_0)\)），正确的透明度混合的颜色应该是\(c_1 a_1 + c_2 a_2 (1 - a_1) + c_0 (1 - a_1) (1 - a_2)\)，所以可以设置透明度混合模式为<code>Blend One SrcAlpha</code>，然后将输出的颜色设置成<code>float4(c1 * a1 + c2 * a2 * (1 - a1), (1 - a1) * (1 - a2))</code>，这样混合后的颜色就是完美的正常的透明度混合了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>//Based on https://www.shadertoy.com/view/3lsSzS</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/BezierShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        [HideInInspector] _MainTex (<span style=color:#e6db74>&#34;Main Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        [Header(Marcos)]
</span></span><span style=display:flex><span>        [Toggle(BEZIERCURVE)] _BezierCurve(<span style=color:#e6db74>&#34;Bezier Curve&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        [Toggle(FLIP)] _Flip (<span style=color:#e6db74>&#34;Flip&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        [Header(Curve Settings)]
</span></span><span style=display:flex><span>        _Color (<span style=color:#e6db74>&#34;Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span>        _Curve (<span style=color:#e6db74>&#34;Curve&#34;</span>, range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.2</span>
</span></span><span style=display:flex><span>        _Width (<span style=color:#e6db74>&#34;Pixel Width&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>        [Header(Shadow Settings)]
</span></span><span style=display:flex><span>        _ShadowColor (<span style=color:#e6db74>&#34;Shadow Color&#34;</span>, color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>        _ShadowOffset (<span style=color:#e6db74>&#34;Shadow Offset&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>        _ShadowWidth (<span style=color:#e6db74>&#34;Shadow Width&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile_local _ FLIP
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma multi_compile_local _ BEZIERCURVE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sampler2D _MainTex;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> _Color;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> _Curve;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> _Width;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> _ShadowColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> _ShadowOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> _ShadowWidth;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _AnchorPos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float2</span> VertexOffsets[] <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> vertexID       <span style=color:#f92672>:</span> SV_VERTEXID;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings Vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS <span style=color:#f92672>=</span> input.positionOS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> heightA <span style=color:#f92672>=</span> _Width <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> heightB <span style=color:#f92672>=</span> _AnchorPos.w <span style=color:#f92672>-</span> _AnchorPos.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> heightC <span style=color:#f92672>=</span> _ShadowOffset <span style=color:#f92672>+</span> _ShadowWidth <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        positionOS.y <span style=color:#f92672>+=</span> VertexOffsets[input.vertexID].x <span style=color:#f92672>*</span> heightA <span style=color:#f92672>+</span> VertexOffsets[input.vertexID].y <span style=color:#f92672>*</span> heightC;
</span></span><span style=display:flex><span>        VertexPositionInputs vertexInput <span style=color:#f92672>=</span> GetVertexPositionInputs(positionOS);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vertexInput.positionCS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//0-1 -&gt; -(heightC) / heightB, (heightA + heightB + heightC) / heightB</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> newCoordY <span style=color:#f92672>=</span> (heightA <span style=color:#f92672>+</span> heightB <span style=color:#f92672>+</span> heightC) <span style=color:#f92672>/</span> heightB <span style=color:#f92672>*</span> input.texcoord.y <span style=color:#f92672>-</span> (heightC) <span style=color:#f92672>/</span> heightB ;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(input.texcoord.x, newCoordY);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> cubic_bezier_normal_iteration(<span style=color:#66d9ef>float</span> t, <span style=color:#66d9ef>float2</span> a0, <span style=color:#66d9ef>float2</span> a1, <span style=color:#66d9ef>float2</span> a2, <span style=color:#66d9ef>float2</span> a3)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//factor should be positive</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//it decreases the step size when lowered.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Lowering the factor and increasing iterations increases the area in which</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//the iteration converges, but this is quite costly</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> factor<span style=color:#f92672>=</span><span style=color:#ae81ff>1.</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>//horner&#39;s method</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> a_2<span style=color:#f92672>=</span>a2<span style=color:#f92672>+</span>t<span style=color:#f92672>*</span>a3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> a_1<span style=color:#f92672>=</span>a1<span style=color:#f92672>+</span>t<span style=color:#f92672>*</span>a_2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> b_2<span style=color:#f92672>=</span>a_2<span style=color:#f92672>+</span>t<span style=color:#f92672>*</span>a3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv_to_p<span style=color:#f92672>=</span>a0<span style=color:#f92672>+</span>t<span style=color:#f92672>*</span>a_1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> tang<span style=color:#f92672>=</span>a_1<span style=color:#f92672>+</span>t<span style=color:#f92672>*</span>b_2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> l_tang<span style=color:#f92672>=</span>dot(tang,tang);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> t<span style=color:#f92672>-</span>factor<span style=color:#f92672>*</span>dot(tang,uv_to_p)<span style=color:#f92672>/</span>l_tang;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> cubic_bezier_dis_approx_sq(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float2</span> p0, <span style=color:#66d9ef>float2</span> p1, <span style=color:#66d9ef>float2</span> p2, <span style=color:#66d9ef>float2</span> p3)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> a3 <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>p0 <span style=color:#f92672>+</span> <span style=color:#ae81ff>3.</span> <span style=color:#f92672>*</span> p1 <span style=color:#f92672>-</span> <span style=color:#ae81ff>3.</span> <span style=color:#f92672>*</span> p2 <span style=color:#f92672>+</span> p3);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> a2 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>3.</span> <span style=color:#f92672>*</span> p0 <span style=color:#f92672>-</span> <span style=color:#ae81ff>6.</span> <span style=color:#f92672>*</span> p1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>3.</span> <span style=color:#f92672>*</span> p2);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> a1 <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>3.</span> <span style=color:#f92672>*</span> p0 <span style=color:#f92672>+</span> <span style=color:#ae81ff>3.</span> <span style=color:#f92672>*</span> p1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> a0 <span style=color:#f92672>=</span> p0 <span style=color:#f92672>-</span> uv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> d0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>e38;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> t0<span style=color:#f92672>=</span><span style=color:#ae81ff>0.</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> num_iterations<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> num_start_params<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>num_start_params;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            t<span style=color:#f92672>=</span>t0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>num_iterations;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                t<span style=color:#f92672>=</span>cubic_bezier_normal_iteration(t,a0,a1,a2,a3);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            t<span style=color:#f92672>=</span>clamp(t,<span style=color:#ae81ff>0.</span>,<span style=color:#ae81ff>1.</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uv_to_p<span style=color:#f92672>=</span>((a3<span style=color:#f92672>*</span>t<span style=color:#f92672>+</span>a2)<span style=color:#f92672>*</span>t<span style=color:#f92672>+</span>a1)<span style=color:#f92672>*</span>t<span style=color:#f92672>+</span>a0;
</span></span><span style=display:flex><span>            d0<span style=color:#f92672>=</span>min(d0,dot(uv_to_p,uv_to_p));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            t0<span style=color:#f92672>+=</span><span style=color:#ae81ff>1.</span><span style=color:#f92672>/</span><span style=color:#66d9ef>float</span>(num_start_params<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> d0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> cubic_bezier_dis_approx(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float2</span> p0, <span style=color:#66d9ef>float2</span> p1, <span style=color:#66d9ef>float2</span> p2, <span style=color:#66d9ef>float2</span> p3)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> Frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ddxX <span style=color:#f92672>=</span> ddx(input.uv.x);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ddyY <span style=color:#f92672>=</span> ddy(input.uv.y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> scale <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(rcp(ddxX), rcp(ddyY));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> coord <span style=color:#f92672>=</span> input.uv;
</span></span><span style=display:flex><span><span style=color:#75715e>#if FLIP</span>
</span></span><span style=display:flex><span>        coord.x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> coord.x;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if BEZIERCURVE</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p0<span style=color:#f92672>=</span><span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> scale;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p1<span style=color:#f92672>=</span><span style=color:#66d9ef>float2</span>(_Curve, <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> scale;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p2<span style=color:#f92672>=</span><span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> _Curve, <span style=color:#ae81ff>0.0</span>) <span style=color:#f92672>*</span> scale;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p3<span style=color:#f92672>=</span><span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>) <span style=color:#f92672>*</span> scale;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> dist <span style=color:#f92672>=</span> cubic_bezier_dis_approx(coord <span style=color:#f92672>*</span> scale,p0,p1,p2,p3);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> widthVal <span style=color:#f92672>=</span> _Width <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> smoothstep(widthVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>, widthVal, dist);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> shadowDist <span style=color:#f92672>=</span> cubic_bezier_dis_approx(coord <span style=color:#f92672>*</span> scale <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>, _ShadowOffset),p0,p1,p2,p3);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> shadowWidthVal <span style=color:#f92672>=</span> _ShadowWidth <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> shadowAlpha <span style=color:#f92672>=</span> smoothstep(shadowWidthVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, shadowDist);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> dist <span style=color:#f92672>=</span> abs((<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> coord.y) <span style=color:#f92672>*</span> scale.y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> widthVal <span style=color:#f92672>=</span> _Width <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> smoothstep(widthVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>, widthVal, dist);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> shadowDist <span style=color:#f92672>=</span> abs((<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> coord.y) <span style=color:#f92672>*</span> scale.y <span style=color:#f92672>-</span> _ShadowOffset);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> shadowWidthVal <span style=color:#f92672>=</span> _ShadowWidth <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> shadowAlpha <span style=color:#f92672>=</span> smoothstep(shadowWidthVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, shadowDist);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> lerp(_ShadowColor.rgb, _Color.rgb, alpha <span style=color:#f92672>*</span> _Color.a);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> finalAlpha <span style=color:#f92672>=</span> max(alpha <span style=color:#f92672>*</span> _Color.a, shadowAlpha <span style=color:#f92672>*</span> _ShadowColor.a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> returnColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, finalAlpha);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//returnColor = float4(input.uv, 0.0, 1.0);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> returnColor;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags{ <span style=color:#e6db74>&#34;Queue&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;RenderType&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Transparent&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Cull Back
</span></span><span style=display:flex><span>            ZTest LEqual
</span></span><span style=display:flex><span>            ZWrite Off
</span></span><span style=display:flex><span>            Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex Vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment Frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=最后的思考>最后的思考<a hidden class=anchor aria-hidden=true href=#最后的思考>#</a></h2><p>数学真奇妙啊！也很感谢Shadertoy上用户们的无私的奉献！但是微积分对我来说还是太难了，是不是应该找个机会补一补呢。。。最后就是我感觉对<code>fwidth</code>抗锯齿的理解又加深了！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li><li><a href=https://zznewclear13.github.io/tags/bezier-curve/>Bezier Curve</a></li><li><a href=https://zznewclear13.github.io/tags/signed-distance-field/>Signed Distance Field</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/create-plant-swaying-in-wind-using-vertex-animation/><span class=title>« Prev</span><br><span>使用顶点动画制作随风飘动的植物</span>
</a><a class=next href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><span class=title>Next »</span><br><span>在Unity中绘制等宽的描边</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>