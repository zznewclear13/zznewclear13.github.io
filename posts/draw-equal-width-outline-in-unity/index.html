<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹ | ZZNEWCLEAR13</title>
<meta name=keywords content="Outline,Space Transformation,Anti-Aliasing"><meta name=description content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹"><meta property="og:description" content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/posts/images/EqualWidthOutline.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-12T12:00:00+08:00"><meta property="article:modified_time" content="2021-12-12T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/posts/images/EqualWidthOutline.jpg"><meta name=twitter:title content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹"><meta name=twitter:description content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹","item":"https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹","name":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹","description":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹.","keywords":["Outline","Space Transformation","Anti-Aliasing"],"articleBody":"å¯¹äºæè¾¹çš„æ€è€ƒ æè¾¹å¯ä»¥è¯´æ˜¯ä¸€ä¸ªç‰¹åˆ«å…³é”®çš„æ•ˆæœï¼Œä¸ä»…ä»…æ˜¯äºŒæ¬¡å…ƒå¡é€šæ¸²æŸ“éœ€è¦ç”¨åˆ°æè¾¹ï¼Œåœ¨ç”¨æˆ·äº¤äº’çš„æ–¹é¢ï¼Œæè¾¹ä¹Ÿæ˜¯ä¸€ä¸ªå¢å¼ºç”¨æˆ·äº¤äº’çš„å…³é”®æ•ˆæœã€‚\nä¸€èˆ¬çš„æè¾¹çš„åšæ³•æ˜¯ç»˜åˆ¶ä¸€ä¸ªæ²¿ç‰©ä½“ç©ºé—´é¡¶ç‚¹æ³•çº¿ï¼ˆæˆ–æ˜¯è®°å½•åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹æ–¹å‘ï¼‰å¤–æ‰©çš„æ¨¡å‹èƒŒé¢ï¼Œè¿™ç§åšæ³•åœ¨ç»å¤§éƒ¨åˆ†æƒ…å†µéƒ½çœ‹ä¸Šå»ä¸é”™ï¼Œä½†æ˜¯æè¾¹çš„æ·±åº¦æµ‹è¯•ä¼šæœ‰ä¸€äº›å°ç‘•ç–µï¼ŒåŒæ—¶åœ¨ç‰©ä½“è·ç¦»æ‘„åƒæœºè¾ƒè¿‘çš„æ—¶å€™ï¼Œæè¾¹ä¼šæ˜¾å¾—è¾ƒç²—ï¼Œæ­¤å¤–è¿™ç§æè¾¹æ²¡æœ‰æŠ—é”¯é½¿çš„æ•ˆæœï¼Œç»˜åˆ¶æ¨¡å‹çš„èƒŒé¢ä¹Ÿè®©é€ æˆäº†æ€§èƒ½çš„æµªè´¹ã€‚å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨Multiple Render Targetsï¼Œæ¸²æŸ“å‡ºä¸€ä¸ªæ¨¡å‹çš„å‰ªå½±ï¼Œç„¶åä½¿ç”¨ç±»ä¼¼é«˜æ–¯æ¨¡ç³Šçš„åŠæ³•ï¼Œå¯¹é‡‡æ ·è¿›è¡Œåç§»ï¼Œè¿™æ ·å¯ä»¥æ¸²æŸ“å‡ºä¸€ä¸ªè¾ƒå¥½çš„å¯ä»¥æœ‰æŠ—é”¯é½¿æ•ˆæœçš„æè¾¹ï¼Œä½†æ˜¯ä»…é™äºæ¨¡å‹å‘å¤–çš„æè¾¹ï¼Œç¼ºå°‘æ¨¡å‹å†…éƒ¨çš„æè¾¹æ•ˆæœã€‚\næœ€å¥½çš„æè¾¹åº”è¯¥æ˜¯èƒ½å¤Ÿæ”¯æŒæ¨¡å‹å¤–æè¾¹ã€å†…æè¾¹ã€æè´¨æè¾¹çš„æè¾¹æ•ˆæœï¼Œpencil +å®ç°äº†è¿™äº›æ•ˆæœï¼Œä½†æ˜¯æ•ˆç‡ä¸æ˜¯å¾ˆé«˜ï¼Œè¿™é‡Œæœ‰ç›¸å…³çš„æ¼”ç¤ºï¼ˆæˆ‘ä¹Ÿæ˜¯çœ‹äº†è¿™ä¸ªä¹‹åæ‰å†³å®šç”¨å®‰å‰æ‹‰çš„æ¨¡å‹çš„ï¼‰ã€‚æˆ‘çœ‹åˆ°çš„è¾ƒå¥½çš„æ–¹æ¡ˆåº”è¯¥è¿˜æ˜¯L-çµåˆƒçš„ä½¿ç”¨é€€åŒ–å››è¾¹å½¢ç”Ÿæˆæè¾¹çš„åŠæ³•ï¼Œgithubä¸Šä¹Ÿåˆ†äº«äº†æºç ã€‚\nè¿™ç¯‡åšå®¢ä¸­ä»‹ç»çš„æè¾¹ï¼Œæ˜¯åŸºäºæˆ‘ä¸Šä¸€ç¯‡åšå®¢ä¸­è®²çš„ä¸–ç•Œç©ºé—´ä¸­ç»˜åˆ¶ç­‰å®½çº¿æ¡çš„æ–¹æ³•ï¼Œä½¿ç”¨DrawProceduralç»˜åˆ¶çš„ç­‰å®½çš„æè¾¹ã€‚æˆ‘è®¤ä¸ºåªæœ‰ç­‰å®½çš„æè¾¹ï¼Œæ‰æ˜¯æœ€èƒ½è¡¨ç°äºŒæ¬¡å…ƒç”»é¢ç‰¹å¾çš„æè¾¹ã€‚è¿™é‡Œçš„â€œç­‰å®½â€ï¼Œå¹¶ä¸æ˜¯è¯´çº¿æ¡çš„å®½åº¦å¤„å¤„ç›¸ç­‰ï¼Œçº¿æ¡å½“ç„¶å¯ä»¥æ§åˆ¶æ¯ä¸€éƒ¨åˆ†çš„ç²—ç»†ï¼Œä½†æ˜¯è¿™ä¸ªæ§åˆ¶çš„ç²—ç»†æ˜¯åŸºäºä¸€ä¸ªå›ºå®šå€¼çš„ç›¸å¯¹ç²—ç»†ï¼ˆä¹Ÿå°±æ˜¯å­˜åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹ç²—ç»†å€¼ï¼‰ï¼Œå½“ç²—ç»†å€¼ç›¸åŒæ—¶ï¼Œä¸ç®¡æ˜¯ç”»é¢çš„å“ªä¸ªéƒ¨åˆ†çš„æè¾¹çš„ç²—ç»†ï¼ˆä¸ç®¡æ˜¯å†…æè¾¹è¿˜æ˜¯å¤–æè¾¹ï¼‰ï¼Œéƒ½åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚\nå®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹ é¦–å…ˆå‚è€ƒé€€åŒ–å››è¾¹å½¢çš„æ¡ˆä¾‹ï¼Œéœ€è¦å…ˆå¯¹æ¨¡å‹æ–‡ä»¶è¿›è¡Œé¢„å¤„ç†ã€‚è¿™é‡Œæˆ‘åšäº†ç®€åŒ–ï¼Œåªå»å¯»æ‰¾ä¸¤ä¸ªä¸‰è§’é¢å…±ç”¨çš„è¾¹ï¼Œå¿½ç•¥äº†åªå±äºä¸€ä¸ªä¸‰è§’é¢çš„è¾¹çš„æƒ…å†µï¼ˆäº‹å®ä¸Šæˆ‘è§‰å¾—è¿™æ ·çœ‹ä¸Šå»çš„è§†è§‰æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼‰ã€‚ä¸€æ¡å…±ç”¨è¾¹å¯¹åº”äº†è¿™æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œä¸¤ä¾§çš„ä¸¤ä¸ªä¸‰è§’å½¢å’Œè¿™ä¸¤ä¸ªä¸‰è§’å½¢å¯¹åº”çš„é¢å¤–çš„ä¸¤ä¸ªé¡¶ç‚¹ã€‚è¿™é‡Œéƒ½ç”¨åºå·æ¥è¡¨ç¤ºï¼Œéœ€è¦6ä¸ªintå€¼ï¼ˆäº‹å®ä¸Šå¯ä»¥å¿½ç•¥ä¸¤ä¸ªä¸‰è§’å½¢çš„ç¼–å·ï¼Œå°±èƒ½å­˜åœ¨ä¸€ä¸ªint4é‡Œäº†ï¼‰ã€‚åˆ¤æ–­ä¸€æ¡è¾¹å…±åŒå±äºä¸¤ä¸ªä¸‰è§’å½¢ï¼Œå°±ç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’å½¢ä¸­çš„æŸä¸¤ä¸ªé¡¶ç‚¹çš„åºå·æ˜¯ç›¸åŒçš„ï¼ˆå®é™…ä¸Šé¡ºåºæ˜¯ç›¸åçš„ï¼‰ã€‚ä½†æ˜¯å®é™…æ“ä½œä¸­ï¼Œå³ä½¿æ˜¯ç›¸åŒçš„é¡¶ç‚¹ï¼Œåœ¨ä¸¤ä¸ªä¸‰è§’å½¢ä¸­é¡¶ç‚¹çš„åºå·ä¹Ÿä¸ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œå› æ­¤éœ€è¦å…ˆæŠŠä¸¤ä¸ªç›¸åŒçš„é¡¶ç‚¹ï¼ˆä½¿ç”¨è·ç¦»æ¥åˆ¤æ–­ï¼‰åˆå¹¶æˆä¸€ä¸ªé¡¶ç‚¹ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä½¿ç”¨vertRemappingè¿™ä¸ªæ•°ç»„çš„ç›®çš„ã€‚å‰©ä¸‹çš„å°±æ˜¯å¾ªç¯æ‰€æœ‰ä¸‰è§’å½¢ï¼Œè·å–å…±ç”¨è¾¹çš„ç®—æ³•éƒ¨åˆ†äº†ï¼Œå°½å¯èƒ½çš„ä¼˜åŒ–ä¸€ä¸‹ï¼Œä¸ç„¶ä¸‰è§’é¢ä¸€å¤šè¿ç®—çš„æ—¶é—´è¦å¾ˆä¹…ã€‚\næœ‰äº†å…±ç”¨è¾¹çš„æ•°æ®ï¼Œé€šè¿‡SkinnedMeshRenderer.BakeMesh()å¯ä»¥è·å–åˆ°å½“å‰å¸§æ¯ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼Œå°±èƒ½è¿›è¡Œæè¾¹çš„è®¡ç®—äº†ã€‚ä½¿ç”¨DrawProceduralæ—¶é¡¶ç‚¹çš„æ•°é‡å¯ä»¥æ˜¯å…¬ç”¨è¾¹æ•°é‡çš„ä¸¤å€ï¼Œè¿™æ ·éœ€è¦åœ¨Geometry Shaderä¸­æŠŠé¡¶ç‚¹æ•°ç›®ä»2æ‰©å……åˆ°6ï¼Œæˆ–è€…æ˜¯åœ¨ç»˜åˆ¶æ—¶å°†é¡¶ç‚¹æ•°é‡è®¾ç½®æˆå…±ç”¨è¾¹æ•°é‡çš„å…­å€ï¼Œå¯èƒ½åè€…æ•ˆç‡ä¼šé«˜ä¸€ç‚¹ï¼Œä¸è¿‡æ€è€ƒçš„æ—¶å€™ä¼šæœ‰ç‚¹ä¹±ï¼Œè¿™é‡Œå°±ä½¿ç”¨Geometry Shaderçš„æ–¹æ³•äº†ã€‚\nå¦‚æœæ˜¯åƒä¹‹å‰çš„åšå®¢ä»‹ç»çš„ï¼Œä»¥å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹ä¸ºä¸­å¿ƒï¼ŒåŒæ—¶å‘å·¦å³ä¸¤ä¾§å¤–æ‰©çš„è¯ï¼Œä¼šå› ä¸ºæ·±åº¦æµ‹è¯•çš„åŸå› ï¼Œå¯¼è‡´æè¾¹éƒ¨åˆ†è¢«æ¨¡å‹é®æŒ¡ï¼Œè¿™ä¸ªé—®é¢˜æ¯”è¾ƒä¸¥é‡ï¼Œä»–ç›´æ¥å¯¼è‡´äº†å¤–æè¾¹å’Œå†…æè¾¹çš„ç²—ç»†ä¸ä¸€æ ·ï¼Œä¹Ÿå¯¼è‡´äº†åœ¨ä¸€æ¡æè¾¹ä¸­ä¼šéœ²å‡ºä¸€éƒ¨åˆ†æ¨¡å‹çš„é—®é¢˜ã€‚è¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ä»…å‘å¤–ä¾§æè¾¹ï¼Œåœ¨è®¡ç®—æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„æ—¶å€™åŒæ—¶è®¡ç®—éœ€è¦æè¾¹çš„æ–¹å‘ï¼Œä½¿ç”¨è¿™ä¸ªæ–¹å‘å‘å¤–æ‰©å±•æè¾¹ï¼Œæœ€åæ•ˆæœè¿˜è›®ä¸é”™çš„ã€‚\nè¦å®ç°é£æ ¼åŒ–æè¾¹çš„è¯ï¼Œé™¤äº†ä½¿ç”¨é¡¶ç‚¹è‰²æ¥æ§åˆ¶æè¾¹çš„ç²—ç»†ä¹‹å¤–ï¼Œè¿˜èƒ½ä½¿ç”¨ä¸€å¼ è´´å›¾ä½œä¸ºæè¾¹çš„ç¬”åˆ·ï¼Œåœ¨ç»˜åˆ¶æè¾¹çš„æ—¶å€™é‡‡æ ·è¿™å¼ è´´å›¾ï¼Œæœ¬ç¯‡åšå®¢å°±æš‚ä¸ä½¿ç”¨è¿™ç§æ–¹æ³•äº†ã€‚\nå…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ å¯¹å½“å‰æ¨¡å‹è·å–åˆ°æ‰€æœ‰çš„å…±ç”¨è¾¹å¯¹åº”çš„å››ä¸ªé¡¶ç‚¹åºå·ï¼Œä¸¥æ ¼ä¿æŒé¡ºåºï¼ æ¯ä¸€å¸§ä½¿ç”¨SkinnedMeshRenderer.BakeMeshï¼Œè·å–æ‰€æœ‰é¡¶ç‚¹å½“å‰çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ã€‚ ä¼ å…¥é¡¶ç‚¹åæ ‡ï¼Œé¡¶ç‚¹é‡æ˜ å°„æ•°ç»„ï¼Œå…±ç”¨è¾¹ä¿¡æ¯ï¼Œå¦‚æœéœ€è¦çš„è¯è¿˜è¦ä¼ é¡¶ç‚¹è‰²åˆ°æè¾¹çš„Shaderä¸­ã€‚ ä½¿ç”¨DrawProceduralç»˜åˆ¶æè¾¹ï¼Œé¡¶ç‚¹æ•°é‡ä¸ºå…±ç”¨è¾¹çš„æ•°é‡çš„ä¸¤å€ã€‚ åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´ï¼ˆå®é™…ä¸Šç”¨çš„æ˜¯å±å¹•ç©ºé—´ï¼‰çš„åæ ‡ï¼Œåˆ¤æ–­è¿™æ¡è¾¹æ˜¯ä¸æ˜¯è½®å»“è¾¹ï¼ŒåŒæ—¶è®°å½•æè¾¹å¤–æ‰©çš„æ–¹å‘ï¼Œç›¸å½“äºå¯¹äºæ¯ä¸€æ¡è¾¹ï¼ˆæ¯ä¸¤ä¸ªç‚¹ï¼‰å­˜ä¸¤ä¸ªboolå˜é‡ã€‚ åœ¨å‡ ä½•ä½“ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹çš„å±å¹•ç©ºé—´çš„åæ ‡ï¼Œè®¡ç®—å‡ºä¸¤ä¸ªç‚¹ä¹‹é—´çš„å‘é‡ï¼Œè®¡ç®—ä¸ä¹‹ç›¸å‚ç›´çš„å¤–æ‰©çš„æ–¹å‘ï¼Œæ ¹æ®ä¸¤ä¸ªå‘é‡ï¼Œè®¡ç®—å‡ºæè¾¹çš„å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´çš„åæ ‡ï¼Œå¹¶èµ‹äºˆuvçš„å€¼ã€‚ åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­ï¼Œæ ¹æ®uvè®¡ç®—å‡ºæè¾¹çš„é¢œè‰²ï¼Œå¯ä»¥é‡‡æ ·è´´å›¾ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è¿”å›è®¡ç®—çš„é¢œè‰²ã€‚ ç”±äºæ•´ä¸ªæè¾¹çš„æ“ä½œè¾ƒä¸ºå¤æ‚ï¼Œæˆ‘å°½å¯èƒ½å¤šçš„å†™äº†æ³¨é‡Šã€‚\nOutlineObject.cs å®šä¹‰å…±ç”¨è¾¹çš„ç»“æ„ä½“ï¼Œä¹Ÿå®šä¹‰ç”¨äºä¿å­˜å…±ç”¨è¾¹æ•°æ®çš„ScriptableObjectã€‚\nusing UnityEngine; namespace ZZNEWCLEAR13.Outline { [System.Serializable] public class OutlineObject : ScriptableObject { [System.Serializable] public class MeshOutlineInfo { public string meshName; //å°½é‡ä¸è¦éƒ½æ˜¾ç¤ºå‡ºæ¥ï¼Œä¸ç„¶å¾ˆå¡ã€‚ã€‚ //é¡¶ç‚¹ã€æ³•çº¿ã€åˆ‡çº¿å’Œé¡¶ç‚¹è‰² [HideInInspector] public Vector3[] vertices; [HideInInspector] public Vector3[] normals; [HideInInspector] public Vector4[] tangents; [HideInInspector] public Color[] colors; //vertRemappingæŠŠç›¸åŒä½ç½®çš„é¡¶ç‚¹ç¼–å·æ˜ å°„åˆ°ç¬¬ä¸€ä¸ªè¯¥ä½ç½®é¡¶ç‚¹çš„ç¼–å· [HideInInspector] public int[] vertRemapping; //ä¸‰è§’å½¢å¯¹åº”çš„é¡¶ç‚¹ç¼–å· [HideInInspector] public Vector3Int[] triangles; public Line[] commonLines; } public MeshOutlineInfo outlineInfo; } [System.Serializable] public struct Line { //Line public int v0; public int v1; //Triangle One: v0, v1, v2 public int t0; public int v2; //Triangle Two: v0, v3, v1 public int t1; public int v3; public Line(int _v0, int _v1) { v0 = _v0; v1 = _v1; t0 = -1; t1 = -1; v2 = -1; v3 = -1; } //é‡è½½äº†Equalsæ–¹æ³• //ä¸¤ä¸ªä¸‰è§’å½¢ä½¿ç”¨åŒä¸€æ¡è¾¹æ—¶ï¼Œè¾¹çš„èŠ‚ç‚¹çš„é¡ºåºæ˜¯ç›¸åçš„ //GetHashCode()ä¸ä¼šå†™ï¼Œä¹Ÿæ²¡å¿…è¦å†™ :) public override bool Equals(object obj) { if (!(obj is Line line)) { return false; } return v0 == line.v1 \u0026\u0026 v1 == line.v0; } } } ModelPreProcess.cs ç”¨äºæ¨¡å‹é¢„å¤„ç†ï¼Œç”Ÿæˆå¹¶ä¿å­˜æ¨¡å‹çš„å…±ç”¨è¾¹çš„ä¿¡æ¯ã€‚\nusing System.Collections.Generic; using UnityEngine; using UnityEditor; namespace ZZNEWCLEAR13.Outline { public class ModelPreProcess : EditorWindow { //å½“ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´è·ç¦»å°äºEPSILONæ—¶ï¼Œè®¤ä¸ºæ˜¯åŒä¸€ä¸ªé¡¶ç‚¹ const float EPSILON = 0.00001f; public GameObject fbxObj; public string saveName = \"OutlineInfo\"; private Rect topToolBarRect { get { return new Rect(20, 10, position.width - 40, 120); } } [MenuItem(\"zznewclear13/Model Pre-process\")] public static ModelPreProcess GetWindow() { ModelPreProcess window = GetWindow(); window.titleContent = new GUIContent(\"Model Pre-process\"); window.Focus(); window.Repaint(); return window; } private void OnGUI() { TopToolBar(topToolBarRect); } private void TopToolBar(Rect rect) { using (new GUILayout.AreaScope(rect)) { fbxObj = (GameObject)EditorGUILayout.ObjectField(\"FBX Object\", fbxObj, typeof(GameObject), false); saveName = EditorGUILayout.TextField(\"Save Name\", saveName); using (new EditorGUI.DisabledGroupScope(!fbxObj)) { if (GUILayout.Button(\"Process!\", new GUILayoutOption[] { GUILayout.Height(30f) })) { ProcessAll(); } } } } private void ProcessAll() { MeshFilter[] meshFilters = fbxObj.GetComponentsInChildren(); SkinnedMeshRenderer[] skinnedMeshRenderers = fbxObj.GetComponentsInChildren(); int meshFilterLength = meshFilters.Length; OutlineObject.MeshOutlineInfo[] mois = new OutlineObject.MeshOutlineInfo[meshFilterLength + skinnedMeshRenderers.Length]; for (int i = 0; i \u003c meshFilters.Length; i++) { mois[i] = ProcessMesh(meshFilters[i].sharedMesh); } for (int i = 0; i \u003c skinnedMeshRenderers.Length; i++) { mois[i + meshFilterLength] = ProcessMesh(skinnedMeshRenderers[i].sharedMesh); } SaveAsset(mois); } //æ‰¾å‡ºå…¶ä¸­çš„å…±åŒè¾¹ï¼Œå¹¶å‚¨å­˜ä¸‰è§’å½¢åºå·å’Œå¦å¤–ä¸¤ä¸ªé¡¶ç‚¹çš„åºå· //æ³¨æ„é¡¶ç‚¹çš„é¡ºåº //v0, v1, v2æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢ //v0, v3, v1æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢ private void CheckLine(int triangleIndex, int vertexIndex, Line line, ref List lineList, ref List commonLines) { bool hasLine = false; int lineListIndex = -1; for (int i = 0; i \u003c lineList.Count; i++) { if (line.Equals(lineList[i])) { hasLine = true; lineListIndex = i; break; } } if (hasLine) { Line tempLine = lineList[lineListIndex]; lineList.RemoveAt(lineListIndex); tempLine.t1 = triangleIndex; tempLine.v3 = vertexIndex; commonLines.Add(tempLine); } else { line.t0 = triangleIndex; line.v2 = vertexIndex; lineList.Add(line); } } //å½“ä¸¤ä¸ªé¡¶ç‚¹è·ç¦»å¾ˆè¿‘æ—¶ï¼Œè§†åšåŒä¸€ä¸ªé¡¶ç‚¹ //ä½¿ç”¨vertRemappingå‚¨å­˜ç›¸åŒé¡¶ç‚¹çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„åºå· private int[] MergeIndexes(Vector3[] vertices) { int[] vertRemapping = new int[vertices.Length]; vertRemapping[0] = 0; for (int i = 1; i \u003c vertices.Length; i++) { bool hasVert = false; for (int j = 0; j \u003c i; j++) { if (vertRemapping[j] \u003c j) { continue; } else { if ((vertices[i] - vertices[vertRemapping[j]]).magnitude \u003c EPSILON) { vertRemapping[i] = vertRemapping[j]; hasVert = true; } } } if (!hasVert) { vertRemapping[i] = i; } } return vertRemapping; } private OutlineObject.MeshOutlineInfo ProcessMesh(Mesh sharedMesh) { OutlineObject.MeshOutlineInfo moi = new OutlineObject.MeshOutlineInfo(); moi.meshName = sharedMesh.name; Vector3[] vertices = sharedMesh.vertices; Vector3[] normals = sharedMesh.normals; Vector4[] tangents = sharedMesh.tangents; Color[] colors = sharedMesh.colors; moi.vertices = vertices; moi.normals = normals; moi.tangents = tangents; moi.colors = colors; int[] vertRemapping = MergeIndexes(vertices); moi.vertRemapping = vertRemapping; int[] triangles = sharedMesh.triangles; List lineList = new List(); List commonLines = new List(); System.Diagnostics.Debug.Assert(triangles.Length % 3 == 0); int triangleCount = triangles.Length / 3; Vector3Int[] packedTriangles = new Vector3Int[triangleCount]; //éå†æ‰€æœ‰çš„ä¸‰è§’å½¢ï¼Œæ³¨æ„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹çš„é¡ºåº for (int i = 0; i \u003c triangleCount; i++) { int triangleIndex = 3 * i; int vID0 = vertRemapping[triangles[triangleIndex]]; int vID1 = vertRemapping[triangles[triangleIndex + 1]]; int vID2 = vertRemapping[triangles[triangleIndex + 2]]; packedTriangles[i] = new Vector3Int(vID0, vID1, vID2); Line line0 = new Line(vID0, vID1); Line line1 = new Line(vID1, vID2); Line line2 = new Line(vID2, vID0); CheckLine(i, vID2, line0, ref lineList, ref commonLines); CheckLine(i, vID0, line1, ref lineList, ref commonLines); CheckLine(i, vID1, line2, ref lineList, ref commonLines); } moi.triangles = packedTriangles; moi.commonLines = commonLines.ToArray(); return moi; } private void SaveAsset(OutlineObject.MeshOutlineInfo[] outlineInfos) { string path = AssetDatabase.GetAssetPath(fbxObj); string assetPath = path.Substring(0, path.LastIndexOf('/')) + \"/\" + saveName; if (!System.IO.Directory.Exists(assetPath)) { System.IO.Directory.CreateDirectory(assetPath); } for (int i = 0; i \u003c outlineInfos.Length; i++) { OutlineObject asset = ScriptableObject.CreateInstance(); asset.outlineInfo = outlineInfos[i]; string tempPath = assetPath + \"/\" + outlineInfos[i].meshName + \".asset\"; AssetDatabase.CreateAsset(asset, tempPath); } AssetDatabase.SaveAssets(); } } } DrawOutline.cs è¿™é‡Œä»¥SkinnedMeshRendererä¸ºä¾‹ï¼Œå› ä¸ºç›¸å¯¹äºæ™®é€šçš„Meshæ¥è¯´è¾ƒä¸ºå¤æ‚ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨ä¿å­˜åœ¨å…±ç”¨è¾¹ä¿¡æ¯é‡Œçš„ç‰©ä½“ç©ºé—´çš„é¡¶ç‚¹åæ ‡ã€‚\nusing System.Collections.Generic; using UnityEngine; namespace ZZNEWCLEAR13.Outline { //ä»…æ”¯æŒSkinnedMeshRenderer //æ™®é€šçš„Meshåªè¦ç¨æ”¹ä¸€ä¸‹ä»£ç å°±å¥½äº† [ExecuteInEditMode] [RequireComponent(typeof(SkinnedMeshRenderer))] public class DrawOutline : MonoBehaviour { public Material outlineMaterial; public GameObject targetGO; public SkinnedMeshRenderer skinnedMeshRenderer; public OutlineObject outlineObject; private Mesh bakedMesh; private List meshVertices; private Vector3[] vertices; private Color[] colors; private int[] vertRemapping; private Line[] lines; private ComputeBuffer verticesBuffer; private ComputeBuffer colorBuffer; private ComputeBuffer vertRemappingBuffer; private ComputeBuffer lineBuffer; private void EnsureBuffer(ref ComputeBuffer buffer, int count, int stride) { if (buffer != null) { buffer.Release(); } buffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } private void OnEnable() { meshVertices = new List(); vertices = outlineObject.outlineInfo.vertices; colors = outlineObject.outlineInfo.colors; vertRemapping = outlineObject.outlineInfo.vertRemapping; lines = outlineObject.outlineInfo.commonLines; EnsureBuffer(ref verticesBuffer, vertices.Length, 3 * 4); EnsureBuffer(ref colorBuffer, vertices.Length, 4 * 4); EnsureBuffer(ref vertRemappingBuffer, vertRemapping.Length, 4); EnsureBuffer(ref lineBuffer, lines.Length, 6 * 4); bakedMesh = new Mesh(); } private void Update() { DrawOutlineProcedural(); } private void DrawOutlineProcedural() { skinnedMeshRenderer.BakeMesh(bakedMesh); bakedMesh.GetVertices(meshVertices); verticesBuffer.SetData(meshVertices); colorBuffer.SetData(colors); vertRemappingBuffer.SetData(vertRemapping); lineBuffer.SetData(lines); MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetBuffer(\"_VerticesBuffer\", verticesBuffer); mpb.SetBuffer(\"_ColorBuffer\", colorBuffer); mpb.SetBuffer(\"_VertRemappingBuffer\", vertRemappingBuffer); mpb.SetBuffer(\"_LineBuffer\", lineBuffer); //ä¸€èˆ¬éœ€è¦ä¼ å…¥SkinnedMeshRendererçš„çˆ¶ç‰©ä½“çš„ç‰©ä½“ç©ºé—´åˆ°ä¸–ç•Œç©ºé—´çš„å˜æ¢çŸ©é˜µ mpb.SetMatrix(\"_ObjToWorldMat\", targetGO.transform.localToWorldMatrix); Bounds bounds = skinnedMeshRenderer.bounds; Graphics.DrawProcedural(outlineMaterial, bounds, MeshTopology.Lines, lines.Length * 2, properties: mpb); } private void OnDestroy() { verticesBuffer.Dispose(); vertRemappingBuffer.Dispose(); lineBuffer.Dispose(); } } } OutlineShader.shader æ„Ÿè§‰å·²ç»äº‹æ— å·¨ç»†çš„å†™åœ¨æ³¨é‡Šé‡Œäº†ï¼Œæœ€å…³é”®çš„å°±æ˜¯æ—¶åˆ»æé†’è‡ªå·±ç»˜åˆ¶ä¸‰è§’å½¢æ—¶çš„é¡¶ç‚¹é¡ºåºã€‚æ„Ÿè§‰æˆ‘å¯¹ä½¿ç”¨æ•°ç»„æ¥è®¾è®¡å¹¶è¡Œè¿ç®—å·²ç»ç‚‰ç«çº¯é’äº†ã€‚ä½¿ç”¨çº¿æ€§ä»£æ•°æ¥åˆ¤æ–­ä¸‰è§’å½¢çš„å…¶ä½™ä¸¤ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨å…±ç”¨è¾¹çš„ä¸¤ä¾§ï¼Œæˆ‘æ„Ÿè§‰æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„åŠæ³•ï¼ˆä¼¼ä¹æ¯”ç›´æ¥è®¡ç®—æ³•çº¿è¦ç¨å¥½ä¸€ç‚¹ï¼Ÿï¼‰ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯å‘ç°æ•ˆæœåŸºæœ¬æ­£ç¡®ä¹‹åå°±ä¸ä¼šå†å›è¿‡å¤´å»éªŒè¯è‡ªå·±çš„ä»£ç äº†å“ˆå“ˆã€‚\nShader \"zznewclear13/OutlineShader\" { Properties { _OutlineColor (\"Outline Color\", color) = (1.0, 1.0, 1.0, 1.0) _OutlineExt (\"Outline Extension\", range(-1, 1)) = 0.1 _OutlineWidth(\"Outline Width\", float) = 1.0 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" float4x4 _ObjToWorldMat; float4 _OutlineColor; float _OutlineExt; float _OutlineWidth; StructuredBuffer\u003cfloat3\u003e _VerticesBuffer; StructuredBuffer\u003cint\u003e _VertRemappingBuffer; //å®é™…å¯ä»¥ç®€åŒ–æˆä¸€ä¸ªint4ï¼Œåªå‚¨å­˜é¡¶ç‚¹åºå· struct LineStruct { int2 lineVertices; // v0, v1 int4 trianglesAndVertices; // t0, v2, t1, v3 }; StructuredBuffer\u003cLineStruct\u003e _LineBuffer; struct Attributes { uint vertexID : SV_VERTEXID; }; struct Geoms { float4 positionCS : TEXCOORD0; bool2 edgeAndSide : TEXCOORD1; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; }; Geoms OutlineVert(Attributes input) { Geoms output = (Geoms)0; //è·å–é¡¶ç‚¹åºå·å’Œè¾¹çš„åºå· int vertexID = input.vertexID % 2; int lineID = input.vertexID / 2; //è·å–è¾¹ä¸Šè¾ƒè¿‘çš„é¡¶ç‚¹å’Œè¾ƒè¿œçš„é¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´åæ ‡ float3 vertexOne = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[vertexID]]]; float3 vertexTwo = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[1 - vertexID]]]; //è·å–ç¬¬ä¸€ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹å’Œç¬¬äºŒä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹ float3 vertexThree = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[vertexID * 2 + 1]]]; float3 vertexFour = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[3 - vertexID * 2]]]; //è½¬æ¢åˆ°è£å‰ªç©ºé—´ float4x4 mvp = mul(UNITY_MATRIX_VP, _ObjToWorldMat); float4 positionCSOne = mul(mvp, float4(vertexOne, 1.0)); float4 positionCSTwo = mul(mvp, float4(vertexTwo, 1.0)); float4 positionCSThree = mul(mvp, float4(vertexThree, 1.0)); float4 positionCSFour = mul(mvp, float4(vertexFour, 1.0)); //è·å–å±å¹•ç©ºé—´çš„åæ ‡ float2 uvOne = positionCSOne.xy / positionCSOne.w; float2 uvTwo = positionCSTwo.xy / positionCSTwo.w; float2 uvThree = positionCSThree.xy / positionCSThree.w; float2 uvFour = positionCSFour.xy / positionCSFour.w; //è¿™é‡Œç®€åŒ–äº†æ±‚æ³•çº¿çš„è¿‡ç¨‹ï¼Œç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨è¾¹çš„ä¸¤ä¾§ float valueA = uvOne.y - uvTwo.y; float valueB = uvOne.x * uvTwo.y - uvTwo.x * uvOne.y; float valueC = uvOne.x - uvTwo.x; float signThree = valueA * uvThree.x + valueB - valueC * uvThree.y; float signFour = valueA * uvFour.x + valueB - valueC * uvFour.y; //Xï¼šè¯¥é¡¶ç‚¹æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„é¡¶ç‚¹ï¼›Yï¼šè¯¥é¡¶ç‚¹åº”è¯¥å‘è¾¹çš„é¡ºæ—¶é’ˆæ–¹å‘è¿˜æ˜¯é€†æ—¶é’ˆæ–¹å‘å¤–æ‰© output.edgeAndSide = bool2((signThree * signFour \u003e= 0), (signThree \u003e= 0)); output.positionCS = positionCSOne; return output; } [maxvertexcount(6)] void OutlineGeomTriangle(line Geoms input[2], inout TriangleStream\u003cVaryings\u003e triangleStream) { Varyings output = (Varyings)0; //åˆ¤æ–­æ˜¯ä¸æ˜¯è¾¹ç•Œè¾¹ï¼Œå…¶å®åªéœ€è¦åˆ¤æ–­ä¸€ä¸ªé¡¶ç‚¹å°±å¯ä»¥äº† if(input[0].edgeAndSide.x \u0026\u0026 input[1].edgeAndSide.x) { //å¯ä»¥é€šè¿‡é¡¶ç‚¹è‰²æ¥è°ƒæ•´æè¾¹å®½åº¦ float outlineWidthOne = _OutlineWidth;// * input[0].color.a; float outlineWidthTwo = _OutlineWidth;// * input[1].color.a; float4 positionCSOne = input[0].positionCS; float4 positionCSTwo = input[1].positionCS; //è·å–å±å¹•ç©ºé—´çš„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„å‘é‡ float2 offset = positionCSOne.xy / positionCSOne.w - positionCSTwo.xy / positionCSTwo.w; float lengthOffset = length(offset); float2 normalizedOffset = normalize(offset * (_ScreenParams.wz - 1.0)); //Xï¼šä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹çš„å‘é‡ //Yï¼šä¸ä¹‹å‚ç›´çš„å¦ä¸€ä¸ªå‘é‡ //ä½¿ç”¨min(1.0, rcp(positionCSOne.w)æ¥ä½¿æè¾¹æŒ‰ç…§è·ç¦»å˜ç»†ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨å¹³æ–¹æ ¹å€’æ•°æ¥æ§åˆ¶ float2 pointOffsetX = float2(normalizedOffset.x, normalizedOffset.y) * min(1.0, rcp(positionCSOne.w)); float2 pointOffsetY = float2(-normalizedOffset.y, normalizedOffset.x) * min(1.0, rcp(positionCSOne.w)); //ç¬¬ä¸€ç¬¬äºŒä¸ªé¡¶ç‚¹ä¸ç”¨å¤–æ‰© //ç¬¬ä¸‰ç¬¬å››ä¸ªé¡¶ç‚¹æŒ‰ç…§edgeAndSideæ¥åˆ¤æ–­å¤–æ‰©çš„æ–¹å‘ //åŒæ—¶ä½¿ç”¨_OutlineExtæ¥æ§åˆ¶å¤–æ‰©å‡ºçš„æ¢¯å½¢çš„å½¢çŠ¶ float4 csOne = positionCSOne; float4 csTwo = positionCSTwo; float4 csThree = float4(-positionCSTwo.w * (pointOffsetX * (1.0 + _OutlineExt) + pointOffsetY * (2 * input[1].edgeAndSide.y - 1)) * (_ScreenParams.zw - 1.0) * outlineWidthTwo, 0, 0) + positionCSTwo; float4 csFour = float4(-positionCSOne.w * (-pointOffsetX * (1.0 + _OutlineExt) - pointOffsetY * (2 * input[0].edgeAndSide.y - 1)) * (_ScreenParams.zw - 1.0) * outlineWidthOne, 0, 0) + positionCSOne; //å››ä¸ªé¡¶ç‚¹çš„UV float2 uvOne = float2(0.0, 0.0); float2 uvTwo = float2(1.0, 0.0); float2 uvThree = float2(1.0, 1.0); float2 uvFour = float2(0.0, 1.0); //ç»˜åˆ¶å¤–æ‰©æ¢¯å½¢çš„å…¶ä¸­ä¸‰ä¸ªé¡¶ç‚¹ output.positionCS = csOne; output.uv = uvOne; triangleStream.Append(output); output.positionCS = csTwo; output.uv = uvTwo; triangleStream.Append(output); output.positionCS = csThree; output.uv = uvThree; triangleStream.Append(output); //å‡ºäºæˆ‘ä¸èƒ½è§£é‡Šçš„åŸå› ï¼Œè¿™é‡Œçš„é¡¶ç‚¹é¡ºåºå’Œå‰é¢æ˜¯ç›¸åçš„ output.positionCS = csOne; output.uv = uvOne; triangleStream.Append(output); output.positionCS = csFour; output.uv = uvFour; triangleStream.Append(output); output.positionCS = csThree; output.uv = uvThree; triangleStream.Append(output); } triangleStream.RestartStrip(); } float4 OutlineFrag(Varyings input) : SV_TARGET { float2 uv = input.uv; //ä½¿ç”¨fwidthè¿›è¡ŒæŠ—é”¯é½¿ return float4(_OutlineColor.rgb, smoothstep(1.0, 1.0 - fwidth(uv.y), input.uv.y)); } ENDHLSL SubShader { Tags {\"Queue\"=\"Transparent\" \"RenderType\"=\"Transparent\" } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Pass { HLSLPROGRAM #pragma target 5.0 #pragma vertex OutlineVert #pragma geometry OutlineGeomTriangle #pragma fragment OutlineFrag ENDHLSL } } } æœ€åçš„æ€è€ƒ æœ¬åšå®¢çš„æ¨¡å‹æ˜¯ç½‘ä¸Šä¸‹è½½çš„ï¼Œæˆ‘ä¹Ÿæ²¡æœ‰çœ‹è¿‡ä¹å›­è¿½æ”¾ï¼Œå¥½åƒè¡£æœéƒ¨åˆ†çš„uvå‡ºäº†ç‚¹é—®é¢˜ï¼Œä¸è¿‡è·Ÿæè¾¹çš„æ•ˆæœæ²¡æœ‰å…³ç³»ï¼Œå°±è¿™æ ·äº†ã€‚\nåœ¨æ¨¡å‹å¯¼å…¥çš„æ—¶å€™æœ€å¥½èƒ½é€‰æ‹©ä¸­ç­‰è´¨é‡ï¼Œè¿™æ ·æ¨¡å‹çš„é¢æ•°ä¼šå°‘ä¸€äº›ï¼Œä¹Ÿä¸ä¼šå‡ºç°å› ä¸ºç¾æœ¯å¤±è¯¯å¯¼è‡´å¥‡æ€ªçš„åœ°æ–¹äº§ç”Ÿæè¾¹çš„é—®é¢˜ã€‚æœ€ç»ˆæè¾¹æ•ˆæœç¡®å®è¿˜è›®ä¸é”™çš„ï¼Œç¡®å®éƒ½æ˜¯ä¸€æ ·çš„å®½ï¼Œä½¿ç”¨fwidthçš„æŠ—é”¯é½¿æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼Œå°±æ˜¯å¹¶æ²¡æœ‰æŠŠå¤–æè¾¹å’Œå†…æè¾¹åˆ†å¼€æ¥åšï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆåšäº†ï¼‰ï¼Œæ ¹æ®å…±ç”¨è¾¹ä¸¤ä¸ªä¸‰è§’é¢æ³•çº¿çš„å¤¹è§’è¿˜èƒ½ç»˜åˆ¶é¢å¤–çš„æè¾¹ï¼Œè¿™é‡Œå°±ä¸é¢å¤–åšäº†ï¼ˆä¸è¿‡åº”è¯¥ä¸å¤ªå¥½åšï¼Œæ·±åº¦æµ‹è¯•çš„é—®é¢˜æ¯”è¾ƒå¤§ï¼‰ï¼Œä¸¤ç§æè´¨ä¹‹é—´çš„æè¾¹ä¹Ÿæ²¡åšï¼ˆå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼‰ã€‚ä½†æ•´ä½“çœ‹ä¸Šå»è¿˜æ˜¯æŒºå¯ä»¥çš„äº†ï¼Œå˜¿å˜¿ã€‚\n","wordCount":"1438","inLanguage":"en","image":"https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/posts/images/EqualWidthOutline.jpg","datePublished":"2021-12-12T12:00:00+08:00","dateModified":"2021-12-12T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹</h1><div class=post-description>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹.</div><div class=post-meta><span title='2021-12-12 12:00:00 +0800 CST'>December 12, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/draw-equal-width-outline-in-unity.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/EqualWidthOutline.jpg alt="Equal Width Outline Cover"><p>Equal Width Outline Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹</div></summary><div class=inner><ul><li><a href=#%e5%af%b9%e4%ba%8e%e6%8f%8f%e8%be%b9%e7%9a%84%e6%80%9d%e8%80%83 aria-label=å¯¹äºæè¾¹çš„æ€è€ƒ>å¯¹äºæè¾¹çš„æ€è€ƒ</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%8f%8f%e8%be%b9%e6%97%b6%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9 aria-label=å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹>å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%8f%8f%e8%be%b9%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ>å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ</a><ul><li><a href=#outlineobjectcs aria-label=OutlineObject.cs>OutlineObject.cs</a></li><li><a href=#modelpreprocesscs aria-label=ModelPreProcess.cs>ModelPreProcess.cs</a></li><li><a href=#drawoutlinecs aria-label=DrawOutline.cs>DrawOutline.cs</a></li><li><a href=#outlineshadershader aria-label=OutlineShader.shader>OutlineShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=å¯¹äºæè¾¹çš„æ€è€ƒ>å¯¹äºæè¾¹çš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#å¯¹äºæè¾¹çš„æ€è€ƒ>#</a></h2><p>æè¾¹å¯ä»¥è¯´æ˜¯ä¸€ä¸ªç‰¹åˆ«å…³é”®çš„æ•ˆæœï¼Œä¸ä»…ä»…æ˜¯äºŒæ¬¡å…ƒå¡é€šæ¸²æŸ“éœ€è¦ç”¨åˆ°æè¾¹ï¼Œåœ¨ç”¨æˆ·äº¤äº’çš„æ–¹é¢ï¼Œæè¾¹ä¹Ÿæ˜¯ä¸€ä¸ªå¢å¼ºç”¨æˆ·äº¤äº’çš„å…³é”®æ•ˆæœã€‚</p><p>ä¸€èˆ¬çš„æè¾¹çš„åšæ³•æ˜¯ç»˜åˆ¶ä¸€ä¸ªæ²¿ç‰©ä½“ç©ºé—´é¡¶ç‚¹æ³•çº¿ï¼ˆæˆ–æ˜¯è®°å½•åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹æ–¹å‘ï¼‰å¤–æ‰©çš„æ¨¡å‹èƒŒé¢ï¼Œè¿™ç§åšæ³•åœ¨ç»å¤§éƒ¨åˆ†æƒ…å†µéƒ½çœ‹ä¸Šå»ä¸é”™ï¼Œä½†æ˜¯æè¾¹çš„æ·±åº¦æµ‹è¯•ä¼šæœ‰ä¸€äº›å°ç‘•ç–µï¼ŒåŒæ—¶åœ¨ç‰©ä½“è·ç¦»æ‘„åƒæœºè¾ƒè¿‘çš„æ—¶å€™ï¼Œæè¾¹ä¼šæ˜¾å¾—è¾ƒç²—ï¼Œæ­¤å¤–è¿™ç§æè¾¹æ²¡æœ‰æŠ—é”¯é½¿çš„æ•ˆæœï¼Œç»˜åˆ¶æ¨¡å‹çš„èƒŒé¢ä¹Ÿè®©é€ æˆäº†æ€§èƒ½çš„æµªè´¹ã€‚å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨Multiple Render Targetsï¼Œæ¸²æŸ“å‡ºä¸€ä¸ªæ¨¡å‹çš„å‰ªå½±ï¼Œç„¶åä½¿ç”¨ç±»ä¼¼é«˜æ–¯æ¨¡ç³Šçš„åŠæ³•ï¼Œå¯¹é‡‡æ ·è¿›è¡Œåç§»ï¼Œè¿™æ ·å¯ä»¥æ¸²æŸ“å‡ºä¸€ä¸ªè¾ƒå¥½çš„å¯ä»¥æœ‰æŠ—é”¯é½¿æ•ˆæœçš„æè¾¹ï¼Œä½†æ˜¯ä»…é™äºæ¨¡å‹å‘å¤–çš„æè¾¹ï¼Œç¼ºå°‘æ¨¡å‹å†…éƒ¨çš„æè¾¹æ•ˆæœã€‚</p><p>æœ€å¥½çš„æè¾¹åº”è¯¥æ˜¯èƒ½å¤Ÿæ”¯æŒæ¨¡å‹å¤–æè¾¹ã€å†…æè¾¹ã€æè´¨æè¾¹çš„æè¾¹æ•ˆæœï¼Œ<a href=https://www.psoft.co.jp/jp/product/pencil/unity/>pencil +</a>å®ç°äº†è¿™äº›æ•ˆæœï¼Œä½†æ˜¯æ•ˆç‡ä¸æ˜¯å¾ˆé«˜ï¼Œ<a href=https://www.bilibili.com/video/BV1Et4y1B7hB>è¿™é‡Œ</a>æœ‰ç›¸å…³çš„æ¼”ç¤ºï¼ˆæˆ‘ä¹Ÿæ˜¯çœ‹äº†è¿™ä¸ªä¹‹åæ‰å†³å®šç”¨å®‰å‰æ‹‰çš„æ¨¡å‹çš„ï¼‰ã€‚æˆ‘çœ‹åˆ°çš„è¾ƒå¥½çš„æ–¹æ¡ˆåº”è¯¥è¿˜æ˜¯L-çµåˆƒçš„<a href=https://blog.csdn.net/lht748/article/details/88680146>ä½¿ç”¨é€€åŒ–å››è¾¹å½¢ç”Ÿæˆæè¾¹</a>çš„åŠæ³•ï¼Œgithubä¸Šä¹Ÿåˆ†äº«äº†<a href=https://github.com/L-LingRen/UnitySimpleCartoonLine>æºç </a>ã€‚</p><p>è¿™ç¯‡åšå®¢ä¸­ä»‹ç»çš„æè¾¹ï¼Œæ˜¯åŸºäºæˆ‘ä¸Šä¸€ç¯‡åšå®¢ä¸­è®²çš„ä¸–ç•Œç©ºé—´ä¸­ç»˜åˆ¶ç­‰å®½çº¿æ¡çš„æ–¹æ³•ï¼Œä½¿ç”¨<code>DrawProcedural</code>ç»˜åˆ¶çš„ç­‰å®½çš„æè¾¹ã€‚æˆ‘è®¤ä¸ºåªæœ‰ç­‰å®½çš„æè¾¹ï¼Œæ‰æ˜¯æœ€èƒ½è¡¨ç°äºŒæ¬¡å…ƒç”»é¢ç‰¹å¾çš„æè¾¹ã€‚è¿™é‡Œçš„â€œç­‰å®½â€ï¼Œå¹¶ä¸æ˜¯è¯´çº¿æ¡çš„å®½åº¦å¤„å¤„ç›¸ç­‰ï¼Œçº¿æ¡å½“ç„¶å¯ä»¥æ§åˆ¶æ¯ä¸€éƒ¨åˆ†çš„ç²—ç»†ï¼Œä½†æ˜¯è¿™ä¸ªæ§åˆ¶çš„ç²—ç»†æ˜¯åŸºäºä¸€ä¸ªå›ºå®šå€¼çš„ç›¸å¯¹ç²—ç»†ï¼ˆä¹Ÿå°±æ˜¯å­˜åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹ç²—ç»†å€¼ï¼‰ï¼Œå½“ç²—ç»†å€¼ç›¸åŒæ—¶ï¼Œä¸ç®¡æ˜¯ç”»é¢çš„å“ªä¸ªéƒ¨åˆ†çš„æè¾¹çš„ç²—ç»†ï¼ˆä¸ç®¡æ˜¯å†…æè¾¹è¿˜æ˜¯å¤–æè¾¹ï¼‰ï¼Œéƒ½åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚</p><h2 id=å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹>å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹<a hidden class=anchor aria-hidden=true href=#å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹>#</a></h2><p>é¦–å…ˆå‚è€ƒé€€åŒ–å››è¾¹å½¢çš„æ¡ˆä¾‹ï¼Œéœ€è¦å…ˆå¯¹æ¨¡å‹æ–‡ä»¶è¿›è¡Œé¢„å¤„ç†ã€‚è¿™é‡Œæˆ‘åšäº†ç®€åŒ–ï¼Œåªå»å¯»æ‰¾ä¸¤ä¸ªä¸‰è§’é¢å…±ç”¨çš„è¾¹ï¼Œå¿½ç•¥äº†åªå±äºä¸€ä¸ªä¸‰è§’é¢çš„è¾¹çš„æƒ…å†µï¼ˆäº‹å®ä¸Šæˆ‘è§‰å¾—è¿™æ ·çœ‹ä¸Šå»çš„è§†è§‰æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼‰ã€‚ä¸€æ¡å…±ç”¨è¾¹å¯¹åº”äº†è¿™æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œä¸¤ä¾§çš„ä¸¤ä¸ªä¸‰è§’å½¢å’Œè¿™ä¸¤ä¸ªä¸‰è§’å½¢å¯¹åº”çš„é¢å¤–çš„ä¸¤ä¸ªé¡¶ç‚¹ã€‚è¿™é‡Œéƒ½ç”¨åºå·æ¥è¡¨ç¤ºï¼Œéœ€è¦6ä¸ªintå€¼ï¼ˆäº‹å®ä¸Šå¯ä»¥å¿½ç•¥ä¸¤ä¸ªä¸‰è§’å½¢çš„ç¼–å·ï¼Œå°±èƒ½å­˜åœ¨ä¸€ä¸ªint4é‡Œäº†ï¼‰ã€‚åˆ¤æ–­ä¸€æ¡è¾¹å…±åŒå±äºä¸¤ä¸ªä¸‰è§’å½¢ï¼Œå°±ç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’å½¢ä¸­çš„æŸä¸¤ä¸ªé¡¶ç‚¹çš„åºå·æ˜¯ç›¸åŒçš„ï¼ˆå®é™…ä¸Šé¡ºåºæ˜¯ç›¸åçš„ï¼‰ã€‚ä½†æ˜¯å®é™…æ“ä½œä¸­ï¼Œå³ä½¿æ˜¯ç›¸åŒçš„é¡¶ç‚¹ï¼Œåœ¨ä¸¤ä¸ªä¸‰è§’å½¢ä¸­é¡¶ç‚¹çš„åºå·ä¹Ÿä¸ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œå› æ­¤éœ€è¦å…ˆæŠŠä¸¤ä¸ªç›¸åŒçš„é¡¶ç‚¹ï¼ˆä½¿ç”¨è·ç¦»æ¥åˆ¤æ–­ï¼‰åˆå¹¶æˆä¸€ä¸ªé¡¶ç‚¹ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä½¿ç”¨<code>vertRemapping</code>è¿™ä¸ªæ•°ç»„çš„ç›®çš„ã€‚å‰©ä¸‹çš„å°±æ˜¯å¾ªç¯æ‰€æœ‰ä¸‰è§’å½¢ï¼Œè·å–å…±ç”¨è¾¹çš„ç®—æ³•éƒ¨åˆ†äº†ï¼Œå°½å¯èƒ½çš„ä¼˜åŒ–ä¸€ä¸‹ï¼Œä¸ç„¶ä¸‰è§’é¢ä¸€å¤šè¿ç®—çš„æ—¶é—´è¦å¾ˆä¹…ã€‚</p><p>æœ‰äº†å…±ç”¨è¾¹çš„æ•°æ®ï¼Œé€šè¿‡<code>SkinnedMeshRenderer.BakeMesh()</code>å¯ä»¥è·å–åˆ°å½“å‰å¸§æ¯ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼Œå°±èƒ½è¿›è¡Œæè¾¹çš„è®¡ç®—äº†ã€‚ä½¿ç”¨<code>DrawProcedural</code>æ—¶é¡¶ç‚¹çš„æ•°é‡å¯ä»¥æ˜¯å…¬ç”¨è¾¹æ•°é‡çš„ä¸¤å€ï¼Œè¿™æ ·éœ€è¦åœ¨Geometry Shaderä¸­æŠŠé¡¶ç‚¹æ•°ç›®ä»2æ‰©å……åˆ°6ï¼Œæˆ–è€…æ˜¯åœ¨ç»˜åˆ¶æ—¶å°†é¡¶ç‚¹æ•°é‡è®¾ç½®æˆå…±ç”¨è¾¹æ•°é‡çš„å…­å€ï¼Œå¯èƒ½åè€…æ•ˆç‡ä¼šé«˜ä¸€ç‚¹ï¼Œä¸è¿‡æ€è€ƒçš„æ—¶å€™ä¼šæœ‰ç‚¹ä¹±ï¼Œè¿™é‡Œå°±ä½¿ç”¨Geometry Shaderçš„æ–¹æ³•äº†ã€‚</p><p>å¦‚æœæ˜¯åƒä¹‹å‰çš„åšå®¢ä»‹ç»çš„ï¼Œä»¥å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹ä¸ºä¸­å¿ƒï¼ŒåŒæ—¶å‘å·¦å³ä¸¤ä¾§å¤–æ‰©çš„è¯ï¼Œä¼šå› ä¸ºæ·±åº¦æµ‹è¯•çš„åŸå› ï¼Œå¯¼è‡´æè¾¹éƒ¨åˆ†è¢«æ¨¡å‹é®æŒ¡ï¼Œè¿™ä¸ªé—®é¢˜æ¯”è¾ƒä¸¥é‡ï¼Œä»–ç›´æ¥å¯¼è‡´äº†å¤–æè¾¹å’Œå†…æè¾¹çš„ç²—ç»†ä¸ä¸€æ ·ï¼Œä¹Ÿå¯¼è‡´äº†åœ¨ä¸€æ¡æè¾¹ä¸­ä¼šéœ²å‡ºä¸€éƒ¨åˆ†æ¨¡å‹çš„é—®é¢˜ã€‚è¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ä»…å‘å¤–ä¾§æè¾¹ï¼Œåœ¨è®¡ç®—æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„æ—¶å€™åŒæ—¶è®¡ç®—éœ€è¦æè¾¹çš„æ–¹å‘ï¼Œä½¿ç”¨è¿™ä¸ªæ–¹å‘å‘å¤–æ‰©å±•æè¾¹ï¼Œæœ€åæ•ˆæœè¿˜è›®ä¸é”™çš„ã€‚</p><p>è¦å®ç°é£æ ¼åŒ–æè¾¹çš„è¯ï¼Œé™¤äº†ä½¿ç”¨é¡¶ç‚¹è‰²æ¥æ§åˆ¶æè¾¹çš„ç²—ç»†ä¹‹å¤–ï¼Œè¿˜èƒ½ä½¿ç”¨ä¸€å¼ è´´å›¾ä½œä¸ºæè¾¹çš„ç¬”åˆ·ï¼Œåœ¨ç»˜åˆ¶æè¾¹çš„æ—¶å€™é‡‡æ ·è¿™å¼ è´´å›¾ï¼Œæœ¬ç¯‡åšå®¢å°±æš‚ä¸ä½¿ç”¨è¿™ç§æ–¹æ³•äº†ã€‚</p><h2 id=å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ>å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ>#</a></h2><ol><li>å¯¹å½“å‰æ¨¡å‹è·å–åˆ°æ‰€æœ‰çš„å…±ç”¨è¾¹å¯¹åº”çš„å››ä¸ªé¡¶ç‚¹åºå·ï¼Œä¸¥æ ¼ä¿æŒé¡ºåºï¼</li><li>æ¯ä¸€å¸§ä½¿ç”¨<code>SkinnedMeshRenderer.BakeMesh</code>ï¼Œè·å–æ‰€æœ‰é¡¶ç‚¹å½“å‰çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ã€‚</li><li>ä¼ å…¥é¡¶ç‚¹åæ ‡ï¼Œé¡¶ç‚¹é‡æ˜ å°„æ•°ç»„ï¼Œå…±ç”¨è¾¹ä¿¡æ¯ï¼Œå¦‚æœéœ€è¦çš„è¯è¿˜è¦ä¼ é¡¶ç‚¹è‰²åˆ°æè¾¹çš„Shaderä¸­ã€‚</li><li>ä½¿ç”¨<code>DrawProcedural</code>ç»˜åˆ¶æè¾¹ï¼Œé¡¶ç‚¹æ•°é‡ä¸ºå…±ç”¨è¾¹çš„æ•°é‡çš„ä¸¤å€ã€‚</li><li>åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´ï¼ˆå®é™…ä¸Šç”¨çš„æ˜¯å±å¹•ç©ºé—´ï¼‰çš„åæ ‡ï¼Œåˆ¤æ–­è¿™æ¡è¾¹æ˜¯ä¸æ˜¯è½®å»“è¾¹ï¼ŒåŒæ—¶è®°å½•æè¾¹å¤–æ‰©çš„æ–¹å‘ï¼Œç›¸å½“äºå¯¹äºæ¯ä¸€æ¡è¾¹ï¼ˆæ¯ä¸¤ä¸ªç‚¹ï¼‰å­˜ä¸¤ä¸ªboolå˜é‡ã€‚</li><li>åœ¨å‡ ä½•ä½“ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹çš„å±å¹•ç©ºé—´çš„åæ ‡ï¼Œè®¡ç®—å‡ºä¸¤ä¸ªç‚¹ä¹‹é—´çš„å‘é‡ï¼Œè®¡ç®—ä¸ä¹‹ç›¸å‚ç›´çš„å¤–æ‰©çš„æ–¹å‘ï¼Œæ ¹æ®ä¸¤ä¸ªå‘é‡ï¼Œè®¡ç®—å‡ºæè¾¹çš„å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´çš„åæ ‡ï¼Œå¹¶èµ‹äºˆuvçš„å€¼ã€‚</li><li>åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­ï¼Œæ ¹æ®uvè®¡ç®—å‡ºæè¾¹çš„é¢œè‰²ï¼Œå¯ä»¥é‡‡æ ·è´´å›¾ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è¿”å›è®¡ç®—çš„é¢œè‰²ã€‚</li></ol><p>ç”±äºæ•´ä¸ªæè¾¹çš„æ“ä½œè¾ƒä¸ºå¤æ‚ï¼Œæˆ‘å°½å¯èƒ½å¤šçš„å†™äº†æ³¨é‡Šã€‚</p><h3 id=outlineobjectcs>OutlineObject.cs<a hidden class=anchor aria-hidden=true href=#outlineobjectcs>#</a></h3><p>å®šä¹‰å…±ç”¨è¾¹çš„ç»“æ„ä½“ï¼Œä¹Ÿå®šä¹‰ç”¨äºä¿å­˜å…±ç”¨è¾¹æ•°æ®çš„<code>ScriptableObject</code>ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ZZNEWCLEAR13.Outline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [System.Serializable]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OutlineObject</span> : ScriptableObject
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MeshOutlineInfo</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> meshName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//å°½é‡ä¸è¦éƒ½æ˜¾ç¤ºå‡ºæ¥ï¼Œä¸ç„¶å¾ˆå¡ã€‚ã€‚</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//é¡¶ç‚¹ã€æ³•çº¿ã€åˆ‡çº¿å’Œé¡¶ç‚¹è‰²</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>            [HideInInspector]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Vector3[] vertices;
</span></span><span style=display:flex><span><span style=color:#a6e22e>            [HideInInspector]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Vector3[] normals;
</span></span><span style=display:flex><span><span style=color:#a6e22e>            [HideInInspector]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Vector4[] tangents;
</span></span><span style=display:flex><span><span style=color:#a6e22e>            [HideInInspector]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Color[] colors;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//vertRemappingæŠŠç›¸åŒä½ç½®çš„é¡¶ç‚¹ç¼–å·æ˜ å°„åˆ°ç¬¬ä¸€ä¸ªè¯¥ä½ç½®é¡¶ç‚¹çš„ç¼–å·</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>            [HideInInspector]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span>[] vertRemapping;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//ä¸‰è§’å½¢å¯¹åº”çš„é¡¶ç‚¹ç¼–å·</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>            [HideInInspector]</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Vector3Int[] triangles;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Line[] commonLines;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> MeshOutlineInfo outlineInfo;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [System.Serializable]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Line</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Line</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Triangle One: v0, v1, v2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> t0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Triangle Two: v0, v3, v1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> t1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Line(<span style=color:#66d9ef>int</span> _v0, <span style=color:#66d9ef>int</span> _v1)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            v0 = _v0;
</span></span><span style=display:flex><span>            v1 = _v1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            t0 = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            t1 = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            v2 = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            v3 = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//é‡è½½äº†Equalsæ–¹æ³•</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//ä¸¤ä¸ªä¸‰è§’å½¢ä½¿ç”¨åŒä¸€æ¡è¾¹æ—¶ï¼Œè¾¹çš„èŠ‚ç‚¹çš„é¡ºåºæ˜¯ç›¸åçš„</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//GetHashCode()ä¸ä¼šå†™ï¼Œä¹Ÿæ²¡å¿…è¦å†™ :)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> Equals(<span style=color:#66d9ef>object</span> obj)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!(obj <span style=color:#66d9ef>is</span> Line line))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> v0 == line.v1 &amp;&amp; v1 == line.v0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=modelpreprocesscs>ModelPreProcess.cs<a hidden class=anchor aria-hidden=true href=#modelpreprocesscs>#</a></h3><p>ç”¨äºæ¨¡å‹é¢„å¤„ç†ï¼Œç”Ÿæˆå¹¶ä¿å­˜æ¨¡å‹çš„å…±ç”¨è¾¹çš„ä¿¡æ¯ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ZZNEWCLEAR13.Outline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ModelPreProcess</span> : EditorWindow
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//å½“ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´è·ç¦»å°äºEPSILONæ—¶ï¼Œè®¤ä¸ºæ˜¯åŒä¸€ä¸ªé¡¶ç‚¹</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> EPSILON = <span style=color:#ae81ff>0.00001f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GameObject fbxObj;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> saveName = <span style=color:#e6db74>&#34;OutlineInfo&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Rect topToolBarRect
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>, position.width - <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>120</span>); }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [MenuItem(&#34;zznewclear13/Model Pre-process&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ModelPreProcess GetWindow()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            ModelPreProcess window = GetWindow&lt;ModelPreProcess&gt;();
</span></span><span style=display:flex><span>            window.titleContent = <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;Model Pre-process&#34;</span>);
</span></span><span style=display:flex><span>            window.Focus();
</span></span><span style=display:flex><span>            window.Repaint();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            TopToolBar(topToolBarRect);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TopToolBar(Rect rect)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                fbxObj = (GameObject)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;FBX Object&#34;</span>, fbxObj, <span style=color:#66d9ef>typeof</span>(GameObject), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                saveName = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Name&#34;</span>, saveName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!fbxObj))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Process!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30f</span>) }))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        ProcessAll();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ProcessAll()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            MeshFilter[] meshFilters = fbxObj.GetComponentsInChildren&lt;MeshFilter&gt;();
</span></span><span style=display:flex><span>            SkinnedMeshRenderer[] skinnedMeshRenderers = fbxObj.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> meshFilterLength = meshFilters.Length;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            OutlineObject.MeshOutlineInfo[] mois = <span style=color:#66d9ef>new</span> OutlineObject.MeshOutlineInfo[meshFilterLength + skinnedMeshRenderers.Length];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshFilters.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                mois[i] = ProcessMesh(meshFilters[i].sharedMesh);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; skinnedMeshRenderers.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                mois[i + meshFilterLength] = ProcessMesh(skinnedMeshRenderers[i].sharedMesh);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            SaveAsset(mois);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//æ‰¾å‡ºå…¶ä¸­çš„å…±åŒè¾¹ï¼Œå¹¶å‚¨å­˜ä¸‰è§’å½¢åºå·å’Œå¦å¤–ä¸¤ä¸ªé¡¶ç‚¹çš„åºå·</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//æ³¨æ„é¡¶ç‚¹çš„é¡ºåº</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//v0, v1, v2æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//v0, v3, v1æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CheckLine(<span style=color:#66d9ef>int</span> triangleIndex, <span style=color:#66d9ef>int</span> vertexIndex, Line line, <span style=color:#66d9ef>ref</span> List&lt;Line&gt; lineList, <span style=color:#66d9ef>ref</span> List&lt;Line&gt; commonLines)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bool</span> hasLine = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> lineListIndex = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; lineList.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (line.Equals(lineList[i]))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    hasLine = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    lineListIndex = i;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (hasLine)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Line tempLine = lineList[lineListIndex];
</span></span><span style=display:flex><span>                lineList.RemoveAt(lineListIndex);
</span></span><span style=display:flex><span>                tempLine.t1 = triangleIndex;
</span></span><span style=display:flex><span>                tempLine.v3 = vertexIndex;
</span></span><span style=display:flex><span>                commonLines.Add(tempLine);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                line.t0 = triangleIndex;
</span></span><span style=display:flex><span>                line.v2 = vertexIndex;
</span></span><span style=display:flex><span>                lineList.Add(line);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//å½“ä¸¤ä¸ªé¡¶ç‚¹è·ç¦»å¾ˆè¿‘æ—¶ï¼Œè§†åšåŒä¸€ä¸ªé¡¶ç‚¹</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//ä½¿ç”¨vertRemappingå‚¨å­˜ç›¸åŒé¡¶ç‚¹çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„åºå·</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] MergeIndexes(Vector3[] vertices)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span>[] vertRemapping = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[vertices.Length];
</span></span><span style=display:flex><span>            vertRemapping[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; vertices.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bool</span> hasVert = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; i; j++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (vertRemapping[j] &lt; j)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> ((vertices[i] - vertices[vertRemapping[j]]).magnitude &lt; EPSILON)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            vertRemapping[i] = vertRemapping[j];
</span></span><span style=display:flex><span>                            hasVert = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!hasVert)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    vertRemapping[i] = i;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vertRemapping;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> OutlineObject.MeshOutlineInfo ProcessMesh(Mesh sharedMesh)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            OutlineObject.MeshOutlineInfo moi = <span style=color:#66d9ef>new</span> OutlineObject.MeshOutlineInfo();
</span></span><span style=display:flex><span>            moi.meshName = sharedMesh.name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Vector3[] vertices = sharedMesh.vertices;
</span></span><span style=display:flex><span>            Vector3[] normals = sharedMesh.normals;
</span></span><span style=display:flex><span>            Vector4[] tangents = sharedMesh.tangents;
</span></span><span style=display:flex><span>            Color[] colors = sharedMesh.colors;
</span></span><span style=display:flex><span>            moi.vertices = vertices;
</span></span><span style=display:flex><span>            moi.normals = normals;
</span></span><span style=display:flex><span>            moi.tangents = tangents;
</span></span><span style=display:flex><span>            moi.colors = colors;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span>[] vertRemapping = MergeIndexes(vertices);
</span></span><span style=display:flex><span>            moi.vertRemapping = vertRemapping;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span>[] triangles = sharedMesh.triangles;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            List&lt;Line&gt; lineList = <span style=color:#66d9ef>new</span> List&lt;Line&gt;();
</span></span><span style=display:flex><span>            List&lt;Line&gt; commonLines = <span style=color:#66d9ef>new</span> List&lt;Line&gt;();
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>            System.Diagnostics.Debug.Assert(triangles.Length % <span style=color:#ae81ff>3</span> == <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> triangleCount = triangles.Length / <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>            Vector3Int[] packedTriangles = <span style=color:#66d9ef>new</span> Vector3Int[triangleCount];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//éå†æ‰€æœ‰çš„ä¸‰è§’å½¢ï¼Œæ³¨æ„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹çš„é¡ºåº</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; triangleCount; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> triangleIndex = <span style=color:#ae81ff>3</span> * i;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> vID0 = vertRemapping[triangles[triangleIndex]];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> vID1 = vertRemapping[triangles[triangleIndex + <span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> vID2 = vertRemapping[triangles[triangleIndex + <span style=color:#ae81ff>2</span>]];
</span></span><span style=display:flex><span>                packedTriangles[i] = <span style=color:#66d9ef>new</span> Vector3Int(vID0, vID1, vID2);
</span></span><span style=display:flex><span>                Line line0 = <span style=color:#66d9ef>new</span> Line(vID0, vID1);
</span></span><span style=display:flex><span>                Line line1 = <span style=color:#66d9ef>new</span> Line(vID1, vID2);
</span></span><span style=display:flex><span>                Line line2 = <span style=color:#66d9ef>new</span> Line(vID2, vID0);
</span></span><span style=display:flex><span>                CheckLine(i, vID2, line0, <span style=color:#66d9ef>ref</span> lineList, <span style=color:#66d9ef>ref</span> commonLines);
</span></span><span style=display:flex><span>                CheckLine(i, vID0, line1, <span style=color:#66d9ef>ref</span> lineList, <span style=color:#66d9ef>ref</span> commonLines);
</span></span><span style=display:flex><span>                CheckLine(i, vID1, line2, <span style=color:#66d9ef>ref</span> lineList, <span style=color:#66d9ef>ref</span> commonLines);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            moi.triangles = packedTriangles;
</span></span><span style=display:flex><span>            moi.commonLines = commonLines.ToArray();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> moi;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveAsset(OutlineObject.MeshOutlineInfo[] outlineInfos)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> path = AssetDatabase.GetAssetPath(fbxObj);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> assetPath = path.Substring(<span style=color:#ae81ff>0</span>, path.LastIndexOf(<span style=color:#e6db74>&#39;/&#39;</span>)) + <span style=color:#e6db74>&#34;/&#34;</span> + saveName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!System.IO.Directory.Exists(assetPath))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                System.IO.Directory.CreateDirectory(assetPath);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; outlineInfos.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                OutlineObject asset = ScriptableObject.CreateInstance&lt;OutlineObject&gt;();
</span></span><span style=display:flex><span>                asset.outlineInfo = outlineInfos[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>string</span> tempPath = assetPath + <span style=color:#e6db74>&#34;/&#34;</span> + outlineInfos[i].meshName + <span style=color:#e6db74>&#34;.asset&#34;</span>;
</span></span><span style=display:flex><span>                AssetDatabase.CreateAsset(asset, tempPath);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            AssetDatabase.SaveAssets();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=drawoutlinecs>DrawOutline.cs<a hidden class=anchor aria-hidden=true href=#drawoutlinecs>#</a></h3><p>è¿™é‡Œä»¥<code>SkinnedMeshRenderer</code>ä¸ºä¾‹ï¼Œå› ä¸ºç›¸å¯¹äºæ™®é€šçš„<code>Mesh</code>æ¥è¯´è¾ƒä¸ºå¤æ‚ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨ä¿å­˜åœ¨å…±ç”¨è¾¹ä¿¡æ¯é‡Œçš„ç‰©ä½“ç©ºé—´çš„é¡¶ç‚¹åæ ‡ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ZZNEWCLEAR13.Outline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//ä»…æ”¯æŒSkinnedMeshRenderer</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//æ™®é€šçš„Meshåªè¦ç¨æ”¹ä¸€ä¸‹ä»£ç å°±å¥½äº†</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [ExecuteInEditMode]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [RequireComponent(typeof(SkinnedMeshRenderer))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DrawOutline</span> : MonoBehaviour
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Material outlineMaterial;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GameObject targetGO;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> SkinnedMeshRenderer skinnedMeshRenderer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> OutlineObject outlineObject;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Mesh bakedMesh;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> List&lt;Vector3&gt; meshVertices;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector3[] vertices;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Color[] colors;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] vertRemapping;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Line[] lines;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer verticesBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer colorBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer vertRemappingBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer lineBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (buffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                buffer.Release();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            meshVertices = <span style=color:#66d9ef>new</span> List&lt;Vector3&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            vertices = outlineObject.outlineInfo.vertices;
</span></span><span style=display:flex><span>            colors = outlineObject.outlineInfo.colors;
</span></span><span style=display:flex><span>            vertRemapping = outlineObject.outlineInfo.vertRemapping;
</span></span><span style=display:flex><span>            lines = outlineObject.outlineInfo.commonLines;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            EnsureBuffer(<span style=color:#66d9ef>ref</span> verticesBuffer, vertices.Length, <span style=color:#ae81ff>3</span> * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>            EnsureBuffer(<span style=color:#66d9ef>ref</span> colorBuffer, vertices.Length, <span style=color:#ae81ff>4</span> * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>            EnsureBuffer(<span style=color:#66d9ef>ref</span> vertRemappingBuffer, vertRemapping.Length, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>            EnsureBuffer(<span style=color:#66d9ef>ref</span> lineBuffer, lines.Length, <span style=color:#ae81ff>6</span> * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            bakedMesh = <span style=color:#66d9ef>new</span> Mesh();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            DrawOutlineProcedural();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DrawOutlineProcedural()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            skinnedMeshRenderer.BakeMesh(bakedMesh);
</span></span><span style=display:flex><span>            bakedMesh.GetVertices(meshVertices);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            verticesBuffer.SetData(meshVertices);
</span></span><span style=display:flex><span>            colorBuffer.SetData(colors);
</span></span><span style=display:flex><span>            vertRemappingBuffer.SetData(vertRemapping);
</span></span><span style=display:flex><span>            lineBuffer.SetData(lines);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
</span></span><span style=display:flex><span>            mpb.SetBuffer(<span style=color:#e6db74>&#34;_VerticesBuffer&#34;</span>, verticesBuffer);
</span></span><span style=display:flex><span>            mpb.SetBuffer(<span style=color:#e6db74>&#34;_ColorBuffer&#34;</span>, colorBuffer);
</span></span><span style=display:flex><span>            mpb.SetBuffer(<span style=color:#e6db74>&#34;_VertRemappingBuffer&#34;</span>, vertRemappingBuffer);
</span></span><span style=display:flex><span>            mpb.SetBuffer(<span style=color:#e6db74>&#34;_LineBuffer&#34;</span>, lineBuffer);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//ä¸€èˆ¬éœ€è¦ä¼ å…¥SkinnedMeshRendererçš„çˆ¶ç‰©ä½“çš„ç‰©ä½“ç©ºé—´åˆ°ä¸–ç•Œç©ºé—´çš„å˜æ¢çŸ©é˜µ</span>
</span></span><span style=display:flex><span>            mpb.SetMatrix(<span style=color:#e6db74>&#34;_ObjToWorldMat&#34;</span>, targetGO.transform.localToWorldMatrix);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Bounds bounds = skinnedMeshRenderer.bounds;
</span></span><span style=display:flex><span>            Graphics.DrawProcedural(outlineMaterial, bounds, MeshTopology.Lines, lines.Length * <span style=color:#ae81ff>2</span>, properties: mpb);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            verticesBuffer.Dispose();
</span></span><span style=display:flex><span>            vertRemappingBuffer.Dispose();
</span></span><span style=display:flex><span>            lineBuffer.Dispose();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=outlineshadershader>OutlineShader.shader<a hidden class=anchor aria-hidden=true href=#outlineshadershader>#</a></h3><p>æ„Ÿè§‰å·²ç»äº‹æ— å·¨ç»†çš„å†™åœ¨æ³¨é‡Šé‡Œäº†ï¼Œæœ€å…³é”®çš„å°±æ˜¯æ—¶åˆ»æé†’è‡ªå·±ç»˜åˆ¶ä¸‰è§’å½¢æ—¶çš„é¡¶ç‚¹é¡ºåºã€‚æ„Ÿè§‰æˆ‘å¯¹ä½¿ç”¨æ•°ç»„æ¥è®¾è®¡å¹¶è¡Œè¿ç®—å·²ç»ç‚‰ç«çº¯é’äº†ã€‚ä½¿ç”¨çº¿æ€§ä»£æ•°æ¥åˆ¤æ–­ä¸‰è§’å½¢çš„å…¶ä½™ä¸¤ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨å…±ç”¨è¾¹çš„ä¸¤ä¾§ï¼Œæˆ‘æ„Ÿè§‰æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„åŠæ³•ï¼ˆä¼¼ä¹æ¯”ç›´æ¥è®¡ç®—æ³•çº¿è¦ç¨å¥½ä¸€ç‚¹ï¼Ÿï¼‰ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯å‘ç°æ•ˆæœåŸºæœ¬æ­£ç¡®ä¹‹åå°±ä¸ä¼šå†å›è¿‡å¤´å»éªŒè¯è‡ªå·±çš„ä»£ç äº†å“ˆå“ˆã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/OutlineShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _OutlineColor (<span style=color:#e6db74>&#34;Outline Color&#34;</span>, color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span>        _OutlineExt (<span style=color:#e6db74>&#34;Outline Extension&#34;</span>, range(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>
</span></span><span style=display:flex><span>        _OutlineWidth(<span style=color:#e6db74>&#34;Outline Width&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> _ObjToWorldMat;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _OutlineColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _OutlineExt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _OutlineWidth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float3</span><span style=color:#f92672>&gt;</span> _VerticesBuffer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _VertRemappingBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//å®é™…å¯ä»¥ç®€åŒ–æˆä¸€ä¸ªint4ï¼Œåªå‚¨å­˜é¡¶ç‚¹åºå·</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> LineStruct
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int2</span> lineVertices; <span style=color:#75715e>// v0, v1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int4</span> trianglesAndVertices; <span style=color:#75715e>// t0, v2, t1, v3</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span>LineStruct<span style=color:#f92672>&gt;</span> _LineBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> vertexID    <span style=color:#f92672>:</span> SV_VERTEXID;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Geoms
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool2</span> edgeAndSide   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Geoms OutlineVert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Geoms output <span style=color:#f92672>=</span> (Geoms)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//è·å–é¡¶ç‚¹åºå·å’Œè¾¹çš„åºå·</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> vertexID <span style=color:#f92672>=</span> input.vertexID <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> lineID <span style=color:#f92672>=</span> input.vertexID <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//è·å–è¾¹ä¸Šè¾ƒè¿‘çš„é¡¶ç‚¹å’Œè¾ƒè¿œçš„é¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´åæ ‡</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> vertexOne <span style=color:#f92672>=</span> _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[vertexID]]];        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> vertexTwo <span style=color:#f92672>=</span> _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> vertexID]]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//è·å–ç¬¬ä¸€ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹å’Œç¬¬äºŒä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> vertexThree <span style=color:#f92672>=</span> _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[vertexID <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]]];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> vertexFour <span style=color:#f92672>=</span> _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[<span style=color:#ae81ff>3</span> <span style=color:#f92672>-</span> vertexID <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>]]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//è½¬æ¢åˆ°è£å‰ªç©ºé—´</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4x4</span> mvp <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, _ObjToWorldMat);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCSOne <span style=color:#f92672>=</span> mul(mvp, <span style=color:#66d9ef>float4</span>(vertexOne, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCSTwo <span style=color:#f92672>=</span> mul(mvp, <span style=color:#66d9ef>float4</span>(vertexTwo, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCSThree <span style=color:#f92672>=</span> mul(mvp, <span style=color:#66d9ef>float4</span>(vertexThree, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCSFour <span style=color:#f92672>=</span> mul(mvp, <span style=color:#66d9ef>float4</span>(vertexFour, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//è·å–å±å¹•ç©ºé—´çš„åæ ‡</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvOne <span style=color:#f92672>=</span> positionCSOne.xy <span style=color:#f92672>/</span> positionCSOne.w;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvTwo <span style=color:#f92672>=</span> positionCSTwo.xy <span style=color:#f92672>/</span> positionCSTwo.w;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvThree <span style=color:#f92672>=</span> positionCSThree.xy <span style=color:#f92672>/</span> positionCSThree.w;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvFour <span style=color:#f92672>=</span> positionCSFour.xy <span style=color:#f92672>/</span> positionCSFour.w;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//è¿™é‡Œç®€åŒ–äº†æ±‚æ³•çº¿çš„è¿‡ç¨‹ï¼Œç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨è¾¹çš„ä¸¤ä¾§</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> valueA <span style=color:#f92672>=</span> uvOne.y <span style=color:#f92672>-</span> uvTwo.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> valueB <span style=color:#f92672>=</span> uvOne.x <span style=color:#f92672>*</span> uvTwo.y <span style=color:#f92672>-</span> uvTwo.x <span style=color:#f92672>*</span> uvOne.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> valueC <span style=color:#f92672>=</span> uvOne.x <span style=color:#f92672>-</span> uvTwo.x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> signThree <span style=color:#f92672>=</span> valueA <span style=color:#f92672>*</span> uvThree.x <span style=color:#f92672>+</span> valueB <span style=color:#f92672>-</span> valueC <span style=color:#f92672>*</span> uvThree.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> signFour <span style=color:#f92672>=</span>  valueA <span style=color:#f92672>*</span> uvFour.x <span style=color:#f92672>+</span> valueB <span style=color:#f92672>-</span> valueC <span style=color:#f92672>*</span> uvFour.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Xï¼šè¯¥é¡¶ç‚¹æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„é¡¶ç‚¹ï¼›Yï¼šè¯¥é¡¶ç‚¹åº”è¯¥å‘è¾¹çš„é¡ºæ—¶é’ˆæ–¹å‘è¿˜æ˜¯é€†æ—¶é’ˆæ–¹å‘å¤–æ‰©</span>
</span></span><span style=display:flex><span>        output.edgeAndSide <span style=color:#f92672>=</span> <span style=color:#66d9ef>bool2</span>((signThree <span style=color:#f92672>*</span> signFour <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>), (signThree <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> positionCSOne;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [maxvertexcount(<span style=color:#ae81ff>6</span>)]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> OutlineGeomTriangle(<span style=color:#66d9ef>line</span> Geoms input[<span style=color:#ae81ff>2</span>], <span style=color:#66d9ef>inout</span> <span style=color:#66d9ef>TriangleStream</span><span style=color:#f92672>&lt;</span>Varyings<span style=color:#f92672>&gt;</span> triangleStream)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//åˆ¤æ–­æ˜¯ä¸æ˜¯è¾¹ç•Œè¾¹ï¼Œå…¶å®åªéœ€è¦åˆ¤æ–­ä¸€ä¸ªé¡¶ç‚¹å°±å¯ä»¥äº†</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(input[<span style=color:#ae81ff>0</span>].edgeAndSide.x <span style=color:#f92672>&amp;&amp;</span> input[<span style=color:#ae81ff>1</span>].edgeAndSide.x)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//å¯ä»¥é€šè¿‡é¡¶ç‚¹è‰²æ¥è°ƒæ•´æè¾¹å®½åº¦</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> outlineWidthOne <span style=color:#f92672>=</span> _OutlineWidth;<span style=color:#75715e>// * input[0].color.a;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> outlineWidthTwo <span style=color:#f92672>=</span> _OutlineWidth;<span style=color:#75715e>// * input[1].color.a;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> positionCSOne <span style=color:#f92672>=</span> input[<span style=color:#ae81ff>0</span>].positionCS;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> positionCSTwo <span style=color:#f92672>=</span> input[<span style=color:#ae81ff>1</span>].positionCS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//è·å–å±å¹•ç©ºé—´çš„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„å‘é‡</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> offset <span style=color:#f92672>=</span> positionCSOne.xy <span style=color:#f92672>/</span> positionCSOne.w <span style=color:#f92672>-</span> positionCSTwo.xy <span style=color:#f92672>/</span> positionCSTwo.w;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> lengthOffset <span style=color:#f92672>=</span> length(offset);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> normalizedOffset <span style=color:#f92672>=</span> normalize(offset <span style=color:#f92672>*</span> (_ScreenParams.wz <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>//Xï¼šä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹çš„å‘é‡</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//Yï¼šä¸ä¹‹å‚ç›´çš„å¦ä¸€ä¸ªå‘é‡</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//ä½¿ç”¨min(1.0, rcp(positionCSOne.w)æ¥ä½¿æè¾¹æŒ‰ç…§è·ç¦»å˜ç»†ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨å¹³æ–¹æ ¹å€’æ•°æ¥æ§åˆ¶</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> pointOffsetX <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(normalizedOffset.x, normalizedOffset.y) <span style=color:#f92672>*</span> min(<span style=color:#ae81ff>1.0</span>, rcp(positionCSOne.w));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> pointOffsetY <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span>normalizedOffset.y, normalizedOffset.x) <span style=color:#f92672>*</span> min(<span style=color:#ae81ff>1.0</span>, rcp(positionCSOne.w));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//ç¬¬ä¸€ç¬¬äºŒä¸ªé¡¶ç‚¹ä¸ç”¨å¤–æ‰©</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//ç¬¬ä¸‰ç¬¬å››ä¸ªé¡¶ç‚¹æŒ‰ç…§edgeAndSideæ¥åˆ¤æ–­å¤–æ‰©çš„æ–¹å‘</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//åŒæ—¶ä½¿ç”¨_OutlineExtæ¥æ§åˆ¶å¤–æ‰©å‡ºçš„æ¢¯å½¢çš„å½¢çŠ¶</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> csOne <span style=color:#f92672>=</span> positionCSOne;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> csTwo <span style=color:#f92672>=</span> positionCSTwo;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> csThree <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#f92672>-</span>positionCSTwo.w <span style=color:#f92672>*</span> (pointOffsetX <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>+</span> _OutlineExt) <span style=color:#f92672>+</span> pointOffsetY <span style=color:#f92672>*</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> input[<span style=color:#ae81ff>1</span>].edgeAndSide.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>*</span> (_ScreenParams.zw <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> outlineWidthTwo, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> positionCSTwo;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> csFour <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#f92672>-</span>positionCSOne.w <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span>pointOffsetX <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>+</span> _OutlineExt) <span style=color:#f92672>-</span> pointOffsetY <span style=color:#f92672>*</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> input[<span style=color:#ae81ff>0</span>].edgeAndSide.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>*</span> (_ScreenParams.zw <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> outlineWidthOne, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> positionCSOne;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//å››ä¸ªé¡¶ç‚¹çš„UV</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uvOne <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uvTwo <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uvThree <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uvFour <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//ç»˜åˆ¶å¤–æ‰©æ¢¯å½¢çš„å…¶ä¸­ä¸‰ä¸ªé¡¶ç‚¹</span>
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> csOne;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> uvOne;
</span></span><span style=display:flex><span>            triangleStream.Append(output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> csTwo;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> uvTwo;
</span></span><span style=display:flex><span>            triangleStream.Append(output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> csThree;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> uvThree;
</span></span><span style=display:flex><span>            triangleStream.Append(output);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//å‡ºäºæˆ‘ä¸èƒ½è§£é‡Šçš„åŸå› ï¼Œè¿™é‡Œçš„é¡¶ç‚¹é¡ºåºå’Œå‰é¢æ˜¯ç›¸åçš„</span>
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> csOne;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> uvOne;
</span></span><span style=display:flex><span>            triangleStream.Append(output);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> csFour;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> uvFour;
</span></span><span style=display:flex><span>            triangleStream.Append(output);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> csThree;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> uvThree;
</span></span><span style=display:flex><span>            triangleStream.Append(output);  
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        triangleStream.RestartStrip();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> OutlineFrag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> input.uv;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//ä½¿ç”¨fwidthè¿›è¡ŒæŠ—é”¯é½¿</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(_OutlineColor.rgb, smoothstep(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> fwidth(uv.y), input.uv.y));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags {<span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> }
</span></span><span style=display:flex><span>        ZWrite Off
</span></span><span style=display:flex><span>        Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma target <span style=color:#ae81ff>5.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex OutlineVert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma geometry OutlineGeomTriangle
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment OutlineFrag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#æœ€åçš„æ€è€ƒ>#</a></h2><p>æœ¬åšå®¢çš„æ¨¡å‹æ˜¯ç½‘ä¸Šä¸‹è½½çš„ï¼Œæˆ‘ä¹Ÿæ²¡æœ‰çœ‹è¿‡ä¹å›­è¿½æ”¾ï¼Œå¥½åƒè¡£æœéƒ¨åˆ†çš„uvå‡ºäº†ç‚¹é—®é¢˜ï¼Œä¸è¿‡è·Ÿæè¾¹çš„æ•ˆæœæ²¡æœ‰å…³ç³»ï¼Œå°±è¿™æ ·äº†ã€‚</p><p>åœ¨æ¨¡å‹å¯¼å…¥çš„æ—¶å€™æœ€å¥½èƒ½é€‰æ‹©ä¸­ç­‰è´¨é‡ï¼Œè¿™æ ·æ¨¡å‹çš„é¢æ•°ä¼šå°‘ä¸€äº›ï¼Œä¹Ÿä¸ä¼šå‡ºç°å› ä¸ºç¾æœ¯å¤±è¯¯å¯¼è‡´å¥‡æ€ªçš„åœ°æ–¹äº§ç”Ÿæè¾¹çš„é—®é¢˜ã€‚æœ€ç»ˆæè¾¹æ•ˆæœç¡®å®è¿˜è›®ä¸é”™çš„ï¼Œç¡®å®éƒ½æ˜¯ä¸€æ ·çš„å®½ï¼Œä½¿ç”¨<code>fwidth</code>çš„æŠ—é”¯é½¿æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼Œå°±æ˜¯å¹¶æ²¡æœ‰æŠŠå¤–æè¾¹å’Œå†…æè¾¹åˆ†å¼€æ¥åšï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆåšäº†ï¼‰ï¼Œæ ¹æ®å…±ç”¨è¾¹ä¸¤ä¸ªä¸‰è§’é¢æ³•çº¿çš„å¤¹è§’è¿˜èƒ½ç»˜åˆ¶é¢å¤–çš„æè¾¹ï¼Œè¿™é‡Œå°±ä¸é¢å¤–åšäº†ï¼ˆä¸è¿‡åº”è¯¥ä¸å¤ªå¥½åšï¼Œæ·±åº¦æµ‹è¯•çš„é—®é¢˜æ¯”è¾ƒå¤§ï¼‰ï¼Œä¸¤ç§æè´¨ä¹‹é—´çš„æè¾¹ä¹Ÿæ²¡åšï¼ˆå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼‰ã€‚ä½†æ•´ä½“çœ‹ä¸Šå»è¿˜æ˜¯æŒºå¯ä»¥çš„äº†ï¼Œå˜¿å˜¿ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/outline/>Outline</a></li><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><span class=title>Â« Prev</span><br><span>åœ¨Unityçš„UIä¸­ç»˜åˆ¶ç­‰å®½çš„è´èµ›å°”æ›²çº¿</span>
</a><a class=next href=https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/><span class=title>Next Â»</span><br><span>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çº¿æ¡</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>