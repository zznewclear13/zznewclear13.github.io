<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹ | ZZNEWCLEAR13</title><meta name=keywords content="Outline,Space Transformation,Anti-Aliasing"><meta name=description content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.a6fe470bfe70eb4fad7ee3efc590e817f121cf0f6d66fa91de327cf6bfbad62d.css integrity="sha256-pv5HC/5w60+tfuPvxZDoF/Ehzw9tZvqR3jJ89r+61i0=" rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹"><meta property="og:description" content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/posts/images/EqualWidthOutline.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-12T12:00:00+08:00"><meta property="article:modified_time" content="2021-12-12T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/posts/images/EqualWidthOutline.jpg"><meta name=twitter:title content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹"><meta name=twitter:description content="åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹","item":"https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹","name":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹","description":"åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹.","keywords":["Outline","Space Transformation","Anti-Aliasing"],"articleBody":"å¯¹äºæè¾¹çš„æ€è€ƒ æè¾¹å¯ä»¥è¯´æ˜¯ä¸€ä¸ªç‰¹åˆ«å…³é”®çš„æ•ˆæœï¼Œä¸ä»…ä»…æ˜¯äºŒæ¬¡å…ƒå¡é€šæ¸²æŸ“éœ€è¦ç”¨åˆ°æè¾¹ï¼Œåœ¨ç”¨æˆ·äº¤äº’çš„æ–¹é¢ï¼Œæè¾¹ä¹Ÿæ˜¯ä¸€ä¸ªå¢å¼ºç”¨æˆ·äº¤äº’çš„å…³é”®æ•ˆæœã€‚\nä¸€èˆ¬çš„æè¾¹çš„åšæ³•æ˜¯ç»˜åˆ¶ä¸€ä¸ªæ²¿ç‰©ä½“ç©ºé—´é¡¶ç‚¹æ³•çº¿ï¼ˆæˆ–æ˜¯è®°å½•åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹æ–¹å‘ï¼‰å¤–æ‰©çš„æ¨¡å‹èƒŒé¢ï¼Œè¿™ç§åšæ³•åœ¨ç»å¤§éƒ¨åˆ†æƒ…å†µéƒ½çœ‹ä¸Šå»ä¸é”™ï¼Œä½†æ˜¯æè¾¹çš„æ·±åº¦æµ‹è¯•ä¼šæœ‰ä¸€äº›å°ç‘•ç–µï¼ŒåŒæ—¶åœ¨ç‰©ä½“è·ç¦»æ‘„åƒæœºè¾ƒè¿‘çš„æ—¶å€™ï¼Œæè¾¹ä¼šæ˜¾å¾—è¾ƒç²—ï¼Œæ­¤å¤–è¿™ç§æè¾¹æ²¡æœ‰æŠ—é”¯é½¿çš„æ•ˆæœï¼Œç»˜åˆ¶æ¨¡å‹çš„èƒŒé¢ä¹Ÿè®©é€ æˆäº†æ€§èƒ½çš„æµªè´¹ã€‚å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨Multiple Render Targetsï¼Œæ¸²æŸ“å‡ºä¸€ä¸ªæ¨¡å‹çš„å‰ªå½±ï¼Œç„¶åä½¿ç”¨ç±»ä¼¼é«˜æ–¯æ¨¡ç³Šçš„åŠæ³•ï¼Œå¯¹é‡‡æ ·è¿›è¡Œåç§»ï¼Œè¿™æ ·å¯ä»¥æ¸²æŸ“å‡ºä¸€ä¸ªè¾ƒå¥½çš„å¯ä»¥æœ‰æŠ—é”¯é½¿æ•ˆæœçš„æè¾¹ï¼Œä½†æ˜¯ä»…é™äºæ¨¡å‹å‘å¤–çš„æè¾¹ï¼Œç¼ºå°‘æ¨¡å‹å†…éƒ¨çš„æè¾¹æ•ˆæœã€‚\næœ€å¥½çš„æè¾¹åº”è¯¥æ˜¯èƒ½å¤Ÿæ”¯æŒæ¨¡å‹å¤–æè¾¹ã€å†…æè¾¹ã€æè´¨æè¾¹çš„æè¾¹æ•ˆæœï¼Œpencil +å®ç°äº†è¿™äº›æ•ˆæœï¼Œä½†æ˜¯æ•ˆç‡ä¸æ˜¯å¾ˆé«˜ï¼Œè¿™é‡Œæœ‰ç›¸å…³çš„æ¼”ç¤ºï¼ˆæˆ‘ä¹Ÿæ˜¯çœ‹äº†è¿™ä¸ªä¹‹åæ‰å†³å®šç”¨å®‰å‰æ‹‰çš„æ¨¡å‹çš„ï¼‰ã€‚æˆ‘çœ‹åˆ°çš„è¾ƒå¥½çš„æ–¹æ¡ˆåº”è¯¥è¿˜æ˜¯L-çµåˆƒçš„ä½¿ç”¨é€€åŒ–å››è¾¹å½¢ç”Ÿæˆæè¾¹çš„åŠæ³•ï¼Œgithubä¸Šä¹Ÿåˆ†äº«äº†æºç ã€‚\nè¿™ç¯‡åšå®¢ä¸­ä»‹ç»çš„æè¾¹ï¼Œæ˜¯åŸºäºæˆ‘ä¸Šä¸€ç¯‡åšå®¢ä¸­è®²çš„ä¸–ç•Œç©ºé—´ä¸­ç»˜åˆ¶ç­‰å®½çº¿æ¡çš„æ–¹æ³•ï¼Œä½¿ç”¨DrawProceduralç»˜åˆ¶çš„ç­‰å®½çš„æè¾¹ã€‚æˆ‘è®¤ä¸ºåªæœ‰ç­‰å®½çš„æè¾¹ï¼Œæ‰æ˜¯æœ€èƒ½è¡¨ç°äºŒæ¬¡å…ƒç”»é¢ç‰¹å¾çš„æè¾¹ã€‚è¿™é‡Œçš„â€œç­‰å®½â€ï¼Œå¹¶ä¸æ˜¯è¯´çº¿æ¡çš„å®½åº¦å¤„å¤„ç›¸ç­‰ï¼Œçº¿æ¡å½“ç„¶å¯ä»¥æ§åˆ¶æ¯ä¸€éƒ¨åˆ†çš„ç²—ç»†ï¼Œä½†æ˜¯è¿™ä¸ªæ§åˆ¶çš„ç²—ç»†æ˜¯åŸºäºä¸€ä¸ªå›ºå®šå€¼çš„ç›¸å¯¹ç²—ç»†ï¼ˆä¹Ÿå°±æ˜¯å­˜åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹ç²—ç»†å€¼ï¼‰ï¼Œå½“ç²—ç»†å€¼ç›¸åŒæ—¶ï¼Œä¸ç®¡æ˜¯ç”»é¢çš„å“ªä¸ªéƒ¨åˆ†çš„æè¾¹çš„ç²—ç»†ï¼ˆä¸ç®¡æ˜¯å†…æè¾¹è¿˜æ˜¯å¤–æè¾¹ï¼‰ï¼Œéƒ½åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚\nå®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹ é¦–å…ˆå‚è€ƒé€€åŒ–å››è¾¹å½¢çš„æ¡ˆä¾‹ï¼Œéœ€è¦å…ˆå¯¹æ¨¡å‹æ–‡ä»¶è¿›è¡Œé¢„å¤„ç†ã€‚è¿™é‡Œæˆ‘åšäº†ç®€åŒ–ï¼Œåªå»å¯»æ‰¾ä¸¤ä¸ªä¸‰è§’é¢å…±ç”¨çš„è¾¹ï¼Œå¿½ç•¥äº†åªå±äºä¸€ä¸ªä¸‰è§’é¢çš„è¾¹çš„æƒ…å†µï¼ˆäº‹å®ä¸Šæˆ‘è§‰å¾—è¿™æ ·çœ‹ä¸Šå»çš„è§†è§‰æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼‰ã€‚ä¸€æ¡å…±ç”¨è¾¹å¯¹åº”äº†è¿™æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œä¸¤ä¾§çš„ä¸¤ä¸ªä¸‰è§’å½¢å’Œè¿™ä¸¤ä¸ªä¸‰è§’å½¢å¯¹åº”çš„é¢å¤–çš„ä¸¤ä¸ªé¡¶ç‚¹ã€‚è¿™é‡Œéƒ½ç”¨åºå·æ¥è¡¨ç¤ºï¼Œéœ€è¦6ä¸ªintå€¼ï¼ˆäº‹å®ä¸Šå¯ä»¥å¿½ç•¥ä¸¤ä¸ªä¸‰è§’å½¢çš„ç¼–å·ï¼Œå°±èƒ½å­˜åœ¨ä¸€ä¸ªint4é‡Œäº†ï¼‰ã€‚åˆ¤æ–­ä¸€æ¡è¾¹å…±åŒå±äºä¸¤ä¸ªä¸‰è§’å½¢ï¼Œå°±ç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’å½¢ä¸­çš„æŸä¸¤ä¸ªé¡¶ç‚¹çš„åºå·æ˜¯ç›¸åŒçš„ï¼ˆå®é™…ä¸Šé¡ºåºæ˜¯ç›¸åçš„ï¼‰ã€‚ä½†æ˜¯å®é™…æ“ä½œä¸­ï¼Œå³ä½¿æ˜¯ç›¸åŒçš„é¡¶ç‚¹ï¼Œåœ¨ä¸¤ä¸ªä¸‰è§’å½¢ä¸­é¡¶ç‚¹çš„åºå·ä¹Ÿä¸ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œå› æ­¤éœ€è¦å…ˆæŠŠä¸¤ä¸ªç›¸åŒçš„é¡¶ç‚¹ï¼ˆä½¿ç”¨è·ç¦»æ¥åˆ¤æ–­ï¼‰åˆå¹¶æˆä¸€ä¸ªé¡¶ç‚¹ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä½¿ç”¨vertRemappingè¿™ä¸ªæ•°ç»„çš„ç›®çš„ã€‚å‰©ä¸‹çš„å°±æ˜¯å¾ªç¯æ‰€æœ‰ä¸‰è§’å½¢ï¼Œè·å–å…±ç”¨è¾¹çš„ç®—æ³•éƒ¨åˆ†äº†ï¼Œå°½å¯èƒ½çš„ä¼˜åŒ–ä¸€ä¸‹ï¼Œä¸ç„¶ä¸‰è§’é¢ä¸€å¤šè¿ç®—çš„æ—¶é—´è¦å¾ˆä¹…ã€‚\næœ‰äº†å…±ç”¨è¾¹çš„æ•°æ®ï¼Œé€šè¿‡SkinnedMeshRenderer.BakeMesh()å¯ä»¥è·å–åˆ°å½“å‰å¸§æ¯ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼Œå°±èƒ½è¿›è¡Œæè¾¹çš„è®¡ç®—äº†ã€‚ä½¿ç”¨DrawProceduralæ—¶é¡¶ç‚¹çš„æ•°é‡å¯ä»¥æ˜¯å…¬ç”¨è¾¹æ•°é‡çš„ä¸¤å€ï¼Œè¿™æ ·éœ€è¦åœ¨Geometry Shaderä¸­æŠŠé¡¶ç‚¹æ•°ç›®ä»2æ‰©å……åˆ°6ï¼Œæˆ–è€…æ˜¯åœ¨ç»˜åˆ¶æ—¶å°†é¡¶ç‚¹æ•°é‡è®¾ç½®æˆå…±ç”¨è¾¹æ•°é‡çš„å…­å€ï¼Œå¯èƒ½åè€…æ•ˆç‡ä¼šé«˜ä¸€ç‚¹ï¼Œä¸è¿‡æ€è€ƒçš„æ—¶å€™ä¼šæœ‰ç‚¹ä¹±ï¼Œè¿™é‡Œå°±ä½¿ç”¨Geometry Shaderçš„æ–¹æ³•äº†ã€‚\nå¦‚æœæ˜¯åƒä¹‹å‰çš„åšå®¢ä»‹ç»çš„ï¼Œä»¥å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹ä¸ºä¸­å¿ƒï¼ŒåŒæ—¶å‘å·¦å³ä¸¤ä¾§å¤–æ‰©çš„è¯ï¼Œä¼šå› ä¸ºæ·±åº¦æµ‹è¯•çš„åŸå› ï¼Œå¯¼è‡´æè¾¹éƒ¨åˆ†è¢«æ¨¡å‹é®æŒ¡ï¼Œè¿™ä¸ªé—®é¢˜æ¯”è¾ƒä¸¥é‡ï¼Œä»–ç›´æ¥å¯¼è‡´äº†å¤–æè¾¹å’Œå†…æè¾¹çš„ç²—ç»†ä¸ä¸€æ ·ï¼Œä¹Ÿå¯¼è‡´äº†åœ¨ä¸€æ¡æè¾¹ä¸­ä¼šéœ²å‡ºä¸€éƒ¨åˆ†æ¨¡å‹çš„é—®é¢˜ã€‚è¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ä»…å‘å¤–ä¾§æè¾¹ï¼Œåœ¨è®¡ç®—æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„æ—¶å€™åŒæ—¶è®¡ç®—éœ€è¦æè¾¹çš„æ–¹å‘ï¼Œä½¿ç”¨è¿™ä¸ªæ–¹å‘å‘å¤–æ‰©å±•æè¾¹ï¼Œæœ€åæ•ˆæœè¿˜è›®ä¸é”™çš„ã€‚\nè¦å®ç°é£æ ¼åŒ–æè¾¹çš„è¯ï¼Œé™¤äº†ä½¿ç”¨é¡¶ç‚¹è‰²æ¥æ§åˆ¶æè¾¹çš„ç²—ç»†ä¹‹å¤–ï¼Œè¿˜èƒ½ä½¿ç”¨ä¸€å¼ è´´å›¾ä½œä¸ºæè¾¹çš„ç¬”åˆ·ï¼Œåœ¨ç»˜åˆ¶æè¾¹çš„æ—¶å€™é‡‡æ ·è¿™å¼ è´´å›¾ï¼Œæœ¬ç¯‡åšå®¢å°±æš‚ä¸ä½¿ç”¨è¿™ç§æ–¹æ³•äº†ã€‚\nå…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ  å¯¹å½“å‰æ¨¡å‹è·å–åˆ°æ‰€æœ‰çš„å…±ç”¨è¾¹å¯¹åº”çš„å››ä¸ªé¡¶ç‚¹åºå·ï¼Œä¸¥æ ¼ä¿æŒé¡ºåºï¼ æ¯ä¸€å¸§ä½¿ç”¨SkinnedMeshRenderer.BakeMeshï¼Œè·å–æ‰€æœ‰é¡¶ç‚¹å½“å‰çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ã€‚ ä¼ å…¥é¡¶ç‚¹åæ ‡ï¼Œé¡¶ç‚¹é‡æ˜ å°„æ•°ç»„ï¼Œå…±ç”¨è¾¹ä¿¡æ¯ï¼Œå¦‚æœéœ€è¦çš„è¯è¿˜è¦ä¼ é¡¶ç‚¹è‰²åˆ°æè¾¹çš„Shaderä¸­ã€‚ ä½¿ç”¨DrawProceduralç»˜åˆ¶æè¾¹ï¼Œé¡¶ç‚¹æ•°é‡ä¸ºå…±ç”¨è¾¹çš„æ•°é‡çš„ä¸¤å€ã€‚ åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´ï¼ˆå®é™…ä¸Šç”¨çš„æ˜¯å±å¹•ç©ºé—´ï¼‰çš„åæ ‡ï¼Œåˆ¤æ–­è¿™æ¡è¾¹æ˜¯ä¸æ˜¯è½®å»“è¾¹ï¼ŒåŒæ—¶è®°å½•æè¾¹å¤–æ‰©çš„æ–¹å‘ï¼Œç›¸å½“äºå¯¹äºæ¯ä¸€æ¡è¾¹ï¼ˆæ¯ä¸¤ä¸ªç‚¹ï¼‰å­˜ä¸¤ä¸ªboolå˜é‡ã€‚ åœ¨å‡ ä½•ä½“ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹çš„å±å¹•ç©ºé—´çš„åæ ‡ï¼Œè®¡ç®—å‡ºä¸¤ä¸ªç‚¹ä¹‹é—´çš„å‘é‡ï¼Œè®¡ç®—ä¸ä¹‹ç›¸å‚ç›´çš„å¤–æ‰©çš„æ–¹å‘ï¼Œæ ¹æ®ä¸¤ä¸ªå‘é‡ï¼Œè®¡ç®—å‡ºæè¾¹çš„å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´çš„åæ ‡ï¼Œå¹¶èµ‹äºˆuvçš„å€¼ã€‚ åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­ï¼Œæ ¹æ®uvè®¡ç®—å‡ºæè¾¹çš„é¢œè‰²ï¼Œå¯ä»¥é‡‡æ ·è´´å›¾ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è¿”å›è®¡ç®—çš„é¢œè‰²ã€‚  ç”±äºæ•´ä¸ªæè¾¹çš„æ“ä½œè¾ƒä¸ºå¤æ‚ï¼Œæˆ‘å°½å¯èƒ½å¤šçš„å†™äº†æ³¨é‡Šã€‚\nOutlineObject.cs å®šä¹‰å…±ç”¨è¾¹çš„ç»“æ„ä½“ï¼Œä¹Ÿå®šä¹‰ç”¨äºä¿å­˜å…±ç”¨è¾¹æ•°æ®çš„ScriptableObjectã€‚\nusing UnityEngine; namespace ZZNEWCLEAR13.Outline { [System.Serializable] public class OutlineObject : ScriptableObject { [System.Serializable] public class MeshOutlineInfo { public string meshName; //å°½é‡ä¸è¦éƒ½æ˜¾ç¤ºå‡ºæ¥ï¼Œä¸ç„¶å¾ˆå¡ã€‚ã€‚  //é¡¶ç‚¹ã€æ³•çº¿ã€åˆ‡çº¿å’Œé¡¶ç‚¹è‰² [HideInInspector] public Vector3[] vertices; [HideInInspector] public Vector3[] normals; [HideInInspector] public Vector4[] tangents; [HideInInspector] public Color[] colors; //vertRemappingæŠŠç›¸åŒä½ç½®çš„é¡¶ç‚¹ç¼–å·æ˜ å°„åˆ°ç¬¬ä¸€ä¸ªè¯¥ä½ç½®é¡¶ç‚¹çš„ç¼–å· [HideInInspector] public int[] vertRemapping; //ä¸‰è§’å½¢å¯¹åº”çš„é¡¶ç‚¹ç¼–å· [HideInInspector] public Vector3Int[] triangles; public Line[] commonLines; } public MeshOutlineInfo outlineInfo; } [System.Serializable] public struct Line { //Line  public int v0; public int v1; //Triangle One: v0, v1, v2  public int t0; public int v2; //Triangle Two: v0, v3, v1  public int t1; public int v3; public Line(int _v0, int _v1) { v0 = _v0; v1 = _v1; t0 = -1; t1 = -1; v2 = -1; v3 = -1; } //é‡è½½äº†Equalsæ–¹æ³•  //ä¸¤ä¸ªä¸‰è§’å½¢ä½¿ç”¨åŒä¸€æ¡è¾¹æ—¶ï¼Œè¾¹çš„èŠ‚ç‚¹çš„é¡ºåºæ˜¯ç›¸åçš„  //GetHashCode()ä¸ä¼šå†™ï¼Œä¹Ÿæ²¡å¿…è¦å†™ :)  public override bool Equals(object obj) { if (!(obj is Line line)) { return false; } return v0 == line.v1 \u0026\u0026 v1 == line.v0; } } } ModelPreProcess.cs ç”¨äºæ¨¡å‹é¢„å¤„ç†ï¼Œç”Ÿæˆå¹¶ä¿å­˜æ¨¡å‹çš„å…±ç”¨è¾¹çš„ä¿¡æ¯ã€‚\nusing System.Collections.Generic; using UnityEngine; using UnityEditor; namespace ZZNEWCLEAR13.Outline { public class ModelPreProcess : EditorWindow { //å½“ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´è·ç¦»å°äºEPSILONæ—¶ï¼Œè®¤ä¸ºæ˜¯åŒä¸€ä¸ªé¡¶ç‚¹  const float EPSILON = 0.00001f; public GameObject fbxObj; public string saveName = \"OutlineInfo\"; private Rect topToolBarRect { get { return new Rect(20, 10, position.width - 40, 120); } } [MenuItem(\"zznewclear13/Model Pre-process\")] public static ModelPreProcess GetWindow() { ModelPreProcess window = GetWindow(); window.titleContent = new GUIContent(\"Model Pre-process\"); window.Focus(); window.Repaint(); return window; } private void OnGUI() { TopToolBar(topToolBarRect); } private void TopToolBar(Rect rect) { using (new GUILayout.AreaScope(rect)) { fbxObj = (GameObject)EditorGUILayout.ObjectField(\"FBX Object\", fbxObj, typeof(GameObject), false); saveName = EditorGUILayout.TextField(\"Save Name\", saveName); using (new EditorGUI.DisabledGroupScope(!fbxObj)) { if (GUILayout.Button(\"Process!\", new GUILayoutOption[] { GUILayout.Height(30f) })) { ProcessAll(); } } } } private void ProcessAll() { MeshFilter[] meshFilters = fbxObj.GetComponentsInChildren(); SkinnedMeshRenderer[] skinnedMeshRenderers = fbxObj.GetComponentsInChildren(); int meshFilterLength = meshFilters.Length; OutlineObject.MeshOutlineInfo[] mois = new OutlineObject.MeshOutlineInfo[meshFilterLength + skinnedMeshRenderers.Length]; for (int i = 0; i for (int i = 0; i //æ‰¾å‡ºå…¶ä¸­çš„å…±åŒè¾¹ï¼Œå¹¶å‚¨å­˜ä¸‰è§’å½¢åºå·å’Œå¦å¤–ä¸¤ä¸ªé¡¶ç‚¹çš„åºå·  //æ³¨æ„é¡¶ç‚¹çš„é¡ºåº  //v0, v1, v2æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢  //v0, v3, v1æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢  private void CheckLine(int triangleIndex, int vertexIndex, Line line, ref List lineList, ref List commonLines) { bool hasLine = false; int lineListIndex = -1; for (int i = 0; i if (line.Equals(lineList[i])) { hasLine = true; lineListIndex = i; break; } } if (hasLine) { Line tempLine = lineList[lineListIndex]; lineList.RemoveAt(lineListIndex); tempLine.t1 = triangleIndex; tempLine.v3 = vertexIndex; commonLines.Add(tempLine); } else { line.t0 = triangleIndex; line.v2 = vertexIndex; lineList.Add(line); } } //å½“ä¸¤ä¸ªé¡¶ç‚¹è·ç¦»å¾ˆè¿‘æ—¶ï¼Œè§†åšåŒä¸€ä¸ªé¡¶ç‚¹  //ä½¿ç”¨vertRemappingå‚¨å­˜ç›¸åŒé¡¶ç‚¹çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„åºå·  private int[] MergeIndexes(Vector3[] vertices) { int[] vertRemapping = new int[vertices.Length]; vertRemapping[0] = 0; for (int i = 1; i bool hasVert = false; for (int j = 0; j if (vertRemapping[j] continue; } else { if ((vertices[i] - vertices[vertRemapping[j]]).magnitude true; } } } if (!hasVert) { vertRemapping[i] = i; } } return vertRemapping; } private OutlineObject.MeshOutlineInfo ProcessMesh(Mesh sharedMesh) { OutlineObject.MeshOutlineInfo moi = new OutlineObject.MeshOutlineInfo(); moi.meshName = sharedMesh.name; Vector3[] vertices = sharedMesh.vertices; Vector3[] normals = sharedMesh.normals; Vector4[] tangents = sharedMesh.tangents; Color[] colors = sharedMesh.colors; moi.vertices = vertices; moi.normals = normals; moi.tangents = tangents; moi.colors = colors; int[] vertRemapping = MergeIndexes(vertices); moi.vertRemapping = vertRemapping; int[] triangles = sharedMesh.triangles; List lineList = new List(); List commonLines = new List(); System.Diagnostics.Debug.Assert(triangles.Length % 3 == 0); int triangleCount = triangles.Length / 3; Vector3Int[] packedTriangles = new Vector3Int[triangleCount]; //éå†æ‰€æœ‰çš„ä¸‰è§’å½¢ï¼Œæ³¨æ„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹çš„é¡ºåº  for (int i = 0; i int triangleIndex = 3 * i; int vID0 = vertRemapping[triangles[triangleIndex]]; int vID1 = vertRemapping[triangles[triangleIndex + 1]]; int vID2 = vertRemapping[triangles[triangleIndex + 2]]; packedTriangles[i] = new Vector3Int(vID0, vID1, vID2); Line line0 = new Line(vID0, vID1); Line line1 = new Line(vID1, vID2); Line line2 = new Line(vID2, vID0); CheckLine(i, vID2, line0, ref lineList, ref commonLines); CheckLine(i, vID0, line1, ref lineList, ref commonLines); CheckLine(i, vID1, line2, ref lineList, ref commonLines); } moi.triangles = packedTriangles; moi.commonLines = commonLines.ToArray(); return moi; } private void SaveAsset(OutlineObject.MeshOutlineInfo[] outlineInfos) { string path = AssetDatabase.GetAssetPath(fbxObj); string assetPath = path.Substring(0, path.LastIndexOf('/')) + \"/\" + saveName; if (!System.IO.Directory.Exists(assetPath)) { System.IO.Directory.CreateDirectory(assetPath); } for (int i = 0; i (); asset.outlineInfo = outlineInfos[i]; string tempPath = assetPath + \"/\" + outlineInfos[i].meshName + \".asset\"; AssetDatabase.CreateAsset(asset, tempPath); } AssetDatabase.SaveAssets(); } } } DrawOutline.cs è¿™é‡Œä»¥SkinnedMeshRendererä¸ºä¾‹ï¼Œå› ä¸ºç›¸å¯¹äºæ™®é€šçš„Meshæ¥è¯´è¾ƒä¸ºå¤æ‚ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨ä¿å­˜åœ¨å…±ç”¨è¾¹ä¿¡æ¯é‡Œçš„ç‰©ä½“ç©ºé—´çš„é¡¶ç‚¹åæ ‡ã€‚\nusing System.Collections.Generic; using UnityEngine; namespace ZZNEWCLEAR13.Outline { //ä»…æ”¯æŒSkinnedMeshRenderer  //æ™®é€šçš„Meshåªè¦ç¨æ”¹ä¸€ä¸‹ä»£ç å°±å¥½äº† [ExecuteInEditMode] [RequireComponent(typeof(SkinnedMeshRenderer))] public class DrawOutline : MonoBehaviour { public Material outlineMaterial; public GameObject targetGO; public SkinnedMeshRenderer skinnedMeshRenderer; public OutlineObject outlineObject; private Mesh bakedMesh; private List meshVertices; private Vector3[] vertices; private Color[] colors; private int[] vertRemapping; private Line[] lines; private ComputeBuffer verticesBuffer; private ComputeBuffer colorBuffer; private ComputeBuffer vertRemappingBuffer; private ComputeBuffer lineBuffer; private void EnsureBuffer(ref ComputeBuffer buffer, int count, int stride) { if (buffer != null) { buffer.Release(); } buffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } private void OnEnable() { meshVertices = new List(); vertices = outlineObject.outlineInfo.vertices; colors = outlineObject.outlineInfo.colors; vertRemapping = outlineObject.outlineInfo.vertRemapping; lines = outlineObject.outlineInfo.commonLines; EnsureBuffer(ref verticesBuffer, vertices.Length, 3 * 4); EnsureBuffer(ref colorBuffer, vertices.Length, 4 * 4); EnsureBuffer(ref vertRemappingBuffer, vertRemapping.Length, 4); EnsureBuffer(ref lineBuffer, lines.Length, 6 * 4); bakedMesh = new Mesh(); } private void Update() { DrawOutlineProcedural(); } private void DrawOutlineProcedural() { skinnedMeshRenderer.BakeMesh(bakedMesh); bakedMesh.GetVertices(meshVertices); verticesBuffer.SetData(meshVertices); colorBuffer.SetData(colors); vertRemappingBuffer.SetData(vertRemapping); lineBuffer.SetData(lines); MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetBuffer(\"_VerticesBuffer\", verticesBuffer); mpb.SetBuffer(\"_ColorBuffer\", colorBuffer); mpb.SetBuffer(\"_VertRemappingBuffer\", vertRemappingBuffer); mpb.SetBuffer(\"_LineBuffer\", lineBuffer); //ä¸€èˆ¬éœ€è¦ä¼ å…¥SkinnedMeshRendererçš„çˆ¶ç‰©ä½“çš„ç‰©ä½“ç©ºé—´åˆ°ä¸–ç•Œç©ºé—´çš„å˜æ¢çŸ©é˜µ  mpb.SetMatrix(\"_ObjToWorldMat\", targetGO.transform.localToWorldMatrix); Bounds bounds = skinnedMeshRenderer.bounds; Graphics.DrawProcedural(outlineMaterial, bounds, MeshTopology.Lines, lines.Length * 2, properties: mpb); } private void OnDestroy() { verticesBuffer.Dispose(); vertRemappingBuffer.Dispose(); lineBuffer.Dispose(); } } } OutlineShader.shader æ„Ÿè§‰å·²ç»äº‹æ— å·¨ç»†çš„å†™åœ¨æ³¨é‡Šé‡Œäº†ï¼Œæœ€å…³é”®çš„å°±æ˜¯æ—¶åˆ»æé†’è‡ªå·±ç»˜åˆ¶ä¸‰è§’å½¢æ—¶çš„é¡¶ç‚¹é¡ºåºã€‚æ„Ÿè§‰æˆ‘å¯¹ä½¿ç”¨æ•°ç»„æ¥è®¾è®¡å¹¶è¡Œè¿ç®—å·²ç»ç‚‰ç«çº¯é’äº†ã€‚ä½¿ç”¨çº¿æ€§ä»£æ•°æ¥åˆ¤æ–­ä¸‰è§’å½¢çš„å…¶ä½™ä¸¤ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨å…±ç”¨è¾¹çš„ä¸¤ä¾§ï¼Œæˆ‘æ„Ÿè§‰æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„åŠæ³•ï¼ˆä¼¼ä¹æ¯”ç›´æ¥è®¡ç®—æ³•çº¿è¦ç¨å¥½ä¸€ç‚¹ï¼Ÿï¼‰ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯å‘ç°æ•ˆæœåŸºæœ¬æ­£ç¡®ä¹‹åå°±ä¸ä¼šå†å›è¿‡å¤´å»éªŒè¯è‡ªå·±çš„ä»£ç äº†å“ˆå“ˆã€‚\nShader \"zznewclear13/OutlineShader\"\r{\rProperties\r{\r_OutlineColor (\"Outline Color\", color) = (1.0, 1.0, 1.0, 1.0)\r_OutlineExt (\"Outline Extension\", range(-1, 1)) = 0.1\r_OutlineWidth(\"Outline Width\", float) = 1.0\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\rfloat4x4 _ObjToWorldMat;\rfloat4 _OutlineColor;\rfloat _OutlineExt;\rfloat _OutlineWidth;\rStructuredBuffer _VerticesBuffer;\rStructuredBuffer _VertRemappingBuffer;\r//å®é™…å¯ä»¥ç®€åŒ–æˆä¸€ä¸ªint4ï¼Œåªå‚¨å­˜é¡¶ç‚¹åºå·\rstruct LineStruct\r{\rint2 lineVertices; // v0, v1\rint4 trianglesAndVertices; // t0, v2, t1, v3\r};\rStructuredBuffer _LineBuffer;\rstruct Attributes\r{\ruint vertexID : SV_VERTEXID;\r};\rstruct Geoms\r{\rfloat4 positionCS : TEXCOORD0;\rbool2 edgeAndSide : TEXCOORD1;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\r};\rGeoms OutlineVert(Attributes input)\r{\rGeoms output = (Geoms)0;\r//è·å–é¡¶ç‚¹åºå·å’Œè¾¹çš„åºå·\rint vertexID = input.vertexID % 2;\rint lineID = input.vertexID / 2;\r//è·å–è¾¹ä¸Šè¾ƒè¿‘çš„é¡¶ç‚¹å’Œè¾ƒè¿œçš„é¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´åæ ‡\rfloat3 vertexOne = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[vertexID]]]; float3 vertexTwo = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[1 - vertexID]]];\r//è·å–ç¬¬ä¸€ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹å’Œç¬¬äºŒä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹\rfloat3 vertexThree = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[vertexID * 2 + 1]]];\rfloat3 vertexFour = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[3 - vertexID * 2]]];\r//è½¬æ¢åˆ°è£å‰ªç©ºé—´\rfloat4x4 mvp = mul(UNITY_MATRIX_VP, _ObjToWorldMat);\rfloat4 positionCSOne = mul(mvp, float4(vertexOne, 1.0));\rfloat4 positionCSTwo = mul(mvp, float4(vertexTwo, 1.0));\rfloat4 positionCSThree = mul(mvp, float4(vertexThree, 1.0));\rfloat4 positionCSFour = mul(mvp, float4(vertexFour, 1.0));\r//è·å–å±å¹•ç©ºé—´çš„åæ ‡\rfloat2 uvOne = positionCSOne.xy / positionCSOne.w;\rfloat2 uvTwo = positionCSTwo.xy / positionCSTwo.w;\rfloat2 uvThree = positionCSThree.xy / positionCSThree.w;\rfloat2 uvFour = positionCSFour.xy / positionCSFour.w;\r//è¿™é‡Œç®€åŒ–äº†æ±‚æ³•çº¿çš„è¿‡ç¨‹ï¼Œç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨è¾¹çš„ä¸¤ä¾§\rfloat valueA = uvOne.y - uvTwo.y;\rfloat valueB = uvOne.x * uvTwo.y - uvTwo.x * uvOne.y;\rfloat valueC = uvOne.x - uvTwo.x;\rfloat signThree = valueA * uvThree.x + valueB - valueC * uvThree.y;\rfloat signFour = valueA * uvFour.x + valueB - valueC * uvFour.y;\r//Xï¼šè¯¥é¡¶ç‚¹æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„é¡¶ç‚¹ï¼›Yï¼šè¯¥é¡¶ç‚¹åº”è¯¥å‘è¾¹çš„é¡ºæ—¶é’ˆæ–¹å‘è¿˜æ˜¯é€†æ—¶é’ˆæ–¹å‘å¤–æ‰©\routput.edgeAndSide = bool2((signThree * signFour = 0), (signThree = 0));\routput.positionCS = positionCSOne;\rreturn output;\r}\r[maxvertexcount(6)]\rvoid OutlineGeomTriangle(line Geoms input[2], inout TriangleStream triangleStream)\r{\rVaryings output = (Varyings)0;\r//åˆ¤æ–­æ˜¯ä¸æ˜¯è¾¹ç•Œè¾¹ï¼Œå…¶å®åªéœ€è¦åˆ¤æ–­ä¸€ä¸ªé¡¶ç‚¹å°±å¯ä»¥äº†\rif(input[0].edgeAndSide.x \u0026\u0026 input[1].edgeAndSide.x)\r{\r//å¯ä»¥é€šè¿‡é¡¶ç‚¹è‰²æ¥è°ƒæ•´æè¾¹å®½åº¦\rfloat outlineWidthOne = _OutlineWidth;// * input[0].color.a;\rfloat outlineWidthTwo = _OutlineWidth;// * input[1].color.a;\rfloat4 positionCSOne = input[0].positionCS;\rfloat4 positionCSTwo = input[1].positionCS;\r//è·å–å±å¹•ç©ºé—´çš„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„å‘é‡\rfloat2 offset = positionCSOne.xy / positionCSOne.w - positionCSTwo.xy / positionCSTwo.w;\rfloat lengthOffset = length(offset);\rfloat2 normalizedOffset = normalize(offset * (_ScreenParams.wz - 1.0));\r//Xï¼šä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹çš„å‘é‡\r//Yï¼šä¸ä¹‹å‚ç›´çš„å¦ä¸€ä¸ªå‘é‡\r//ä½¿ç”¨min(1.0, rcp(positionCSOne.w)æ¥ä½¿æè¾¹æŒ‰ç…§è·ç¦»å˜ç»†ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨å¹³æ–¹æ ¹å€’æ•°æ¥æ§åˆ¶\rfloat2 pointOffsetX = float2(normalizedOffset.x, normalizedOffset.y) * min(1.0, rcp(positionCSOne.w));\rfloat2 pointOffsetY = float2(-normalizedOffset.y, normalizedOffset.x) * min(1.0, rcp(positionCSOne.w));\r//ç¬¬ä¸€ç¬¬äºŒä¸ªé¡¶ç‚¹ä¸ç”¨å¤–æ‰©\r//ç¬¬ä¸‰ç¬¬å››ä¸ªé¡¶ç‚¹æŒ‰ç…§edgeAndSideæ¥åˆ¤æ–­å¤–æ‰©çš„æ–¹å‘\r//åŒæ—¶ä½¿ç”¨_OutlineExtæ¥æ§åˆ¶å¤–æ‰©å‡ºçš„æ¢¯å½¢çš„å½¢çŠ¶\rfloat4 csOne = positionCSOne;\rfloat4 csTwo = positionCSTwo;\rfloat4 csThree = float4(-positionCSTwo.w * (pointOffsetX * (1.0 + _OutlineExt) + pointOffsetY * (2 * input[1].edgeAndSide.y - 1)) * (_ScreenParams.zw - 1.0) * outlineWidthTwo, 0, 0) + positionCSTwo;\rfloat4 csFour = float4(-positionCSOne.w * (-pointOffsetX * (1.0 + _OutlineExt) - pointOffsetY * (2 * input[0].edgeAndSide.y - 1)) * (_ScreenParams.zw - 1.0) * outlineWidthOne, 0, 0) + positionCSOne;\r//å››ä¸ªé¡¶ç‚¹çš„UV\rfloat2 uvOne = float2(0.0, 0.0);\rfloat2 uvTwo = float2(1.0, 0.0);\rfloat2 uvThree = float2(1.0, 1.0);\rfloat2 uvFour = float2(0.0, 1.0);\r//ç»˜åˆ¶å¤–æ‰©æ¢¯å½¢çš„å…¶ä¸­ä¸‰ä¸ªé¡¶ç‚¹\routput.positionCS = csOne;\routput.uv = uvOne;\rtriangleStream.Append(output);\routput.positionCS = csTwo;\routput.uv = uvTwo;\rtriangleStream.Append(output);\routput.positionCS = csThree;\routput.uv = uvThree;\rtriangleStream.Append(output);\r//å‡ºäºæˆ‘ä¸èƒ½è§£é‡Šçš„åŸå› ï¼Œè¿™é‡Œçš„é¡¶ç‚¹é¡ºåºå’Œå‰é¢æ˜¯ç›¸åçš„\routput.positionCS = csOne;\routput.uv = uvOne;\rtriangleStream.Append(output);\routput.positionCS = csFour;\routput.uv = uvFour;\rtriangleStream.Append(output);\routput.positionCS = csThree;\routput.uv = uvThree;\rtriangleStream.Append(output); }\rtriangleStream.RestartStrip();\r}\rfloat4 OutlineFrag(Varyings input) : SV_TARGET\r{\rfloat2 uv = input.uv;\r//ä½¿ç”¨fwidthè¿›è¡ŒæŠ—é”¯é½¿\rreturn float4(_OutlineColor.rgb, smoothstep(1.0, 1.0 - fwidth(uv.y), input.uv.y));\r}\rENDHLSL\rSubShader\r{\rTags {\"Queue\"=\"Transparent\" \"RenderType\"=\"Transparent\" }\rZWrite Off\rBlend SrcAlpha OneMinusSrcAlpha\rPass\r{\rHLSLPROGRAM\r#pragma target 5.0\r#pragma vertex OutlineVert\r#pragma geometry OutlineGeomTriangle\r#pragma fragment OutlineFrag\rENDHLSL\r}\r}\r}\ræœ€åçš„æ€è€ƒ æœ¬åšå®¢çš„æ¨¡å‹æ˜¯ç½‘ä¸Šä¸‹è½½çš„ï¼Œæˆ‘ä¹Ÿæ²¡æœ‰çœ‹è¿‡ä¹å›­è¿½æ”¾ï¼Œå¥½åƒè¡£æœéƒ¨åˆ†çš„uvå‡ºäº†ç‚¹é—®é¢˜ï¼Œä¸è¿‡è·Ÿæè¾¹çš„æ•ˆæœæ²¡æœ‰å…³ç³»ï¼Œå°±è¿™æ ·äº†ã€‚\nåœ¨æ¨¡å‹å¯¼å…¥çš„æ—¶å€™æœ€å¥½èƒ½é€‰æ‹©ä¸­ç­‰è´¨é‡ï¼Œè¿™æ ·æ¨¡å‹çš„é¢æ•°ä¼šå°‘ä¸€äº›ï¼Œä¹Ÿä¸ä¼šå‡ºç°å› ä¸ºç¾æœ¯å¤±è¯¯å¯¼è‡´å¥‡æ€ªçš„åœ°æ–¹äº§ç”Ÿæè¾¹çš„é—®é¢˜ã€‚æœ€ç»ˆæè¾¹æ•ˆæœç¡®å®è¿˜è›®ä¸é”™çš„ï¼Œç¡®å®éƒ½æ˜¯ä¸€æ ·çš„å®½ï¼Œä½¿ç”¨fwidthçš„æŠ—é”¯é½¿æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼Œå°±æ˜¯å¹¶æ²¡æœ‰æŠŠå¤–æè¾¹å’Œå†…æè¾¹åˆ†å¼€æ¥åšï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆåšäº†ï¼‰ï¼Œæ ¹æ®å…±ç”¨è¾¹ä¸¤ä¸ªä¸‰è§’é¢æ³•çº¿çš„å¤¹è§’è¿˜èƒ½ç»˜åˆ¶é¢å¤–çš„æè¾¹ï¼Œè¿™é‡Œå°±ä¸é¢å¤–åšäº†ï¼ˆä¸è¿‡åº”è¯¥ä¸å¤ªå¥½åšï¼Œæ·±åº¦æµ‹è¯•çš„é—®é¢˜æ¯”è¾ƒå¤§ï¼‰ï¼Œä¸¤ç§æè´¨ä¹‹é—´çš„æè¾¹ä¹Ÿæ²¡åšï¼ˆå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼‰ã€‚ä½†æ•´ä½“çœ‹ä¸Šå»è¿˜æ˜¯æŒºå¯ä»¥çš„äº†ï¼Œå˜¿å˜¿ã€‚\n","wordCount":"1438","inLanguage":"en","image":"https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/posts/images/EqualWidthOutline.jpg","datePublished":"2021-12-12T12:00:00+08:00","dateModified":"2021-12-12T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/draw-equal-width-outline-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹</h1><div class=post-description>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½ä¸”æŠ—é”¯é½¿çš„æè¾¹.</div><div class=post-meta><span title="2021-12-12 12:00:00 +0800 CST">December 12, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/draw-equal-width-outline-in-unity.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/EqualWidthOutline.jpg alt="Equal Width Outline Cover"><p>Equal Width Outline Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çš„æè¾¹</div></summary><div class=inner><ul><li><a href=#%e5%af%b9%e4%ba%8e%e6%8f%8f%e8%be%b9%e7%9a%84%e6%80%9d%e8%80%83 aria-label=å¯¹äºæè¾¹çš„æ€è€ƒ>å¯¹äºæè¾¹çš„æ€è€ƒ</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%8f%8f%e8%be%b9%e6%97%b6%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9 aria-label=å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹>å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%8f%8f%e8%be%b9%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ>å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ</a><ul><li><a href=#outlineobjectcs aria-label=OutlineObject.cs>OutlineObject.cs</a></li><li><a href=#modelpreprocesscs aria-label=ModelPreProcess.cs>ModelPreProcess.cs</a></li><li><a href=#drawoutlinecs aria-label=DrawOutline.cs>DrawOutline.cs</a></li><li><a href=#outlineshadershader aria-label=OutlineShader.shader>OutlineShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=å¯¹äºæè¾¹çš„æ€è€ƒ>å¯¹äºæè¾¹çš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#å¯¹äºæè¾¹çš„æ€è€ƒ>#</a></h2><p>æè¾¹å¯ä»¥è¯´æ˜¯ä¸€ä¸ªç‰¹åˆ«å…³é”®çš„æ•ˆæœï¼Œä¸ä»…ä»…æ˜¯äºŒæ¬¡å…ƒå¡é€šæ¸²æŸ“éœ€è¦ç”¨åˆ°æè¾¹ï¼Œåœ¨ç”¨æˆ·äº¤äº’çš„æ–¹é¢ï¼Œæè¾¹ä¹Ÿæ˜¯ä¸€ä¸ªå¢å¼ºç”¨æˆ·äº¤äº’çš„å…³é”®æ•ˆæœã€‚</p><p>ä¸€èˆ¬çš„æè¾¹çš„åšæ³•æ˜¯ç»˜åˆ¶ä¸€ä¸ªæ²¿ç‰©ä½“ç©ºé—´é¡¶ç‚¹æ³•çº¿ï¼ˆæˆ–æ˜¯è®°å½•åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹æ–¹å‘ï¼‰å¤–æ‰©çš„æ¨¡å‹èƒŒé¢ï¼Œè¿™ç§åšæ³•åœ¨ç»å¤§éƒ¨åˆ†æƒ…å†µéƒ½çœ‹ä¸Šå»ä¸é”™ï¼Œä½†æ˜¯æè¾¹çš„æ·±åº¦æµ‹è¯•ä¼šæœ‰ä¸€äº›å°ç‘•ç–µï¼ŒåŒæ—¶åœ¨ç‰©ä½“è·ç¦»æ‘„åƒæœºè¾ƒè¿‘çš„æ—¶å€™ï¼Œæè¾¹ä¼šæ˜¾å¾—è¾ƒç²—ï¼Œæ­¤å¤–è¿™ç§æè¾¹æ²¡æœ‰æŠ—é”¯é½¿çš„æ•ˆæœï¼Œç»˜åˆ¶æ¨¡å‹çš„èƒŒé¢ä¹Ÿè®©é€ æˆäº†æ€§èƒ½çš„æµªè´¹ã€‚å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨Multiple Render Targetsï¼Œæ¸²æŸ“å‡ºä¸€ä¸ªæ¨¡å‹çš„å‰ªå½±ï¼Œç„¶åä½¿ç”¨ç±»ä¼¼é«˜æ–¯æ¨¡ç³Šçš„åŠæ³•ï¼Œå¯¹é‡‡æ ·è¿›è¡Œåç§»ï¼Œè¿™æ ·å¯ä»¥æ¸²æŸ“å‡ºä¸€ä¸ªè¾ƒå¥½çš„å¯ä»¥æœ‰æŠ—é”¯é½¿æ•ˆæœçš„æè¾¹ï¼Œä½†æ˜¯ä»…é™äºæ¨¡å‹å‘å¤–çš„æè¾¹ï¼Œç¼ºå°‘æ¨¡å‹å†…éƒ¨çš„æè¾¹æ•ˆæœã€‚</p><p>æœ€å¥½çš„æè¾¹åº”è¯¥æ˜¯èƒ½å¤Ÿæ”¯æŒæ¨¡å‹å¤–æè¾¹ã€å†…æè¾¹ã€æè´¨æè¾¹çš„æè¾¹æ•ˆæœï¼Œ<a href=https://www.psoft.co.jp/jp/product/pencil/unity/>pencil +</a>å®ç°äº†è¿™äº›æ•ˆæœï¼Œä½†æ˜¯æ•ˆç‡ä¸æ˜¯å¾ˆé«˜ï¼Œ<a href=https://www.bilibili.com/video/BV1Et4y1B7hB>è¿™é‡Œ</a>æœ‰ç›¸å…³çš„æ¼”ç¤ºï¼ˆæˆ‘ä¹Ÿæ˜¯çœ‹äº†è¿™ä¸ªä¹‹åæ‰å†³å®šç”¨å®‰å‰æ‹‰çš„æ¨¡å‹çš„ï¼‰ã€‚æˆ‘çœ‹åˆ°çš„è¾ƒå¥½çš„æ–¹æ¡ˆåº”è¯¥è¿˜æ˜¯L-çµåˆƒçš„<a href=https://blog.csdn.net/lht748/article/details/88680146>ä½¿ç”¨é€€åŒ–å››è¾¹å½¢ç”Ÿæˆæè¾¹</a>çš„åŠæ³•ï¼Œgithubä¸Šä¹Ÿåˆ†äº«äº†<a href=https://github.com/L-LingRen/UnitySimpleCartoonLine>æºç </a>ã€‚</p><p>è¿™ç¯‡åšå®¢ä¸­ä»‹ç»çš„æè¾¹ï¼Œæ˜¯åŸºäºæˆ‘ä¸Šä¸€ç¯‡åšå®¢ä¸­è®²çš„ä¸–ç•Œç©ºé—´ä¸­ç»˜åˆ¶ç­‰å®½çº¿æ¡çš„æ–¹æ³•ï¼Œä½¿ç”¨<code>DrawProcedural</code>ç»˜åˆ¶çš„ç­‰å®½çš„æè¾¹ã€‚æˆ‘è®¤ä¸ºåªæœ‰ç­‰å®½çš„æè¾¹ï¼Œæ‰æ˜¯æœ€èƒ½è¡¨ç°äºŒæ¬¡å…ƒç”»é¢ç‰¹å¾çš„æè¾¹ã€‚è¿™é‡Œçš„â€œç­‰å®½â€ï¼Œå¹¶ä¸æ˜¯è¯´çº¿æ¡çš„å®½åº¦å¤„å¤„ç›¸ç­‰ï¼Œçº¿æ¡å½“ç„¶å¯ä»¥æ§åˆ¶æ¯ä¸€éƒ¨åˆ†çš„ç²—ç»†ï¼Œä½†æ˜¯è¿™ä¸ªæ§åˆ¶çš„ç²—ç»†æ˜¯åŸºäºä¸€ä¸ªå›ºå®šå€¼çš„ç›¸å¯¹ç²—ç»†ï¼ˆä¹Ÿå°±æ˜¯å­˜åœ¨é¡¶ç‚¹è‰²ä¸­çš„æè¾¹ç²—ç»†å€¼ï¼‰ï¼Œå½“ç²—ç»†å€¼ç›¸åŒæ—¶ï¼Œä¸ç®¡æ˜¯ç”»é¢çš„å“ªä¸ªéƒ¨åˆ†çš„æè¾¹çš„ç²—ç»†ï¼ˆä¸ç®¡æ˜¯å†…æè¾¹è¿˜æ˜¯å¤–æè¾¹ï¼‰ï¼Œéƒ½åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚</p><h2 id=å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹>å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹<a hidden class=anchor aria-hidden=true href=#å®ç°æè¾¹æ—¶éœ€è¦æ³¨æ„çš„ç‚¹>#</a></h2><p>é¦–å…ˆå‚è€ƒé€€åŒ–å››è¾¹å½¢çš„æ¡ˆä¾‹ï¼Œéœ€è¦å…ˆå¯¹æ¨¡å‹æ–‡ä»¶è¿›è¡Œé¢„å¤„ç†ã€‚è¿™é‡Œæˆ‘åšäº†ç®€åŒ–ï¼Œåªå»å¯»æ‰¾ä¸¤ä¸ªä¸‰è§’é¢å…±ç”¨çš„è¾¹ï¼Œå¿½ç•¥äº†åªå±äºä¸€ä¸ªä¸‰è§’é¢çš„è¾¹çš„æƒ…å†µï¼ˆäº‹å®ä¸Šæˆ‘è§‰å¾—è¿™æ ·çœ‹ä¸Šå»çš„è§†è§‰æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼‰ã€‚ä¸€æ¡å…±ç”¨è¾¹å¯¹åº”äº†è¿™æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œä¸¤ä¾§çš„ä¸¤ä¸ªä¸‰è§’å½¢å’Œè¿™ä¸¤ä¸ªä¸‰è§’å½¢å¯¹åº”çš„é¢å¤–çš„ä¸¤ä¸ªé¡¶ç‚¹ã€‚è¿™é‡Œéƒ½ç”¨åºå·æ¥è¡¨ç¤ºï¼Œéœ€è¦6ä¸ªintå€¼ï¼ˆäº‹å®ä¸Šå¯ä»¥å¿½ç•¥ä¸¤ä¸ªä¸‰è§’å½¢çš„ç¼–å·ï¼Œå°±èƒ½å­˜åœ¨ä¸€ä¸ªint4é‡Œäº†ï¼‰ã€‚åˆ¤æ–­ä¸€æ¡è¾¹å…±åŒå±äºä¸¤ä¸ªä¸‰è§’å½¢ï¼Œå°±ç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’å½¢ä¸­çš„æŸä¸¤ä¸ªé¡¶ç‚¹çš„åºå·æ˜¯ç›¸åŒçš„ï¼ˆå®é™…ä¸Šé¡ºåºæ˜¯ç›¸åçš„ï¼‰ã€‚ä½†æ˜¯å®é™…æ“ä½œä¸­ï¼Œå³ä½¿æ˜¯ç›¸åŒçš„é¡¶ç‚¹ï¼Œåœ¨ä¸¤ä¸ªä¸‰è§’å½¢ä¸­é¡¶ç‚¹çš„åºå·ä¹Ÿä¸ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œå› æ­¤éœ€è¦å…ˆæŠŠä¸¤ä¸ªç›¸åŒçš„é¡¶ç‚¹ï¼ˆä½¿ç”¨è·ç¦»æ¥åˆ¤æ–­ï¼‰åˆå¹¶æˆä¸€ä¸ªé¡¶ç‚¹ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä½¿ç”¨<code>vertRemapping</code>è¿™ä¸ªæ•°ç»„çš„ç›®çš„ã€‚å‰©ä¸‹çš„å°±æ˜¯å¾ªç¯æ‰€æœ‰ä¸‰è§’å½¢ï¼Œè·å–å…±ç”¨è¾¹çš„ç®—æ³•éƒ¨åˆ†äº†ï¼Œå°½å¯èƒ½çš„ä¼˜åŒ–ä¸€ä¸‹ï¼Œä¸ç„¶ä¸‰è§’é¢ä¸€å¤šè¿ç®—çš„æ—¶é—´è¦å¾ˆä¹…ã€‚</p><p>æœ‰äº†å…±ç”¨è¾¹çš„æ•°æ®ï¼Œé€šè¿‡<code>SkinnedMeshRenderer.BakeMesh()</code>å¯ä»¥è·å–åˆ°å½“å‰å¸§æ¯ä¸ªé¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ï¼Œå°±èƒ½è¿›è¡Œæè¾¹çš„è®¡ç®—äº†ã€‚ä½¿ç”¨<code>DrawProcedural</code>æ—¶é¡¶ç‚¹çš„æ•°é‡å¯ä»¥æ˜¯å…¬ç”¨è¾¹æ•°é‡çš„ä¸¤å€ï¼Œè¿™æ ·éœ€è¦åœ¨Geometry Shaderä¸­æŠŠé¡¶ç‚¹æ•°ç›®ä»2æ‰©å……åˆ°6ï¼Œæˆ–è€…æ˜¯åœ¨ç»˜åˆ¶æ—¶å°†é¡¶ç‚¹æ•°é‡è®¾ç½®æˆå…±ç”¨è¾¹æ•°é‡çš„å…­å€ï¼Œå¯èƒ½åè€…æ•ˆç‡ä¼šé«˜ä¸€ç‚¹ï¼Œä¸è¿‡æ€è€ƒçš„æ—¶å€™ä¼šæœ‰ç‚¹ä¹±ï¼Œè¿™é‡Œå°±ä½¿ç”¨Geometry Shaderçš„æ–¹æ³•äº†ã€‚</p><p>å¦‚æœæ˜¯åƒä¹‹å‰çš„åšå®¢ä»‹ç»çš„ï¼Œä»¥å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹ä¸ºä¸­å¿ƒï¼ŒåŒæ—¶å‘å·¦å³ä¸¤ä¾§å¤–æ‰©çš„è¯ï¼Œä¼šå› ä¸ºæ·±åº¦æµ‹è¯•çš„åŸå› ï¼Œå¯¼è‡´æè¾¹éƒ¨åˆ†è¢«æ¨¡å‹é®æŒ¡ï¼Œè¿™ä¸ªé—®é¢˜æ¯”è¾ƒä¸¥é‡ï¼Œä»–ç›´æ¥å¯¼è‡´äº†å¤–æè¾¹å’Œå†…æè¾¹çš„ç²—ç»†ä¸ä¸€æ ·ï¼Œä¹Ÿå¯¼è‡´äº†åœ¨ä¸€æ¡æè¾¹ä¸­ä¼šéœ²å‡ºä¸€éƒ¨åˆ†æ¨¡å‹çš„é—®é¢˜ã€‚è¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ä»…å‘å¤–ä¾§æè¾¹ï¼Œåœ¨è®¡ç®—æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„æ—¶å€™åŒæ—¶è®¡ç®—éœ€è¦æè¾¹çš„æ–¹å‘ï¼Œä½¿ç”¨è¿™ä¸ªæ–¹å‘å‘å¤–æ‰©å±•æè¾¹ï¼Œæœ€åæ•ˆæœè¿˜è›®ä¸é”™çš„ã€‚</p><p>è¦å®ç°é£æ ¼åŒ–æè¾¹çš„è¯ï¼Œé™¤äº†ä½¿ç”¨é¡¶ç‚¹è‰²æ¥æ§åˆ¶æè¾¹çš„ç²—ç»†ä¹‹å¤–ï¼Œè¿˜èƒ½ä½¿ç”¨ä¸€å¼ è´´å›¾ä½œä¸ºæè¾¹çš„ç¬”åˆ·ï¼Œåœ¨ç»˜åˆ¶æè¾¹çš„æ—¶å€™é‡‡æ ·è¿™å¼ è´´å›¾ï¼Œæœ¬ç¯‡åšå®¢å°±æš‚ä¸ä½¿ç”¨è¿™ç§æ–¹æ³•äº†ã€‚</p><h2 id=å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ>å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æè¾¹çš„æ“ä½œ>#</a></h2><ol><li>å¯¹å½“å‰æ¨¡å‹è·å–åˆ°æ‰€æœ‰çš„å…±ç”¨è¾¹å¯¹åº”çš„å››ä¸ªé¡¶ç‚¹åºå·ï¼Œä¸¥æ ¼ä¿æŒé¡ºåºï¼</li><li>æ¯ä¸€å¸§ä½¿ç”¨<code>SkinnedMeshRenderer.BakeMesh</code>ï¼Œè·å–æ‰€æœ‰é¡¶ç‚¹å½“å‰çš„ç‰©ä½“ç©ºé—´çš„åæ ‡ã€‚</li><li>ä¼ å…¥é¡¶ç‚¹åæ ‡ï¼Œé¡¶ç‚¹é‡æ˜ å°„æ•°ç»„ï¼Œå…±ç”¨è¾¹ä¿¡æ¯ï¼Œå¦‚æœéœ€è¦çš„è¯è¿˜è¦ä¼ é¡¶ç‚¹è‰²åˆ°æè¾¹çš„Shaderä¸­ã€‚</li><li>ä½¿ç”¨<code>DrawProcedural</code>ç»˜åˆ¶æè¾¹ï¼Œé¡¶ç‚¹æ•°é‡ä¸ºå…±ç”¨è¾¹çš„æ•°é‡çš„ä¸¤å€ã€‚</li><li>åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´ï¼ˆå®é™…ä¸Šç”¨çš„æ˜¯å±å¹•ç©ºé—´ï¼‰çš„åæ ‡ï¼Œåˆ¤æ–­è¿™æ¡è¾¹æ˜¯ä¸æ˜¯è½®å»“è¾¹ï¼ŒåŒæ—¶è®°å½•æè¾¹å¤–æ‰©çš„æ–¹å‘ï¼Œç›¸å½“äºå¯¹äºæ¯ä¸€æ¡è¾¹ï¼ˆæ¯ä¸¤ä¸ªç‚¹ï¼‰å­˜ä¸¤ä¸ªboolå˜é‡ã€‚</li><li>åœ¨å‡ ä½•ä½“ç€è‰²å™¨ä¸­ï¼Œè®¡ç®—å…±ç”¨è¾¹ä¸¤ä¸ªé¡¶ç‚¹çš„å±å¹•ç©ºé—´çš„åæ ‡ï¼Œè®¡ç®—å‡ºä¸¤ä¸ªç‚¹ä¹‹é—´çš„å‘é‡ï¼Œè®¡ç®—ä¸ä¹‹ç›¸å‚ç›´çš„å¤–æ‰©çš„æ–¹å‘ï¼Œæ ¹æ®ä¸¤ä¸ªå‘é‡ï¼Œè®¡ç®—å‡ºæè¾¹çš„å››ä¸ªé¡¶ç‚¹çš„è£å‰ªç©ºé—´çš„åæ ‡ï¼Œå¹¶èµ‹äºˆuvçš„å€¼ã€‚</li><li>åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­ï¼Œæ ¹æ®uvè®¡ç®—å‡ºæè¾¹çš„é¢œè‰²ï¼Œå¯ä»¥é‡‡æ ·è´´å›¾ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è¿”å›è®¡ç®—çš„é¢œè‰²ã€‚</li></ol><p>ç”±äºæ•´ä¸ªæè¾¹çš„æ“ä½œè¾ƒä¸ºå¤æ‚ï¼Œæˆ‘å°½å¯èƒ½å¤šçš„å†™äº†æ³¨é‡Šã€‚</p><h3 id=outlineobjectcs>OutlineObject.cs<a hidden class=anchor aria-hidden=true href=#outlineobjectcs>#</a></h3><p>å®šä¹‰å…±ç”¨è¾¹çš„ç»“æ„ä½“ï¼Œä¹Ÿå®šä¹‰ç”¨äºä¿å­˜å…±ç”¨è¾¹æ•°æ®çš„<code>ScriptableObject</code>ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> UnityEngine;

<span style=color:#66d9ef>namespace</span> ZZNEWCLEAR13.Outline
{
<span style=color:#a6e22e>    [System.Serializable]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OutlineObject</span> : ScriptableObject
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MeshOutlineInfo</span>
        {
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> meshName;

            <span style=color:#75715e>//å°½é‡ä¸è¦éƒ½æ˜¾ç¤ºå‡ºæ¥ï¼Œä¸ç„¶å¾ˆå¡ã€‚ã€‚
</span><span style=color:#75715e></span>            <span style=color:#75715e>//é¡¶ç‚¹ã€æ³•çº¿ã€åˆ‡çº¿å’Œé¡¶ç‚¹è‰²
</span><span style=color:#75715e></span><span style=color:#a6e22e>            [HideInInspector]</span>
            <span style=color:#66d9ef>public</span> Vector3[] vertices;
<span style=color:#a6e22e>            [HideInInspector]</span>
            <span style=color:#66d9ef>public</span> Vector3[] normals;
<span style=color:#a6e22e>            [HideInInspector]</span>
            <span style=color:#66d9ef>public</span> Vector4[] tangents;
<span style=color:#a6e22e>            [HideInInspector]</span>
            <span style=color:#66d9ef>public</span> Color[] colors;

            <span style=color:#75715e>//vertRemappingæŠŠç›¸åŒä½ç½®çš„é¡¶ç‚¹ç¼–å·æ˜ å°„åˆ°ç¬¬ä¸€ä¸ªè¯¥ä½ç½®é¡¶ç‚¹çš„ç¼–å·
</span><span style=color:#75715e></span><span style=color:#a6e22e>            [HideInInspector]</span>
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span>[] vertRemapping;
            <span style=color:#75715e>//ä¸‰è§’å½¢å¯¹åº”çš„é¡¶ç‚¹ç¼–å·
</span><span style=color:#75715e></span><span style=color:#a6e22e>            [HideInInspector]</span>
            <span style=color:#66d9ef>public</span> Vector3Int[] triangles;

            <span style=color:#66d9ef>public</span> Line[] commonLines;
        }

        <span style=color:#66d9ef>public</span> MeshOutlineInfo outlineInfo;
    }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [System.Serializable]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Line</span>
    {
        <span style=color:#75715e>//Line
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v0;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v1;

        <span style=color:#75715e>//Triangle One: v0, v1, v2
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> t0;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v2;

        <span style=color:#75715e>//Triangle Two: v0, v3, v1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> t1;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> v3;

        <span style=color:#66d9ef>public</span> Line(<span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>v0, <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>v1)
        {
            v0 = <span style=color:#ae81ff>_</span>v0;
            v1 = <span style=color:#ae81ff>_</span>v1;

            t0 = -<span style=color:#ae81ff>1</span>;
            t1 = -<span style=color:#ae81ff>1</span>;
            v2 = -<span style=color:#ae81ff>1</span>;
            v3 = -<span style=color:#ae81ff>1</span>;
        }

        <span style=color:#75715e>//é‡è½½äº†Equalsæ–¹æ³•
</span><span style=color:#75715e></span>        <span style=color:#75715e>//ä¸¤ä¸ªä¸‰è§’å½¢ä½¿ç”¨åŒä¸€æ¡è¾¹æ—¶ï¼Œè¾¹çš„èŠ‚ç‚¹çš„é¡ºåºæ˜¯ç›¸åçš„
</span><span style=color:#75715e></span>        <span style=color:#75715e>//GetHashCode()ä¸ä¼šå†™ï¼Œä¹Ÿæ²¡å¿…è¦å†™ :)
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> Equals(<span style=color:#66d9ef>object</span> obj)
        {
            <span style=color:#66d9ef>if</span> (!(obj <span style=color:#66d9ef>is</span> Line line))
            {
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
            }
            <span style=color:#66d9ef>return</span> v0 == line.v1 &amp;&amp; v1 == line.v0;
        }
    }
}
</code></pre></div><h3 id=modelpreprocesscs>ModelPreProcess.cs<a hidden class=anchor aria-hidden=true href=#modelpreprocesscs>#</a></h3><p>ç”¨äºæ¨¡å‹é¢„å¤„ç†ï¼Œç”Ÿæˆå¹¶ä¿å­˜æ¨¡å‹çš„å…±ç”¨è¾¹çš„ä¿¡æ¯ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> UnityEditor;

<span style=color:#66d9ef>namespace</span> ZZNEWCLEAR13.Outline
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ModelPreProcess</span> : EditorWindow
    {
        <span style=color:#75715e>//å½“ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´è·ç¦»å°äºEPSILONæ—¶ï¼Œè®¤ä¸ºæ˜¯åŒä¸€ä¸ªé¡¶ç‚¹
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> EPSILON = <span style=color:#ae81ff>0.00001f</span>;

        <span style=color:#66d9ef>public</span> GameObject fbxObj;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> saveName = <span style=color:#e6db74>&#34;OutlineInfo&#34;</span>;

        <span style=color:#66d9ef>private</span> Rect topToolBarRect
        {
            <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>, position.width - <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>120</span>); }
        }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [MenuItem(&#34;zznewclear13/Model Pre-process&#34;)]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ModelPreProcess GetWindow()
        {
            ModelPreProcess window = GetWindow&lt;ModelPreProcess&gt;();
            window.titleContent = <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;Model Pre-process&#34;</span>);
            window.Focus();
            window.Repaint();
            <span style=color:#66d9ef>return</span> window;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
        {
            TopToolBar(topToolBarRect);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TopToolBar(Rect rect)
        {
            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
            {
                fbxObj = (GameObject)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;FBX Object&#34;</span>, fbxObj, <span style=color:#66d9ef>typeof</span>(GameObject), <span style=color:#66d9ef>false</span>);
                saveName = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Name&#34;</span>, saveName);

                <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!fbxObj))
                {
                    <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Process!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30f</span>) }))
                    {
                        ProcessAll();
                    }
                }
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ProcessAll()
        {
            MeshFilter[] meshFilters = fbxObj.GetComponentsInChildren&lt;MeshFilter&gt;();
            SkinnedMeshRenderer[] skinnedMeshRenderers = fbxObj.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();
            <span style=color:#66d9ef>int</span> meshFilterLength = meshFilters.Length;

            OutlineObject.MeshOutlineInfo[] mois = <span style=color:#66d9ef>new</span> OutlineObject.MeshOutlineInfo[meshFilterLength + skinnedMeshRenderers.Length];

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshFilters.Length; i++)
            {
                mois[i] = ProcessMesh(meshFilters[i].sharedMesh);
            }
            
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; skinnedMeshRenderers.Length; i++)
            {
                mois[i + meshFilterLength] = ProcessMesh(skinnedMeshRenderers[i].sharedMesh);
            }

            SaveAsset(mois);
        }

        <span style=color:#75715e>//æ‰¾å‡ºå…¶ä¸­çš„å…±åŒè¾¹ï¼Œå¹¶å‚¨å­˜ä¸‰è§’å½¢åºå·å’Œå¦å¤–ä¸¤ä¸ªé¡¶ç‚¹çš„åºå·
</span><span style=color:#75715e></span>        <span style=color:#75715e>//æ³¨æ„é¡¶ç‚¹çš„é¡ºåº
</span><span style=color:#75715e></span>        <span style=color:#75715e>//v0, v1, v2æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢
</span><span style=color:#75715e></span>        <span style=color:#75715e>//v0, v3, v1æ˜¯ä¸€ä¸ªæ­£é¢çš„ä¸‰è§’å½¢
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CheckLine(<span style=color:#66d9ef>int</span> triangleIndex, <span style=color:#66d9ef>int</span> vertexIndex, Line line, <span style=color:#66d9ef>ref</span> List&lt;Line&gt; lineList, <span style=color:#66d9ef>ref</span> List&lt;Line&gt; commonLines)
        {
            <span style=color:#66d9ef>bool</span> hasLine = <span style=color:#66d9ef>false</span>;
            <span style=color:#66d9ef>int</span> lineListIndex = -<span style=color:#ae81ff>1</span>;
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; lineList.Count; i++)
            {
                <span style=color:#66d9ef>if</span> (line.Equals(lineList[i]))
                {
                    hasLine = <span style=color:#66d9ef>true</span>;
                    lineListIndex = i;
                    <span style=color:#66d9ef>break</span>;
                }
            }

            <span style=color:#66d9ef>if</span> (hasLine)
            {
                Line tempLine = lineList[lineListIndex];
                lineList.RemoveAt(lineListIndex);
                tempLine.t1 = triangleIndex;
                tempLine.v3 = vertexIndex;
                commonLines.Add(tempLine);
            }
            <span style=color:#66d9ef>else</span>
            {
                line.t0 = triangleIndex;
                line.v2 = vertexIndex;
                lineList.Add(line);
            }
        }

        <span style=color:#75715e>//å½“ä¸¤ä¸ªé¡¶ç‚¹è·ç¦»å¾ˆè¿‘æ—¶ï¼Œè§†åšåŒä¸€ä¸ªé¡¶ç‚¹
</span><span style=color:#75715e></span>        <span style=color:#75715e>//ä½¿ç”¨vertRemappingå‚¨å­˜ç›¸åŒé¡¶ç‚¹çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹çš„åºå·
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] MergeIndexes(Vector3[] vertices)
        {
            <span style=color:#66d9ef>int</span>[] vertRemapping = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[vertices.Length];
            vertRemapping[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>0</span>;

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; vertices.Length; i++)
            {
                <span style=color:#66d9ef>bool</span> hasVert = <span style=color:#66d9ef>false</span>;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; i; j++)
                {
                    <span style=color:#66d9ef>if</span> (vertRemapping[j] &lt; j)
                    {
                        <span style=color:#66d9ef>continue</span>;
                    }
                    <span style=color:#66d9ef>else</span>
                    {
                        <span style=color:#66d9ef>if</span> ((vertices[i] - vertices[vertRemapping[j]]).magnitude &lt; EPSILON)
                        {
                            vertRemapping[i] = vertRemapping[j];
                            hasVert = <span style=color:#66d9ef>true</span>;
                        }
                    }
                }
                <span style=color:#66d9ef>if</span> (!hasVert)
                {
                    vertRemapping[i] = i;
                }
            }
            <span style=color:#66d9ef>return</span> vertRemapping;
        }

        <span style=color:#66d9ef>private</span> OutlineObject.MeshOutlineInfo ProcessMesh(Mesh sharedMesh)
        {
            OutlineObject.MeshOutlineInfo moi = <span style=color:#66d9ef>new</span> OutlineObject.MeshOutlineInfo();
            moi.meshName = sharedMesh.name;

            Vector3[] vertices = sharedMesh.vertices;
            Vector3[] normals = sharedMesh.normals;
            Vector4[] tangents = sharedMesh.tangents;
            Color[] colors = sharedMesh.colors;
            moi.vertices = vertices;
            moi.normals = normals;
            moi.tangents = tangents;
            moi.colors = colors;

            <span style=color:#66d9ef>int</span>[] vertRemapping = MergeIndexes(vertices);
            moi.vertRemapping = vertRemapping;

            <span style=color:#66d9ef>int</span>[] triangles = sharedMesh.triangles;

            List&lt;Line&gt; lineList = <span style=color:#66d9ef>new</span> List&lt;Line&gt;();
            List&lt;Line&gt; commonLines = <span style=color:#66d9ef>new</span> List&lt;Line&gt;();
  
            System.Diagnostics.Debug.Assert(triangles.Length % <span style=color:#ae81ff>3</span> == <span style=color:#ae81ff>0</span>);
            <span style=color:#66d9ef>int</span> triangleCount = triangles.Length / <span style=color:#ae81ff>3</span>;
            Vector3Int[] packedTriangles = <span style=color:#66d9ef>new</span> Vector3Int[triangleCount];

            <span style=color:#75715e>//éå†æ‰€æœ‰çš„ä¸‰è§’å½¢ï¼Œæ³¨æ„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹çš„é¡ºåº
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; triangleCount; i++)
            {
                <span style=color:#66d9ef>int</span> triangleIndex = <span style=color:#ae81ff>3</span> * i;
                <span style=color:#66d9ef>int</span> vID0 = vertRemapping[triangles[triangleIndex]];
                <span style=color:#66d9ef>int</span> vID1 = vertRemapping[triangles[triangleIndex + <span style=color:#ae81ff>1</span>]];
                <span style=color:#66d9ef>int</span> vID2 = vertRemapping[triangles[triangleIndex + <span style=color:#ae81ff>2</span>]];
                packedTriangles[i] = <span style=color:#66d9ef>new</span> Vector3Int(vID0, vID1, vID2);
                Line line0 = <span style=color:#66d9ef>new</span> Line(vID0, vID1);
                Line line1 = <span style=color:#66d9ef>new</span> Line(vID1, vID2);
                Line line2 = <span style=color:#66d9ef>new</span> Line(vID2, vID0);
                CheckLine(i, vID2, line0, <span style=color:#66d9ef>ref</span> lineList, <span style=color:#66d9ef>ref</span> commonLines);
                CheckLine(i, vID0, line1, <span style=color:#66d9ef>ref</span> lineList, <span style=color:#66d9ef>ref</span> commonLines);
                CheckLine(i, vID1, line2, <span style=color:#66d9ef>ref</span> lineList, <span style=color:#66d9ef>ref</span> commonLines);
            }

            moi.triangles = packedTriangles;
            moi.commonLines = commonLines.ToArray();

            <span style=color:#66d9ef>return</span> moi;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveAsset(OutlineObject.MeshOutlineInfo[] outlineInfos)
        {
            <span style=color:#66d9ef>string</span> path = AssetDatabase.GetAssetPath(fbxObj);
            <span style=color:#66d9ef>string</span> assetPath = path.Substring(<span style=color:#ae81ff>0</span>, path.LastIndexOf(<span style=color:#e6db74>&#39;/&#39;</span>)) + <span style=color:#e6db74>&#34;/&#34;</span> + saveName;

            <span style=color:#66d9ef>if</span> (!System.IO.Directory.Exists(assetPath))
            {
                System.IO.Directory.CreateDirectory(assetPath);
            }

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; outlineInfos.Length; i++)
            {
                OutlineObject asset = ScriptableObject.CreateInstance&lt;OutlineObject&gt;();
                asset.outlineInfo = outlineInfos[i];

                <span style=color:#66d9ef>string</span> tempPath = assetPath + <span style=color:#e6db74>&#34;/&#34;</span> + outlineInfos[i].meshName + <span style=color:#e6db74>&#34;.asset&#34;</span>;
                AssetDatabase.CreateAsset(asset, tempPath);
            }
            AssetDatabase.SaveAssets();
        }
    }
}
</code></pre></div><h3 id=drawoutlinecs>DrawOutline.cs<a hidden class=anchor aria-hidden=true href=#drawoutlinecs>#</a></h3><p>è¿™é‡Œä»¥<code>SkinnedMeshRenderer</code>ä¸ºä¾‹ï¼Œå› ä¸ºç›¸å¯¹äºæ™®é€šçš„<code>Mesh</code>æ¥è¯´è¾ƒä¸ºå¤æ‚ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨ä¿å­˜åœ¨å…±ç”¨è¾¹ä¿¡æ¯é‡Œçš„ç‰©ä½“ç©ºé—´çš„é¡¶ç‚¹åæ ‡ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;

<span style=color:#66d9ef>namespace</span> ZZNEWCLEAR13.Outline
{
    <span style=color:#75715e>//ä»…æ”¯æŒSkinnedMeshRenderer
</span><span style=color:#75715e></span>    <span style=color:#75715e>//æ™®é€šçš„Meshåªè¦ç¨æ”¹ä¸€ä¸‹ä»£ç å°±å¥½äº†
</span><span style=color:#75715e></span><span style=color:#a6e22e>    [ExecuteInEditMode]</span>
<span style=color:#a6e22e>    [RequireComponent(typeof(SkinnedMeshRenderer))]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DrawOutline</span> : MonoBehaviour
    {
        <span style=color:#66d9ef>public</span> Material outlineMaterial;
        <span style=color:#66d9ef>public</span> GameObject targetGO;
        <span style=color:#66d9ef>public</span> SkinnedMeshRenderer skinnedMeshRenderer;
        <span style=color:#66d9ef>public</span> OutlineObject outlineObject;

        <span style=color:#66d9ef>private</span> Mesh bakedMesh;

        <span style=color:#66d9ef>private</span> List&lt;Vector3&gt; meshVertices;
        <span style=color:#66d9ef>private</span> Vector3[] vertices;
        <span style=color:#66d9ef>private</span> Color[] colors;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] vertRemapping;
        <span style=color:#66d9ef>private</span> Line[] lines;

        <span style=color:#66d9ef>private</span> ComputeBuffer verticesBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer colorBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer vertRemappingBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer lineBuffer;

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
        {
            <span style=color:#66d9ef>if</span> (buffer != <span style=color:#66d9ef>null</span>)
            {
                buffer.Release();
            }
            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
        {
            meshVertices = <span style=color:#66d9ef>new</span> List&lt;Vector3&gt;();

            vertices = outlineObject.outlineInfo.vertices;
            colors = outlineObject.outlineInfo.colors;
            vertRemapping = outlineObject.outlineInfo.vertRemapping;
            lines = outlineObject.outlineInfo.commonLines;

            EnsureBuffer(<span style=color:#66d9ef>ref</span> verticesBuffer, vertices.Length, <span style=color:#ae81ff>3</span> * <span style=color:#ae81ff>4</span>);
            EnsureBuffer(<span style=color:#66d9ef>ref</span> colorBuffer, vertices.Length, <span style=color:#ae81ff>4</span> * <span style=color:#ae81ff>4</span>);
            EnsureBuffer(<span style=color:#66d9ef>ref</span> vertRemappingBuffer, vertRemapping.Length, <span style=color:#ae81ff>4</span>);
            EnsureBuffer(<span style=color:#66d9ef>ref</span> lineBuffer, lines.Length, <span style=color:#ae81ff>6</span> * <span style=color:#ae81ff>4</span>);

            bakedMesh = <span style=color:#66d9ef>new</span> Mesh();
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
        {
            DrawOutlineProcedural();
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DrawOutlineProcedural()
        {
            skinnedMeshRenderer.BakeMesh(bakedMesh);
            bakedMesh.GetVertices(meshVertices);

            verticesBuffer.SetData(meshVertices);
            colorBuffer.SetData(colors);
            vertRemappingBuffer.SetData(vertRemapping);
            lineBuffer.SetData(lines);

            MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
            mpb.SetBuffer(<span style=color:#e6db74>&#34;_VerticesBuffer&#34;</span>, verticesBuffer);
            mpb.SetBuffer(<span style=color:#e6db74>&#34;_ColorBuffer&#34;</span>, colorBuffer);
            mpb.SetBuffer(<span style=color:#e6db74>&#34;_VertRemappingBuffer&#34;</span>, vertRemappingBuffer);
            mpb.SetBuffer(<span style=color:#e6db74>&#34;_LineBuffer&#34;</span>, lineBuffer);
            <span style=color:#75715e>//ä¸€èˆ¬éœ€è¦ä¼ å…¥SkinnedMeshRendererçš„çˆ¶ç‰©ä½“çš„ç‰©ä½“ç©ºé—´åˆ°ä¸–ç•Œç©ºé—´çš„å˜æ¢çŸ©é˜µ
</span><span style=color:#75715e></span>            mpb.SetMatrix(<span style=color:#e6db74>&#34;_ObjToWorldMat&#34;</span>, targetGO.transform.localToWorldMatrix);

            Bounds bounds = skinnedMeshRenderer.bounds;
            Graphics.DrawProcedural(outlineMaterial, bounds, MeshTopology.Lines, lines.Length * <span style=color:#ae81ff>2</span>, properties: mpb);
        }
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
        {
            verticesBuffer.Dispose();
            vertRemappingBuffer.Dispose();
            lineBuffer.Dispose();
        }
    }
}
</code></pre></div><h3 id=outlineshadershader>OutlineShader.shader<a hidden class=anchor aria-hidden=true href=#outlineshadershader>#</a></h3><p>æ„Ÿè§‰å·²ç»äº‹æ— å·¨ç»†çš„å†™åœ¨æ³¨é‡Šé‡Œäº†ï¼Œæœ€å…³é”®çš„å°±æ˜¯æ—¶åˆ»æé†’è‡ªå·±ç»˜åˆ¶ä¸‰è§’å½¢æ—¶çš„é¡¶ç‚¹é¡ºåºã€‚æ„Ÿè§‰æˆ‘å¯¹ä½¿ç”¨æ•°ç»„æ¥è®¾è®¡å¹¶è¡Œè¿ç®—å·²ç»ç‚‰ç«çº¯é’äº†ã€‚ä½¿ç”¨çº¿æ€§ä»£æ•°æ¥åˆ¤æ–­ä¸‰è§’å½¢çš„å…¶ä½™ä¸¤ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨å…±ç”¨è¾¹çš„ä¸¤ä¾§ï¼Œæˆ‘æ„Ÿè§‰æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„åŠæ³•ï¼ˆä¼¼ä¹æ¯”ç›´æ¥è®¡ç®—æ³•çº¿è¦ç¨å¥½ä¸€ç‚¹ï¼Ÿï¼‰ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯å‘ç°æ•ˆæœåŸºæœ¬æ­£ç¡®ä¹‹åå°±ä¸ä¼šå†å›è¿‡å¤´å»éªŒè¯è‡ªå·±çš„ä»£ç äº†å“ˆå“ˆã€‚</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/OutlineShader&quot;
{
    Properties
    {
        _OutlineColor (&quot;Outline Color&quot;, color) = (1.0, 1.0, 1.0, 1.0)
        _OutlineExt (&quot;Outline Extension&quot;, range(-1, 1)) = 0.1
        _OutlineWidth(&quot;Outline Width&quot;, float) = 1.0
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    
    float4x4 _ObjToWorldMat;
    float4 _OutlineColor;
    float _OutlineExt;
    float _OutlineWidth;

    StructuredBuffer&lt;float3&gt; _VerticesBuffer;
    StructuredBuffer&lt;int&gt; _VertRemappingBuffer;

    //å®é™…å¯ä»¥ç®€åŒ–æˆä¸€ä¸ªint4ï¼Œåªå‚¨å­˜é¡¶ç‚¹åºå·
    struct LineStruct
    {
        int2 lineVertices; // v0, v1
        int4 trianglesAndVertices; // t0, v2, t1, v3
    };
    StructuredBuffer&lt;LineStruct&gt; _LineBuffer;

    struct Attributes
    {
        uint vertexID    : SV_VERTEXID;
    };

    struct Geoms
    {
        float4 positionCS   : TEXCOORD0;
        bool2 edgeAndSide   : TEXCOORD1;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
    };

    Geoms OutlineVert(Attributes input)
    {
        Geoms output = (Geoms)0;
        //è·å–é¡¶ç‚¹åºå·å’Œè¾¹çš„åºå·
        int vertexID = input.vertexID % 2;
        int lineID = input.vertexID / 2;

        //è·å–è¾¹ä¸Šè¾ƒè¿‘çš„é¡¶ç‚¹å’Œè¾ƒè¿œçš„é¡¶ç‚¹çš„ç‰©ä½“ç©ºé—´åæ ‡
        float3 vertexOne = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[vertexID]]];        
        float3 vertexTwo = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].lineVertices[1 - vertexID]]];

        //è·å–ç¬¬ä¸€ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹å’Œç¬¬äºŒä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹
        float3 vertexThree = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[vertexID * 2 + 1]]];
        float3 vertexFour = _VerticesBuffer[_VertRemappingBuffer[_LineBuffer[lineID].trianglesAndVertices[3 - vertexID * 2]]];

        //è½¬æ¢åˆ°è£å‰ªç©ºé—´
        float4x4 mvp = mul(UNITY_MATRIX_VP, _ObjToWorldMat);
        float4 positionCSOne = mul(mvp, float4(vertexOne, 1.0));
        float4 positionCSTwo = mul(mvp, float4(vertexTwo, 1.0));
        float4 positionCSThree = mul(mvp, float4(vertexThree, 1.0));
        float4 positionCSFour = mul(mvp, float4(vertexFour, 1.0));

        //è·å–å±å¹•ç©ºé—´çš„åæ ‡
        float2 uvOne = positionCSOne.xy / positionCSOne.w;
        float2 uvTwo = positionCSTwo.xy / positionCSTwo.w;
        float2 uvThree = positionCSThree.xy / positionCSThree.w;
        float2 uvFour = positionCSFour.xy / positionCSFour.w;

        //è¿™é‡Œç®€åŒ–äº†æ±‚æ³•çº¿çš„è¿‡ç¨‹ï¼Œç›¸å½“äºåˆ¤æ–­ä¸¤ä¸ªä¸‰è§’é¢çš„æœ€åä¸€ä¸ªé¡¶ç‚¹æ˜¯ä¸æ˜¯åœ¨è¾¹çš„ä¸¤ä¾§
        float valueA = uvOne.y - uvTwo.y;
        float valueB = uvOne.x * uvTwo.y - uvTwo.x * uvOne.y;
        float valueC = uvOne.x - uvTwo.x;

        float signThree = valueA * uvThree.x + valueB - valueC * uvThree.y;
        float signFour =  valueA * uvFour.x + valueB - valueC * uvFour.y;

        //Xï¼šè¯¥é¡¶ç‚¹æ˜¯ä¸æ˜¯è½®å»“è¾¹çš„é¡¶ç‚¹ï¼›Yï¼šè¯¥é¡¶ç‚¹åº”è¯¥å‘è¾¹çš„é¡ºæ—¶é’ˆæ–¹å‘è¿˜æ˜¯é€†æ—¶é’ˆæ–¹å‘å¤–æ‰©
        output.edgeAndSide = bool2((signThree * signFour &gt;= 0), (signThree &gt;= 0));
        output.positionCS = positionCSOne;
        return output;
    }

    [maxvertexcount(6)]
	void OutlineGeomTriangle(line Geoms input[2], inout TriangleStream&lt;Varyings&gt; triangleStream)
    {
        Varyings output = (Varyings)0;
        //åˆ¤æ–­æ˜¯ä¸æ˜¯è¾¹ç•Œè¾¹ï¼Œå…¶å®åªéœ€è¦åˆ¤æ–­ä¸€ä¸ªé¡¶ç‚¹å°±å¯ä»¥äº†
        if(input[0].edgeAndSide.x &amp;&amp; input[1].edgeAndSide.x)
        {
            //å¯ä»¥é€šè¿‡é¡¶ç‚¹è‰²æ¥è°ƒæ•´æè¾¹å®½åº¦
            float outlineWidthOne = _OutlineWidth;// * input[0].color.a;
            float outlineWidthTwo = _OutlineWidth;// * input[1].color.a;

            float4 positionCSOne = input[0].positionCS;
            float4 positionCSTwo = input[1].positionCS;

            //è·å–å±å¹•ç©ºé—´çš„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„å‘é‡
            float2 offset = positionCSOne.xy / positionCSOne.w - positionCSTwo.xy / positionCSTwo.w;
            float lengthOffset = length(offset);
            float2 normalizedOffset = normalize(offset * (_ScreenParams.wz - 1.0));
            
            //Xï¼šä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹çš„å‘é‡
            //Yï¼šä¸ä¹‹å‚ç›´çš„å¦ä¸€ä¸ªå‘é‡
            //ä½¿ç”¨min(1.0, rcp(positionCSOne.w)æ¥ä½¿æè¾¹æŒ‰ç…§è·ç¦»å˜ç»†ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨å¹³æ–¹æ ¹å€’æ•°æ¥æ§åˆ¶
            float2 pointOffsetX = float2(normalizedOffset.x, normalizedOffset.y) * min(1.0, rcp(positionCSOne.w));
            float2 pointOffsetY = float2(-normalizedOffset.y, normalizedOffset.x) * min(1.0, rcp(positionCSOne.w));

            //ç¬¬ä¸€ç¬¬äºŒä¸ªé¡¶ç‚¹ä¸ç”¨å¤–æ‰©
            //ç¬¬ä¸‰ç¬¬å››ä¸ªé¡¶ç‚¹æŒ‰ç…§edgeAndSideæ¥åˆ¤æ–­å¤–æ‰©çš„æ–¹å‘
            //åŒæ—¶ä½¿ç”¨_OutlineExtæ¥æ§åˆ¶å¤–æ‰©å‡ºçš„æ¢¯å½¢çš„å½¢çŠ¶
            float4 csOne = positionCSOne;
            float4 csTwo = positionCSTwo;
            float4 csThree = float4(-positionCSTwo.w * (pointOffsetX * (1.0 + _OutlineExt) + pointOffsetY * (2 * input[1].edgeAndSide.y - 1)) * (_ScreenParams.zw - 1.0) * outlineWidthTwo, 0, 0) + positionCSTwo;
            float4 csFour = float4(-positionCSOne.w * (-pointOffsetX * (1.0 + _OutlineExt) - pointOffsetY * (2 * input[0].edgeAndSide.y - 1)) * (_ScreenParams.zw - 1.0) * outlineWidthOne, 0, 0) + positionCSOne;

            //å››ä¸ªé¡¶ç‚¹çš„UV
            float2 uvOne = float2(0.0, 0.0);
            float2 uvTwo = float2(1.0, 0.0);
            float2 uvThree = float2(1.0, 1.0);
            float2 uvFour = float2(0.0, 1.0);

            //ç»˜åˆ¶å¤–æ‰©æ¢¯å½¢çš„å…¶ä¸­ä¸‰ä¸ªé¡¶ç‚¹
            output.positionCS = csOne;
            output.uv = uvOne;
            triangleStream.Append(output);

            output.positionCS = csTwo;
            output.uv = uvTwo;
            triangleStream.Append(output);

            output.positionCS = csThree;
            output.uv = uvThree;
            triangleStream.Append(output);

            //å‡ºäºæˆ‘ä¸èƒ½è§£é‡Šçš„åŸå› ï¼Œè¿™é‡Œçš„é¡¶ç‚¹é¡ºåºå’Œå‰é¢æ˜¯ç›¸åçš„
            output.positionCS = csOne;
            output.uv = uvOne;
            triangleStream.Append(output);
        
            output.positionCS = csFour;
            output.uv = uvFour;
            triangleStream.Append(output);
        
            output.positionCS = csThree;
            output.uv = uvThree;
            triangleStream.Append(output);  
        }
        triangleStream.RestartStrip();
    }

    float4 OutlineFrag(Varyings input) : SV_TARGET
    {
        float2 uv = input.uv;
        //ä½¿ç”¨fwidthè¿›è¡ŒæŠ—é”¯é½¿
        return float4(_OutlineColor.rgb, smoothstep(1.0, 1.0 - fwidth(uv.y), input.uv.y));
    }

    ENDHLSL

    SubShader
    {
        Tags {&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot; }
        ZWrite Off
        Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM
            #pragma target 5.0

            #pragma vertex OutlineVert
            #pragma geometry OutlineGeomTriangle
            #pragma fragment OutlineFrag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#æœ€åçš„æ€è€ƒ>#</a></h2><p>æœ¬åšå®¢çš„æ¨¡å‹æ˜¯ç½‘ä¸Šä¸‹è½½çš„ï¼Œæˆ‘ä¹Ÿæ²¡æœ‰çœ‹è¿‡ä¹å›­è¿½æ”¾ï¼Œå¥½åƒè¡£æœéƒ¨åˆ†çš„uvå‡ºäº†ç‚¹é—®é¢˜ï¼Œä¸è¿‡è·Ÿæè¾¹çš„æ•ˆæœæ²¡æœ‰å…³ç³»ï¼Œå°±è¿™æ ·äº†ã€‚</p><p>åœ¨æ¨¡å‹å¯¼å…¥çš„æ—¶å€™æœ€å¥½èƒ½é€‰æ‹©ä¸­ç­‰è´¨é‡ï¼Œè¿™æ ·æ¨¡å‹çš„é¢æ•°ä¼šå°‘ä¸€äº›ï¼Œä¹Ÿä¸ä¼šå‡ºç°å› ä¸ºç¾æœ¯å¤±è¯¯å¯¼è‡´å¥‡æ€ªçš„åœ°æ–¹äº§ç”Ÿæè¾¹çš„é—®é¢˜ã€‚æœ€ç»ˆæè¾¹æ•ˆæœç¡®å®è¿˜è›®ä¸é”™çš„ï¼Œç¡®å®éƒ½æ˜¯ä¸€æ ·çš„å®½ï¼Œä½¿ç”¨<code>fwidth</code>çš„æŠ—é”¯é½¿æ•ˆæœä¹Ÿè›®ä¸é”™çš„ï¼Œå°±æ˜¯å¹¶æ²¡æœ‰æŠŠå¤–æè¾¹å’Œå†…æè¾¹åˆ†å¼€æ¥åšï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆåšäº†ï¼‰ï¼Œæ ¹æ®å…±ç”¨è¾¹ä¸¤ä¸ªä¸‰è§’é¢æ³•çº¿çš„å¤¹è§’è¿˜èƒ½ç»˜åˆ¶é¢å¤–çš„æè¾¹ï¼Œè¿™é‡Œå°±ä¸é¢å¤–åšäº†ï¼ˆä¸è¿‡åº”è¯¥ä¸å¤ªå¥½åšï¼Œæ·±åº¦æµ‹è¯•çš„é—®é¢˜æ¯”è¾ƒå¤§ï¼‰ï¼Œä¸¤ç§æè´¨ä¹‹é—´çš„æè¾¹ä¹Ÿæ²¡åšï¼ˆå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼‰ã€‚ä½†æ•´ä½“çœ‹ä¸Šå»è¿˜æ˜¯æŒºå¯ä»¥çš„äº†ï¼Œå˜¿å˜¿ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/outline/>Outline</a></li><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/draw-equal-width-bezier-curve-in-unity/><span class=title>Â« Prev</span><br><span>åœ¨Unityçš„UIä¸­ç»˜åˆ¶ç­‰å®½çš„è´èµ›å°”æ›²çº¿</span></a>
<a class=next href=https://zznewclear13.github.io/posts/draw-equal-width-line-in-unity/><span class=title>Next Â»</span><br><span>åœ¨Unityä¸­ç»˜åˆ¶ç­‰å®½çº¿æ¡</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>