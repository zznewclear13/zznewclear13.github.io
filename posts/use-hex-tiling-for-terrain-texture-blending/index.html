<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在地形贴图混合时使用六边形平铺 | ZZNEWCLEAR13</title>
<meta name=keywords content="Terrain,Hex Tiling"><meta name=description content="混合多张贴图的同时减少平铺的重复感."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="在地形贴图混合时使用六边形平铺"><meta property="og:description" content="混合多张贴图的同时减少平铺的重复感."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/"><meta property="og:image" content="https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/posts/images/HexTiling.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-19T12:00:00+08:00"><meta property="article:modified_time" content="2024-03-19T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/posts/images/HexTiling.png"><meta name=twitter:title content="在地形贴图混合时使用六边形平铺"><meta name=twitter:description content="混合多张贴图的同时减少平铺的重复感."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在地形贴图混合时使用六边形平铺","item":"https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在地形贴图混合时使用六边形平铺","name":"在地形贴图混合时使用六边形平铺","description":"混合多张贴图的同时减少平铺的重复感.","keywords":["Terrain","Hex Tiling"],"articleBody":"动机 最近看到了三角洲行动介绍的在虚幻引擎4中实现的地形渲染方案，感觉受益匪浅。不过在Unity中要想实现一个即插即用的虚拟贴图的技术应该有些困难，于是我把目光放在了最一开始所介绍的对地形贴图做混合的方案上。\n三角洲行动提出的方案是这样的，在地形计算的时候，从对材质ID图的四个像素采样退化成对三个像素采样，这样一来既能减少地形混合的时候的采样次数，二来相较于采样四个像素，三个像素多了一个斜向45度的效果，能够减轻一些地形的块面感。不过他们也有语焉不详的地方，虽然只采样三个像素能够提供斜向45度，但是对于斜向-45度，仅使用同一种方式采样三个像素是不能消除这个方向的块面感的，当然想必他们也有对应的解决方案就是了。此外他们声称材质ID图是一张R8的贴图，但这张贴图里面怎么会有5bit的下层ID，5bit的上层ID，再有3bit的权重值呢？我只能认为这张材质ID图实际上只包含了一个5bit的材质ID和3bit的权重了，这个3bit的权重值会在和另外几个像素混合时使用到。\n不过三次采样倒是让我想起了Hex Tiling。在Practical Real-Time Hex-Tiling里介绍了一种通过六边形平铺来降低平铺时纹理重复感的算法，这种算法正巧需要对主贴图采样三次（不考虑随机采样的话）。Github中也能找到参考的代码。\n这样一来我们就能在三角洲行动的方案上再提出一种新的地形混合的方法了。我们同样是采样三个像素，不过我们在地形中会将这三个像素用等边三角形的方式排布，而不是目前所用的直角三角形。所以我们的流程是，先将当前的世界空间或者uv做一次三角形格点的变换，使用变换后的格点采样材质ID图获得三个材质ID和权重，再使用获得的数据和本身的六边形平铺的权重进行混合，就能得到我们最终的混合后的地形材质了。如果把我们的材质ID图平铺到世界空间，看上去应该是这样的：\n生成材质ID图 为了快速生成材质ID图（我可不想手画），我们考虑使用Compute Shader通过Perlin Noise生成材质ID，使用普通的hash生成权重。为了使我们的材质ID图也能正常的平铺，我们在计算Perlin Noise的时候，要注意使用取模的运算将计算的uv值限制在同一个范围内。\n我们只需要一个8bit的数据，但是由于Unity保存贴图的种种限制，我们可以将R8_Uint的数据除以255转换成R8_UNorm类型的数据再储存到贴图中。\nGenerateMatIDComputeShader.compute #pragma kernel MatIDGenMain RWTexture2D\u003cfloat\u003e _RW_MatIDTex; float4 _TextureSize; // https://www.shadertoy.com/view/4djSRW float hash12(float2 p) { float3 p3 = frac(float3(p.xyx) * .1031); p3 += dot(p3, p3.yzx + 33.33); return frac((p3.x + p3.y) * p3.z); } float2 repeat(float2 coord, float2 size, float2 offset) { return coord - floor(coord / size) * size + offset; } float encode(int weight, int index) { int encoded = (weight \u003c\u003c 5) | index; return float(encoded) / 255.0f; } float noise(float2 p ) { float2 i = floor( p ); float2 f = frac( p );\tfloat2 u = f*f*f*(f*(f*6.0-15.0)+10.0); float2 ts = _TextureSize.xy / 32.0f; float2 offset = 50.0f; float rv = lerp( lerp( hash12( repeat(i + float2(0.0,0.0), ts, offset) ), hash12( repeat(i + float2(1.0,0.0), ts, offset) ), u.x), lerp( hash12( repeat(i + float2(0.0,1.0), ts, offset) ), hash12( repeat(i + float2(1.0,1.0), ts, offset)), u.x), u.y); return rv * 2.0f - 1.0f; } [numthreads(8,8,1)] void MatIDGenMain (uint3 id : SV_DispatchThreadID) { float hashVal1 = hash12(float2(id.xy) + 12.3f); int weight = int(floor(hashVal1 * 8.0f)); float rv = 0.0f; float2 uv = float2(id.xy) / 32.0f + 50.0f; rv = 0.5000*noise( uv ); uv *=2.0f; rv += 0.2500*noise( uv ); uv *=2.0f; rv += 0.1250*noise( uv ); uv *=2.0f; rv += 0.0625*noise( uv ); rv = rv * 0.5f + 0.5f; int index = int(rv * 32.0f); float returnVal = encode(weight, index); _RW_MatIDTex[id.xy] = returnVal; } MatIDGenerator.cs using UnityEngine; using UnityEditor; using System.IO; public class MatIDGenerator : EditorWindow { private TextureSize textureSize = TextureSize._256x256; private ComputeShader computeShader; private string savePath = \"Assets/HexTiling/MatID\"; private static readonly string suffix = \".tga\"; private RenderTexture rt; private enum TextureSize { _256x256 = 256, _512x512 = 512, _1024x1024 = 1024, } Rect rect { get { return new Rect(20.0f, 20.0f, position.width - 40.0f, position.height - 10.0f); } } private void EnsureRT() { if (rt == null || rt.width != (int)textureSize || rt.height != (int)textureSize) { if (rt != null) rt.Release(); RenderTextureDescriptor desc = new RenderTextureDescriptor { width = (int)textureSize, height = (int)textureSize, volumeDepth = 1, dimension = UnityEngine.Rendering.TextureDimension.Tex2D, depthBufferBits = 0, msaaSamples = 1, graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm, enableRandomWrite = true }; rt = new RenderTexture(desc); if (!rt.IsCreated()) rt.Create(); } } [MenuItem(\"zznewclear13/Mat ID Generator\")] public static void Init() { MatIDGenerator window = GetWindow(\"Mat ID Generator\"); window.Show(); window.Repaint(); window.Focus(); } private void OnGUI() { using (new GUILayout.AreaScope(rect)) { computeShader = (ComputeShader)EditorGUILayout.ObjectField(\"Compute Shader\", computeShader, typeof(ComputeShader), false); textureSize = (TextureSize)EditorGUILayout.EnumPopup(\"Output Texture Size\", textureSize); savePath = EditorGUILayout.TextField(\"Save Path\", savePath); using (new EditorGUI.DisabledGroupScope(!computeShader)) { if (GUILayout.Button(\"Generate!\", new GUILayoutOption[] { GUILayout.Height(30.0f) })) { GenerateMatID(); } } } } private void GenerateMatID() { EnsureRT(); float ts = (float)textureSize; int kernelID = computeShader.FindKernel(\"MatIDGenMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); Vector2Int dispatchCount = new Vector2Int(Mathf.CeilToInt(ts / x), Mathf.CeilToInt(ts / y)); computeShader.SetTexture(kernelID, \"_RW_MatIDTex\", rt); computeShader.SetVector(\"_TextureSize\", new Vector4(ts, ts, 1.0f / ts, 1.0f / ts)); computeShader.Dispatch(kernelID, dispatchCount.x, dispatchCount.y, 1); SaveRenderTextureToFile(rt); } private void SaveRenderTextureToFile(RenderTexture rt) { RenderTexture prev = RenderTexture.active; RenderTexture.active = rt; int ts = (int)textureSize; Texture2D toSave = new Texture2D(ts, ts, TextureFormat.R8, false, true); toSave.ReadPixels(new Rect(0.0f, 0.0f, ts, ts), 0, 0); byte[] bytes = toSave.EncodeToTGA(); FileStream fs = File.OpenWrite(savePath + suffix); fs.Write(bytes); fs.Close(); AssetDatabase.Refresh(); TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix); ti.mipmapEnabled = false; ti.sRGBTexture = false; ti.textureCompression = TextureImporterCompression.Uncompressed; ti.SaveAndReimport(); Texture2D tempTexture = AssetDatabase.LoadAssetAtPath(savePath + suffix); EditorGUIUtility.PingObject(tempTexture); RenderTexture.active = prev; } private void OnDestroy() { if (rt != null) rt.Release(); } } 对地形贴图做混合 为了简便，我们只对地形的Base Color进行混合，要想对法线或者是三平面映射进行混合，Hex Tiling的代码案例里也提供了相应的函数。我额外的使用了一个_Shape参数，数值越小就越多地显示出六边形的特征，越大则越多地显示出权重混合的特征。权重混合应该还有更好的方式，比如当三角形的两个点材质ID一致的时候，将混合的效果从三个权重混合简化成两个权重混合，不过这个后续有时间再考虑吧。这个Shader也能支持32张地形贴图的混合，第142行改成index = (data \u0026 31);即可，不过我可没那么多张贴图，就限制到4张了。\nHexTilingShader.shader // MIT License // // Copyright (c) 2024 zznewclear@gmail.com // Copyright (c) 2022 mmikk // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE // SOFTWARE. Shader \"zznewclear13/HexTilingShader\" { Properties { _MatIDTex (\"Mat ID Texture\", 2D) = \"black\" {} _TerrainMainTex (\"Terrain Main Tex\", 2DArray) = \"\" {} _Rotation (\"Rotation\", Range(0, 1)) = 0.5 _Shape (\"Shape\", Range(0, 1)) = 0.5 _G_EXP (\"G Exp\", Range(1, 10)) = 3.0 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #define M_PI 3.1415926f static float g_fallOffContrast = 0.6; static float g_exp = 7; Texture2DArray _TerrainMainTex; Texture2D\u003cfloat\u003e _MatIDTex; CBUFFER_START(UnityPerMaterial) SamplerState sampler_MainTex; SamplerState sampler_TerrainMainTex; SamplerState sampler_PointRepeat; float4 _MatIDTex_TexelSize; float _Rotation; float _Shape; float _G_EXP; CBUFFER_END struct Attributes { float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float3 positionWS : TEXCOORD1; }; Varyings vert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); output.positionCS = vpi.positionCS; output.uv = input.texcoord; output.positionWS = vpi.positionWS; return output; } float2 hash22(float2 p) { float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx+33.33); return frac((p3.xx+p3.yz)*p3.zy); } void TriangleGrid(out float w1, out float w2, out float w3, out int2 vertex1, out int2 vertex2, out int2 vertex3, float2 st) { // Scaling of the input st *= 2 * sqrt(3); // Skew input space into simplex triangle grid const float2x2 gridToSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054); float2 skewedCoord = mul(gridToSkewedGrid, st); int2 baseId = int2( floor ( skewedCoord )); float3 temp = float3( frac( skewedCoord ), 0); temp.z = 1.0 - temp.x - temp.y; float s = step(0.0, -temp.z); float s2 = 2*s-1; w1 = -temp.z*s2; w2 = s - temp.y*s2; w3 = s - temp.x*s2; vertex1 = baseId + int2(s,s); vertex2 = baseId + int2(s,1-s); vertex3 = baseId + int2(1-s,s); } float2 MakeCenST(int2 Vertex) { float2x2 invSkewMat = float2x2(1.0, 0.5, 0.0, 1.0/1.15470054); return mul(invSkewMat, Vertex) / (2 * sqrt(3)); } float2x2 LoadRot2x2(int2 idx, float rotStrength) { float angle = abs(idx.x*idx.y) + abs(idx.x+idx.y) + M_PI; angle = fmod(angle, 2*M_PI); if(angle\u003c0) angle += 2*M_PI; if(angle\u003eM_PI) angle -= 2*M_PI; angle *= rotStrength; float cs = cos(angle), si = sin(angle); return float2x2(cs, -si, si, cs); } int2 repeat(int2 coord, float2 size) { return coord - int2(floor(float2(coord) / size) * size); } void decodeData(int data, out float weight, out int index) { index = (data \u0026 31) % 4; int iWeight = (data\u003e\u003e5)\u00267; weight = float(iWeight + 1) / 8.0f; } float4 frag(Varyings input) : SV_TARGET { float2 xy = input.positionWS.xz * 0.3f; float4 color; float w1, w2, w3; int2 vertex1, vertex2, vertex3; TriangleGrid(w1, w2, w3, vertex1, vertex2, vertex3, xy); int2 rect1 = vertex1 + int2(vertex1.y / 2, 0); int2 rect2 = vertex2 + int2(vertex2.y / 2, 0); int2 rect3 = vertex3 + int2(vertex3.y / 2, 0); float2 size = _MatIDTex_TexelSize.zw; int data1 = int(_MatIDTex.Load(int3(repeat(rect1, size), 0)) * 255.0f + 0.5f); int data2 = int(_MatIDTex.Load(int3(repeat(rect2, size), 0)) * 255.0f + 0.5f); int data3 = int(_MatIDTex.Load(int3(repeat(rect3, size), 0)) * 255.0f + 0.5f); float weight1, weight2, weight3; int index1, index2, index3; decodeData(data1, weight1, index1);decodeData(data2, weight2, index2);decodeData(data3, weight3, index3); float3 weights = float3(weight1, weight2, weight3); float weightSum = dot(weights, float3(1.0f, 1.0f, 1.0f)); weights /= weightSum; weights = lerp(1.0f, weights, _Shape); float rotStrength = _Rotation; float2x2 rot1 = LoadRot2x2(vertex1, rotStrength); float2x2 rot2 = LoadRot2x2(vertex2, rotStrength); float2x2 rot3 = LoadRot2x2(vertex3, rotStrength); float2 cen1 = MakeCenST(vertex1); float2 cen2 = MakeCenST(vertex2); float2 cen3 = MakeCenST(vertex3); float2 st1 = mul(xy - cen1, rot1) + cen1 + hash22(vertex1); float2 st2 = mul(xy - cen2, rot2) + cen2 + hash22(vertex2); float2 st3 = mul(xy - cen3, rot3) + cen3 + hash22(vertex3); float2 dSTdx = ddx(xy), dSTdy = ddy(xy); float4 c1 = _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, float3(st1, index1), mul(dSTdx, rot1), mul(dSTdy, rot1)); float4 c2 = _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, float3(st2, index2), mul(dSTdx, rot2), mul(dSTdy, rot2)); float4 c3 = _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, float3(st3, index3), mul(dSTdx, rot3), mul(dSTdy, rot3)); // use luminance as weight float3 Lw = float3(0.299, 0.587, 0.114); float3 Dw = float3(dot(c1.xyz,Lw),dot(c2.xyz,Lw),dot(c3.xyz,Lw)); Dw = lerp(1.0, Dw, g_fallOffContrast); float3 W = Dw*pow(float3(w1 * weights.x, w2 * weights.y, w3 * weights.z), _G_EXP); W /= (W.x+W.y+W.z); color = W.x * c1 + W.y * c2 + W.z * c3; return color; } ENDHLSL SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { HLSLPROGRAM #pragma vertex vert #pragma fragment frag ENDHLSL } } } 最终的效果 效果看上去就是这样了，左边是远景的截图，从中我们看不出任何平铺的痕迹，右边是近景的截图，该怎么说呢，看上去好像很有机地混合在了一起。。。\n后记 呃呃这篇不知道该扯些啥了，反正是一个比较简单的效果。六边形平铺好早之前就想做了，终于有时间一试。大体上效果还是可以的，但是当出现垂直的线条的时候，会有左一个六边形，右一个六边形的情况出现，我觉得可能可以通过手动修改权重值来优化这个问题，或者是上面提到的三个权重变两个的方法，不过也懒得再去试了。\n","wordCount":"1441","inLanguage":"en","image":"https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/posts/images/HexTiling.png","datePublished":"2024-03-19T12:00:00+08:00","dateModified":"2024-03-19T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">在地形贴图混合时使用六边形平铺</h1><div class=post-description>混合多张贴图的同时减少平铺的重复感.</div><div class=post-meta><span title='2024-03-19 12:00:00 +0800 CST'>March 19, 2024</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/use-hex-tiling-for-terrain-texture-blending.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/HexTiling.png alt="Hex Tiling Cover"><p>Hex Tiling Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在地形贴图混合时使用六边形平铺</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba aria-label=动机>动机</a></li><li><a href=#%e7%94%9f%e6%88%90%e6%9d%90%e8%b4%a8id%e5%9b%be aria-label=生成材质ID图>生成材质ID图</a><ul><li><a href=#generatematidcomputeshadercompute aria-label=GenerateMatIDComputeShader.compute>GenerateMatIDComputeShader.compute</a></li><li><a href=#matidgeneratorcs aria-label=MatIDGenerator.cs>MatIDGenerator.cs</a></li></ul></li><li><a href=#%e5%af%b9%e5%9c%b0%e5%bd%a2%e8%b4%b4%e5%9b%be%e5%81%9a%e6%b7%b7%e5%90%88 aria-label=对地形贴图做混合>对地形贴图做混合</a><ul><li><a href=#hextilingshadershader aria-label=HexTilingShader.shader>HexTilingShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e7%bb%88%e7%9a%84%e6%95%88%e6%9e%9c aria-label=最终的效果>最终的效果</a></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=动机>动机<a hidden class=anchor aria-hidden=true href=#动机>#</a></h2><p>最近看到了三角洲行动介绍的<a href=https://www.bilibili.com/video/BV1MC4y1Y7ft>在虚幻引擎4中实现的地形渲染方案</a>，感觉受益匪浅。不过在Unity中要想实现一个即插即用的虚拟贴图的技术应该有些困难，于是我把目光放在了最一开始所介绍的对地形贴图做混合的方案上。</p><p>三角洲行动提出的方案是这样的，在地形计算的时候，从对材质ID图的四个像素采样退化成对三个像素采样，这样一来既能减少地形混合的时候的采样次数，二来相较于采样四个像素，三个像素多了一个斜向45度的效果，能够减轻一些地形的块面感。不过他们也有语焉不详的地方，虽然只采样三个像素能够提供斜向45度，但是对于斜向-45度，仅使用同一种方式采样三个像素是不能消除这个方向的块面感的，当然想必他们也有对应的解决方案就是了。此外他们声称材质ID图是一张R8的贴图，但这张贴图里面怎么会有5bit的下层ID，5bit的上层ID，再有3bit的权重值呢？我只能认为这张材质ID图实际上只包含了一个5bit的材质ID和3bit的权重了，这个3bit的权重值会在和另外几个像素混合时使用到。</p><p>不过三次采样倒是让我想起了Hex Tiling。在<a href=https://jcgt.org/published/0011/03/05/>Practical Real-Time Hex-Tiling</a>里介绍了一种通过六边形平铺来降低平铺时纹理重复感的算法，这种算法正巧需要对主贴图采样三次（不考虑随机采样的话）。Github中也能找到<a href=https://github.com/mmikk/hextile-demo>参考的代码</a>。</p><p>这样一来我们就能在三角洲行动的方案上再提出一种新的地形混合的方法了。我们同样是采样三个像素，不过我们在地形中会将这三个像素用等边三角形的方式排布，而不是目前所用的直角三角形。所以我们的流程是，先将当前的世界空间或者uv做一次三角形格点的变换，使用变换后的格点采样材质ID图获得三个材质ID和权重，再使用获得的数据和本身的六边形平铺的权重进行混合，就能得到我们最终的混合后的地形材质了。如果把我们的材质ID图平铺到世界空间，看上去应该是这样的：</p><p><img loading=lazy src=../images/HexTiledMatIDTex.png#center alt="Hex Tiled MatIDTex"></p><h2 id=生成材质id图>生成材质ID图<a hidden class=anchor aria-hidden=true href=#生成材质id图>#</a></h2><p>为了快速生成材质ID图（我可不想手画），我们考虑使用Compute Shader通过Perlin Noise生成材质ID，使用普通的hash生成权重。为了使我们的材质ID图也能正常的平铺，我们在计算Perlin Noise的时候，要注意使用取模的运算将计算的uv值限制在同一个范围内。</p><p>我们只需要一个8bit的数据，但是由于Unity保存贴图的种种限制，我们可以将<code>R8_Uint</code>的数据除以255转换成<code>R8_UNorm</code>类型的数据再储存到贴图中。</p><h3 id=generatematidcomputeshadercompute>GenerateMatIDComputeShader.compute<a hidden class=anchor aria-hidden=true href=#generatematidcomputeshadercompute>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel MatIDGenMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _RW_MatIDTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://www.shadertoy.com/view/4djSRW</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> hash12(<span style=color:#66d9ef>float2</span> p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> p3  <span style=color:#f92672>=</span> frac(<span style=color:#66d9ef>float3</span>(p.xyx) <span style=color:#f92672>*</span> .<span style=color:#ae81ff>1031</span>);
</span></span><span style=display:flex><span>    p3 <span style=color:#f92672>+=</span> dot(p3, p3.yzx <span style=color:#f92672>+</span> <span style=color:#ae81ff>33.33</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> frac((p3.x <span style=color:#f92672>+</span> p3.y) <span style=color:#f92672>*</span> p3.z);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> repeat(<span style=color:#66d9ef>float2</span> coord, <span style=color:#66d9ef>float2</span> size, <span style=color:#66d9ef>float2</span> offset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> coord <span style=color:#f92672>-</span> floor(coord <span style=color:#f92672>/</span> size) <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> encode(<span style=color:#66d9ef>int</span> weight, <span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> encoded <span style=color:#f92672>=</span> (weight <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>) <span style=color:#f92672>|</span> index;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float</span>(encoded) <span style=color:#f92672>/</span> <span style=color:#ae81ff>255.0f</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> noise(<span style=color:#66d9ef>float2</span> p )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> i <span style=color:#f92672>=</span> floor( p );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> f <span style=color:#f92672>=</span> frac( p );	
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> u <span style=color:#f92672>=</span> f<span style=color:#f92672>*</span>f<span style=color:#f92672>*</span>f<span style=color:#f92672>*</span>(f<span style=color:#f92672>*</span>(f<span style=color:#f92672>*</span><span style=color:#ae81ff>6.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>15.0</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>10.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> ts <span style=color:#f92672>=</span> _TextureSize.xy <span style=color:#f92672>/</span> <span style=color:#ae81ff>32.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>50.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rv <span style=color:#f92672>=</span> lerp( lerp( hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>0.0</span>), ts, offset) ), 
</span></span><span style=display:flex><span>                     hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>0.0</span>), ts, offset) ), u.x),
</span></span><span style=display:flex><span>                lerp( hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>1.0</span>), ts, offset) ), 
</span></span><span style=display:flex><span>                     hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>1.0</span>), ts, offset)), u.x), u.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rv <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0f</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> MatIDGenMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> hashVal1 <span style=color:#f92672>=</span> hash12(<span style=color:#66d9ef>float2</span>(id.xy) <span style=color:#f92672>+</span> <span style=color:#ae81ff>12.3f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(floor(hashVal1 <span style=color:#f92672>*</span> <span style=color:#ae81ff>8.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rv <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(id.xy) <span style=color:#f92672>/</span> <span style=color:#ae81ff>32.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>50.0f</span>;
</span></span><span style=display:flex><span>	rv  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5000</span><span style=color:#f92672>*</span>noise( uv ); uv <span style=color:#f92672>*=</span><span style=color:#ae81ff>2.0f</span>;
</span></span><span style=display:flex><span>	rv <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.2500</span><span style=color:#f92672>*</span>noise( uv ); uv <span style=color:#f92672>*=</span><span style=color:#ae81ff>2.0f</span>;
</span></span><span style=display:flex><span>	rv <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.1250</span><span style=color:#f92672>*</span>noise( uv ); uv <span style=color:#f92672>*=</span><span style=color:#ae81ff>2.0f</span>;
</span></span><span style=display:flex><span>	rv <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.0625</span><span style=color:#f92672>*</span>noise( uv );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    rv <span style=color:#f92672>=</span> rv <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(rv <span style=color:#f92672>*</span> <span style=color:#ae81ff>32.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> returnVal <span style=color:#f92672>=</span> encode(weight, index);
</span></span><span style=display:flex><span>    _RW_MatIDTex[id.xy] <span style=color:#f92672>=</span> returnVal;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=matidgeneratorcs>MatIDGenerator.cs<a hidden class=anchor aria-hidden=true href=#matidgeneratorcs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MatIDGenerator</span> : EditorWindow
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TextureSize textureSize = TextureSize._256x256;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> savePath = <span style=color:#e6db74>&#34;Assets/HexTiling/MatID&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> suffix = <span style=color:#e6db74>&#34;.tga&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RenderTexture rt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>enum</span> TextureSize
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _256x256 = <span style=color:#ae81ff>256</span>,
</span></span><span style=display:flex><span>        _512x512 = <span style=color:#ae81ff>512</span>,
</span></span><span style=display:flex><span>        _1024x1024 = <span style=color:#ae81ff>1024</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Rect rect
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20.0f</span>, <span style=color:#ae81ff>20.0f</span>, position.width - <span style=color:#ae81ff>40.0f</span>, position.height - <span style=color:#ae81ff>10.0f</span>); }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRT()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span> || rt.width != (<span style=color:#66d9ef>int</span>)textureSize || rt.height != (<span style=color:#66d9ef>int</span>)textureSize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                width = (<span style=color:#66d9ef>int</span>)textureSize,
</span></span><span style=display:flex><span>                height = (<span style=color:#66d9ef>int</span>)textureSize,
</span></span><span style=display:flex><span>                volumeDepth = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                dimension = UnityEngine.Rendering.TextureDimension.Tex2D,
</span></span><span style=display:flex><span>                depthBufferBits = <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                msaaSamples = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm,
</span></span><span style=display:flex><span>                enableRandomWrite = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            rt = <span style=color:#66d9ef>new</span> RenderTexture(desc);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [MenuItem(&#34;zznewclear13/Mat ID Generator&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Init()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MatIDGenerator window = GetWindow&lt;MatIDGenerator&gt;(<span style=color:#e6db74>&#34;Mat ID Generator&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        window.Show();
</span></span><span style=display:flex><span>        window.Repaint();
</span></span><span style=display:flex><span>        window.Focus();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader = (ComputeShader)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Compute Shader&#34;</span>, computeShader, <span style=color:#66d9ef>typeof</span>(ComputeShader), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>            textureSize = (TextureSize)EditorGUILayout.EnumPopup(<span style=color:#e6db74>&#34;Output Texture Size&#34;</span>, textureSize);
</span></span><span style=display:flex><span>            savePath = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Path&#34;</span>, savePath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!computeShader))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Generate!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30.0f</span>) }))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    GenerateMatID();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateMatID()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EnsureRT();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ts = (<span style=color:#66d9ef>float</span>)textureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;MatIDGenMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        Vector2Int dispatchCount = <span style=color:#66d9ef>new</span> Vector2Int(Mathf.CeilToInt(ts / x),
</span></span><span style=display:flex><span>                                                    Mathf.CeilToInt(ts / y));
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_MatIDTex&#34;</span>, rt);
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(ts, ts, <span style=color:#ae81ff>1.0f</span> / ts, <span style=color:#ae81ff>1.0f</span> / ts));
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernelID, dispatchCount.x, dispatchCount.y, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        SaveRenderTextureToFile(rt);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveRenderTextureToFile(RenderTexture rt)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        RenderTexture prev = RenderTexture.active;
</span></span><span style=display:flex><span>        RenderTexture.active = rt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ts = (<span style=color:#66d9ef>int</span>)textureSize;
</span></span><span style=display:flex><span>        Texture2D toSave = <span style=color:#66d9ef>new</span> Texture2D(ts, ts, TextureFormat.R8, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        toSave.ReadPixels(<span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, ts, ts), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>[] bytes = toSave.EncodeToTGA();
</span></span><span style=display:flex><span>        FileStream fs = File.OpenWrite(savePath + suffix);
</span></span><span style=display:flex><span>        fs.Write(bytes);
</span></span><span style=display:flex><span>        fs.Close();
</span></span><span style=display:flex><span>        AssetDatabase.Refresh();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix);
</span></span><span style=display:flex><span>        ti.mipmapEnabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        ti.sRGBTexture = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        ti.textureCompression = TextureImporterCompression.Uncompressed;
</span></span><span style=display:flex><span>        ti.SaveAndReimport();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Texture2D tempTexture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(savePath + suffix);
</span></span><span style=display:flex><span>        EditorGUIUtility.PingObject(tempTexture);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        RenderTexture.active = prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=对地形贴图做混合>对地形贴图做混合<a hidden class=anchor aria-hidden=true href=#对地形贴图做混合>#</a></h2><p>为了简便，我们只对地形的Base Color进行混合，要想对法线或者是三平面映射进行混合，Hex Tiling的代码案例里也提供了相应的函数。我额外的使用了一个<code>_Shape</code>参数，数值越小就越多地显示出六边形的特征，越大则越多地显示出权重混合的特征。权重混合应该还有更好的方式，比如当三角形的两个点材质ID一致的时候，将混合的效果从三个权重混合简化成两个权重混合，不过这个后续有时间再考虑吧。这个Shader也能支持32张地形贴图的混合，第142行改成<code>index = (data & 31);</code>即可，不过我可没那么多张贴图，就限制到4张了。</p><h3 id=hextilingshadershader>HexTilingShader.shader<a hidden class=anchor aria-hidden=true href=#hextilingshadershader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>// MIT License</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Copyright (c) 2024 zznewclear@gmail.com</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Copyright (c) 2022 mmikk</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Permission is hereby granted, free of charge, to any person obtaining a copy</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// of this software and associated documentation files (the &#34;Software&#34;), to deal</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// in the Software without restriction, including without limitation the rights</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copies of the Software, and to permit persons to whom the Software is</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// furnished to do so, subject to the following conditions:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The above copyright notice and this permission notice shall be included in all</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copies or substantial portions of the Software.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// SOFTWARE.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/HexTilingShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>		_MatIDTex (<span style=color:#e6db74>&#34;Mat ID Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;black&#34;</span> {}
</span></span><span style=display:flex><span>		_TerrainMainTex (<span style=color:#e6db74>&#34;Terrain Main Tex&#34;</span>, <span style=color:#ae81ff>2</span>DArray) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_Rotation (<span style=color:#e6db74>&#34;Rotation&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>		_Shape (<span style=color:#e6db74>&#34;Shape&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>		_G_EXP (<span style=color:#e6db74>&#34;G Exp&#34;</span>, Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>#</span>define M_PI <span style=color:#ae81ff>3.1415926f</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> g_fallOffContrast <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.6</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> g_exp <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>Texture2DArray</span> _TerrainMainTex;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _MatIDTex;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SamplerState</span> sampler_MainTex;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SamplerState</span> sampler_TerrainMainTex;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SamplerState</span> sampler_PointRepeat;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> _MatIDTex_TexelSize;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> _Rotation;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> _Shape;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> _G_EXP;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        output.positionWS <span style=color:#f92672>=</span> vpi.positionWS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> hash22(<span style=color:#66d9ef>float2</span> p)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float3</span> p3 <span style=color:#f92672>=</span> frac(<span style=color:#66d9ef>float3</span>(p.xyx) <span style=color:#f92672>*</span> <span style=color:#66d9ef>float3</span>(.<span style=color:#ae81ff>1031</span>, .<span style=color:#ae81ff>1030</span>, .<span style=color:#ae81ff>0</span><span style=color:#ae81ff>973</span>));
</span></span><span style=display:flex><span>		p3 <span style=color:#f92672>+=</span> dot(p3, p3.yzx<span style=color:#f92672>+</span><span style=color:#ae81ff>33.33</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> frac((p3.xx<span style=color:#f92672>+</span>p3.yz)<span style=color:#f92672>*</span>p3.zy);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> TriangleGrid(<span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> w1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> w2, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> w3, 
</span></span><span style=display:flex><span>				  <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> vertex1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> vertex2, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> vertex3,
</span></span><span style=display:flex><span>				  <span style=color:#66d9ef>float2</span> st)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// Scaling of the input</span>
</span></span><span style=display:flex><span>	    st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> sqrt(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// Skew input space into simplex triangle grid</span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float2x2</span> gridToSkewedGrid <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>float2x2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.57735027</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.15470054</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> skewedCoord <span style=color:#f92672>=</span> mul(gridToSkewedGrid, st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> baseId <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>( floor ( skewedCoord ));
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> temp <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>( frac( skewedCoord ), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    temp.z <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> temp.x <span style=color:#f92672>-</span> temp.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> s <span style=color:#f92672>=</span> step(<span style=color:#ae81ff>0.0</span>, <span style=color:#f92672>-</span>temp.z);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> s2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>s<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    w1 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>temp.z<span style=color:#f92672>*</span>s2;
</span></span><span style=display:flex><span>	    w2 <span style=color:#f92672>=</span> s <span style=color:#f92672>-</span> temp.y<span style=color:#f92672>*</span>s2;
</span></span><span style=display:flex><span>	    w3 <span style=color:#f92672>=</span> s <span style=color:#f92672>-</span> temp.x<span style=color:#f92672>*</span>s2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    vertex1 <span style=color:#f92672>=</span> baseId <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(s,s);
</span></span><span style=display:flex><span>	    vertex2 <span style=color:#f92672>=</span> baseId <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(s,<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>s);
</span></span><span style=display:flex><span>	    vertex3 <span style=color:#f92672>=</span> baseId <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>s,s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> MakeCenST(<span style=color:#66d9ef>int2</span> Vertex)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2x2</span> invSkewMat <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2x2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.15470054</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> mul(invSkewMat, Vertex) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> sqrt(<span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2x2</span> LoadRot2x2(<span style=color:#66d9ef>int2</span> idx, <span style=color:#66d9ef>float</span> rotStrength)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> angle <span style=color:#f92672>=</span> abs(idx.x<span style=color:#f92672>*</span>idx.y) <span style=color:#f92672>+</span> abs(idx.x<span style=color:#f92672>+</span>idx.y) <span style=color:#f92672>+</span> M_PI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    angle <span style=color:#f92672>=</span> fmod(angle, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>M_PI); 
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span>(angle<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>) angle <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>M_PI;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span>(angle<span style=color:#f92672>&gt;</span>M_PI) angle <span style=color:#f92672>-=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>M_PI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    angle <span style=color:#f92672>*=</span> rotStrength;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> cs <span style=color:#f92672>=</span> cos(angle), si <span style=color:#f92672>=</span> sin(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float2x2</span>(cs, <span style=color:#f92672>-</span>si, si, cs);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span> repeat(<span style=color:#66d9ef>int2</span> coord, <span style=color:#66d9ef>float2</span> size)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> coord <span style=color:#f92672>-</span> <span style=color:#66d9ef>int2</span>(floor(<span style=color:#66d9ef>float2</span>(coord) <span style=color:#f92672>/</span> size) <span style=color:#f92672>*</span> size);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> decodeData(<span style=color:#66d9ef>int</span> data, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> weight, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		index <span style=color:#f92672>=</span> (data <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>31</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> iWeight <span style=color:#f92672>=</span> (data<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>5</span>)<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>		weight <span style=color:#f92672>=</span> <span style=color:#66d9ef>float</span>(iWeight <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>8.0f</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> xy <span style=color:#f92672>=</span> input.positionWS.xz <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.3f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> color;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> w1, w2, w3;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> vertex1, vertex2, vertex3;
</span></span><span style=display:flex><span>	    TriangleGrid(w1, w2, w3, vertex1, vertex2, vertex3, xy);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> rect1 <span style=color:#f92672>=</span> vertex1 <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(vertex1.y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> rect2 <span style=color:#f92672>=</span> vertex2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(vertex2.y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> rect3 <span style=color:#f92672>=</span> vertex3 <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(vertex3.y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float2</span> size <span style=color:#f92672>=</span> _MatIDTex_TexelSize.zw;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> data1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_MatIDTex.Load(<span style=color:#66d9ef>int3</span>(repeat(rect1, size), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>255.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> data2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_MatIDTex.Load(<span style=color:#66d9ef>int3</span>(repeat(rect2, size), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>255.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> data3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_MatIDTex.Load(<span style=color:#66d9ef>int3</span>(repeat(rect3, size), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>255.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> weight1, weight2, weight3;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> index1, index2, index3;
</span></span><span style=display:flex><span>		decodeData(data1, weight1, index1);decodeData(data2, weight2, index2);decodeData(data3, weight3, index3);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float3</span> weights <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(weight1, weight2, weight3);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> weightSum <span style=color:#f92672>=</span> dot(weights, <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>		weights <span style=color:#f92672>/=</span> weightSum;
</span></span><span style=display:flex><span>		weights <span style=color:#f92672>=</span> lerp(<span style=color:#ae81ff>1.0f</span>, weights, _Shape);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> rotStrength <span style=color:#f92672>=</span> _Rotation;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float2x2</span> rot1 <span style=color:#f92672>=</span> LoadRot2x2(vertex1, rotStrength);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2x2</span> rot2 <span style=color:#f92672>=</span> LoadRot2x2(vertex2, rotStrength);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2x2</span> rot3 <span style=color:#f92672>=</span> LoadRot2x2(vertex3, rotStrength);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> cen1 <span style=color:#f92672>=</span> MakeCenST(vertex1);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> cen2 <span style=color:#f92672>=</span> MakeCenST(vertex2);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> cen3 <span style=color:#f92672>=</span> MakeCenST(vertex3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> st1 <span style=color:#f92672>=</span> mul(xy <span style=color:#f92672>-</span> cen1, rot1) <span style=color:#f92672>+</span> cen1 <span style=color:#f92672>+</span> hash22(vertex1);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> st2 <span style=color:#f92672>=</span> mul(xy <span style=color:#f92672>-</span> cen2, rot2) <span style=color:#f92672>+</span> cen2 <span style=color:#f92672>+</span> hash22(vertex2);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> st3 <span style=color:#f92672>=</span> mul(xy <span style=color:#f92672>-</span> cen3, rot3) <span style=color:#f92672>+</span> cen3 <span style=color:#f92672>+</span> hash22(vertex3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> dSTdx <span style=color:#f92672>=</span> ddx(xy), dSTdy <span style=color:#f92672>=</span> ddy(xy);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> c1 <span style=color:#f92672>=</span> _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, <span style=color:#66d9ef>float3</span>(st1, index1), mul(dSTdx, rot1), mul(dSTdy, rot1));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> c2 <span style=color:#f92672>=</span> _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, <span style=color:#66d9ef>float3</span>(st2, index2), mul(dSTdx, rot2), mul(dSTdy, rot2));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> c3 <span style=color:#f92672>=</span> _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, <span style=color:#66d9ef>float3</span>(st3, index3), mul(dSTdx, rot3), mul(dSTdy, rot3));
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>		<span style=color:#75715e>// use luminance as weight</span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> Lw <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.299</span>, <span style=color:#ae81ff>0.587</span>, <span style=color:#ae81ff>0.114</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> Dw <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(dot(c1.xyz,Lw),dot(c2.xyz,Lw),dot(c3.xyz,Lw));
</span></span><span style=display:flex><span>	    Dw <span style=color:#f92672>=</span> lerp(<span style=color:#ae81ff>1.0</span>, Dw, g_fallOffContrast);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> W <span style=color:#f92672>=</span> Dw<span style=color:#f92672>*</span>pow(<span style=color:#66d9ef>float3</span>(w1 <span style=color:#f92672>*</span> weights.x, w2 <span style=color:#f92672>*</span> weights.y, w3 <span style=color:#f92672>*</span> weights.z), _G_EXP);
</span></span><span style=display:flex><span>	    W <span style=color:#f92672>/=</span> (W.x<span style=color:#f92672>+</span>W.y<span style=color:#f92672>+</span>W.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    color <span style=color:#f92672>=</span> W.x <span style=color:#f92672>*</span> c1 <span style=color:#f92672>+</span> W.y <span style=color:#f92672>*</span> c2 <span style=color:#f92672>+</span> W.z <span style=color:#f92672>*</span> c3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> color;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Opaque&#34;</span> }
</span></span><span style=display:flex><span>        LOD <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=最终的效果>最终的效果<a hidden class=anchor aria-hidden=true href=#最终的效果>#</a></h2><p>效果看上去就是这样了，左边是远景的截图，从中我们看不出任何平铺的痕迹，右边是近景的截图，该怎么说呢，看上去好像很有机地混合在了一起。。。</p><p><img loading=lazy src=../images/HexTiling.png#center alt="Hex Tiling"></p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>呃呃这篇不知道该扯些啥了，反正是一个比较简单的效果。六边形平铺好早之前就想做了，终于有时间一试。大体上效果还是可以的，但是当出现垂直的线条的时候，会有左一个六边形，右一个六边形的情况出现，我觉得可能可以通过手动修改权重值来优化这个问题，或者是上面提到的三个权重变两个的方法，不过也懒得再去试了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/terrain/>Terrain</a></li><li><a href=https://zznewclear13.github.io/tags/hex-tiling/>Hex Tiling</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/><span class=title>« Prev</span><br><span>径向分派Compute Shader</span>
</a><a class=next href=https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/><span class=title>Next »</span><br><span>从视差映射、浮雕映射中获取正确的深度值</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>