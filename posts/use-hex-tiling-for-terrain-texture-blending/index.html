<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º | ZZNEWCLEAR13</title>
<meta name=keywords content="Terrain,Hex Tiling"><meta name=description content="æ··åˆå¤šå¼ è´´å›¾çš„åŒæ—¶å‡å°‘å¹³é“ºçš„é‡å¤æ„Ÿ."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º"><meta property="og:description" content="æ··åˆå¤šå¼ è´´å›¾çš„åŒæ—¶å‡å°‘å¹³é“ºçš„é‡å¤æ„Ÿ."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/"><meta property="og:image" content="https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/posts/images/HexTiling.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-19T12:00:00+08:00"><meta property="article:modified_time" content="2024-03-19T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/posts/images/HexTiling.png"><meta name=twitter:title content="åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º"><meta name=twitter:description content="æ··åˆå¤šå¼ è´´å›¾çš„åŒæ—¶å‡å°‘å¹³é“ºçš„é‡å¤æ„Ÿ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º","item":"https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º","name":"åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º","description":"æ··åˆå¤šå¼ è´´å›¾çš„åŒæ—¶å‡å°‘å¹³é“ºçš„é‡å¤æ„Ÿ.","keywords":["Terrain","Hex Tiling"],"articleBody":"åŠ¨æœº æœ€è¿‘çœ‹åˆ°äº†ä¸‰è§’æ´²è¡ŒåŠ¨ä»‹ç»çš„åœ¨è™šå¹»å¼•æ“4ä¸­å®ç°çš„åœ°å½¢æ¸²æŸ“æ–¹æ¡ˆï¼Œæ„Ÿè§‰å—ç›ŠåŒªæµ…ã€‚ä¸è¿‡åœ¨Unityä¸­è¦æƒ³å®ç°ä¸€ä¸ªå³æ’å³ç”¨çš„è™šæ‹Ÿè´´å›¾çš„æŠ€æœ¯åº”è¯¥æœ‰äº›å›°éš¾ï¼Œäºæ˜¯æˆ‘æŠŠç›®å…‰æ”¾åœ¨äº†æœ€ä¸€å¼€å§‹æ‰€ä»‹ç»çš„å¯¹åœ°å½¢è´´å›¾åšæ··åˆçš„æ–¹æ¡ˆä¸Šã€‚\nä¸‰è§’æ´²è¡ŒåŠ¨æå‡ºçš„æ–¹æ¡ˆæ˜¯è¿™æ ·çš„ï¼Œåœ¨åœ°å½¢è®¡ç®—çš„æ—¶å€™ï¼Œä»å¯¹æè´¨IDå›¾çš„å››ä¸ªåƒç´ é‡‡æ ·é€€åŒ–æˆå¯¹ä¸‰ä¸ªåƒç´ é‡‡æ ·ï¼Œè¿™æ ·ä¸€æ¥æ—¢èƒ½å‡å°‘åœ°å½¢æ··åˆçš„æ—¶å€™çš„é‡‡æ ·æ¬¡æ•°ï¼ŒäºŒæ¥ç›¸è¾ƒäºé‡‡æ ·å››ä¸ªåƒç´ ï¼Œä¸‰ä¸ªåƒç´ å¤šäº†ä¸€ä¸ªæ–œå‘45åº¦çš„æ•ˆæœï¼Œèƒ½å¤Ÿå‡è½»ä¸€äº›åœ°å½¢çš„å—é¢æ„Ÿã€‚ä¸è¿‡ä»–ä»¬ä¹Ÿæœ‰è¯­ç„‰ä¸è¯¦çš„åœ°æ–¹ï¼Œè™½ç„¶åªé‡‡æ ·ä¸‰ä¸ªåƒç´ èƒ½å¤Ÿæä¾›æ–œå‘45åº¦ï¼Œä½†æ˜¯å¯¹äºæ–œå‘-45åº¦ï¼Œä»…ä½¿ç”¨åŒä¸€ç§æ–¹å¼é‡‡æ ·ä¸‰ä¸ªåƒç´ æ˜¯ä¸èƒ½æ¶ˆé™¤è¿™ä¸ªæ–¹å‘çš„å—é¢æ„Ÿçš„ï¼Œå½“ç„¶æƒ³å¿…ä»–ä»¬ä¹Ÿæœ‰å¯¹åº”çš„è§£å†³æ–¹æ¡ˆå°±æ˜¯äº†ã€‚æ­¤å¤–ä»–ä»¬å£°ç§°æè´¨IDå›¾æ˜¯ä¸€å¼ R8çš„è´´å›¾ï¼Œä½†è¿™å¼ è´´å›¾é‡Œé¢æ€ä¹ˆä¼šæœ‰5bitçš„ä¸‹å±‚IDï¼Œ5bitçš„ä¸Šå±‚IDï¼Œå†æœ‰3bitçš„æƒé‡å€¼å‘¢ï¼Ÿæˆ‘åªèƒ½è®¤ä¸ºè¿™å¼ æè´¨IDå›¾å®é™…ä¸ŠåªåŒ…å«äº†ä¸€ä¸ª5bitçš„æè´¨IDå’Œ3bitçš„æƒé‡äº†ï¼Œè¿™ä¸ª3bitçš„æƒé‡å€¼ä¼šåœ¨å’Œå¦å¤–å‡ ä¸ªåƒç´ æ··åˆæ—¶ä½¿ç”¨åˆ°ã€‚\nä¸è¿‡ä¸‰æ¬¡é‡‡æ ·å€’æ˜¯è®©æˆ‘æƒ³èµ·äº†Hex Tilingã€‚åœ¨Practical Real-Time Hex-Tilingé‡Œä»‹ç»äº†ä¸€ç§é€šè¿‡å…­è¾¹å½¢å¹³é“ºæ¥é™ä½å¹³é“ºæ—¶çº¹ç†é‡å¤æ„Ÿçš„ç®—æ³•ï¼Œè¿™ç§ç®—æ³•æ­£å·§éœ€è¦å¯¹ä¸»è´´å›¾é‡‡æ ·ä¸‰æ¬¡ï¼ˆä¸è€ƒè™‘éšæœºé‡‡æ ·çš„è¯ï¼‰ã€‚Githubä¸­ä¹Ÿèƒ½æ‰¾åˆ°å‚è€ƒçš„ä»£ç ã€‚\nè¿™æ ·ä¸€æ¥æˆ‘ä»¬å°±èƒ½åœ¨ä¸‰è§’æ´²è¡ŒåŠ¨çš„æ–¹æ¡ˆä¸Šå†æå‡ºä¸€ç§æ–°çš„åœ°å½¢æ··åˆçš„æ–¹æ³•äº†ã€‚æˆ‘ä»¬åŒæ ·æ˜¯é‡‡æ ·ä¸‰ä¸ªåƒç´ ï¼Œä¸è¿‡æˆ‘ä»¬åœ¨åœ°å½¢ä¸­ä¼šå°†è¿™ä¸‰ä¸ªåƒç´ ç”¨ç­‰è¾¹ä¸‰è§’å½¢çš„æ–¹å¼æ’å¸ƒï¼Œè€Œä¸æ˜¯ç›®å‰æ‰€ç”¨çš„ç›´è§’ä¸‰è§’å½¢ã€‚æ‰€ä»¥æˆ‘ä»¬çš„æµç¨‹æ˜¯ï¼Œå…ˆå°†å½“å‰çš„ä¸–ç•Œç©ºé—´æˆ–è€…uvåšä¸€æ¬¡ä¸‰è§’å½¢æ ¼ç‚¹çš„å˜æ¢ï¼Œä½¿ç”¨å˜æ¢åçš„æ ¼ç‚¹é‡‡æ ·æè´¨IDå›¾è·å¾—ä¸‰ä¸ªæè´¨IDå’Œæƒé‡ï¼Œå†ä½¿ç”¨è·å¾—çš„æ•°æ®å’Œæœ¬èº«çš„å…­è¾¹å½¢å¹³é“ºçš„æƒé‡è¿›è¡Œæ··åˆï¼Œå°±èƒ½å¾—åˆ°æˆ‘ä»¬æœ€ç»ˆçš„æ··åˆåçš„åœ°å½¢æè´¨äº†ã€‚å¦‚æœæŠŠæˆ‘ä»¬çš„æè´¨IDå›¾å¹³é“ºåˆ°ä¸–ç•Œç©ºé—´ï¼Œçœ‹ä¸Šå»åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š\nç”Ÿæˆæè´¨IDå›¾ ä¸ºäº†å¿«é€Ÿç”Ÿæˆæè´¨IDå›¾ï¼ˆæˆ‘å¯ä¸æƒ³æ‰‹ç”»ï¼‰ï¼Œæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨Compute Shaderé€šè¿‡Perlin Noiseç”Ÿæˆæè´¨IDï¼Œä½¿ç”¨æ™®é€šçš„hashç”Ÿæˆæƒé‡ã€‚ä¸ºäº†ä½¿æˆ‘ä»¬çš„æè´¨IDå›¾ä¹Ÿèƒ½æ­£å¸¸çš„å¹³é“ºï¼Œæˆ‘ä»¬åœ¨è®¡ç®—Perlin Noiseçš„æ—¶å€™ï¼Œè¦æ³¨æ„ä½¿ç”¨å–æ¨¡çš„è¿ç®—å°†è®¡ç®—çš„uvå€¼é™åˆ¶åœ¨åŒä¸€ä¸ªèŒƒå›´å†…ã€‚\næˆ‘ä»¬åªéœ€è¦ä¸€ä¸ª8bitçš„æ•°æ®ï¼Œä½†æ˜¯ç”±äºUnityä¿å­˜è´´å›¾çš„ç§ç§é™åˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†R8_Uintçš„æ•°æ®é™¤ä»¥255è½¬æ¢æˆR8_UNormç±»å‹çš„æ•°æ®å†å‚¨å­˜åˆ°è´´å›¾ä¸­ã€‚\nGenerateMatIDComputeShader.compute #pragma kernel MatIDGenMain RWTexture2D\u003cfloat\u003e _RW_MatIDTex; float4 _TextureSize; // https://www.shadertoy.com/view/4djSRW float hash12(float2 p) { float3 p3 = frac(float3(p.xyx) * .1031); p3 += dot(p3, p3.yzx + 33.33); return frac((p3.x + p3.y) * p3.z); } float2 repeat(float2 coord, float2 size, float2 offset) { return coord - floor(coord / size) * size + offset; } float encode(int weight, int index) { int encoded = (weight \u003c\u003c 5) | index; return float(encoded) / 255.0f; } float noise(float2 p ) { float2 i = floor( p ); float2 f = frac( p );\tfloat2 u = f*f*f*(f*(f*6.0-15.0)+10.0); float2 ts = _TextureSize.xy / 32.0f; float2 offset = 50.0f; float rv = lerp( lerp( hash12( repeat(i + float2(0.0,0.0), ts, offset) ), hash12( repeat(i + float2(1.0,0.0), ts, offset) ), u.x), lerp( hash12( repeat(i + float2(0.0,1.0), ts, offset) ), hash12( repeat(i + float2(1.0,1.0), ts, offset)), u.x), u.y); return rv * 2.0f - 1.0f; } [numthreads(8,8,1)] void MatIDGenMain (uint3 id : SV_DispatchThreadID) { float hashVal1 = hash12(float2(id.xy) + 12.3f); int weight = int(floor(hashVal1 * 8.0f)); float rv = 0.0f; float2 uv = float2(id.xy) / 32.0f + 50.0f; rv = 0.5000*noise( uv ); uv *=2.0f; rv += 0.2500*noise( uv ); uv *=2.0f; rv += 0.1250*noise( uv ); uv *=2.0f; rv += 0.0625*noise( uv ); rv = rv * 0.5f + 0.5f; int index = int(rv * 32.0f); float returnVal = encode(weight, index); _RW_MatIDTex[id.xy] = returnVal; } MatIDGenerator.cs using UnityEngine; using UnityEditor; using System.IO; public class MatIDGenerator : EditorWindow { private TextureSize textureSize = TextureSize._256x256; private ComputeShader computeShader; private string savePath = \"Assets/HexTiling/MatID\"; private static readonly string suffix = \".tga\"; private RenderTexture rt; private enum TextureSize { _256x256 = 256, _512x512 = 512, _1024x1024 = 1024, } Rect rect { get { return new Rect(20.0f, 20.0f, position.width - 40.0f, position.height - 10.0f); } } private void EnsureRT() { if (rt == null || rt.width != (int)textureSize || rt.height != (int)textureSize) { if (rt != null) rt.Release(); RenderTextureDescriptor desc = new RenderTextureDescriptor { width = (int)textureSize, height = (int)textureSize, volumeDepth = 1, dimension = UnityEngine.Rendering.TextureDimension.Tex2D, depthBufferBits = 0, msaaSamples = 1, graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm, enableRandomWrite = true }; rt = new RenderTexture(desc); if (!rt.IsCreated()) rt.Create(); } } [MenuItem(\"zznewclear13/Mat ID Generator\")] public static void Init() { MatIDGenerator window = GetWindow(\"Mat ID Generator\"); window.Show(); window.Repaint(); window.Focus(); } private void OnGUI() { using (new GUILayout.AreaScope(rect)) { computeShader = (ComputeShader)EditorGUILayout.ObjectField(\"Compute Shader\", computeShader, typeof(ComputeShader), false); textureSize = (TextureSize)EditorGUILayout.EnumPopup(\"Output Texture Size\", textureSize); savePath = EditorGUILayout.TextField(\"Save Path\", savePath); using (new EditorGUI.DisabledGroupScope(!computeShader)) { if (GUILayout.Button(\"Generate!\", new GUILayoutOption[] { GUILayout.Height(30.0f) })) { GenerateMatID(); } } } } private void GenerateMatID() { EnsureRT(); float ts = (float)textureSize; int kernelID = computeShader.FindKernel(\"MatIDGenMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); Vector2Int dispatchCount = new Vector2Int(Mathf.CeilToInt(ts / x), Mathf.CeilToInt(ts / y)); computeShader.SetTexture(kernelID, \"_RW_MatIDTex\", rt); computeShader.SetVector(\"_TextureSize\", new Vector4(ts, ts, 1.0f / ts, 1.0f / ts)); computeShader.Dispatch(kernelID, dispatchCount.x, dispatchCount.y, 1); SaveRenderTextureToFile(rt); } private void SaveRenderTextureToFile(RenderTexture rt) { RenderTexture prev = RenderTexture.active; RenderTexture.active = rt; int ts = (int)textureSize; Texture2D toSave = new Texture2D(ts, ts, TextureFormat.R8, false, true); toSave.ReadPixels(new Rect(0.0f, 0.0f, ts, ts), 0, 0); byte[] bytes = toSave.EncodeToTGA(); FileStream fs = File.OpenWrite(savePath + suffix); fs.Write(bytes); fs.Close(); AssetDatabase.Refresh(); TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix); ti.mipmapEnabled = false; ti.sRGBTexture = false; ti.textureCompression = TextureImporterCompression.Uncompressed; ti.SaveAndReimport(); Texture2D tempTexture = AssetDatabase.LoadAssetAtPath(savePath + suffix); EditorGUIUtility.PingObject(tempTexture); RenderTexture.active = prev; } private void OnDestroy() { if (rt != null) rt.Release(); } } å¯¹åœ°å½¢è´´å›¾åšæ··åˆ ä¸ºäº†ç®€ä¾¿ï¼Œæˆ‘ä»¬åªå¯¹åœ°å½¢çš„Base Colorè¿›è¡Œæ··åˆï¼Œè¦æƒ³å¯¹æ³•çº¿æˆ–è€…æ˜¯ä¸‰å¹³é¢æ˜ å°„è¿›è¡Œæ··åˆï¼ŒHex Tilingçš„ä»£ç æ¡ˆä¾‹é‡Œä¹Ÿæä¾›äº†ç›¸åº”çš„å‡½æ•°ã€‚æˆ‘é¢å¤–çš„ä½¿ç”¨äº†ä¸€ä¸ª_Shapeå‚æ•°ï¼Œæ•°å€¼è¶Šå°å°±è¶Šå¤šåœ°æ˜¾ç¤ºå‡ºå…­è¾¹å½¢çš„ç‰¹å¾ï¼Œè¶Šå¤§åˆ™è¶Šå¤šåœ°æ˜¾ç¤ºå‡ºæƒé‡æ··åˆçš„ç‰¹å¾ã€‚æƒé‡æ··åˆåº”è¯¥è¿˜æœ‰æ›´å¥½çš„æ–¹å¼ï¼Œæ¯”å¦‚å½“ä¸‰è§’å½¢çš„ä¸¤ä¸ªç‚¹æè´¨IDä¸€è‡´çš„æ—¶å€™ï¼Œå°†æ··åˆçš„æ•ˆæœä»ä¸‰ä¸ªæƒé‡æ··åˆç®€åŒ–æˆä¸¤ä¸ªæƒé‡æ··åˆï¼Œä¸è¿‡è¿™ä¸ªåç»­æœ‰æ—¶é—´å†è€ƒè™‘å§ã€‚è¿™ä¸ªShaderä¹Ÿèƒ½æ”¯æŒ32å¼ åœ°å½¢è´´å›¾çš„æ··åˆï¼Œç¬¬142è¡Œæ”¹æˆindex = (data \u0026 31);å³å¯ï¼Œä¸è¿‡æˆ‘å¯æ²¡é‚£ä¹ˆå¤šå¼ è´´å›¾ï¼Œå°±é™åˆ¶åˆ°4å¼ äº†ã€‚\nHexTilingShader.shader // MIT License // // Copyright (c) 2024 zznewclear@gmail.com // Copyright (c) 2022 mmikk // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the \"Software\"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE // SOFTWARE. Shader \"zznewclear13/HexTilingShader\" { Properties { _MatIDTex (\"Mat ID Texture\", 2D) = \"black\" {} _TerrainMainTex (\"Terrain Main Tex\", 2DArray) = \"\" {} _Rotation (\"Rotation\", Range(0, 1)) = 0.5 _Shape (\"Shape\", Range(0, 1)) = 0.5 _G_EXP (\"G Exp\", Range(1, 10)) = 3.0 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #define M_PI 3.1415926f static float g_fallOffContrast = 0.6; static float g_exp = 7; Texture2DArray _TerrainMainTex; Texture2D\u003cfloat\u003e _MatIDTex; CBUFFER_START(UnityPerMaterial) SamplerState sampler_MainTex; SamplerState sampler_TerrainMainTex; SamplerState sampler_PointRepeat; float4 _MatIDTex_TexelSize; float _Rotation; float _Shape; float _G_EXP; CBUFFER_END struct Attributes { float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float3 positionWS : TEXCOORD1; }; Varyings vert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); output.positionCS = vpi.positionCS; output.uv = input.texcoord; output.positionWS = vpi.positionWS; return output; } float2 hash22(float2 p) { float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx+33.33); return frac((p3.xx+p3.yz)*p3.zy); } void TriangleGrid(out float w1, out float w2, out float w3, out int2 vertex1, out int2 vertex2, out int2 vertex3, float2 st) { // Scaling of the input st *= 2 * sqrt(3); // Skew input space into simplex triangle grid const float2x2 gridToSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054); float2 skewedCoord = mul(gridToSkewedGrid, st); int2 baseId = int2( floor ( skewedCoord )); float3 temp = float3( frac( skewedCoord ), 0); temp.z = 1.0 - temp.x - temp.y; float s = step(0.0, -temp.z); float s2 = 2*s-1; w1 = -temp.z*s2; w2 = s - temp.y*s2; w3 = s - temp.x*s2; vertex1 = baseId + int2(s,s); vertex2 = baseId + int2(s,1-s); vertex3 = baseId + int2(1-s,s); } float2 MakeCenST(int2 Vertex) { float2x2 invSkewMat = float2x2(1.0, 0.5, 0.0, 1.0/1.15470054); return mul(invSkewMat, Vertex) / (2 * sqrt(3)); } float2x2 LoadRot2x2(int2 idx, float rotStrength) { float angle = abs(idx.x*idx.y) + abs(idx.x+idx.y) + M_PI; angle = fmod(angle, 2*M_PI); if(angle\u003c0) angle += 2*M_PI; if(angle\u003eM_PI) angle -= 2*M_PI; angle *= rotStrength; float cs = cos(angle), si = sin(angle); return float2x2(cs, -si, si, cs); } int2 repeat(int2 coord, float2 size) { return coord - int2(floor(float2(coord) / size) * size); } void decodeData(int data, out float weight, out int index) { index = (data \u0026 31) % 4; int iWeight = (data\u003e\u003e5)\u00267; weight = float(iWeight + 1) / 8.0f; } float4 frag(Varyings input) : SV_TARGET { float2 xy = input.positionWS.xz * 0.3f; float4 color; float w1, w2, w3; int2 vertex1, vertex2, vertex3; TriangleGrid(w1, w2, w3, vertex1, vertex2, vertex3, xy); int2 rect1 = vertex1 + int2(vertex1.y / 2, 0); int2 rect2 = vertex2 + int2(vertex2.y / 2, 0); int2 rect3 = vertex3 + int2(vertex3.y / 2, 0); float2 size = _MatIDTex_TexelSize.zw; int data1 = int(_MatIDTex.Load(int3(repeat(rect1, size), 0)) * 255.0f + 0.5f); int data2 = int(_MatIDTex.Load(int3(repeat(rect2, size), 0)) * 255.0f + 0.5f); int data3 = int(_MatIDTex.Load(int3(repeat(rect3, size), 0)) * 255.0f + 0.5f); float weight1, weight2, weight3; int index1, index2, index3; decodeData(data1, weight1, index1);decodeData(data2, weight2, index2);decodeData(data3, weight3, index3); float3 weights = float3(weight1, weight2, weight3); float weightSum = dot(weights, float3(1.0f, 1.0f, 1.0f)); weights /= weightSum; weights = lerp(1.0f, weights, _Shape); float rotStrength = _Rotation; float2x2 rot1 = LoadRot2x2(vertex1, rotStrength); float2x2 rot2 = LoadRot2x2(vertex2, rotStrength); float2x2 rot3 = LoadRot2x2(vertex3, rotStrength); float2 cen1 = MakeCenST(vertex1); float2 cen2 = MakeCenST(vertex2); float2 cen3 = MakeCenST(vertex3); float2 st1 = mul(xy - cen1, rot1) + cen1 + hash22(vertex1); float2 st2 = mul(xy - cen2, rot2) + cen2 + hash22(vertex2); float2 st3 = mul(xy - cen3, rot3) + cen3 + hash22(vertex3); float2 dSTdx = ddx(xy), dSTdy = ddy(xy); float4 c1 = _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, float3(st1, index1), mul(dSTdx, rot1), mul(dSTdy, rot1)); float4 c2 = _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, float3(st2, index2), mul(dSTdx, rot2), mul(dSTdy, rot2)); float4 c3 = _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, float3(st3, index3), mul(dSTdx, rot3), mul(dSTdy, rot3)); // use luminance as weight float3 Lw = float3(0.299, 0.587, 0.114); float3 Dw = float3(dot(c1.xyz,Lw),dot(c2.xyz,Lw),dot(c3.xyz,Lw)); Dw = lerp(1.0, Dw, g_fallOffContrast); float3 W = Dw*pow(float3(w1 * weights.x, w2 * weights.y, w3 * weights.z), _G_EXP); W /= (W.x+W.y+W.z); color = W.x * c1 + W.y * c2 + W.z * c3; return color; } ENDHLSL SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { HLSLPROGRAM #pragma vertex vert #pragma fragment frag ENDHLSL } } } æœ€ç»ˆçš„æ•ˆæœ æ•ˆæœçœ‹ä¸Šå»å°±æ˜¯è¿™æ ·äº†ï¼Œå·¦è¾¹æ˜¯è¿œæ™¯çš„æˆªå›¾ï¼Œä»ä¸­æˆ‘ä»¬çœ‹ä¸å‡ºä»»ä½•å¹³é“ºçš„ç—•è¿¹ï¼Œå³è¾¹æ˜¯è¿‘æ™¯çš„æˆªå›¾ï¼Œè¯¥æ€ä¹ˆè¯´å‘¢ï¼Œçœ‹ä¸Šå»å¥½åƒå¾ˆæœ‰æœºåœ°æ··åˆåœ¨äº†ä¸€èµ·ã€‚ã€‚ã€‚\nåè®° å‘ƒå‘ƒè¿™ç¯‡ä¸çŸ¥é“è¯¥æ‰¯äº›å•¥äº†ï¼Œåæ­£æ˜¯ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„æ•ˆæœã€‚å…­è¾¹å½¢å¹³é“ºå¥½æ—©ä¹‹å‰å°±æƒ³åšäº†ï¼Œç»ˆäºæœ‰æ—¶é—´ä¸€è¯•ã€‚å¤§ä½“ä¸Šæ•ˆæœè¿˜æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯å½“å‡ºç°å‚ç›´çš„çº¿æ¡çš„æ—¶å€™ï¼Œä¼šæœ‰å·¦ä¸€ä¸ªå…­è¾¹å½¢ï¼Œå³ä¸€ä¸ªå…­è¾¹å½¢çš„æƒ…å†µå‡ºç°ï¼Œæˆ‘è§‰å¾—å¯èƒ½å¯ä»¥é€šè¿‡æ‰‹åŠ¨ä¿®æ”¹æƒé‡å€¼æ¥ä¼˜åŒ–è¿™ä¸ªé—®é¢˜ï¼Œæˆ–è€…æ˜¯ä¸Šé¢æåˆ°çš„ä¸‰ä¸ªæƒé‡å˜ä¸¤ä¸ªçš„æ–¹æ³•ï¼Œä¸è¿‡ä¹Ÿæ‡’å¾—å†å»è¯•äº†ã€‚\n","wordCount":"1441","inLanguage":"en","image":"https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/posts/images/HexTiling.png","datePublished":"2024-03-19T12:00:00+08:00","dateModified":"2024-03-19T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º</h1><div class=post-description>æ··åˆå¤šå¼ è´´å›¾çš„åŒæ—¶å‡å°‘å¹³é“ºçš„é‡å¤æ„Ÿ.</div><div class=post-meta><span title='2024-03-19 12:00:00 +0800 CST'>March 19, 2024</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/use-hex-tiling-for-terrain-texture-blending.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/HexTiling.png alt="Hex Tiling Cover"><p>Hex Tiling Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba aria-label=åŠ¨æœº>åŠ¨æœº</a></li><li><a href=#%e7%94%9f%e6%88%90%e6%9d%90%e8%b4%a8id%e5%9b%be aria-label=ç”Ÿæˆæè´¨IDå›¾>ç”Ÿæˆæè´¨IDå›¾</a><ul><li><a href=#generatematidcomputeshadercompute aria-label=GenerateMatIDComputeShader.compute>GenerateMatIDComputeShader.compute</a></li><li><a href=#matidgeneratorcs aria-label=MatIDGenerator.cs>MatIDGenerator.cs</a></li></ul></li><li><a href=#%e5%af%b9%e5%9c%b0%e5%bd%a2%e8%b4%b4%e5%9b%be%e5%81%9a%e6%b7%b7%e5%90%88 aria-label=å¯¹åœ°å½¢è´´å›¾åšæ··åˆ>å¯¹åœ°å½¢è´´å›¾åšæ··åˆ</a><ul><li><a href=#hextilingshadershader aria-label=HexTilingShader.shader>HexTilingShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e7%bb%88%e7%9a%84%e6%95%88%e6%9e%9c aria-label=æœ€ç»ˆçš„æ•ˆæœ>æœ€ç»ˆçš„æ•ˆæœ</a></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=åŠ¨æœº>åŠ¨æœº<a hidden class=anchor aria-hidden=true href=#åŠ¨æœº>#</a></h2><p>æœ€è¿‘çœ‹åˆ°äº†ä¸‰è§’æ´²è¡ŒåŠ¨ä»‹ç»çš„<a href=https://www.bilibili.com/video/BV1MC4y1Y7ft>åœ¨è™šå¹»å¼•æ“4ä¸­å®ç°çš„åœ°å½¢æ¸²æŸ“æ–¹æ¡ˆ</a>ï¼Œæ„Ÿè§‰å—ç›ŠåŒªæµ…ã€‚ä¸è¿‡åœ¨Unityä¸­è¦æƒ³å®ç°ä¸€ä¸ªå³æ’å³ç”¨çš„è™šæ‹Ÿè´´å›¾çš„æŠ€æœ¯åº”è¯¥æœ‰äº›å›°éš¾ï¼Œäºæ˜¯æˆ‘æŠŠç›®å…‰æ”¾åœ¨äº†æœ€ä¸€å¼€å§‹æ‰€ä»‹ç»çš„å¯¹åœ°å½¢è´´å›¾åšæ··åˆçš„æ–¹æ¡ˆä¸Šã€‚</p><p>ä¸‰è§’æ´²è¡ŒåŠ¨æå‡ºçš„æ–¹æ¡ˆæ˜¯è¿™æ ·çš„ï¼Œåœ¨åœ°å½¢è®¡ç®—çš„æ—¶å€™ï¼Œä»å¯¹æè´¨IDå›¾çš„å››ä¸ªåƒç´ é‡‡æ ·é€€åŒ–æˆå¯¹ä¸‰ä¸ªåƒç´ é‡‡æ ·ï¼Œè¿™æ ·ä¸€æ¥æ—¢èƒ½å‡å°‘åœ°å½¢æ··åˆçš„æ—¶å€™çš„é‡‡æ ·æ¬¡æ•°ï¼ŒäºŒæ¥ç›¸è¾ƒäºé‡‡æ ·å››ä¸ªåƒç´ ï¼Œä¸‰ä¸ªåƒç´ å¤šäº†ä¸€ä¸ªæ–œå‘45åº¦çš„æ•ˆæœï¼Œèƒ½å¤Ÿå‡è½»ä¸€äº›åœ°å½¢çš„å—é¢æ„Ÿã€‚ä¸è¿‡ä»–ä»¬ä¹Ÿæœ‰è¯­ç„‰ä¸è¯¦çš„åœ°æ–¹ï¼Œè™½ç„¶åªé‡‡æ ·ä¸‰ä¸ªåƒç´ èƒ½å¤Ÿæä¾›æ–œå‘45åº¦ï¼Œä½†æ˜¯å¯¹äºæ–œå‘-45åº¦ï¼Œä»…ä½¿ç”¨åŒä¸€ç§æ–¹å¼é‡‡æ ·ä¸‰ä¸ªåƒç´ æ˜¯ä¸èƒ½æ¶ˆé™¤è¿™ä¸ªæ–¹å‘çš„å—é¢æ„Ÿçš„ï¼Œå½“ç„¶æƒ³å¿…ä»–ä»¬ä¹Ÿæœ‰å¯¹åº”çš„è§£å†³æ–¹æ¡ˆå°±æ˜¯äº†ã€‚æ­¤å¤–ä»–ä»¬å£°ç§°æè´¨IDå›¾æ˜¯ä¸€å¼ R8çš„è´´å›¾ï¼Œä½†è¿™å¼ è´´å›¾é‡Œé¢æ€ä¹ˆä¼šæœ‰5bitçš„ä¸‹å±‚IDï¼Œ5bitçš„ä¸Šå±‚IDï¼Œå†æœ‰3bitçš„æƒé‡å€¼å‘¢ï¼Ÿæˆ‘åªèƒ½è®¤ä¸ºè¿™å¼ æè´¨IDå›¾å®é™…ä¸ŠåªåŒ…å«äº†ä¸€ä¸ª5bitçš„æè´¨IDå’Œ3bitçš„æƒé‡äº†ï¼Œè¿™ä¸ª3bitçš„æƒé‡å€¼ä¼šåœ¨å’Œå¦å¤–å‡ ä¸ªåƒç´ æ··åˆæ—¶ä½¿ç”¨åˆ°ã€‚</p><p>ä¸è¿‡ä¸‰æ¬¡é‡‡æ ·å€’æ˜¯è®©æˆ‘æƒ³èµ·äº†Hex Tilingã€‚åœ¨<a href=https://jcgt.org/published/0011/03/05/>Practical Real-Time Hex-Tiling</a>é‡Œä»‹ç»äº†ä¸€ç§é€šè¿‡å…­è¾¹å½¢å¹³é“ºæ¥é™ä½å¹³é“ºæ—¶çº¹ç†é‡å¤æ„Ÿçš„ç®—æ³•ï¼Œè¿™ç§ç®—æ³•æ­£å·§éœ€è¦å¯¹ä¸»è´´å›¾é‡‡æ ·ä¸‰æ¬¡ï¼ˆä¸è€ƒè™‘éšæœºé‡‡æ ·çš„è¯ï¼‰ã€‚Githubä¸­ä¹Ÿèƒ½æ‰¾åˆ°<a href=https://github.com/mmikk/hextile-demo>å‚è€ƒçš„ä»£ç </a>ã€‚</p><p>è¿™æ ·ä¸€æ¥æˆ‘ä»¬å°±èƒ½åœ¨ä¸‰è§’æ´²è¡ŒåŠ¨çš„æ–¹æ¡ˆä¸Šå†æå‡ºä¸€ç§æ–°çš„åœ°å½¢æ··åˆçš„æ–¹æ³•äº†ã€‚æˆ‘ä»¬åŒæ ·æ˜¯é‡‡æ ·ä¸‰ä¸ªåƒç´ ï¼Œä¸è¿‡æˆ‘ä»¬åœ¨åœ°å½¢ä¸­ä¼šå°†è¿™ä¸‰ä¸ªåƒç´ ç”¨ç­‰è¾¹ä¸‰è§’å½¢çš„æ–¹å¼æ’å¸ƒï¼Œè€Œä¸æ˜¯ç›®å‰æ‰€ç”¨çš„ç›´è§’ä¸‰è§’å½¢ã€‚æ‰€ä»¥æˆ‘ä»¬çš„æµç¨‹æ˜¯ï¼Œå…ˆå°†å½“å‰çš„ä¸–ç•Œç©ºé—´æˆ–è€…uvåšä¸€æ¬¡ä¸‰è§’å½¢æ ¼ç‚¹çš„å˜æ¢ï¼Œä½¿ç”¨å˜æ¢åçš„æ ¼ç‚¹é‡‡æ ·æè´¨IDå›¾è·å¾—ä¸‰ä¸ªæè´¨IDå’Œæƒé‡ï¼Œå†ä½¿ç”¨è·å¾—çš„æ•°æ®å’Œæœ¬èº«çš„å…­è¾¹å½¢å¹³é“ºçš„æƒé‡è¿›è¡Œæ··åˆï¼Œå°±èƒ½å¾—åˆ°æˆ‘ä»¬æœ€ç»ˆçš„æ··åˆåçš„åœ°å½¢æè´¨äº†ã€‚å¦‚æœæŠŠæˆ‘ä»¬çš„æè´¨IDå›¾å¹³é“ºåˆ°ä¸–ç•Œç©ºé—´ï¼Œçœ‹ä¸Šå»åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š</p><p><img loading=lazy src=../images/HexTiledMatIDTex.png#center alt="Hex Tiled MatIDTex"></p><h2 id=ç”Ÿæˆæè´¨idå›¾>ç”Ÿæˆæè´¨IDå›¾<a hidden class=anchor aria-hidden=true href=#ç”Ÿæˆæè´¨idå›¾>#</a></h2><p>ä¸ºäº†å¿«é€Ÿç”Ÿæˆæè´¨IDå›¾ï¼ˆæˆ‘å¯ä¸æƒ³æ‰‹ç”»ï¼‰ï¼Œæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨Compute Shaderé€šè¿‡Perlin Noiseç”Ÿæˆæè´¨IDï¼Œä½¿ç”¨æ™®é€šçš„hashç”Ÿæˆæƒé‡ã€‚ä¸ºäº†ä½¿æˆ‘ä»¬çš„æè´¨IDå›¾ä¹Ÿèƒ½æ­£å¸¸çš„å¹³é“ºï¼Œæˆ‘ä»¬åœ¨è®¡ç®—Perlin Noiseçš„æ—¶å€™ï¼Œè¦æ³¨æ„ä½¿ç”¨å–æ¨¡çš„è¿ç®—å°†è®¡ç®—çš„uvå€¼é™åˆ¶åœ¨åŒä¸€ä¸ªèŒƒå›´å†…ã€‚</p><p>æˆ‘ä»¬åªéœ€è¦ä¸€ä¸ª8bitçš„æ•°æ®ï¼Œä½†æ˜¯ç”±äºUnityä¿å­˜è´´å›¾çš„ç§ç§é™åˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†<code>R8_Uint</code>çš„æ•°æ®é™¤ä»¥255è½¬æ¢æˆ<code>R8_UNorm</code>ç±»å‹çš„æ•°æ®å†å‚¨å­˜åˆ°è´´å›¾ä¸­ã€‚</p><h3 id=generatematidcomputeshadercompute>GenerateMatIDComputeShader.compute<a hidden class=anchor aria-hidden=true href=#generatematidcomputeshadercompute>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel MatIDGenMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _RW_MatIDTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://www.shadertoy.com/view/4djSRW</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> hash12(<span style=color:#66d9ef>float2</span> p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float3</span> p3  <span style=color:#f92672>=</span> frac(<span style=color:#66d9ef>float3</span>(p.xyx) <span style=color:#f92672>*</span> .<span style=color:#ae81ff>1031</span>);
</span></span><span style=display:flex><span>    p3 <span style=color:#f92672>+=</span> dot(p3, p3.yzx <span style=color:#f92672>+</span> <span style=color:#ae81ff>33.33</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> frac((p3.x <span style=color:#f92672>+</span> p3.y) <span style=color:#f92672>*</span> p3.z);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> repeat(<span style=color:#66d9ef>float2</span> coord, <span style=color:#66d9ef>float2</span> size, <span style=color:#66d9ef>float2</span> offset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> coord <span style=color:#f92672>-</span> floor(coord <span style=color:#f92672>/</span> size) <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> encode(<span style=color:#66d9ef>int</span> weight, <span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> encoded <span style=color:#f92672>=</span> (weight <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>) <span style=color:#f92672>|</span> index;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float</span>(encoded) <span style=color:#f92672>/</span> <span style=color:#ae81ff>255.0f</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> noise(<span style=color:#66d9ef>float2</span> p )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> i <span style=color:#f92672>=</span> floor( p );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> f <span style=color:#f92672>=</span> frac( p );	
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> u <span style=color:#f92672>=</span> f<span style=color:#f92672>*</span>f<span style=color:#f92672>*</span>f<span style=color:#f92672>*</span>(f<span style=color:#f92672>*</span>(f<span style=color:#f92672>*</span><span style=color:#ae81ff>6.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>15.0</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>10.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> ts <span style=color:#f92672>=</span> _TextureSize.xy <span style=color:#f92672>/</span> <span style=color:#ae81ff>32.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>50.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rv <span style=color:#f92672>=</span> lerp( lerp( hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>0.0</span>), ts, offset) ), 
</span></span><span style=display:flex><span>                     hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>0.0</span>), ts, offset) ), u.x),
</span></span><span style=display:flex><span>                lerp( hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>1.0</span>), ts, offset) ), 
</span></span><span style=display:flex><span>                     hash12( repeat(i <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0</span>,<span style=color:#ae81ff>1.0</span>), ts, offset)), u.x), u.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rv <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0f</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> MatIDGenMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> hashVal1 <span style=color:#f92672>=</span> hash12(<span style=color:#66d9ef>float2</span>(id.xy) <span style=color:#f92672>+</span> <span style=color:#ae81ff>12.3f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(floor(hashVal1 <span style=color:#f92672>*</span> <span style=color:#ae81ff>8.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rv <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(id.xy) <span style=color:#f92672>/</span> <span style=color:#ae81ff>32.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>50.0f</span>;
</span></span><span style=display:flex><span>	rv  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5000</span><span style=color:#f92672>*</span>noise( uv ); uv <span style=color:#f92672>*=</span><span style=color:#ae81ff>2.0f</span>;
</span></span><span style=display:flex><span>	rv <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.2500</span><span style=color:#f92672>*</span>noise( uv ); uv <span style=color:#f92672>*=</span><span style=color:#ae81ff>2.0f</span>;
</span></span><span style=display:flex><span>	rv <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.1250</span><span style=color:#f92672>*</span>noise( uv ); uv <span style=color:#f92672>*=</span><span style=color:#ae81ff>2.0f</span>;
</span></span><span style=display:flex><span>	rv <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.0625</span><span style=color:#f92672>*</span>noise( uv );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    rv <span style=color:#f92672>=</span> rv <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(rv <span style=color:#f92672>*</span> <span style=color:#ae81ff>32.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> returnVal <span style=color:#f92672>=</span> encode(weight, index);
</span></span><span style=display:flex><span>    _RW_MatIDTex[id.xy] <span style=color:#f92672>=</span> returnVal;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=matidgeneratorcs>MatIDGenerator.cs<a hidden class=anchor aria-hidden=true href=#matidgeneratorcs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MatIDGenerator</span> : EditorWindow
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TextureSize textureSize = TextureSize._256x256;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> savePath = <span style=color:#e6db74>&#34;Assets/HexTiling/MatID&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> suffix = <span style=color:#e6db74>&#34;.tga&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RenderTexture rt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>enum</span> TextureSize
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _256x256 = <span style=color:#ae81ff>256</span>,
</span></span><span style=display:flex><span>        _512x512 = <span style=color:#ae81ff>512</span>,
</span></span><span style=display:flex><span>        _1024x1024 = <span style=color:#ae81ff>1024</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Rect rect
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20.0f</span>, <span style=color:#ae81ff>20.0f</span>, position.width - <span style=color:#ae81ff>40.0f</span>, position.height - <span style=color:#ae81ff>10.0f</span>); }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRT()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span> || rt.width != (<span style=color:#66d9ef>int</span>)textureSize || rt.height != (<span style=color:#66d9ef>int</span>)textureSize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                width = (<span style=color:#66d9ef>int</span>)textureSize,
</span></span><span style=display:flex><span>                height = (<span style=color:#66d9ef>int</span>)textureSize,
</span></span><span style=display:flex><span>                volumeDepth = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                dimension = UnityEngine.Rendering.TextureDimension.Tex2D,
</span></span><span style=display:flex><span>                depthBufferBits = <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                msaaSamples = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm,
</span></span><span style=display:flex><span>                enableRandomWrite = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            rt = <span style=color:#66d9ef>new</span> RenderTexture(desc);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [MenuItem(&#34;zznewclear13/Mat ID Generator&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Init()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MatIDGenerator window = GetWindow&lt;MatIDGenerator&gt;(<span style=color:#e6db74>&#34;Mat ID Generator&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        window.Show();
</span></span><span style=display:flex><span>        window.Repaint();
</span></span><span style=display:flex><span>        window.Focus();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader = (ComputeShader)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Compute Shader&#34;</span>, computeShader, <span style=color:#66d9ef>typeof</span>(ComputeShader), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>            textureSize = (TextureSize)EditorGUILayout.EnumPopup(<span style=color:#e6db74>&#34;Output Texture Size&#34;</span>, textureSize);
</span></span><span style=display:flex><span>            savePath = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Path&#34;</span>, savePath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!computeShader))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Generate!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30.0f</span>) }))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    GenerateMatID();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateMatID()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EnsureRT();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ts = (<span style=color:#66d9ef>float</span>)textureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;MatIDGenMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        Vector2Int dispatchCount = <span style=color:#66d9ef>new</span> Vector2Int(Mathf.CeilToInt(ts / x),
</span></span><span style=display:flex><span>                                                    Mathf.CeilToInt(ts / y));
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_MatIDTex&#34;</span>, rt);
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(ts, ts, <span style=color:#ae81ff>1.0f</span> / ts, <span style=color:#ae81ff>1.0f</span> / ts));
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernelID, dispatchCount.x, dispatchCount.y, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        SaveRenderTextureToFile(rt);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveRenderTextureToFile(RenderTexture rt)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        RenderTexture prev = RenderTexture.active;
</span></span><span style=display:flex><span>        RenderTexture.active = rt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ts = (<span style=color:#66d9ef>int</span>)textureSize;
</span></span><span style=display:flex><span>        Texture2D toSave = <span style=color:#66d9ef>new</span> Texture2D(ts, ts, TextureFormat.R8, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        toSave.ReadPixels(<span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, ts, ts), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>[] bytes = toSave.EncodeToTGA();
</span></span><span style=display:flex><span>        FileStream fs = File.OpenWrite(savePath + suffix);
</span></span><span style=display:flex><span>        fs.Write(bytes);
</span></span><span style=display:flex><span>        fs.Close();
</span></span><span style=display:flex><span>        AssetDatabase.Refresh();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix);
</span></span><span style=display:flex><span>        ti.mipmapEnabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        ti.sRGBTexture = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        ti.textureCompression = TextureImporterCompression.Uncompressed;
</span></span><span style=display:flex><span>        ti.SaveAndReimport();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Texture2D tempTexture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(savePath + suffix);
</span></span><span style=display:flex><span>        EditorGUIUtility.PingObject(tempTexture);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        RenderTexture.active = prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=å¯¹åœ°å½¢è´´å›¾åšæ··åˆ>å¯¹åœ°å½¢è´´å›¾åšæ··åˆ<a hidden class=anchor aria-hidden=true href=#å¯¹åœ°å½¢è´´å›¾åšæ··åˆ>#</a></h2><p>ä¸ºäº†ç®€ä¾¿ï¼Œæˆ‘ä»¬åªå¯¹åœ°å½¢çš„Base Colorè¿›è¡Œæ··åˆï¼Œè¦æƒ³å¯¹æ³•çº¿æˆ–è€…æ˜¯ä¸‰å¹³é¢æ˜ å°„è¿›è¡Œæ··åˆï¼ŒHex Tilingçš„ä»£ç æ¡ˆä¾‹é‡Œä¹Ÿæä¾›äº†ç›¸åº”çš„å‡½æ•°ã€‚æˆ‘é¢å¤–çš„ä½¿ç”¨äº†ä¸€ä¸ª<code>_Shape</code>å‚æ•°ï¼Œæ•°å€¼è¶Šå°å°±è¶Šå¤šåœ°æ˜¾ç¤ºå‡ºå…­è¾¹å½¢çš„ç‰¹å¾ï¼Œè¶Šå¤§åˆ™è¶Šå¤šåœ°æ˜¾ç¤ºå‡ºæƒé‡æ··åˆçš„ç‰¹å¾ã€‚æƒé‡æ··åˆåº”è¯¥è¿˜æœ‰æ›´å¥½çš„æ–¹å¼ï¼Œæ¯”å¦‚å½“ä¸‰è§’å½¢çš„ä¸¤ä¸ªç‚¹æè´¨IDä¸€è‡´çš„æ—¶å€™ï¼Œå°†æ··åˆçš„æ•ˆæœä»ä¸‰ä¸ªæƒé‡æ··åˆç®€åŒ–æˆä¸¤ä¸ªæƒé‡æ··åˆï¼Œä¸è¿‡è¿™ä¸ªåç»­æœ‰æ—¶é—´å†è€ƒè™‘å§ã€‚è¿™ä¸ªShaderä¹Ÿèƒ½æ”¯æŒ32å¼ åœ°å½¢è´´å›¾çš„æ··åˆï¼Œç¬¬142è¡Œæ”¹æˆ<code>index = (data & 31);</code>å³å¯ï¼Œä¸è¿‡æˆ‘å¯æ²¡é‚£ä¹ˆå¤šå¼ è´´å›¾ï¼Œå°±é™åˆ¶åˆ°4å¼ äº†ã€‚</p><h3 id=hextilingshadershader>HexTilingShader.shader<a hidden class=anchor aria-hidden=true href=#hextilingshadershader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>// MIT License</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Copyright (c) 2024 zznewclear@gmail.com</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Copyright (c) 2022 mmikk</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Permission is hereby granted, free of charge, to any person obtaining a copy</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// of this software and associated documentation files (the &#34;Software&#34;), to deal</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// in the Software without restriction, including without limitation the rights</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copies of the Software, and to permit persons to whom the Software is</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// furnished to do so, subject to the following conditions:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The above copyright notice and this permission notice shall be included in all</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copies or substantial portions of the Software.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// SOFTWARE.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/HexTilingShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>		_MatIDTex (<span style=color:#e6db74>&#34;Mat ID Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;black&#34;</span> {}
</span></span><span style=display:flex><span>		_TerrainMainTex (<span style=color:#e6db74>&#34;Terrain Main Tex&#34;</span>, <span style=color:#ae81ff>2</span>DArray) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_Rotation (<span style=color:#e6db74>&#34;Rotation&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>		_Shape (<span style=color:#e6db74>&#34;Shape&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>		_G_EXP (<span style=color:#e6db74>&#34;G Exp&#34;</span>, Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>#</span>define M_PI <span style=color:#ae81ff>3.1415926f</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> g_fallOffContrast <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.6</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> g_exp <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>Texture2DArray</span> _TerrainMainTex;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _MatIDTex;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SamplerState</span> sampler_MainTex;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SamplerState</span> sampler_TerrainMainTex;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SamplerState</span> sampler_PointRepeat;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> _MatIDTex_TexelSize;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> _Rotation;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> _Shape;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> _G_EXP;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        output.positionWS <span style=color:#f92672>=</span> vpi.positionWS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> hash22(<span style=color:#66d9ef>float2</span> p)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float3</span> p3 <span style=color:#f92672>=</span> frac(<span style=color:#66d9ef>float3</span>(p.xyx) <span style=color:#f92672>*</span> <span style=color:#66d9ef>float3</span>(.<span style=color:#ae81ff>1031</span>, .<span style=color:#ae81ff>1030</span>, .<span style=color:#ae81ff>0</span><span style=color:#ae81ff>973</span>));
</span></span><span style=display:flex><span>		p3 <span style=color:#f92672>+=</span> dot(p3, p3.yzx<span style=color:#f92672>+</span><span style=color:#ae81ff>33.33</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> frac((p3.xx<span style=color:#f92672>+</span>p3.yz)<span style=color:#f92672>*</span>p3.zy);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> TriangleGrid(<span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> w1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> w2, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> w3, 
</span></span><span style=display:flex><span>				  <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> vertex1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> vertex2, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> vertex3,
</span></span><span style=display:flex><span>				  <span style=color:#66d9ef>float2</span> st)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// Scaling of the input</span>
</span></span><span style=display:flex><span>	    st <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> sqrt(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// Skew input space into simplex triangle grid</span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float2x2</span> gridToSkewedGrid <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>float2x2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.57735027</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.15470054</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> skewedCoord <span style=color:#f92672>=</span> mul(gridToSkewedGrid, st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> baseId <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>( floor ( skewedCoord ));
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> temp <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>( frac( skewedCoord ), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    temp.z <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> temp.x <span style=color:#f92672>-</span> temp.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> s <span style=color:#f92672>=</span> step(<span style=color:#ae81ff>0.0</span>, <span style=color:#f92672>-</span>temp.z);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> s2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>s<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    w1 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>temp.z<span style=color:#f92672>*</span>s2;
</span></span><span style=display:flex><span>	    w2 <span style=color:#f92672>=</span> s <span style=color:#f92672>-</span> temp.y<span style=color:#f92672>*</span>s2;
</span></span><span style=display:flex><span>	    w3 <span style=color:#f92672>=</span> s <span style=color:#f92672>-</span> temp.x<span style=color:#f92672>*</span>s2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    vertex1 <span style=color:#f92672>=</span> baseId <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(s,s);
</span></span><span style=display:flex><span>	    vertex2 <span style=color:#f92672>=</span> baseId <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(s,<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>s);
</span></span><span style=display:flex><span>	    vertex3 <span style=color:#f92672>=</span> baseId <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>s,s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> MakeCenST(<span style=color:#66d9ef>int2</span> Vertex)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2x2</span> invSkewMat <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2x2</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.15470054</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> mul(invSkewMat, Vertex) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> sqrt(<span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2x2</span> LoadRot2x2(<span style=color:#66d9ef>int2</span> idx, <span style=color:#66d9ef>float</span> rotStrength)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> angle <span style=color:#f92672>=</span> abs(idx.x<span style=color:#f92672>*</span>idx.y) <span style=color:#f92672>+</span> abs(idx.x<span style=color:#f92672>+</span>idx.y) <span style=color:#f92672>+</span> M_PI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    angle <span style=color:#f92672>=</span> fmod(angle, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>M_PI); 
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span>(angle<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>) angle <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>M_PI;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span>(angle<span style=color:#f92672>&gt;</span>M_PI) angle <span style=color:#f92672>-=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>M_PI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    angle <span style=color:#f92672>*=</span> rotStrength;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float</span> cs <span style=color:#f92672>=</span> cos(angle), si <span style=color:#f92672>=</span> sin(angle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float2x2</span>(cs, <span style=color:#f92672>-</span>si, si, cs);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span> repeat(<span style=color:#66d9ef>int2</span> coord, <span style=color:#66d9ef>float2</span> size)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> coord <span style=color:#f92672>-</span> <span style=color:#66d9ef>int2</span>(floor(<span style=color:#66d9ef>float2</span>(coord) <span style=color:#f92672>/</span> size) <span style=color:#f92672>*</span> size);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> decodeData(<span style=color:#66d9ef>int</span> data, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> weight, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		index <span style=color:#f92672>=</span> (data <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>31</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> iWeight <span style=color:#f92672>=</span> (data<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>5</span>)<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>		weight <span style=color:#f92672>=</span> <span style=color:#66d9ef>float</span>(iWeight <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>8.0f</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> xy <span style=color:#f92672>=</span> input.positionWS.xz <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.3f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> color;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> w1, w2, w3;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> vertex1, vertex2, vertex3;
</span></span><span style=display:flex><span>	    TriangleGrid(w1, w2, w3, vertex1, vertex2, vertex3, xy);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> rect1 <span style=color:#f92672>=</span> vertex1 <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(vertex1.y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> rect2 <span style=color:#f92672>=</span> vertex2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(vertex2.y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int2</span> rect3 <span style=color:#f92672>=</span> vertex3 <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(vertex3.y <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float2</span> size <span style=color:#f92672>=</span> _MatIDTex_TexelSize.zw;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> data1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_MatIDTex.Load(<span style=color:#66d9ef>int3</span>(repeat(rect1, size), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>255.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> data2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_MatIDTex.Load(<span style=color:#66d9ef>int3</span>(repeat(rect2, size), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>255.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> data3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_MatIDTex.Load(<span style=color:#66d9ef>int3</span>(repeat(rect3, size), <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>255.0f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> weight1, weight2, weight3;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> index1, index2, index3;
</span></span><span style=display:flex><span>		decodeData(data1, weight1, index1);decodeData(data2, weight2, index2);decodeData(data3, weight3, index3);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float3</span> weights <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(weight1, weight2, weight3);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> weightSum <span style=color:#f92672>=</span> dot(weights, <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>		weights <span style=color:#f92672>/=</span> weightSum;
</span></span><span style=display:flex><span>		weights <span style=color:#f92672>=</span> lerp(<span style=color:#ae81ff>1.0f</span>, weights, _Shape);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> rotStrength <span style=color:#f92672>=</span> _Rotation;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float2x2</span> rot1 <span style=color:#f92672>=</span> LoadRot2x2(vertex1, rotStrength);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2x2</span> rot2 <span style=color:#f92672>=</span> LoadRot2x2(vertex2, rotStrength);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2x2</span> rot3 <span style=color:#f92672>=</span> LoadRot2x2(vertex3, rotStrength);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> cen1 <span style=color:#f92672>=</span> MakeCenST(vertex1);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> cen2 <span style=color:#f92672>=</span> MakeCenST(vertex2);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> cen3 <span style=color:#f92672>=</span> MakeCenST(vertex3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> st1 <span style=color:#f92672>=</span> mul(xy <span style=color:#f92672>-</span> cen1, rot1) <span style=color:#f92672>+</span> cen1 <span style=color:#f92672>+</span> hash22(vertex1);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> st2 <span style=color:#f92672>=</span> mul(xy <span style=color:#f92672>-</span> cen2, rot2) <span style=color:#f92672>+</span> cen2 <span style=color:#f92672>+</span> hash22(vertex2);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> st3 <span style=color:#f92672>=</span> mul(xy <span style=color:#f92672>-</span> cen3, rot3) <span style=color:#f92672>+</span> cen3 <span style=color:#f92672>+</span> hash22(vertex3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float2</span> dSTdx <span style=color:#f92672>=</span> ddx(xy), dSTdy <span style=color:#f92672>=</span> ddy(xy);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> c1 <span style=color:#f92672>=</span> _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, <span style=color:#66d9ef>float3</span>(st1, index1), mul(dSTdx, rot1), mul(dSTdy, rot1));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> c2 <span style=color:#f92672>=</span> _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, <span style=color:#66d9ef>float3</span>(st2, index2), mul(dSTdx, rot2), mul(dSTdy, rot2));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float4</span> c3 <span style=color:#f92672>=</span> _TerrainMainTex.SampleGrad(sampler_TerrainMainTex, <span style=color:#66d9ef>float3</span>(st3, index3), mul(dSTdx, rot3), mul(dSTdy, rot3));
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>		<span style=color:#75715e>// use luminance as weight</span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> Lw <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.299</span>, <span style=color:#ae81ff>0.587</span>, <span style=color:#ae81ff>0.114</span>);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> Dw <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(dot(c1.xyz,Lw),dot(c2.xyz,Lw),dot(c3.xyz,Lw));
</span></span><span style=display:flex><span>	    Dw <span style=color:#f92672>=</span> lerp(<span style=color:#ae81ff>1.0</span>, Dw, g_fallOffContrast);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>float3</span> W <span style=color:#f92672>=</span> Dw<span style=color:#f92672>*</span>pow(<span style=color:#66d9ef>float3</span>(w1 <span style=color:#f92672>*</span> weights.x, w2 <span style=color:#f92672>*</span> weights.y, w3 <span style=color:#f92672>*</span> weights.z), _G_EXP);
</span></span><span style=display:flex><span>	    W <span style=color:#f92672>/=</span> (W.x<span style=color:#f92672>+</span>W.y<span style=color:#f92672>+</span>W.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    color <span style=color:#f92672>=</span> W.x <span style=color:#f92672>*</span> c1 <span style=color:#f92672>+</span> W.y <span style=color:#f92672>*</span> c2 <span style=color:#f92672>+</span> W.z <span style=color:#f92672>*</span> c3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> color;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Opaque&#34;</span> }
</span></span><span style=display:flex><span>        LOD <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=æœ€ç»ˆçš„æ•ˆæœ>æœ€ç»ˆçš„æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#æœ€ç»ˆçš„æ•ˆæœ>#</a></h2><p>æ•ˆæœçœ‹ä¸Šå»å°±æ˜¯è¿™æ ·äº†ï¼Œå·¦è¾¹æ˜¯è¿œæ™¯çš„æˆªå›¾ï¼Œä»ä¸­æˆ‘ä»¬çœ‹ä¸å‡ºä»»ä½•å¹³é“ºçš„ç—•è¿¹ï¼Œå³è¾¹æ˜¯è¿‘æ™¯çš„æˆªå›¾ï¼Œè¯¥æ€ä¹ˆè¯´å‘¢ï¼Œçœ‹ä¸Šå»å¥½åƒå¾ˆæœ‰æœºåœ°æ··åˆåœ¨äº†ä¸€èµ·ã€‚ã€‚ã€‚</p><p><img loading=lazy src=../images/HexTiling.png#center alt="Hex Tiling"></p><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>å‘ƒå‘ƒè¿™ç¯‡ä¸çŸ¥é“è¯¥æ‰¯äº›å•¥äº†ï¼Œåæ­£æ˜¯ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„æ•ˆæœã€‚å…­è¾¹å½¢å¹³é“ºå¥½æ—©ä¹‹å‰å°±æƒ³åšäº†ï¼Œç»ˆäºæœ‰æ—¶é—´ä¸€è¯•ã€‚å¤§ä½“ä¸Šæ•ˆæœè¿˜æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯å½“å‡ºç°å‚ç›´çš„çº¿æ¡çš„æ—¶å€™ï¼Œä¼šæœ‰å·¦ä¸€ä¸ªå…­è¾¹å½¢ï¼Œå³ä¸€ä¸ªå…­è¾¹å½¢çš„æƒ…å†µå‡ºç°ï¼Œæˆ‘è§‰å¾—å¯èƒ½å¯ä»¥é€šè¿‡æ‰‹åŠ¨ä¿®æ”¹æƒé‡å€¼æ¥ä¼˜åŒ–è¿™ä¸ªé—®é¢˜ï¼Œæˆ–è€…æ˜¯ä¸Šé¢æåˆ°çš„ä¸‰ä¸ªæƒé‡å˜ä¸¤ä¸ªçš„æ–¹æ³•ï¼Œä¸è¿‡ä¹Ÿæ‡’å¾—å†å»è¯•äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/terrain/>Terrain</a></li><li><a href=https://zznewclear13.github.io/tags/hex-tiling/>Hex Tiling</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/><span class=title>Â« Prev</span><br><span>å¾„å‘åˆ†æ´¾Compute Shader</span>
</a><a class=next href=https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/><span class=title>Next Â»</span><br><span>ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>