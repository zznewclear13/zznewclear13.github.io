<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼ | ZZNEWCLEAR13</title>
<meta name=keywords content="Relaxed Cone Step Mapping,Parallax Occlusion Mapping,Space Transformation"><meta name=description content="åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼"><meta property="og:description" content="åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/"><meta property="og:image" content="https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/posts/images/CorrectDepth_POM_RCSM.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-16T12:00:00+08:00"><meta property="article:modified_time" content="2024-03-16T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/posts/images/CorrectDepth_POM_RCSM.png"><meta name=twitter:title content="ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼"><meta name=twitter:description content="åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼","item":"https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼","name":"ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼","description":"åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º.","keywords":["Relaxed Cone Step Mapping","Parallax Occlusion Mapping","Space Transformation"],"articleBody":"POMå’ŒRCSM åœ¨æˆ‘ä¹‹å‰çš„æ–‡ç« åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mappingå°±å·²ç»ä»‹ç»è¿‡äº†è§†å·®æ˜ å°„å’Œæ¾æ•£åœ†é”¥æ­¥è¿›æµ®é›•æ˜ å°„çš„è®¡ç®—æ–¹æ³•äº†ï¼Œä½†æ˜¯ä¹‹å‰å¹¶æ²¡æœ‰å¯¹è®¡ç®—æ·±åº¦å€¼åšç›¸åº”çš„ç ”ç©¶ï¼ŒåŒæ—¶ä¹Ÿé™åˆ¶äºç¯‡å¹…çš„åŸå› å°±æ²¡æœ‰å†å±•å¼€äº†ï¼Œè¿™ç¯‡æ–‡ç« ç›¸å½“äºæ˜¯ä¹‹å‰æ–‡ç« çš„åç»­ã€‚ä¸ºäº†ç®€ä¾¿ï¼Œåç»­å°†è¿™ä¸¤ç§è®¡ç®—æ–¹æ³•ç»Ÿç§°ä¸ºè§†å·®æ˜ å°„ã€‚\nåœ¨è§†å·®æ˜ å°„ä¸­è®¡ç®—æ·±åº¦å€¼æ˜¯ä¸€ä¸ªå¾ˆç›´æ¥çš„æƒ³æ³•ï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½ä¼šæœ‰å…¶ä»–ç‰©ä½“è¢«æ”¾ç½®åœ¨è§†å·®æ˜ å°„çš„è¡¨é¢ï¼Œä¸ä¹‹å‘ç”Ÿç©¿æ’ï¼Œå¦‚æœä¸åšç‰¹æ®Šå¤„ç†ï¼Œå°±ä¼šä½¿ç”¨æ¨¡å‹æœ¬èº«çš„æ·±åº¦å€¼è¿›è¡Œæ·±åº¦æ¯”è¾ƒï¼Œå¯¼è‡´åˆ«çš„ç‰©ä½“ä¸èƒ½æœ‰æ­£ç¡®çš„è¢«é®æŒ¡çš„æ•ˆæœï¼Œå‰Šå¼±äº†è§†å·®æ˜ å°„å¸¦æ¥çš„çœŸå®æ„Ÿã€‚ç½‘ä¸Šæˆ‘æ‰¾äº†ä¸€åœˆï¼Œå¹¶æ²¡æœ‰æ‰¾åˆ°å’Œè®¡ç®—è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ç›¸å…³çš„æ–‡ç« ï¼Œå› æ­¤æˆ‘æƒ³ç”¨è¿™ç¯‡æ–‡ç« è¿›è¡Œç›¸å…³çš„ä»‹ç»ã€‚\nUnityçš„é«˜æ¸…ç®¡çº¿ï¼ˆHDRPï¼‰çš„Lit Shaderæ”¯æŒè®¡ç®—åƒç´ æ·±åº¦åç§»ï¼Œæä¾›äº†Primitive Lengthï¼ŒPrimitive Widthï¼Œå’ŒAmplitudeä¸‰ä¸ªå‚æ•°ã€‚Amplitudeå¯ä»¥ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„å¼ºåº¦å€¼ï¼Œè™½ç„¶å…¶ä¸€ä¸ªå•ä½å’Œä¸–ç•Œç©ºé—´çš„ä¸€ç±³å®Œå…¨ä¸èƒ½ç›´æ¥ç­‰åŒèµ·æ¥ï¼Œä½†æ˜¯å€¼è¶Šå¤§è§†å·®çœ‹ä¸Šå»å°±è¶Šæ·±ï¼Œå¯ä»¥æ ¹æ®è§†è§‰å®æ—¶è°ƒæ•´è¿™ä¸ªå‚æ•°ã€‚å¦å¤–ä¸¤ä¸ªå‚æ•°å°±å¾ˆå¥‡æ€ªäº†ï¼Œå±…ç„¶å’Œæ¨¡å‹çš„å¤§å°æœ‰å…³ï¼ŒåŒä¸€ä¸ªæè´¨çƒï¼Œç”¨åœ¨Quadä¸Šè¿™é‡Œå°±è¦å¡«1ï¼Œç”¨åœ¨Planeä¸Šå°±è¦å¡«10ï¼Œå“ªæœ‰è¿™ç§é“ç†ï¼Ÿè™šå¹»å¼•æ“åˆ™æ˜¯æä¾›äº†POMçš„æ¥å£ï¼Œè‡³äºè¾“å…¥å’Œè¾“å‡ºå®Œå…¨éƒ½ç”±ç”¨æˆ·æ§åˆ¶ï¼Œè¿™é‡Œå°±ä¸å¤ªå¥½ç›´æ¥æ¯”è¾ƒäº†ã€‚\nå›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹ è§†å·®æ˜ å°„ä¸€èˆ¬ä¸ä¼šç›´æ¥åœ¨ä¸–ç•Œç©ºé—´æ­¥è¿›ï¼Œè€Œæ˜¯ä¼šå…ˆå°†ä¸–ç•Œç©ºé—´çš„è§†çº¿viewWSè½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´viewTSï¼Œåœ¨åˆ‡çº¿ç©ºé—´æ­¥è¿›ã€‚ç…§å¸¸ç†_ParallaxIntensityæ˜¯ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„æ·±åº¦çš„ï¼Œå› æ­¤ä¼šä½¿ç”¨è¿™ä¸ªå‚æ•°æ§åˆ¶zæ–¹å‘æ­¥è¿›çš„è·ç¦»ï¼Œä½†ä¸ºäº†æ–¹ä¾¿å’Œé«˜åº¦å›¾ä¸­è®°è½½çš„é«˜åº¦è¿›è¡Œå¯¹æ¯”ï¼Œä¼šå…ˆå¯¹viewTSçš„zåˆ†é‡è¿›è¡Œå½’ä¸€åŒ–ï¼Œå°†_ParallaxIntensityåœ¨æ­¥è¿›æ—¶ä¹˜åˆ°viewTSçš„xyåˆ†é‡ä¸Šï¼Œä¹‹åå°±æ˜¯å¾ªç¯æ¯”è¾ƒæ·±åº¦è¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯äº†ã€‚\nä½†æ˜¯ä¸ºä»€ä¹ˆæ˜¯åˆ‡çº¿ç©ºé—´å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºåˆ‡çº¿tangentå’Œå‰¯åˆ‡çº¿bitangentä»£è¡¨äº†è´´å›¾UVçš„xyçš„æ­£æ–¹å‘ï¼Œå°†è§†çº¿è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´ï¼Œå…¶å®ç›®çš„æ˜¯å°†è§†çº¿è½¬åˆ°UVç©ºé—´ï¼Œæˆ–è€…è¯´æ˜¯è´´å›¾ç©ºé—´ï¼ˆTexture Spaceï¼Œå› ä¸ºå…¶ä¸åˆ‡çº¿ç©ºé—´çš„ç›¸ä¼¼æ€§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç”¨TSæ¥åšç®€å†™ï¼‰ã€‚è¿™é‡Œå°±å‡ºç°äº†æœ€é‡è¦çš„ä¸€ä¸ªé—®é¢˜ï¼ŒUnityä¸­é€šè¿‡GetVertexNormalInputsè·å¾—åˆ°çš„ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿æ˜¯ç»è¿‡å½’ä¸€åŒ–çš„ï¼Œä¸¢å¤±äº†ç‰©ä½“è‡ªèº«çš„ç¼©æ”¾ï¼Œæ‰€ä»¥æˆ‘ä»¬å…¶å®åº”è¯¥å…ˆå°†ä¸–ç•Œåæ ‡çš„è§†çº¿viewWSè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´viewOSï¼Œç„¶åå†ä½¿ç”¨ç‰©ä½“ç©ºé—´çš„tbnçŸ©é˜µï¼Œå°†viewOSè½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´viewTSã€‚ä½†åˆå¦‚æˆ‘ä¸Šé¢è¯´åˆ°çš„ï¼Œæˆ‘ä»¬çœŸå®çš„ç›®çš„æ˜¯è´´å›¾ç©ºé—´ï¼Œåˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´æ˜¯å­˜åœ¨å·®å¼‚æ€§çš„ã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆUnityçš„HDRPè¦ä½¿ç”¨é¢å¤–çš„å‚æ•°Primitive Lengthå’ŒPrimitive Widthäº†ï¼Œè¿™ä¸¤ä¸ªå‚æ•°çš„ç›®çš„æ˜¯é€šè¿‡é¢å¤–çš„ç¼©æ”¾ï¼Œå°†åˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´å¯¹åº”èµ·æ¥ã€‚\nè¿™ä¸¤ä¸ªå‚æ•°çš„æ„ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ï¼Œè¿™é‡Œæˆ‘ä»¬è®°ä¸ºuvScaleã€‚åŒæ—¶æˆ‘ä»¬å¯ä»¥é¡ºç†æˆç« åœ°æ­£å¼å¼•å…¥_ParallaxIntensityè¿™ä¸ªå‚æ•°ï¼Œå®ƒçš„å«ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ä¸­é¢œè‰²ä¸º0çš„ç‚¹å¯¹åº”çš„ç‰©ä½“ç©ºé—´çš„æ·±åº¦å€¼ã€‚è´´å›¾ç©ºé—´è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´ï¼Œåªéœ€è¦å¯¹xyzä¸‰ä¸ªåˆ†é‡åˆ†åˆ«ä¹˜ä¸ŠuvScale.xï¼ŒuvScale.yï¼Œå’Œ_ParallaxIntensityå³å¯ã€‚_ParallaxIntensityè¿™ä¸ªå‚æ•°æˆ‘ä»¬å¯ä»¥ä½œä¸ºæè´¨çƒçš„ä¸€ä¸ªè¾“å…¥è¿›è¡Œæ§åˆ¶ï¼ŒuvScaleæ˜¯ä¸€ä¸ªè·Ÿæ¨¡å‹ç›¸å…³çš„å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Geometry Shaderä¸­è®¡ç®—è€Œå¾—ã€‚\nuvScaleçš„è®¡ç®— å¦‚ä¸Šé¢æ‰€å±ï¼ŒuvScaleæŒ‡ä»£çš„æ˜¯è´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ã€‚å¯¹äºä¸¤ä¸ªé¡¶ç‚¹v0å’Œv1ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡å…¶å®å°±æ˜¯è¿™ä¸¤ä¸ªé¡¶ç‚¹uvå€¼çš„å·®ï¼Œç‰©ä½“ç©ºé—´çš„é•¿åº¦å…¶å®å°±æ˜¯ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œä¸ºäº†å¯¹åº”åˆ°è´´å›¾ç©ºé—´ä¸Šï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—è¿™æ®µè·ç¦»åœ¨åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ä¸Šçš„æŠ•å½±é•¿åº¦ï¼Œåè€…é™¤ä»¥å‰è€…å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„uvScaleäº†ã€‚ç”±äºæ„æˆä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹å¯èƒ½ä¼šå­˜åœ¨æŸä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´uvçš„æŸä¸ªåˆ†é‡çš„å˜åŒ–ç‡ä¸º0ï¼Œå¯¼è‡´æˆ‘ä»¬è®¡ç®—uvScaleçš„æ—¶å€™é™¤ä»¥é›¶ï¼Œæˆ‘ä»¬åœ¨æ£€æµ‹åˆ°è¿™ä¸ªæƒ…å†µçš„æ—¶å€™ä½¿ç”¨ç¬¬ä¸‰ä¸ªé¡¶ç‚¹å³å¯ã€‚\nè´´å›¾ç©ºé—´å˜æ¢ åœ¨è·å¾—äº†ç‰©ä½“ç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿ä¹‹åï¼Œä¸ºäº†æ„æˆè´´å›¾ç©ºé—´çš„ä¸‰ä¸ªåŸºå‘é‡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹è¿™ä¸ªå‘é‡ä½¿ç”¨uvScaleå’Œ_ParallaxIntensityè¿›è¡Œç¼©æ”¾ã€‚è¿™ä¸ªç¼©æ”¾å¯¼è‡´äº†æˆ‘ä»¬æŒ‰ç…§ä»¥å¾€çš„float3x3(tangentOS * uvScale.x, bitangentOS * uvScale.y, normalOS * _ParallaxIntensity)æ„æˆçš„çŸ©é˜µä¸å†æ˜¯ä¸€ä¸ªæ­£äº¤çŸ©é˜µï¼Œå®ƒå®é™…ä¸Šæ˜¯è´´å›¾ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„å˜æ¢çŸ©é˜µçš„è½¬ç½®ã€‚å› æ­¤å°†ç‰©ä½“ç©ºé—´çš„è§†çº¿viewOSè½¬æ¢åˆ°è´´å›¾ç©ºé—´viewTSæ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®çš„é€†å·¦ä¹˜viewOSï¼Œå°†è´´å›¾ç©ºé—´çš„è§†çº¿viewTSè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´viewOSæ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®å·¦ä¹˜viewTSã€‚\næ·±åº¦çš„è·å– è¿™ä¸ªå°±ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•äº†ï¼Œæˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„æ—¶å€™ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„zæ–¹å‘çš„æ·±åº¦å€¼lenã€‚è€Œç”±äºæˆ‘ä»¬çš„viewTSä¼šåšé™¤ä»¥zåˆ†é‡çš„å½’ä¸€åŒ–ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å½’ä¸€åŒ–å‰çš„-viewTSä¹˜ä¸Šlenå†é™¤ä»¥zåˆ†é‡ï¼Œå°±èƒ½çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´ä¸­æ€»çš„æ­¥è¿›çš„å‘é‡ï¼Œå°†å…¶è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´ï¼Œå’Œå½“å‰ç‚¹çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ç›¸åŠ åå†è½¬æ¢åˆ°è£å‰ªç©ºé—´ï¼Œå…¶zåˆ†é‡é™¤ä»¥wåˆ†é‡å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„æ·±åº¦å€¼äº†ã€‚\nå…·ä½“çš„ä»£ç  è¿™é‡Œåªåšäº†å¯è¡Œæ€§çš„ç ”ç©¶ï¼Œåº”è¯¥æœ‰ä¸ªæ–¹æ³•èƒ½å¤Ÿç®€åŒ–è®¡ç®—çŸ©é˜µçš„é€†è¿™ä¸€æ­¥æ“ä½œã€‚åœ¨è®¡ç®—ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿çš„æ—¶å€™ï¼Œå¯ä»¥ä¸è¿›è¡Œå½’ä¸€åŒ–ï¼Œè¿™æ ·æˆ‘ä»¬ä¹Ÿå°±ä¸éœ€è¦å…ˆè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°è´´å›¾ç©ºé—´äº†ã€‚\nPOMShader.shader Shader \"zznewclear13/POMShader\" { Properties { [Toggle(OUTPUT_DEPTH)] _OutputDepth (\"Output Depth\", Float) = 1 _BaseColor(\"Base Color\", Color) = (1, 1, 1, 1) _MainTex (\"Texture\", 2D) = \"white\" {} _HeightMap(\"Height Map\", 2D) = \"white\" {} _NormalMap(\"Normal Map\", 2D) = \"bump\" {} _NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1 _ParallaxIntensity (\"Parallax Intensity\", Float) = 1 _ParallaxIteration (\"Parallax Iteration\", Float) = 15 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" #pragma shader_feature OUTPUT_DEPTH sampler2D _MainTex; sampler2D _HeightMap; sampler2D _NormalMap; CBUFFER_START(UnityPerMaterial) float4 _BaseColor; float4 _MainTex_ST; float _NormalIntensity; float _ParallaxIntensity; float _ParallaxIteration; CBUFFER_END struct a2v { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; }; struct v2g { float4 positionCS : SV_POSITION; float3 positionOS : TEXCOORD0; float3 positionWS : TEXCOORD1; float4 tangentOS : TEXCOORD2; float3 bitangentOS : TEXCOORD3; float3 normalOS : TEXCOORD4; float2 texcoord : TEXCOORD5; }; struct g2f { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD1; float4 tbnWSPos[3] : TEXCOORD2; // tbnWS, posWS float4 tbnOSView[3] : TEXCOORD5; // tbnOS, viewWS float2 uvScale : TEXCOORD8; }; v2g vert(a2v input) { v2g output = (v2g)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS); output.positionCS = vpi.positionCS; output.positionOS = input.positionOS.xyz; output.positionWS = vpi.positionWS; output.normalOS = input.normalOS; output.tangentOS = input.tangentOS; output.bitangentOS = cross(input.normalOS, input.tangentOS.xyz) * input.tangentOS.w * GetOddNegativeScale(); output.texcoord = input.texcoord; return output; } [maxvertexcount(3)] void geom(triangle v2g IN[3], inout TriangleStream\u003cg2f\u003e tristream) { float3 camWS = GetCameraPositionWS(); g2f output = (g2f)0; float3 posDiff01 = IN[1].positionOS - IN[0].positionOS; float3 posDiff02 = IN[2].positionOS - IN[0].positionOS; float3 tangentOS0 = IN[0].tangentOS.xyz; float3 bitangentOS0 = IN[1].bitangentOS; float2 uvDiff01 = IN[1].texcoord - IN[0].texcoord; float2 uvDiff02 = IN[2].texcoord - IN[0].texcoord; float2 uvScale; if (uvDiff01.x != 0.0f) uvScale.x = dot(posDiff01, tangentOS0) / uvDiff01.x; else uvScale.x = dot(posDiff02, tangentOS0) / uvDiff02.x; if (uvDiff01.y != 0.0f) uvScale.y = dot(posDiff01, bitangentOS0) / uvDiff01.y; else uvScale.y = dot(posDiff02, bitangentOS0) / uvDiff02.y; for (int i=0; i\u003c3; ++i) { v2g input = IN[i]; VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS); float3 viewWS = camWS - input.positionWS; output.positionCS = input.positionCS; output.uv = input.texcoord; output.tbnWSPos[0] = float4(vni.tangentWS, input.positionWS.x); output.tbnWSPos[1] = float4(vni.bitangentWS, input.positionWS.y); output.tbnWSPos[2] = float4(vni.normalWS, input.positionWS.z); output.tbnOSView[0] = float4(input.tangentOS.xyz, viewWS.x); output.tbnOSView[1] = float4(input.bitangentOS, viewWS.y); output.tbnOSView[2] = float4(input.normalOS, viewWS.z); output.uvScale = uvScale; tristream.Append(output); } tristream.RestartStrip(); } float sampleHeight(float2 uv) { return 1.0f - tex2D(_HeightMap, uv).r; } float2 parallax(float2 uv, float3 view, out float len) { float numLayers = _ParallaxIteration; float layerDepth = 1.0f / numLayers; float2 p = view.xy; float2 deltaUVs = p / numLayers; float texd = sampleHeight(uv); float d = 0.0f; [unroll(30)] for (; d \u003c texd; d += layerDepth) { uv -= deltaUVs; texd = sampleHeight(uv); } float2 lastUVs = uv + deltaUVs; float lastD = d - layerDepth; float after = texd - d; float before = sampleHeight(lastUVs) - d + layerDepth; float w = after / (after - before); len = lerp(d, lastD, w); return lerp(uv, lastUVs, w); } // Returns the determinant of a 2x2 matrix. float spvDet2x2(float a1, float a2, float b1, float b2) { return a1 * b2 - b1 * a2; } // Returns the inverse of a matrix, by using the algorithm of calculating the classical // adjoint and dividing by the determinant. The contents of the matrix are changed. float3x3 spvInverse(float3x3 m) { float3x3 adj;\t// The adjoint matrix (inverse after dividing by determinant) // Create the transpose of the cofactors, as the classical adjoint of the matrix. adj[0][0] = spvDet2x2(m[1][1], m[1][2], m[2][1], m[2][2]); adj[0][1] = -spvDet2x2(m[0][1], m[0][2], m[2][1], m[2][2]); adj[0][2] = spvDet2x2(m[0][1], m[0][2], m[1][1], m[1][2]); adj[1][0] = -spvDet2x2(m[1][0], m[1][2], m[2][0], m[2][2]); adj[1][1] = spvDet2x2(m[0][0], m[0][2], m[2][0], m[2][2]); adj[1][2] = -spvDet2x2(m[0][0], m[0][2], m[1][0], m[1][2]); adj[2][0] = spvDet2x2(m[1][0], m[1][1], m[2][0], m[2][1]); adj[2][1] = -spvDet2x2(m[0][0], m[0][1], m[2][0], m[2][1]); adj[2][2] = spvDet2x2(m[0][0], m[0][1], m[1][0], m[1][1]); // Calculate the determinant as a combination of the cofactors of the first row. float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0]); // Divide the classical adjoint matrix by the determinant. // If determinant is zero, matrix is not invertable, so leave it unchanged. return (det != 0.0f) ? (adj * (1.0f / det)) : m; } float4 frag(g2f input #if defined(OUTPUT_DEPTH) , out float depth : SV_DEPTH #endif ) : SV_TARGET { float3 tos = input.tbnOSView[0].xyz * input.uvScale.x; float3 bos = input.tbnOSView[1].xyz * input.uvScale.y; float3 nos = input.tbnOSView[2].xyz * _ParallaxIntensity; float3x3 t2wOS = float3x3(tos.x, bos.x, nos.x, tos.y, bos.y, nos.y, tos.z, bos.z, nos.z); float3 viewWS = float3(input.tbnOSView[0].w, input.tbnOSView[1].w, input.tbnOSView[2].w); float3 viewOS = mul((float3x3)UNITY_MATRIX_I_M, viewWS); float3 viewTS = mul(spvInverse(t2wOS), viewOS); float z = max(abs(viewTS.z), 1e-5) * (viewTS.z \u003e= 0.0f ? 1.0f : -1.0f); float len; float2 uv = parallax((input.uv * _MainTex_ST.xy + _MainTex_ST.zw), viewTS * float3(_MainTex_ST.xy, 1.0f) / z, len); #if defined(OUTPUT_DEPTH) float3 offsetTS = -viewTS * (len / z); float3 offsetOS = mul(t2wOS, offsetTS); float3 positionWS = float3(input.tbnWSPos[0].w, input.tbnWSPos[1].w, input.tbnWSPos[2].w); float3 posWS = positionWS + mul((float3x3)UNITY_MATRIX_M, offsetOS); float4 posCS = mul(UNITY_MATRIX_VP, float4(posWS, 1.0f)); depth = posCS.z / posCS.w; #endif float4 mainTex = tex2D(_MainTex, uv) * _BaseColor; float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity)); float3 tws = input.tbnWSPos[0].xyz; float3 bws = input.tbnWSPos[1].xyz; float3 nws = input.tbnWSPos[2].xyz; float3 n = normalize(mul(normalTS, float3x3(tws, bws, nws))); Light mainLight = GetMainLight(); float ndotl = max(0.0f, dot(n, mainLight.direction)); float3 color = mainTex.rgb * mainLight.color * ndotl; float alpha = mainTex.a; return float4(color, alpha); } ENDHLSL SubShader { Tags{ \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Cull Back Pass { HLSLPROGRAM #pragma vertex vert #pragma geometry geom #pragma fragment frag ENDHLSL } } } RCSMShader.Shader Shader \"zznewclear13/RCSMShader\" { Properties { [Toggle(OUTPUT_DEPTH)] _OutputDepth (\"Output Depth\", Float) = 1 _BaseColor(\"Base Color\", Color) = (1, 1, 1, 1) _MainTex (\"Texture\", 2D) = \"white\" {} _RCSMTex(\"RCSM Texture\", 2D) = \"white\" {} _NormalMap(\"Normal Map\", 2D) = \"bump\" {} _NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1 _ParallaxIntensity(\"Parallax Intensity\", Float) = 1 _ParallaxIteration(\"Parallax Iteration\", Float) = 15 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" #pragma shader_feature OUTPUT_DEPTH sampler2D _MainTex; sampler2D _NormalMap; sampler2D _RCSMTex; CBUFFER_START(UnityPerMaterial) float4 _BaseColor; float4 _MainTex_ST; float _NormalIntensity; float _ParallaxIntensity; float _ParallaxIteration; CBUFFER_END struct a2v { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; }; struct v2g { float4 positionCS : SV_POSITION; float3 positionOS : TEXCOORD0; float3 positionWS : TEXCOORD1; float4 tangentOS : TEXCOORD2; float3 bitangentOS : TEXCOORD3; float3 normalOS : TEXCOORD4; float2 texcoord : TEXCOORD5; }; struct g2f { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD1; float4 tbnWSPos[3] : TEXCOORD2; // tbnWS, posWS float4 tbnOSView[3] : TEXCOORD5; // tbnOS, viewWS float2 uvScale : TEXCOORD8; }; v2g vert(a2v input) { v2g output = (v2g)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS); output.positionCS = vpi.positionCS; output.positionOS = input.positionOS.xyz; output.positionWS = vpi.positionWS; output.normalOS = input.normalOS; output.tangentOS = input.tangentOS; output.bitangentOS = cross(input.normalOS, input.tangentOS.xyz) * input.tangentOS.w * GetOddNegativeScale(); output.texcoord = input.texcoord; return output; } [maxvertexcount(3)] void geom(triangle v2g IN[3], inout TriangleStream\u003cg2f\u003e tristream) { float3 camWS = GetCameraPositionWS(); g2f output = (g2f)0; float3 posDiff01 = IN[1].positionOS - IN[0].positionOS; float3 posDiff02 = IN[2].positionOS - IN[0].positionOS; float3 tangentOS0 = IN[0].tangentOS.xyz; float3 bitangentOS0 = IN[1].bitangentOS; float2 uvDiff01 = IN[1].texcoord - IN[0].texcoord; float2 uvDiff02 = IN[2].texcoord - IN[0].texcoord; float2 uvScale; if (uvDiff01.x != 0.0f) uvScale.x = dot(posDiff01, tangentOS0) / uvDiff01.x; else uvScale.x = dot(posDiff02, tangentOS0) / uvDiff02.x; if (uvDiff01.y != 0.0f) uvScale.y = dot(posDiff01, bitangentOS0) / uvDiff01.y; else uvScale.y = dot(posDiff02, bitangentOS0) / uvDiff02.y; for (int i=0; i\u003c3; ++i) { v2g input = IN[i]; VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS); float3 viewWS = camWS - input.positionWS; output.positionCS = input.positionCS; output.uv = input.texcoord; output.tbnWSPos[0] = float4(vni.tangentWS, input.positionWS.x); output.tbnWSPos[1] = float4(vni.bitangentWS, input.positionWS.y); output.tbnWSPos[2] = float4(vni.normalWS, input.positionWS.z); output.tbnOSView[0] = float4(input.tangentOS.xyz, viewWS.x); output.tbnOSView[1] = float4(input.bitangentOS, viewWS.y); output.tbnOSView[2] = float4(input.normalOS, viewWS.z); output.uvScale = uvScale; tristream.Append(output); } tristream.RestartStrip(); } float2 sampleRCSM(float2 uv) { float2 rcsm = tex2D(_RCSMTex, uv).xy; return float2(1.0f - rcsm.x, rcsm.y); } float getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight) { float totalRatio = rayRatio / coneRatio + 1.0f; return (sampleHeight - rayHeight) / totalRatio; } float2 parallax(float2 uv, float3 view, out float len) { view.xy = -view.xy * _ParallaxIntensity; float3 samplePos = float3(uv, 0.0f); float2 rcsm = sampleRCSM(samplePos.xy); float rayRatio = length(view.xy); float coneRatio = rcsm.y; float rayHeight = samplePos.z; float sampleHeight = rcsm.x; float stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight); [unroll(30)] for (int i = 0; i \u003c _ParallaxIteration; ++i) { samplePos += stepLength * view; rcsm = sampleRCSM(samplePos.xy); coneRatio = rcsm.y; rayHeight = samplePos.z; sampleHeight = rcsm.x; if (sampleHeight \u003c= rayHeight) break; stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight); } stepLength *= 0.5f; samplePos -= stepLength * view; [unroll] for (int j = 0; j \u003c 5; ++j) { rcsm = sampleRCSM(samplePos.xy); stepLength *= 0.5f; if (samplePos.z \u003e= rcsm.x) { samplePos -= stepLength * view; } else if(samplePos.z \u003c rcsm.x) { samplePos += stepLength * view; } } len = samplePos.z; return samplePos.xy; } // Returns the determinant of a 2x2 matrix. float spvDet2x2(float a1, float a2, float b1, float b2) { return a1 * b2 - b1 * a2; } // Returns the inverse of a matrix, by using the algorithm of calculating the classical // adjoint and dividing by the determinant. The contents of the matrix are changed. float3x3 spvInverse(float3x3 m) { float3x3 adj;\t// The adjoint matrix (inverse after dividing by determinant) // Create the transpose of the cofactors, as the classical adjoint of the matrix. adj[0][0] = spvDet2x2(m[1][1], m[1][2], m[2][1], m[2][2]); adj[0][1] = -spvDet2x2(m[0][1], m[0][2], m[2][1], m[2][2]); adj[0][2] = spvDet2x2(m[0][1], m[0][2], m[1][1], m[1][2]); adj[1][0] = -spvDet2x2(m[1][0], m[1][2], m[2][0], m[2][2]); adj[1][1] = spvDet2x2(m[0][0], m[0][2], m[2][0], m[2][2]); adj[1][2] = -spvDet2x2(m[0][0], m[0][2], m[1][0], m[1][2]); adj[2][0] = spvDet2x2(m[1][0], m[1][1], m[2][0], m[2][1]); adj[2][1] = -spvDet2x2(m[0][0], m[0][1], m[2][0], m[2][1]); adj[2][2] = spvDet2x2(m[0][0], m[0][1], m[1][0], m[1][1]); // Calculate the determinant as a combination of the cofactors of the first row. float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0]); // Divide the classical adjoint matrix by the determinant. // If determinant is zero, matrix is not invertable, so leave it unchanged. return (det != 0.0f) ? (adj * (1.0f / det)) : m; } float4 frag(g2f input #if defined(OUTPUT_DEPTH) , out float depth : SV_DEPTH #endif ) : SV_TARGET { float3 tos = input.tbnOSView[0].xyz * input.uvScale.x; float3 bos = input.tbnOSView[1].xyz * input.uvScale.y; float3 nos = input.tbnOSView[2].xyz * _ParallaxIntensity; float3x3 t2wOS = float3x3(tos.x, bos.x, nos.x, tos.y, bos.y, nos.y, tos.z, bos.z, nos.z); float3 viewWS = float3(input.tbnOSView[0].w, input.tbnOSView[1].w, input.tbnOSView[2].w); float3 viewOS = mul((float3x3)UNITY_MATRIX_I_M, viewWS); float3 viewTS = mul(spvInverse(t2wOS), viewOS); float z = max(abs(viewTS.z), 1e-5) * (viewTS.z \u003e= 0.0f ? 1.0f : -1.0f); float len; float2 uv = parallax((input.uv * _MainTex_ST.xy + _MainTex_ST.zw), viewTS * float3(_MainTex_ST.xy, 1.0f) / z, len); #if defined(OUTPUT_DEPTH) float3 offsetTS = -viewTS * (len / z); float3 offsetOS = mul(t2wOS, offsetTS); float3 positionWS = float3(input.tbnWSPos[0].w, input.tbnWSPos[1].w, input.tbnWSPos[2].w); float3 posWS = positionWS + mul((float3x3)UNITY_MATRIX_M, offsetOS); float4 posCS = mul(UNITY_MATRIX_VP, float4(posWS, 1.0f)); depth = posCS.z / posCS.w; #endif float4 mainTex = tex2D(_MainTex, uv) * _BaseColor; float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity)); float3 tws = input.tbnWSPos[0].xyz; float3 bws = input.tbnWSPos[1].xyz; float3 nws = input.tbnWSPos[2].xyz; float3 n = normalize(mul(normalTS, float3x3(tws, bws, nws))); Light mainLight = GetMainLight(); float ndotl = max(0.0f, dot(n, mainLight.direction)); float3 color = mainTex.rgb * mainLight.color * ndotl; float alpha = mainTex.a; return float4(color, alpha); } ENDHLSL SubShader { Tags{ \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Cull Back Pass { HLSLPROGRAM #pragma vertex vert #pragma geometry geom #pragma fragment frag ENDHLSL } } } æœ€ç»ˆçš„æ•ˆæœ æœ€åçš„æ•ˆæœä¹Ÿå°±å¦‚å°é¢å›¾ä¸€æ ·äº†ï¼Œå·¦è¾¹æ˜¯RCSMåšçš„ï¼Œå…¶ä½™çš„åˆ™æ˜¯æ™®é€šçš„POMæ•ˆæœã€‚ç‰¹åœ°å¯¹æ¨¡å‹åšäº†ç¼©æ”¾ï¼Œå¯¹è´´å›¾çš„å¹³é“ºè¿›è¡Œè°ƒæ•´ï¼Œç”¨æ¥è¡¨æ˜è¿™ä¸ªè®¡ç®—æ–¹å¼çš„æ­£ç¡®æ€§ï¼ŒåŒæ ·çš„æè´¨çƒç”¨åœ¨ä¸åŒçš„æ¨¡å‹ä¸Šä¹Ÿèƒ½å¤Ÿå¾—åˆ°æ­£ç¡®çš„æ·±åº¦å€¼ã€‚ä½†æ˜¯åƒçƒä½“è¿™æ ·çš„uvå¹¶ä¸è§„åˆ™çš„æ¨¡å‹ï¼Œç”¨ä¸Šè¿°çš„æ–¹æ³•å¹¶ä¸èƒ½å¾—åˆ°å®Œç¾çš„æ·±åº¦æ•ˆæœã€‚ä¸Šé¢å’Œä¸‹é¢å¹³é¢ä½¿ç”¨çš„è´´å›¾æ¥è‡ªQuixelçš„Megascansã€‚\nåè®° åˆè¿…é€Ÿåœ°å†™äº†ä¸€ç¯‡æ–‡ç« ï¼Œè®¡ç®—äº†è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ä¹‹åï¼Œå„ç§å±å¹•ç©ºé—´çš„ç®—æ³•ä¹Ÿéƒ½èƒ½å¤Ÿæ­£å¸¸åœ°ä½¿ç”¨äº†ï¼Œå¾ˆå¥½ã€‚è¯åˆè¯´å›æ¥äº†æˆ‘è¢«LearnOpenGLçš„è´´å›¾å‘äº†ä¸€æ³¢ï¼Œå±…ç„¶æ²¡æœ‰æ„è¯†åˆ°ä¸Šé¢çš„æ³•çº¿å›¾å’Œå¹³å¸¸ä½¿ç”¨çš„æ³•çº¿å›¾æ˜¯ä¸ä¸€æ ·çš„ï¼Œæˆ‘å°±è¯´æ€ä¹ˆçœ‹ä¸Šå»æœ‰ä¸€ç§è¿å’Œæ„Ÿã€‚åæ¥æˆ‘ç›´æ¥åœ¨Blenderé‡Œè‡ªå·±å¯¼å‡ºäº†è¿™ä¸ªToy Boxçš„æ³•çº¿å’Œæ·±åº¦å›¾ï¼Œè¿™æ‰æ„Ÿè§‰ä¸€åˆ‡éƒ½æ­£å¸¸äº†ã€‚\n","wordCount":"1871","inLanguage":"en","image":"https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/posts/images/CorrectDepth_POM_RCSM.png","datePublished":"2024-03-16T12:00:00+08:00","dateModified":"2024-03-16T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼</h1><div class=post-description>åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º.</div><div class=post-meta><span title='2024-03-16 12:00:00 +0800 CST'>March 16, 2024</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/get-correct-depth-from-parallax-occlusion-mapping.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/CorrectDepth_POM_RCSM.png alt="Correct Depth POM & RCSM Cover"><p>Correct Depth POM & RCSM Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼</div></summary><div class=inner><ul><li><a href=#pom%e5%92%8crcsm aria-label=POMå’ŒRCSM>POMå’ŒRCSM</a></li><li><a href=#%e5%9b%9e%e9%a1%bepom%e7%9a%84%e8%ae%a1%e7%ae%97%e8%bf%87%e7%a8%8b aria-label=å›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹>å›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹</a><ul><li><a href=#uvscale%e7%9a%84%e8%ae%a1%e7%ae%97 aria-label=uvScaleçš„è®¡ç®—>uvScaleçš„è®¡ç®—</a></li><li><a href=#%e8%b4%b4%e5%9b%be%e7%a9%ba%e9%97%b4%e5%8f%98%e6%8d%a2 aria-label=è´´å›¾ç©ºé—´å˜æ¢>è´´å›¾ç©ºé—´å˜æ¢</a></li><li><a href=#%e6%b7%b1%e5%ba%a6%e7%9a%84%e8%8e%b7%e5%8f%96 aria-label=æ·±åº¦çš„è·å–>æ·±åº¦çš„è·å–</a></li></ul></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç </a><ul><li><a href=#pomshadershader aria-label=POMShader.shader>POMShader.shader</a></li><li><a href=#rcsmshadershader aria-label=RCSMShader.Shader>RCSMShader.Shader</a></li></ul></li><li><a href=#%e6%9c%80%e7%bb%88%e7%9a%84%e6%95%88%e6%9e%9c aria-label=æœ€ç»ˆçš„æ•ˆæœ>æœ€ç»ˆçš„æ•ˆæœ</a></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=pomå’Œrcsm>POMå’ŒRCSM<a hidden class=anchor aria-hidden=true href=#pomå’Œrcsm>#</a></h2><p>åœ¨æˆ‘ä¹‹å‰çš„æ–‡ç« <a href=https://zznewclear13.github.io/relaxed-cone-step-mapping-in-unity/>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</a>å°±å·²ç»ä»‹ç»è¿‡äº†è§†å·®æ˜ å°„å’Œæ¾æ•£åœ†é”¥æ­¥è¿›æµ®é›•æ˜ å°„çš„è®¡ç®—æ–¹æ³•äº†ï¼Œä½†æ˜¯ä¹‹å‰å¹¶æ²¡æœ‰å¯¹è®¡ç®—æ·±åº¦å€¼åšç›¸åº”çš„ç ”ç©¶ï¼ŒåŒæ—¶ä¹Ÿé™åˆ¶äºç¯‡å¹…çš„åŸå› å°±æ²¡æœ‰å†å±•å¼€äº†ï¼Œè¿™ç¯‡æ–‡ç« ç›¸å½“äºæ˜¯ä¹‹å‰æ–‡ç« çš„åç»­ã€‚ä¸ºäº†ç®€ä¾¿ï¼Œåç»­å°†è¿™ä¸¤ç§è®¡ç®—æ–¹æ³•ç»Ÿç§°ä¸ºè§†å·®æ˜ å°„ã€‚</p><p>åœ¨è§†å·®æ˜ å°„ä¸­è®¡ç®—æ·±åº¦å€¼æ˜¯ä¸€ä¸ªå¾ˆç›´æ¥çš„æƒ³æ³•ï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½ä¼šæœ‰å…¶ä»–ç‰©ä½“è¢«æ”¾ç½®åœ¨è§†å·®æ˜ å°„çš„è¡¨é¢ï¼Œä¸ä¹‹å‘ç”Ÿç©¿æ’ï¼Œå¦‚æœä¸åšç‰¹æ®Šå¤„ç†ï¼Œå°±ä¼šä½¿ç”¨æ¨¡å‹æœ¬èº«çš„æ·±åº¦å€¼è¿›è¡Œæ·±åº¦æ¯”è¾ƒï¼Œå¯¼è‡´åˆ«çš„ç‰©ä½“ä¸èƒ½æœ‰æ­£ç¡®çš„è¢«é®æŒ¡çš„æ•ˆæœï¼Œå‰Šå¼±äº†è§†å·®æ˜ å°„å¸¦æ¥çš„çœŸå®æ„Ÿã€‚ç½‘ä¸Šæˆ‘æ‰¾äº†ä¸€åœˆï¼Œå¹¶æ²¡æœ‰æ‰¾åˆ°å’Œè®¡ç®—è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ç›¸å…³çš„æ–‡ç« ï¼Œå› æ­¤æˆ‘æƒ³ç”¨è¿™ç¯‡æ–‡ç« è¿›è¡Œç›¸å…³çš„ä»‹ç»ã€‚</p><p>Unityçš„é«˜æ¸…ç®¡çº¿ï¼ˆHDRPï¼‰çš„Lit Shaderæ”¯æŒè®¡ç®—åƒç´ æ·±åº¦åç§»ï¼Œæä¾›äº†<code>Primitive Length</code>ï¼Œ<code>Primitive Width</code>ï¼Œå’Œ<code>Amplitude</code>ä¸‰ä¸ªå‚æ•°ã€‚<code>Amplitude</code>å¯ä»¥ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„å¼ºåº¦å€¼ï¼Œè™½ç„¶å…¶ä¸€ä¸ªå•ä½å’Œä¸–ç•Œç©ºé—´çš„ä¸€ç±³å®Œå…¨ä¸èƒ½ç›´æ¥ç­‰åŒèµ·æ¥ï¼Œä½†æ˜¯å€¼è¶Šå¤§è§†å·®çœ‹ä¸Šå»å°±è¶Šæ·±ï¼Œå¯ä»¥æ ¹æ®è§†è§‰å®æ—¶è°ƒæ•´è¿™ä¸ªå‚æ•°ã€‚å¦å¤–ä¸¤ä¸ªå‚æ•°å°±å¾ˆå¥‡æ€ªäº†ï¼Œå±…ç„¶å’Œæ¨¡å‹çš„å¤§å°æœ‰å…³ï¼ŒåŒä¸€ä¸ªæè´¨çƒï¼Œç”¨åœ¨Quadä¸Šè¿™é‡Œå°±è¦å¡«1ï¼Œç”¨åœ¨Planeä¸Šå°±è¦å¡«10ï¼Œå“ªæœ‰è¿™ç§é“ç†ï¼Ÿè™šå¹»å¼•æ“åˆ™æ˜¯æä¾›äº†POMçš„æ¥å£ï¼Œè‡³äºè¾“å…¥å’Œè¾“å‡ºå®Œå…¨éƒ½ç”±ç”¨æˆ·æ§åˆ¶ï¼Œè¿™é‡Œå°±ä¸å¤ªå¥½ç›´æ¥æ¯”è¾ƒäº†ã€‚</p><h2 id=å›é¡¾pomçš„è®¡ç®—è¿‡ç¨‹>å›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹<a hidden class=anchor aria-hidden=true href=#å›é¡¾pomçš„è®¡ç®—è¿‡ç¨‹>#</a></h2><p>è§†å·®æ˜ å°„ä¸€èˆ¬ä¸ä¼šç›´æ¥åœ¨ä¸–ç•Œç©ºé—´æ­¥è¿›ï¼Œè€Œæ˜¯ä¼šå…ˆå°†ä¸–ç•Œç©ºé—´çš„è§†çº¿<code>viewWS</code>è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´<code>viewTS</code>ï¼Œåœ¨åˆ‡çº¿ç©ºé—´æ­¥è¿›ã€‚ç…§å¸¸ç†<code>_ParallaxIntensity</code>æ˜¯ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„æ·±åº¦çš„ï¼Œå› æ­¤ä¼šä½¿ç”¨è¿™ä¸ªå‚æ•°æ§åˆ¶zæ–¹å‘æ­¥è¿›çš„è·ç¦»ï¼Œä½†ä¸ºäº†æ–¹ä¾¿å’Œé«˜åº¦å›¾ä¸­è®°è½½çš„é«˜åº¦è¿›è¡Œå¯¹æ¯”ï¼Œä¼šå…ˆå¯¹<code>viewTS</code>çš„zåˆ†é‡è¿›è¡Œå½’ä¸€åŒ–ï¼Œå°†<code>_ParallaxIntensity</code>åœ¨æ­¥è¿›æ—¶ä¹˜åˆ°<code>viewTS</code>çš„xyåˆ†é‡ä¸Šï¼Œä¹‹åå°±æ˜¯å¾ªç¯æ¯”è¾ƒæ·±åº¦è¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯äº†ã€‚</p><p>ä½†æ˜¯ä¸ºä»€ä¹ˆæ˜¯åˆ‡çº¿ç©ºé—´å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºåˆ‡çº¿tangentå’Œå‰¯åˆ‡çº¿bitangentä»£è¡¨äº†è´´å›¾UVçš„xyçš„æ­£æ–¹å‘ï¼Œå°†è§†çº¿è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´ï¼Œå…¶å®ç›®çš„æ˜¯å°†è§†çº¿è½¬åˆ°UVç©ºé—´ï¼Œæˆ–è€…è¯´æ˜¯è´´å›¾ç©ºé—´ï¼ˆTexture Spaceï¼Œå› ä¸ºå…¶ä¸åˆ‡çº¿ç©ºé—´çš„ç›¸ä¼¼æ€§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç”¨TSæ¥åšç®€å†™ï¼‰ã€‚è¿™é‡Œå°±å‡ºç°äº†æœ€é‡è¦çš„ä¸€ä¸ªé—®é¢˜ï¼ŒUnityä¸­é€šè¿‡<code>GetVertexNormalInputs</code>è·å¾—åˆ°çš„ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿æ˜¯ç»è¿‡å½’ä¸€åŒ–çš„ï¼Œä¸¢å¤±äº†ç‰©ä½“è‡ªèº«çš„ç¼©æ”¾ï¼Œæ‰€ä»¥æˆ‘ä»¬å…¶å®åº”è¯¥å…ˆå°†ä¸–ç•Œåæ ‡çš„è§†çº¿<code>viewWS</code>è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´<code>viewOS</code>ï¼Œç„¶åå†ä½¿ç”¨ç‰©ä½“ç©ºé—´çš„tbnçŸ©é˜µï¼Œå°†<code>viewOS</code>è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´<code>viewTS</code>ã€‚ä½†åˆå¦‚æˆ‘ä¸Šé¢è¯´åˆ°çš„ï¼Œæˆ‘ä»¬çœŸå®çš„ç›®çš„æ˜¯è´´å›¾ç©ºé—´ï¼Œåˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´æ˜¯å­˜åœ¨å·®å¼‚æ€§çš„ã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆUnityçš„HDRPè¦ä½¿ç”¨é¢å¤–çš„å‚æ•°<code>Primitive Length</code>å’Œ<code>Primitive Width</code>äº†ï¼Œè¿™ä¸¤ä¸ªå‚æ•°çš„ç›®çš„æ˜¯é€šè¿‡é¢å¤–çš„ç¼©æ”¾ï¼Œå°†åˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´å¯¹åº”èµ·æ¥ã€‚</p><p>è¿™ä¸¤ä¸ªå‚æ•°çš„æ„ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ï¼Œè¿™é‡Œæˆ‘ä»¬è®°ä¸º<code>uvScale</code>ã€‚åŒæ—¶æˆ‘ä»¬å¯ä»¥é¡ºç†æˆç« åœ°æ­£å¼å¼•å…¥<code>_ParallaxIntensity</code>è¿™ä¸ªå‚æ•°ï¼Œå®ƒçš„å«ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ä¸­é¢œè‰²ä¸º0çš„ç‚¹å¯¹åº”çš„ç‰©ä½“ç©ºé—´çš„æ·±åº¦å€¼ã€‚è´´å›¾ç©ºé—´è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´ï¼Œåªéœ€è¦å¯¹xyzä¸‰ä¸ªåˆ†é‡åˆ†åˆ«ä¹˜ä¸Š<code>uvScale.x</code>ï¼Œ<code>uvScale.y</code>ï¼Œå’Œ<code>_ParallaxIntensity</code>å³å¯ã€‚<code>_ParallaxIntensity</code>è¿™ä¸ªå‚æ•°æˆ‘ä»¬å¯ä»¥ä½œä¸ºæè´¨çƒçš„ä¸€ä¸ªè¾“å…¥è¿›è¡Œæ§åˆ¶ï¼Œ<code>uvScale</code>æ˜¯ä¸€ä¸ªè·Ÿæ¨¡å‹ç›¸å…³çš„å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Geometry Shaderä¸­è®¡ç®—è€Œå¾—ã€‚</p><h3 id=uvscaleçš„è®¡ç®—>uvScaleçš„è®¡ç®—<a hidden class=anchor aria-hidden=true href=#uvscaleçš„è®¡ç®—>#</a></h3><p>å¦‚ä¸Šé¢æ‰€å±ï¼Œ<code>uvScale</code>æŒ‡ä»£çš„æ˜¯è´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ã€‚å¯¹äºä¸¤ä¸ªé¡¶ç‚¹<code>v0</code>å’Œ<code>v1</code>ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡å…¶å®å°±æ˜¯è¿™ä¸¤ä¸ªé¡¶ç‚¹uvå€¼çš„å·®ï¼Œç‰©ä½“ç©ºé—´çš„é•¿åº¦å…¶å®å°±æ˜¯ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œä¸ºäº†å¯¹åº”åˆ°è´´å›¾ç©ºé—´ä¸Šï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—è¿™æ®µè·ç¦»åœ¨åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ä¸Šçš„æŠ•å½±é•¿åº¦ï¼Œåè€…é™¤ä»¥å‰è€…å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„<code>uvScale</code>äº†ã€‚ç”±äºæ„æˆä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹å¯èƒ½ä¼šå­˜åœ¨æŸä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´uvçš„æŸä¸ªåˆ†é‡çš„å˜åŒ–ç‡ä¸º0ï¼Œå¯¼è‡´æˆ‘ä»¬è®¡ç®—<code>uvScale</code>çš„æ—¶å€™é™¤ä»¥é›¶ï¼Œæˆ‘ä»¬åœ¨æ£€æµ‹åˆ°è¿™ä¸ªæƒ…å†µçš„æ—¶å€™ä½¿ç”¨ç¬¬ä¸‰ä¸ªé¡¶ç‚¹å³å¯ã€‚</p><h3 id=è´´å›¾ç©ºé—´å˜æ¢>è´´å›¾ç©ºé—´å˜æ¢<a hidden class=anchor aria-hidden=true href=#è´´å›¾ç©ºé—´å˜æ¢>#</a></h3><p>åœ¨è·å¾—äº†ç‰©ä½“ç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿ä¹‹åï¼Œä¸ºäº†æ„æˆè´´å›¾ç©ºé—´çš„ä¸‰ä¸ªåŸºå‘é‡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹è¿™ä¸ªå‘é‡ä½¿ç”¨<code>uvScale</code>å’Œ<code>_ParallaxIntensity</code>è¿›è¡Œç¼©æ”¾ã€‚è¿™ä¸ªç¼©æ”¾å¯¼è‡´äº†æˆ‘ä»¬æŒ‰ç…§ä»¥å¾€çš„<code>float3x3(tangentOS * uvScale.x, bitangentOS * uvScale.y, normalOS * _ParallaxIntensity)</code>æ„æˆçš„çŸ©é˜µä¸å†æ˜¯ä¸€ä¸ªæ­£äº¤çŸ©é˜µï¼Œå®ƒå®é™…ä¸Šæ˜¯è´´å›¾ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„å˜æ¢çŸ©é˜µçš„è½¬ç½®ã€‚å› æ­¤å°†ç‰©ä½“ç©ºé—´çš„è§†çº¿<code>viewOS</code>è½¬æ¢åˆ°è´´å›¾ç©ºé—´<code>viewTS</code>æ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®çš„é€†å·¦ä¹˜<code>viewOS</code>ï¼Œå°†è´´å›¾ç©ºé—´çš„è§†çº¿<code>viewTS</code>è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´<code>viewOS</code>æ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®å·¦ä¹˜<code>viewTS</code>ã€‚</p><h3 id=æ·±åº¦çš„è·å–>æ·±åº¦çš„è·å–<a hidden class=anchor aria-hidden=true href=#æ·±åº¦çš„è·å–>#</a></h3><p>è¿™ä¸ªå°±ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•äº†ï¼Œæˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„æ—¶å€™ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„zæ–¹å‘çš„æ·±åº¦å€¼<code>len</code>ã€‚è€Œç”±äºæˆ‘ä»¬çš„<code>viewTS</code>ä¼šåšé™¤ä»¥zåˆ†é‡çš„å½’ä¸€åŒ–ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å½’ä¸€åŒ–å‰çš„<code>-viewTS</code>ä¹˜ä¸Š<code>len</code>å†é™¤ä»¥zåˆ†é‡ï¼Œå°±èƒ½çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´ä¸­æ€»çš„æ­¥è¿›çš„å‘é‡ï¼Œå°†å…¶è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´ï¼Œå’Œå½“å‰ç‚¹çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ç›¸åŠ åå†è½¬æ¢åˆ°è£å‰ªç©ºé—´ï¼Œå…¶zåˆ†é‡é™¤ä»¥wåˆ†é‡å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„æ·±åº¦å€¼äº†ã€‚</p><h2 id=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç <a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„ä»£ç >#</a></h2><p>è¿™é‡Œåªåšäº†å¯è¡Œæ€§çš„ç ”ç©¶ï¼Œåº”è¯¥æœ‰ä¸ªæ–¹æ³•èƒ½å¤Ÿç®€åŒ–è®¡ç®—çŸ©é˜µçš„é€†è¿™ä¸€æ­¥æ“ä½œã€‚åœ¨è®¡ç®—ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿çš„æ—¶å€™ï¼Œå¯ä»¥ä¸è¿›è¡Œå½’ä¸€åŒ–ï¼Œè¿™æ ·æˆ‘ä»¬ä¹Ÿå°±ä¸éœ€è¦å…ˆè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°è´´å›¾ç©ºé—´äº†ã€‚</p><h3 id=pomshadershader>POMShader.shader<a hidden class=anchor aria-hidden=true href=#pomshadershader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/POMShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        [Toggle(OUTPUT_DEPTH)] _OutputDepth (<span style=color:#e6db74>&#34;Output Depth&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _BaseColor(<span style=color:#e6db74>&#34;Base Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _HeightMap(<span style=color:#e6db74>&#34;Height Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalMap(<span style=color:#e6db74>&#34;Normal Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bump&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalIntensity(<span style=color:#e6db74>&#34;Normal Intensity&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _ParallaxIntensity (<span style=color:#e6db74>&#34;Parallax Intensity&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _ParallaxIteration (<span style=color:#e6db74>&#34;Parallax Iteration&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature OUTPUT_DEPTH
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sampler2D _MainTex;
</span></span><span style=display:flex><span>    sampler2D _HeightMap;
</span></span><span style=display:flex><span>    sampler2D _NormalMap;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _BaseColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _MainTex_ST;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _NormalIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIteration;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> a2v
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> v2g
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionOS   <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangentOS  <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> TEXCOORD4;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD5;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> g2f
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tbnWSPos[<span style=color:#ae81ff>3</span>]  <span style=color:#f92672>:</span> TEXCOORD2; <span style=color:#75715e>// tbnWS, posWS</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tbnOSView[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>:</span> TEXCOORD5; <span style=color:#75715e>// tbnOS, viewWS</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvScale      <span style=color:#f92672>:</span> TEXCOORD8;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    v2g vert(a2v input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        v2g output <span style=color:#f92672>=</span> (v2g)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS, input.tangentOS);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.positionOS <span style=color:#f92672>=</span> input.positionOS.xyz;
</span></span><span style=display:flex><span>        output.positionWS <span style=color:#f92672>=</span> vpi.positionWS;
</span></span><span style=display:flex><span>        output.normalOS <span style=color:#f92672>=</span> input.normalOS;
</span></span><span style=display:flex><span>        output.tangentOS <span style=color:#f92672>=</span> input.tangentOS;
</span></span><span style=display:flex><span>        output.bitangentOS <span style=color:#f92672>=</span> cross(input.normalOS, input.tangentOS.xyz) <span style=color:#f92672>*</span> input.tangentOS.w <span style=color:#f92672>*</span> GetOddNegativeScale();
</span></span><span style=display:flex><span>        output.texcoord <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [maxvertexcount(<span style=color:#ae81ff>3</span>)]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> geom(<span style=color:#66d9ef>triangle</span> v2g IN[<span style=color:#ae81ff>3</span>], <span style=color:#66d9ef>inout</span> <span style=color:#66d9ef>TriangleStream</span><span style=color:#f92672>&lt;</span>g2f<span style=color:#f92672>&gt;</span> tristream)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> camWS <span style=color:#f92672>=</span> GetCameraPositionWS();
</span></span><span style=display:flex><span>        g2f output <span style=color:#f92672>=</span> (g2f)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> posDiff01 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>1</span>].positionOS <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].positionOS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> posDiff02 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>2</span>].positionOS <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].positionOS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tangentOS0 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>0</span>].tangentOS.xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangentOS0 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>1</span>].bitangentOS;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvDiff01 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>1</span>].texcoord <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvDiff02 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>2</span>].texcoord <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvScale;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (uvDiff01.x <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0f</span>) uvScale.x <span style=color:#f92672>=</span> dot(posDiff01, tangentOS0) <span style=color:#f92672>/</span> uvDiff01.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> uvScale.x <span style=color:#f92672>=</span> dot(posDiff02, tangentOS0) <span style=color:#f92672>/</span> uvDiff02.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (uvDiff01.y <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0f</span>) uvScale.y <span style=color:#f92672>=</span> dot(posDiff01, bitangentOS0) <span style=color:#f92672>/</span> uvDiff01.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> uvScale.y <span style=color:#f92672>=</span> dot(posDiff02, bitangentOS0) <span style=color:#f92672>/</span> uvDiff02.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            v2g input <span style=color:#f92672>=</span> IN[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS, input.tangentOS);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> viewWS <span style=color:#f92672>=</span> camWS <span style=color:#f92672>-</span> input.positionWS;
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> input.positionCS;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>            output.tbnWSPos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.tangentWS, input.positionWS.x);
</span></span><span style=display:flex><span>            output.tbnWSPos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.bitangentWS, input.positionWS.y);
</span></span><span style=display:flex><span>            output.tbnWSPos[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.normalWS, input.positionWS.z);
</span></span><span style=display:flex><span>            output.tbnOSView[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.tangentOS.xyz, viewWS.x);
</span></span><span style=display:flex><span>            output.tbnOSView[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.bitangentOS, viewWS.y);
</span></span><span style=display:flex><span>            output.tbnOSView[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.normalOS, viewWS.z);
</span></span><span style=display:flex><span>            output.uvScale <span style=color:#f92672>=</span> uvScale;
</span></span><span style=display:flex><span>            tristream.Append(output);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        tristream.RestartStrip();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> sampleHeight(<span style=color:#66d9ef>float2</span> uv)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> tex2D(_HeightMap, uv).r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> parallax(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float3</span> view, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> len)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> numLayers <span style=color:#f92672>=</span> _ParallaxIteration;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> layerDepth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> numLayers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p <span style=color:#f92672>=</span> view.xy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> deltaUVs <span style=color:#f92672>=</span> p <span style=color:#f92672>/</span> numLayers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> texd <span style=color:#f92672>=</span> sampleHeight(uv);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>30</span>)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (; d <span style=color:#f92672>&lt;</span> texd; d <span style=color:#f92672>+=</span> layerDepth)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            uv <span style=color:#f92672>-=</span> deltaUVs;
</span></span><span style=display:flex><span>            texd <span style=color:#f92672>=</span> sampleHeight(uv);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> lastUVs <span style=color:#f92672>=</span> uv <span style=color:#f92672>+</span> deltaUVs;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lastD <span style=color:#f92672>=</span> d <span style=color:#f92672>-</span> layerDepth;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> after <span style=color:#f92672>=</span> texd <span style=color:#f92672>-</span> d;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> before <span style=color:#f92672>=</span> sampleHeight(lastUVs) <span style=color:#f92672>-</span> d <span style=color:#f92672>+</span> layerDepth;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> w <span style=color:#f92672>=</span> after <span style=color:#f92672>/</span> (after <span style=color:#f92672>-</span> before);
</span></span><span style=display:flex><span>        len <span style=color:#f92672>=</span> lerp(d, lastD, w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> lerp(uv, lastUVs, w);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Returns the determinant of a 2x2 matrix.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> spvDet2x2(<span style=color:#66d9ef>float</span> a1, <span style=color:#66d9ef>float</span> a2, <span style=color:#66d9ef>float</span> b1, <span style=color:#66d9ef>float</span> b2)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a1 <span style=color:#f92672>*</span> b2 <span style=color:#f92672>-</span> b1 <span style=color:#f92672>*</span> a2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Returns the inverse of a matrix, by using the algorithm of calculating the classical</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// adjoint and dividing by the determinant. The contents of the matrix are changed.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> spvInverse(<span style=color:#66d9ef>float3x3</span> m)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3x3</span> adj;	<span style=color:#75715e>// The adjoint matrix (inverse after dividing by determinant)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create the transpose of the cofactors, as the classical adjoint of the matrix.</span>
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate the determinant as a combination of the cofactors of the first row.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> det <span style=color:#f92672>=</span> (adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> (adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> (adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>*</span> m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Divide the classical adjoint matrix by the determinant.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If determinant is zero, matrix is not invertable, so leave it unchanged.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (det <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0f</span>) <span style=color:#f92672>?</span> (adj <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> det)) <span style=color:#f92672>:</span> m;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(g2f input
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(OUTPUT_DEPTH)</span>
</span></span><span style=display:flex><span>    , <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> depth <span style=color:#f92672>:</span> SV_DEPTH
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tos <span style=color:#f92672>=</span> input.tbnOSView[<span style=color:#ae81ff>0</span>].xyz <span style=color:#f92672>*</span> input.uvScale.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bos <span style=color:#f92672>=</span> input.tbnOSView[<span style=color:#ae81ff>1</span>].xyz <span style=color:#f92672>*</span> input.uvScale.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> nos <span style=color:#f92672>=</span> input.tbnOSView[<span style=color:#ae81ff>2</span>].xyz <span style=color:#f92672>*</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3x3</span> t2wOS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3x3</span>(tos.x, bos.x, nos.x,
</span></span><span style=display:flex><span>                                    tos.y, bos.y, nos.y,
</span></span><span style=display:flex><span>                                    tos.z, bos.z, nos.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(input.tbnOSView[<span style=color:#ae81ff>0</span>].w, input.tbnOSView[<span style=color:#ae81ff>1</span>].w, input.tbnOSView[<span style=color:#ae81ff>2</span>].w);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewOS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_I_M, viewWS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewTS <span style=color:#f92672>=</span> mul(spvInverse(t2wOS), viewOS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> z <span style=color:#f92672>=</span> max(abs(viewTS.z), <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>) <span style=color:#f92672>*</span> (viewTS.z <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> len;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> parallax((input.uv <span style=color:#f92672>*</span> _MainTex_ST.xy <span style=color:#f92672>+</span> _MainTex_ST.zw), viewTS <span style=color:#f92672>*</span> <span style=color:#66d9ef>float3</span>(_MainTex_ST.xy, <span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> z, len);
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(OUTPUT_DEPTH)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> offsetTS <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>viewTS <span style=color:#f92672>*</span> (len <span style=color:#f92672>/</span> z);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> offsetOS <span style=color:#f92672>=</span> mul(t2wOS, offsetTS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(input.tbnWSPos[<span style=color:#ae81ff>0</span>].w, input.tbnWSPos[<span style=color:#ae81ff>1</span>].w, input.tbnWSPos[<span style=color:#ae81ff>2</span>].w);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> posWS <span style=color:#f92672>=</span> positionWS <span style=color:#f92672>+</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_M, offsetOS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> posCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(posWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>        depth <span style=color:#f92672>=</span> posCS.z <span style=color:#f92672>/</span> posCS.w;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> mainTex <span style=color:#f92672>=</span> tex2D(_MainTex, uv) <span style=color:#f92672>*</span> _BaseColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalTS <span style=color:#f92672>=</span> normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tws <span style=color:#f92672>=</span> input.tbnWSPos[<span style=color:#ae81ff>0</span>].xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bws <span style=color:#f92672>=</span> input.tbnWSPos[<span style=color:#ae81ff>1</span>].xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> nws <span style=color:#f92672>=</span> input.tbnWSPos[<span style=color:#ae81ff>2</span>].xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> n <span style=color:#f92672>=</span> normalize(mul(normalTS, <span style=color:#66d9ef>float3x3</span>(tws, bws, nws)));
</span></span><span style=display:flex><span>        Light mainLight <span style=color:#f92672>=</span> GetMainLight();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ndotl <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.0f</span>, dot(n, mainLight.direction));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> mainTex.rgb <span style=color:#f92672>*</span> mainLight.color <span style=color:#f92672>*</span> ndotl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> mainTex.a;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(color, alpha);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags{ <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Geometry&#34;</span>}
</span></span><span style=display:flex><span>        Cull Back
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma geometry geom
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=rcsmshadershader>RCSMShader.Shader<a hidden class=anchor aria-hidden=true href=#rcsmshadershader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/RCSMShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        [Toggle(OUTPUT_DEPTH)] _OutputDepth (<span style=color:#e6db74>&#34;Output Depth&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _BaseColor(<span style=color:#e6db74>&#34;Base Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _RCSMTex(<span style=color:#e6db74>&#34;RCSM Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalMap(<span style=color:#e6db74>&#34;Normal Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bump&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalIntensity(<span style=color:#e6db74>&#34;Normal Intensity&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _ParallaxIntensity(<span style=color:#e6db74>&#34;Parallax Intensity&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _ParallaxIteration(<span style=color:#e6db74>&#34;Parallax Iteration&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>pragma shader_feature OUTPUT_DEPTH
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sampler2D _MainTex;
</span></span><span style=display:flex><span>    sampler2D _NormalMap;
</span></span><span style=display:flex><span>    sampler2D _RCSMTex;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _BaseColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _MainTex_ST;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _NormalIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIteration;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> a2v
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> v2g
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionOS   <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangentOS  <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> TEXCOORD4;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD5;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> g2f
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tbnWSPos[<span style=color:#ae81ff>3</span>]  <span style=color:#f92672>:</span> TEXCOORD2; <span style=color:#75715e>// tbnWS, posWS</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tbnOSView[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>:</span> TEXCOORD5; <span style=color:#75715e>// tbnOS, viewWS</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvScale      <span style=color:#f92672>:</span> TEXCOORD8;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    v2g vert(a2v input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        v2g output <span style=color:#f92672>=</span> (v2g)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS, input.tangentOS);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.positionOS <span style=color:#f92672>=</span> input.positionOS.xyz;
</span></span><span style=display:flex><span>        output.positionWS <span style=color:#f92672>=</span> vpi.positionWS;
</span></span><span style=display:flex><span>        output.normalOS <span style=color:#f92672>=</span> input.normalOS;
</span></span><span style=display:flex><span>        output.tangentOS <span style=color:#f92672>=</span> input.tangentOS;
</span></span><span style=display:flex><span>        output.bitangentOS <span style=color:#f92672>=</span> cross(input.normalOS, input.tangentOS.xyz) <span style=color:#f92672>*</span> input.tangentOS.w <span style=color:#f92672>*</span> GetOddNegativeScale();
</span></span><span style=display:flex><span>        output.texcoord <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [maxvertexcount(<span style=color:#ae81ff>3</span>)]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> geom(<span style=color:#66d9ef>triangle</span> v2g IN[<span style=color:#ae81ff>3</span>], <span style=color:#66d9ef>inout</span> <span style=color:#66d9ef>TriangleStream</span><span style=color:#f92672>&lt;</span>g2f<span style=color:#f92672>&gt;</span> tristream)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> camWS <span style=color:#f92672>=</span> GetCameraPositionWS();
</span></span><span style=display:flex><span>        g2f output <span style=color:#f92672>=</span> (g2f)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> posDiff01 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>1</span>].positionOS <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].positionOS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> posDiff02 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>2</span>].positionOS <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].positionOS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tangentOS0 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>0</span>].tangentOS.xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangentOS0 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>1</span>].bitangentOS;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvDiff01 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>1</span>].texcoord <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvDiff02 <span style=color:#f92672>=</span> IN[<span style=color:#ae81ff>2</span>].texcoord <span style=color:#f92672>-</span> IN[<span style=color:#ae81ff>0</span>].texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvScale;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (uvDiff01.x <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0f</span>) uvScale.x <span style=color:#f92672>=</span> dot(posDiff01, tangentOS0) <span style=color:#f92672>/</span> uvDiff01.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> uvScale.x <span style=color:#f92672>=</span> dot(posDiff02, tangentOS0) <span style=color:#f92672>/</span> uvDiff02.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (uvDiff01.y <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0f</span>) uvScale.y <span style=color:#f92672>=</span> dot(posDiff01, bitangentOS0) <span style=color:#f92672>/</span> uvDiff01.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> uvScale.y <span style=color:#f92672>=</span> dot(posDiff02, bitangentOS0) <span style=color:#f92672>/</span> uvDiff02.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            v2g input <span style=color:#f92672>=</span> IN[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS, input.tangentOS);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> viewWS <span style=color:#f92672>=</span> camWS <span style=color:#f92672>-</span> input.positionWS;
</span></span><span style=display:flex><span>            output.positionCS <span style=color:#f92672>=</span> input.positionCS;
</span></span><span style=display:flex><span>            output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>            output.tbnWSPos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.tangentWS, input.positionWS.x);
</span></span><span style=display:flex><span>            output.tbnWSPos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.bitangentWS, input.positionWS.y);
</span></span><span style=display:flex><span>            output.tbnWSPos[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.normalWS, input.positionWS.z);
</span></span><span style=display:flex><span>            output.tbnOSView[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.tangentOS.xyz, viewWS.x);
</span></span><span style=display:flex><span>            output.tbnOSView[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.bitangentOS, viewWS.y);
</span></span><span style=display:flex><span>            output.tbnOSView[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.normalOS, viewWS.z);
</span></span><span style=display:flex><span>            output.uvScale <span style=color:#f92672>=</span> uvScale;
</span></span><span style=display:flex><span>            tristream.Append(output);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        tristream.RestartStrip();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> sampleRCSM(<span style=color:#66d9ef>float2</span> uv)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> rcsm <span style=color:#f92672>=</span> tex2D(_RCSMTex, uv).xy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> rcsm.x, rcsm.y);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> getStepLength(<span style=color:#66d9ef>float</span> rayRatio, <span style=color:#66d9ef>float</span> coneRatio, <span style=color:#66d9ef>float</span> rayHeight, <span style=color:#66d9ef>float</span> sampleHeight)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> totalRatio <span style=color:#f92672>=</span> rayRatio <span style=color:#f92672>/</span> coneRatio <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (sampleHeight <span style=color:#f92672>-</span> rayHeight) <span style=color:#f92672>/</span> totalRatio;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> parallax(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float3</span> view, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> len)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        view.xy <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>view.xy <span style=color:#f92672>*</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> samplePos <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(uv, <span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> rcsm <span style=color:#f92672>=</span> sampleRCSM(samplePos.xy);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> rayRatio <span style=color:#f92672>=</span> length(view.xy);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> coneRatio <span style=color:#f92672>=</span> rcsm.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> rayHeight <span style=color:#f92672>=</span> samplePos.z;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sampleHeight <span style=color:#f92672>=</span> rcsm.x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> stepLength <span style=color:#f92672>=</span> getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);  
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>30</span>)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> _ParallaxIteration; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            samplePos <span style=color:#f92672>+=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>            rcsm <span style=color:#f92672>=</span> sampleRCSM(samplePos.xy);
</span></span><span style=display:flex><span>            coneRatio <span style=color:#f92672>=</span> rcsm.y;
</span></span><span style=display:flex><span>            rayHeight <span style=color:#f92672>=</span> samplePos.z;
</span></span><span style=display:flex><span>            sampleHeight <span style=color:#f92672>=</span> rcsm.x;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (sampleHeight <span style=color:#f92672>&lt;=</span> rayHeight) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            stepLength <span style=color:#f92672>=</span> getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        stepLength <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>        samplePos <span style=color:#f92672>-=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            rcsm <span style=color:#f92672>=</span> sampleRCSM(samplePos.xy);
</span></span><span style=display:flex><span>            stepLength <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (samplePos.z <span style=color:#f92672>&gt;=</span> rcsm.x)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                samplePos <span style=color:#f92672>-=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(samplePos.z <span style=color:#f92672>&lt;</span> rcsm.x)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                samplePos <span style=color:#f92672>+=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        len <span style=color:#f92672>=</span> samplePos.z;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> samplePos.xy;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Returns the determinant of a 2x2 matrix.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> spvDet2x2(<span style=color:#66d9ef>float</span> a1, <span style=color:#66d9ef>float</span> a2, <span style=color:#66d9ef>float</span> b1, <span style=color:#66d9ef>float</span> b2)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a1 <span style=color:#f92672>*</span> b2 <span style=color:#f92672>-</span> b1 <span style=color:#f92672>*</span> a2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Returns the inverse of a matrix, by using the algorithm of calculating the classical</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// adjoint and dividing by the determinant. The contents of the matrix are changed.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> spvInverse(<span style=color:#66d9ef>float3x3</span> m)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3x3</span> adj;	<span style=color:#75715e>// The adjoint matrix (inverse after dividing by determinant)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create the transpose of the cofactors, as the classical adjoint of the matrix.</span>
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        adj[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span>  spvDet2x2(m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>], m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate the determinant as a combination of the cofactors of the first row.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> det <span style=color:#f92672>=</span> (adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> m[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> (adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> m[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> (adj[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>*</span> m[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Divide the classical adjoint matrix by the determinant.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If determinant is zero, matrix is not invertable, so leave it unchanged.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (det <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0.0f</span>) <span style=color:#f92672>?</span> (adj <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> det)) <span style=color:#f92672>:</span> m;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(g2f input
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(OUTPUT_DEPTH)</span>
</span></span><span style=display:flex><span>    , <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> depth <span style=color:#f92672>:</span> SV_DEPTH
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tos <span style=color:#f92672>=</span> input.tbnOSView[<span style=color:#ae81ff>0</span>].xyz <span style=color:#f92672>*</span> input.uvScale.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bos <span style=color:#f92672>=</span> input.tbnOSView[<span style=color:#ae81ff>1</span>].xyz <span style=color:#f92672>*</span> input.uvScale.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> nos <span style=color:#f92672>=</span> input.tbnOSView[<span style=color:#ae81ff>2</span>].xyz <span style=color:#f92672>*</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3x3</span> t2wOS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3x3</span>(tos.x, bos.x, nos.x,
</span></span><span style=display:flex><span>                                    tos.y, bos.y, nos.y,
</span></span><span style=display:flex><span>                                    tos.z, bos.z, nos.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(input.tbnOSView[<span style=color:#ae81ff>0</span>].w, input.tbnOSView[<span style=color:#ae81ff>1</span>].w, input.tbnOSView[<span style=color:#ae81ff>2</span>].w);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewOS <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_I_M, viewWS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewTS <span style=color:#f92672>=</span> mul(spvInverse(t2wOS), viewOS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> z <span style=color:#f92672>=</span> max(abs(viewTS.z), <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>) <span style=color:#f92672>*</span> (viewTS.z <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> len;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> parallax((input.uv <span style=color:#f92672>*</span> _MainTex_ST.xy <span style=color:#f92672>+</span> _MainTex_ST.zw), viewTS <span style=color:#f92672>*</span> <span style=color:#66d9ef>float3</span>(_MainTex_ST.xy, <span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> z, len);
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(OUTPUT_DEPTH)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> offsetTS <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>viewTS <span style=color:#f92672>*</span> (len <span style=color:#f92672>/</span> z);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> offsetOS <span style=color:#f92672>=</span> mul(t2wOS, offsetTS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> positionWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(input.tbnWSPos[<span style=color:#ae81ff>0</span>].w, input.tbnWSPos[<span style=color:#ae81ff>1</span>].w, input.tbnWSPos[<span style=color:#ae81ff>2</span>].w);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> posWS <span style=color:#f92672>=</span> positionWS <span style=color:#f92672>+</span> mul((<span style=color:#66d9ef>float3x3</span>)UNITY_MATRIX_M, offsetOS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> posCS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_VP, <span style=color:#66d9ef>float4</span>(posWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>        depth <span style=color:#f92672>=</span> posCS.z <span style=color:#f92672>/</span> posCS.w;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> mainTex <span style=color:#f92672>=</span> tex2D(_MainTex, uv) <span style=color:#f92672>*</span> _BaseColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalTS <span style=color:#f92672>=</span> normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tws <span style=color:#f92672>=</span> input.tbnWSPos[<span style=color:#ae81ff>0</span>].xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bws <span style=color:#f92672>=</span> input.tbnWSPos[<span style=color:#ae81ff>1</span>].xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> nws <span style=color:#f92672>=</span> input.tbnWSPos[<span style=color:#ae81ff>2</span>].xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> n <span style=color:#f92672>=</span> normalize(mul(normalTS, <span style=color:#66d9ef>float3x3</span>(tws, bws, nws)));
</span></span><span style=display:flex><span>        Light mainLight <span style=color:#f92672>=</span> GetMainLight();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ndotl <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.0f</span>, dot(n, mainLight.direction));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> mainTex.rgb <span style=color:#f92672>*</span> mainLight.color <span style=color:#f92672>*</span> ndotl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> mainTex.a;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(color, alpha);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags{ <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Geometry&#34;</span>}
</span></span><span style=display:flex><span>        Cull Back
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma geometry geom
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=æœ€ç»ˆçš„æ•ˆæœ>æœ€ç»ˆçš„æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#æœ€ç»ˆçš„æ•ˆæœ>#</a></h2><p>æœ€åçš„æ•ˆæœä¹Ÿå°±å¦‚å°é¢å›¾ä¸€æ ·äº†ï¼Œå·¦è¾¹æ˜¯RCSMåšçš„ï¼Œå…¶ä½™çš„åˆ™æ˜¯æ™®é€šçš„POMæ•ˆæœã€‚ç‰¹åœ°å¯¹æ¨¡å‹åšäº†ç¼©æ”¾ï¼Œå¯¹è´´å›¾çš„å¹³é“ºè¿›è¡Œè°ƒæ•´ï¼Œç”¨æ¥è¡¨æ˜è¿™ä¸ªè®¡ç®—æ–¹å¼çš„æ­£ç¡®æ€§ï¼ŒåŒæ ·çš„æè´¨çƒç”¨åœ¨ä¸åŒçš„æ¨¡å‹ä¸Šä¹Ÿèƒ½å¤Ÿå¾—åˆ°æ­£ç¡®çš„æ·±åº¦å€¼ã€‚ä½†æ˜¯åƒçƒä½“è¿™æ ·çš„uvå¹¶ä¸è§„åˆ™çš„æ¨¡å‹ï¼Œç”¨ä¸Šè¿°çš„æ–¹æ³•å¹¶ä¸èƒ½å¾—åˆ°å®Œç¾çš„æ·±åº¦æ•ˆæœã€‚ä¸Šé¢å’Œä¸‹é¢å¹³é¢ä½¿ç”¨çš„è´´å›¾æ¥è‡ªQuixelçš„Megascansã€‚</p><p><img loading=lazy src=../images/CorrectDepth_POM_RCSM.png#center alt="Correct Depth POM &amp;amp; RCSM"></p><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>åˆè¿…é€Ÿåœ°å†™äº†ä¸€ç¯‡æ–‡ç« ï¼Œè®¡ç®—äº†è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ä¹‹åï¼Œå„ç§å±å¹•ç©ºé—´çš„ç®—æ³•ä¹Ÿéƒ½èƒ½å¤Ÿæ­£å¸¸åœ°ä½¿ç”¨äº†ï¼Œå¾ˆå¥½ã€‚è¯åˆè¯´å›æ¥äº†æˆ‘è¢«LearnOpenGLçš„è´´å›¾å‘äº†ä¸€æ³¢ï¼Œå±…ç„¶æ²¡æœ‰æ„è¯†åˆ°ä¸Šé¢çš„æ³•çº¿å›¾å’Œå¹³å¸¸ä½¿ç”¨çš„æ³•çº¿å›¾æ˜¯ä¸ä¸€æ ·çš„ï¼Œæˆ‘å°±è¯´æ€ä¹ˆçœ‹ä¸Šå»æœ‰ä¸€ç§è¿å’Œæ„Ÿã€‚åæ¥æˆ‘ç›´æ¥åœ¨Blenderé‡Œè‡ªå·±å¯¼å‡ºäº†è¿™ä¸ªToy Boxçš„<a href=../images/Toy_Box_Normal.jpg>æ³•çº¿</a>å’Œ<a href=../images/Toy_Box_Height.jpg>æ·±åº¦å›¾</a>ï¼Œè¿™æ‰æ„Ÿè§‰ä¸€åˆ‡éƒ½æ­£å¸¸äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/relaxed-cone-step-mapping/>Relaxed Cone Step Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/parallax-occlusion-mapping/>Parallax Occlusion Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/><span class=title>Â« Prev</span><br><span>åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º</span>
</a><a class=next href=https://zznewclear13.github.io/posts/screen-space-reflection-en/><span class=title>Next Â»</span><br><span>Screen Space Reflection</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>