<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼ | ZZNEWCLEAR13</title><meta name=keywords content="Relaxed Cone Step Mapping,Parallax Occlusion Mapping,Space Transformation"><meta name=description content="åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/><link crossorigin=anonymous href=/assets/css/stylesheet.a6fe470bfe70eb4fad7ee3efc590e817f121cf0f6d66fa91de327cf6bfbad62d.css integrity="sha256-pv5HC/5w60+tfuPvxZDoF/Ehzw9tZvqR3jJ89r+61i0=" rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼"><meta property="og:description" content="åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/"><meta property="og:image" content="https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/posts/images/CorrectDepth_POM_RCSM.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-16T12:00:00+08:00"><meta property="article:modified_time" content="2024-03-16T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/posts/images/CorrectDepth_POM_RCSM.png"><meta name=twitter:title content="ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼"><meta name=twitter:description content="åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼","item":"https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼","name":"ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼","description":"åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º.","keywords":["Relaxed Cone Step Mapping","Parallax Occlusion Mapping","Space Transformation"],"articleBody":"POMå’ŒRCSM åœ¨æˆ‘ä¹‹å‰çš„æ–‡ç« åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mappingå°±å·²ç»ä»‹ç»è¿‡äº†è§†å·®æ˜ å°„å’Œæ¾æ•£åœ†é”¥æ­¥è¿›æµ®é›•æ˜ å°„çš„è®¡ç®—æ–¹æ³•äº†ï¼Œä½†æ˜¯ä¹‹å‰å¹¶æ²¡æœ‰å¯¹è®¡ç®—æ·±åº¦å€¼åšç›¸åº”çš„ç ”ç©¶ï¼ŒåŒæ—¶ä¹Ÿé™åˆ¶äºç¯‡å¹…çš„åŸå› å°±æ²¡æœ‰å†å±•å¼€äº†ï¼Œè¿™ç¯‡æ–‡ç« ç›¸å½“äºæ˜¯ä¹‹å‰æ–‡ç« çš„åç»­ã€‚ä¸ºäº†ç®€ä¾¿ï¼Œåç»­å°†è¿™ä¸¤ç§è®¡ç®—æ–¹æ³•ç»Ÿç§°ä¸ºè§†å·®æ˜ å°„ã€‚\nåœ¨è§†å·®æ˜ å°„ä¸­è®¡ç®—æ·±åº¦å€¼æ˜¯ä¸€ä¸ªå¾ˆç›´æ¥çš„æƒ³æ³•ï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½ä¼šæœ‰å…¶ä»–ç‰©ä½“è¢«æ”¾ç½®åœ¨è§†å·®æ˜ å°„çš„è¡¨é¢ï¼Œä¸ä¹‹å‘ç”Ÿç©¿æ’ï¼Œå¦‚æœä¸åšç‰¹æ®Šå¤„ç†ï¼Œå°±ä¼šä½¿ç”¨æ¨¡å‹æœ¬èº«çš„æ·±åº¦å€¼è¿›è¡Œæ·±åº¦æ¯”è¾ƒï¼Œå¯¼è‡´åˆ«çš„ç‰©ä½“ä¸èƒ½æœ‰æ­£ç¡®çš„è¢«é®æŒ¡çš„æ•ˆæœï¼Œå‰Šå¼±äº†è§†å·®æ˜ å°„å¸¦æ¥çš„çœŸå®æ„Ÿã€‚ç½‘ä¸Šæˆ‘æ‰¾äº†ä¸€åœˆï¼Œå¹¶æ²¡æœ‰æ‰¾åˆ°å’Œè®¡ç®—è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ç›¸å…³çš„æ–‡ç« ï¼Œå› æ­¤æˆ‘æƒ³ç”¨è¿™ç¯‡æ–‡ç« è¿›è¡Œç›¸å…³çš„ä»‹ç»ã€‚\nUnityçš„é«˜æ¸…ç®¡çº¿ï¼ˆHDRPï¼‰çš„Lit Shaderæ”¯æŒè®¡ç®—åƒç´ æ·±åº¦åç§»ï¼Œæä¾›äº†Primitive Lengthï¼ŒPrimitive Widthï¼Œå’ŒAmplitudeä¸‰ä¸ªå‚æ•°ã€‚Amplitudeå¯ä»¥ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„å¼ºåº¦å€¼ï¼Œè™½ç„¶å…¶ä¸€ä¸ªå•ä½å’Œä¸–ç•Œç©ºé—´çš„ä¸€ç±³å®Œå…¨ä¸èƒ½ç›´æ¥ç­‰åŒèµ·æ¥ï¼Œä½†æ˜¯å€¼è¶Šå¤§è§†å·®çœ‹ä¸Šå»å°±è¶Šæ·±ï¼Œå¯ä»¥æ ¹æ®è§†è§‰å®æ—¶è°ƒæ•´è¿™ä¸ªå‚æ•°ã€‚å¦å¤–ä¸¤ä¸ªå‚æ•°å°±å¾ˆå¥‡æ€ªäº†ï¼Œå±…ç„¶å’Œæ¨¡å‹çš„å¤§å°æœ‰å…³ï¼ŒåŒä¸€ä¸ªæè´¨çƒï¼Œç”¨åœ¨Quadä¸Šè¿™é‡Œå°±è¦å¡«1ï¼Œç”¨åœ¨Planeä¸Šå°±è¦å¡«10ï¼Œå“ªæœ‰è¿™ç§é“ç†ï¼Ÿè™šå¹»å¼•æ“åˆ™æ˜¯æä¾›äº†POMçš„æ¥å£ï¼Œè‡³äºè¾“å…¥å’Œè¾“å‡ºå®Œå…¨éƒ½ç”±ç”¨æˆ·æ§åˆ¶ï¼Œè¿™é‡Œå°±ä¸å¤ªå¥½ç›´æ¥æ¯”è¾ƒäº†ã€‚\nå›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹ è§†å·®æ˜ å°„ä¸€èˆ¬ä¸ä¼šç›´æ¥åœ¨ä¸–ç•Œç©ºé—´æ­¥è¿›ï¼Œè€Œæ˜¯ä¼šå…ˆå°†ä¸–ç•Œç©ºé—´çš„è§†çº¿viewWSè½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´viewTSï¼Œåœ¨åˆ‡çº¿ç©ºé—´æ­¥è¿›ã€‚ç…§å¸¸ç†_ParallaxIntensityæ˜¯ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„æ·±åº¦çš„ï¼Œå› æ­¤ä¼šä½¿ç”¨è¿™ä¸ªå‚æ•°æ§åˆ¶zæ–¹å‘æ­¥è¿›çš„è·ç¦»ï¼Œä½†ä¸ºäº†æ–¹ä¾¿å’Œé«˜åº¦å›¾ä¸­è®°è½½çš„é«˜åº¦è¿›è¡Œå¯¹æ¯”ï¼Œä¼šå…ˆå¯¹viewTSçš„zåˆ†é‡è¿›è¡Œå½’ä¸€åŒ–ï¼Œå°†_ParallaxIntensityåœ¨æ­¥è¿›æ—¶ä¹˜åˆ°viewTSçš„xyåˆ†é‡ä¸Šï¼Œä¹‹åå°±æ˜¯å¾ªç¯æ¯”è¾ƒæ·±åº¦è¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯äº†ã€‚\nä½†æ˜¯ä¸ºä»€ä¹ˆæ˜¯åˆ‡çº¿ç©ºé—´å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºåˆ‡çº¿tangentå’Œå‰¯åˆ‡çº¿bitangentä»£è¡¨äº†è´´å›¾UVçš„xyçš„æ­£æ–¹å‘ï¼Œå°†è§†çº¿è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´ï¼Œå…¶å®ç›®çš„æ˜¯å°†è§†çº¿è½¬åˆ°UVç©ºé—´ï¼Œæˆ–è€…è¯´æ˜¯è´´å›¾ç©ºé—´ï¼ˆTexture Spaceï¼Œå› ä¸ºå…¶ä¸åˆ‡çº¿ç©ºé—´çš„ç›¸ä¼¼æ€§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç”¨TSæ¥åšç®€å†™ï¼‰ã€‚è¿™é‡Œå°±å‡ºç°äº†æœ€é‡è¦çš„ä¸€ä¸ªé—®é¢˜ï¼ŒUnityä¸­é€šè¿‡GetVertexNormalInputsè·å¾—åˆ°çš„ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿æ˜¯ç»è¿‡å½’ä¸€åŒ–çš„ï¼Œä¸¢å¤±äº†ç‰©ä½“è‡ªèº«çš„ç¼©æ”¾ï¼Œæ‰€ä»¥æˆ‘ä»¬å…¶å®åº”è¯¥å…ˆå°†ä¸–ç•Œåæ ‡çš„è§†çº¿viewWSè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´viewOSï¼Œç„¶åå†ä½¿ç”¨ç‰©ä½“ç©ºé—´çš„tbnçŸ©é˜µï¼Œå°†viewOSè½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´viewTSã€‚ä½†åˆå¦‚æˆ‘ä¸Šé¢è¯´åˆ°çš„ï¼Œæˆ‘ä»¬çœŸå®çš„ç›®çš„æ˜¯è´´å›¾ç©ºé—´ï¼Œåˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´æ˜¯å­˜åœ¨å·®å¼‚æ€§çš„ã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆUnityçš„HDRPè¦ä½¿ç”¨é¢å¤–çš„å‚æ•°Primitive Lengthå’ŒPrimitive Widthäº†ï¼Œè¿™ä¸¤ä¸ªå‚æ•°çš„ç›®çš„æ˜¯é€šè¿‡é¢å¤–çš„ç¼©æ”¾ï¼Œå°†åˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´å¯¹åº”èµ·æ¥ã€‚\nè¿™ä¸¤ä¸ªå‚æ•°çš„æ„ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ï¼Œè¿™é‡Œæˆ‘ä»¬è®°ä¸ºuvScaleã€‚åŒæ—¶æˆ‘ä»¬å¯ä»¥é¡ºç†æˆç« åœ°æ­£å¼å¼•å…¥_ParallaxIntensityè¿™ä¸ªå‚æ•°ï¼Œå®ƒçš„å«ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ä¸­é¢œè‰²ä¸º0çš„ç‚¹å¯¹åº”çš„ç‰©ä½“ç©ºé—´çš„æ·±åº¦å€¼ã€‚è´´å›¾ç©ºé—´è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´ï¼Œåªéœ€è¦å¯¹xyzä¸‰ä¸ªåˆ†é‡åˆ†åˆ«ä¹˜ä¸ŠuvScale.xï¼ŒuvScale.yï¼Œå’Œ_ParallaxIntensityå³å¯ã€‚_ParallaxIntensityè¿™ä¸ªå‚æ•°æˆ‘ä»¬å¯ä»¥ä½œä¸ºæè´¨çƒçš„ä¸€ä¸ªè¾“å…¥è¿›è¡Œæ§åˆ¶ï¼ŒuvScaleæ˜¯ä¸€ä¸ªè·Ÿæ¨¡å‹ç›¸å…³çš„å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Geometry Shaderä¸­è®¡ç®—è€Œå¾—ã€‚\nuvScaleçš„è®¡ç®— å¦‚ä¸Šé¢æ‰€å±ï¼ŒuvScaleæŒ‡ä»£çš„æ˜¯è´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ã€‚å¯¹äºä¸¤ä¸ªé¡¶ç‚¹v0å’Œv1ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡å…¶å®å°±æ˜¯è¿™ä¸¤ä¸ªé¡¶ç‚¹uvå€¼çš„å·®ï¼Œç‰©ä½“ç©ºé—´çš„é•¿åº¦å…¶å®å°±æ˜¯ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œä¸ºäº†å¯¹åº”åˆ°è´´å›¾ç©ºé—´ä¸Šï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—è¿™æ®µè·ç¦»åœ¨åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ä¸Šçš„æŠ•å½±é•¿åº¦ï¼Œåè€…é™¤ä»¥å‰è€…å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„uvScaleäº†ã€‚ç”±äºæ„æˆä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹å¯èƒ½ä¼šå­˜åœ¨æŸä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´uvçš„æŸä¸ªåˆ†é‡çš„å˜åŒ–ç‡ä¸º0ï¼Œå¯¼è‡´æˆ‘ä»¬è®¡ç®—uvScaleçš„æ—¶å€™é™¤ä»¥é›¶ï¼Œæˆ‘ä»¬åœ¨æ£€æµ‹åˆ°è¿™ä¸ªæƒ…å†µçš„æ—¶å€™ä½¿ç”¨ç¬¬ä¸‰ä¸ªé¡¶ç‚¹å³å¯ã€‚\nè´´å›¾ç©ºé—´å˜æ¢ åœ¨è·å¾—äº†ç‰©ä½“ç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿ä¹‹åï¼Œä¸ºäº†æ„æˆè´´å›¾ç©ºé—´çš„ä¸‰ä¸ªåŸºå‘é‡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹è¿™ä¸ªå‘é‡ä½¿ç”¨uvScaleå’Œ_ParallaxIntensityè¿›è¡Œç¼©æ”¾ã€‚è¿™ä¸ªç¼©æ”¾å¯¼è‡´äº†æˆ‘ä»¬æŒ‰ç…§ä»¥å¾€çš„float3x3(tangentOS * uvScale.x, bitangentOS * uvScale.y, normalOS * _ParallaxIntensity)æ„æˆçš„çŸ©é˜µä¸å†æ˜¯ä¸€ä¸ªæ­£äº¤çŸ©é˜µï¼Œå®ƒå®é™…ä¸Šæ˜¯è´´å›¾ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„å˜æ¢çŸ©é˜µçš„è½¬ç½®ã€‚å› æ­¤å°†ç‰©ä½“ç©ºé—´çš„è§†çº¿viewOSè½¬æ¢åˆ°è´´å›¾ç©ºé—´viewTSæ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®çš„é€†å·¦ä¹˜viewOSï¼Œå°†è´´å›¾ç©ºé—´çš„è§†çº¿viewTSè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´viewOSæ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®å·¦ä¹˜viewTSã€‚\næ·±åº¦çš„è·å– è¿™ä¸ªå°±ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•äº†ï¼Œæˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„æ—¶å€™ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„zæ–¹å‘çš„æ·±åº¦å€¼lenã€‚è€Œç”±äºæˆ‘ä»¬çš„viewTSä¼šåšé™¤ä»¥zåˆ†é‡çš„å½’ä¸€åŒ–ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å½’ä¸€åŒ–å‰çš„-viewTSä¹˜ä¸Šlenå†é™¤ä»¥zåˆ†é‡ï¼Œå°±èƒ½çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´ä¸­æ€»çš„æ­¥è¿›çš„å‘é‡ï¼Œå°†å…¶è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´ï¼Œå’Œå½“å‰ç‚¹çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ç›¸åŠ åå†è½¬æ¢åˆ°è£å‰ªç©ºé—´ï¼Œå…¶zåˆ†é‡é™¤ä»¥wåˆ†é‡å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„æ·±åº¦å€¼äº†ã€‚\nå…·ä½“çš„ä»£ç  è¿™é‡Œåªåšäº†å¯è¡Œæ€§çš„ç ”ç©¶ï¼Œåº”è¯¥æœ‰ä¸ªæ–¹æ³•èƒ½å¤Ÿç®€åŒ–è®¡ç®—çŸ©é˜µçš„é€†è¿™ä¸€æ­¥æ“ä½œã€‚åœ¨è®¡ç®—ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿çš„æ—¶å€™ï¼Œå¯ä»¥ä¸è¿›è¡Œå½’ä¸€åŒ–ï¼Œè¿™æ ·æˆ‘ä»¬ä¹Ÿå°±ä¸éœ€è¦å…ˆè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°è´´å›¾ç©ºé—´äº†ã€‚\nPOMShader.shader Shader \"zznewclear13/POMShader\"\r{\rProperties\r{\r[Toggle(OUTPUT_DEPTH)] _OutputDepth (\"Output Depth\", Float) = 1\r_BaseColor(\"Base Color\", Color) = (1, 1, 1, 1)\r_MainTex (\"Texture\", 2D) = \"white\" {}\r_HeightMap(\"Height Map\", 2D) = \"white\" {}\r_NormalMap(\"Normal Map\", 2D) = \"bump\" {}\r_NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1\r_ParallaxIntensity (\"Parallax Intensity\", Float) = 1\r_ParallaxIteration (\"Parallax Iteration\", Float) = 15\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\r#pragma shader_feature OUTPUT_DEPTH\rsampler2D _MainTex;\rsampler2D _HeightMap;\rsampler2D _NormalMap;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat4 _MainTex_ST;\rfloat _NormalIntensity;\rfloat _ParallaxIntensity;\rfloat _ParallaxIteration;\rCBUFFER_END\rstruct a2v\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct v2g\r{\rfloat4 positionCS : SV_POSITION;\rfloat3 positionOS : TEXCOORD0;\rfloat3 positionWS : TEXCOORD1;\rfloat4 tangentOS : TEXCOORD2;\rfloat3 bitangentOS : TEXCOORD3;\rfloat3 normalOS : TEXCOORD4;\rfloat2 texcoord : TEXCOORD5;\r};\rstruct g2f\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD1;\rfloat4 tbnWSPos[3] : TEXCOORD2; // tbnWS, posWS\rfloat4 tbnOSView[3] : TEXCOORD5; // tbnOS, viewWS\rfloat2 uvScale : TEXCOORD8;\r};\rv2g vert(a2v input)\r{\rv2g output = (v2g)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);\routput.positionCS = vpi.positionCS;\routput.positionOS = input.positionOS.xyz;\routput.positionWS = vpi.positionWS;\routput.normalOS = input.normalOS;\routput.tangentOS = input.tangentOS;\routput.bitangentOS = cross(input.normalOS, input.tangentOS.xyz) * input.tangentOS.w * GetOddNegativeScale();\routput.texcoord = input.texcoord;\rreturn output;\r}\r[maxvertexcount(3)]\rvoid geom(triangle v2g IN[3], inout TriangleStream tristream)\r{\rfloat3 camWS = GetCameraPositionWS();\rg2f output = (g2f)0;\rfloat3 posDiff01 = IN[1].positionOS - IN[0].positionOS;\rfloat3 posDiff02 = IN[2].positionOS - IN[0].positionOS;\rfloat3 tangentOS0 = IN[0].tangentOS.xyz;\rfloat3 bitangentOS0 = IN[1].bitangentOS;\rfloat2 uvDiff01 = IN[1].texcoord - IN[0].texcoord;\rfloat2 uvDiff02 = IN[2].texcoord - IN[0].texcoord;\rfloat2 uvScale;\rif (uvDiff01.x != 0.0f) uvScale.x = dot(posDiff01, tangentOS0) / uvDiff01.x;\relse uvScale.x = dot(posDiff02, tangentOS0) / uvDiff02.x;\rif (uvDiff01.y != 0.0f) uvScale.y = dot(posDiff01, bitangentOS0) / uvDiff01.y;\relse uvScale.y = dot(posDiff02, bitangentOS0) / uvDiff02.y;\rfor (int i=0; i= 0.0f ? 1.0f : -1.0f);\rfloat len;\rfloat2 uv = parallax((input.uv * _MainTex_ST.xy + _MainTex_ST.zw), viewTS * float3(_MainTex_ST.xy, 1.0f) / z, len);\r#if defined(OUTPUT_DEPTH)\rfloat3 offsetTS = -viewTS * (len / z);\rfloat3 offsetOS = mul(t2wOS, offsetTS);\rfloat3 positionWS = float3(input.tbnWSPos[0].w, input.tbnWSPos[1].w, input.tbnWSPos[2].w);\rfloat3 posWS = positionWS + mul((float3x3)UNITY_MATRIX_M, offsetOS);\rfloat4 posCS = mul(UNITY_MATRIX_VP, float4(posWS, 1.0f));\rdepth = posCS.z / posCS.w;\r#endif\rfloat4 mainTex = tex2D(_MainTex, uv) * _BaseColor;\rfloat3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));\rfloat3 tws = input.tbnWSPos[0].xyz;\rfloat3 bws = input.tbnWSPos[1].xyz;\rfloat3 nws = input.tbnWSPos[2].xyz;\rfloat3 n = normalize(mul(normalTS, float3x3(tws, bws, nws)));\rLight mainLight = GetMainLight();\rfloat ndotl = max(0.0f, dot(n, mainLight.direction));\rfloat3 color = mainTex.rgb * mainLight.color * ndotl;\rfloat alpha = mainTex.a;\rreturn float4(color, alpha);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"}\rCull Back\rPass\r{\rHLSLPROGRAM\r#pragma vertex vert\r#pragma geometry geom\r#pragma fragment frag\rENDHLSL\r}\r}\r}\rRCSMShader.Shader Shader \"zznewclear13/RCSMShader\"\r{\rProperties\r{\r[Toggle(OUTPUT_DEPTH)] _OutputDepth (\"Output Depth\", Float) = 1\r_BaseColor(\"Base Color\", Color) = (1, 1, 1, 1)\r_MainTex (\"Texture\", 2D) = \"white\" {}\r_RCSMTex(\"RCSM Texture\", 2D) = \"white\" {}\r_NormalMap(\"Normal Map\", 2D) = \"bump\" {}\r_NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1\r_ParallaxIntensity(\"Parallax Intensity\", Float) = 1\r_ParallaxIteration(\"Parallax Iteration\", Float) = 15\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\r#pragma shader_feature OUTPUT_DEPTH\rsampler2D _MainTex;\rsampler2D _NormalMap;\rsampler2D _RCSMTex;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat4 _MainTex_ST;\rfloat _NormalIntensity;\rfloat _ParallaxIntensity;\rfloat _ParallaxIteration;\rCBUFFER_END\rstruct a2v\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct v2g\r{\rfloat4 positionCS : SV_POSITION;\rfloat3 positionOS : TEXCOORD0;\rfloat3 positionWS : TEXCOORD1;\rfloat4 tangentOS : TEXCOORD2;\rfloat3 bitangentOS : TEXCOORD3;\rfloat3 normalOS : TEXCOORD4;\rfloat2 texcoord : TEXCOORD5;\r};\rstruct g2f\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD1;\rfloat4 tbnWSPos[3] : TEXCOORD2; // tbnWS, posWS\rfloat4 tbnOSView[3] : TEXCOORD5; // tbnOS, viewWS\rfloat2 uvScale : TEXCOORD8;\r};\rv2g vert(a2v input)\r{\rv2g output = (v2g)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);\routput.positionCS = vpi.positionCS;\routput.positionOS = input.positionOS.xyz;\routput.positionWS = vpi.positionWS;\routput.normalOS = input.normalOS;\routput.tangentOS = input.tangentOS;\routput.bitangentOS = cross(input.normalOS, input.tangentOS.xyz) * input.tangentOS.w * GetOddNegativeScale();\routput.texcoord = input.texcoord;\rreturn output;\r}\r[maxvertexcount(3)]\rvoid geom(triangle v2g IN[3], inout TriangleStream tristream)\r{\rfloat3 camWS = GetCameraPositionWS();\rg2f output = (g2f)0;\rfloat3 posDiff01 = IN[1].positionOS - IN[0].positionOS;\rfloat3 posDiff02 = IN[2].positionOS - IN[0].positionOS;\rfloat3 tangentOS0 = IN[0].tangentOS.xyz;\rfloat3 bitangentOS0 = IN[1].bitangentOS;\rfloat2 uvDiff01 = IN[1].texcoord - IN[0].texcoord;\rfloat2 uvDiff02 = IN[2].texcoord - IN[0].texcoord;\rfloat2 uvScale;\rif (uvDiff01.x != 0.0f) uvScale.x = dot(posDiff01, tangentOS0) / uvDiff01.x;\relse uvScale.x = dot(posDiff02, tangentOS0) / uvDiff02.x;\rif (uvDiff01.y != 0.0f) uvScale.y = dot(posDiff01, bitangentOS0) / uvDiff01.y;\relse uvScale.y = dot(posDiff02, bitangentOS0) / uvDiff02.y;\rfor (int i=0; i= rcsm.x)\r{\rsamplePos -= stepLength * view;\r}\relse if(samplePos.z = 0.0f ? 1.0f : -1.0f);\rfloat len;\rfloat2 uv = parallax((input.uv * _MainTex_ST.xy + _MainTex_ST.zw), viewTS * float3(_MainTex_ST.xy, 1.0f) / z, len);\r#if defined(OUTPUT_DEPTH)\rfloat3 offsetTS = -viewTS * (len / z);\rfloat3 offsetOS = mul(t2wOS, offsetTS);\rfloat3 positionWS = float3(input.tbnWSPos[0].w, input.tbnWSPos[1].w, input.tbnWSPos[2].w);\rfloat3 posWS = positionWS + mul((float3x3)UNITY_MATRIX_M, offsetOS);\rfloat4 posCS = mul(UNITY_MATRIX_VP, float4(posWS, 1.0f));\rdepth = posCS.z / posCS.w;\r#endif\rfloat4 mainTex = tex2D(_MainTex, uv) * _BaseColor;\rfloat3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));\rfloat3 tws = input.tbnWSPos[0].xyz;\rfloat3 bws = input.tbnWSPos[1].xyz;\rfloat3 nws = input.tbnWSPos[2].xyz;\rfloat3 n = normalize(mul(normalTS, float3x3(tws, bws, nws)));\rLight mainLight = GetMainLight();\rfloat ndotl = max(0.0f, dot(n, mainLight.direction));\rfloat3 color = mainTex.rgb * mainLight.color * ndotl;\rfloat alpha = mainTex.a;\rreturn float4(color, alpha);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"}\rCull Back\rPass\r{\rHLSLPROGRAM\r#pragma vertex vert\r#pragma geometry geom\r#pragma fragment frag\rENDHLSL\r}\r}\r}\ræœ€ç»ˆçš„æ•ˆæœ æœ€åçš„æ•ˆæœä¹Ÿå°±å¦‚å°é¢å›¾ä¸€æ ·äº†ï¼Œå·¦è¾¹æ˜¯RCSMåšçš„ï¼Œå…¶ä½™çš„åˆ™æ˜¯æ™®é€šçš„POMæ•ˆæœã€‚ç‰¹åœ°å¯¹æ¨¡å‹åšäº†ç¼©æ”¾ï¼Œå¯¹è´´å›¾çš„å¹³é“ºè¿›è¡Œè°ƒæ•´ï¼Œç”¨æ¥è¡¨æ˜è¿™ä¸ªè®¡ç®—æ–¹å¼çš„æ­£ç¡®æ€§ï¼ŒåŒæ ·çš„æè´¨çƒç”¨åœ¨ä¸åŒçš„æ¨¡å‹ä¸Šä¹Ÿèƒ½å¤Ÿå¾—åˆ°æ­£ç¡®çš„æ·±åº¦å€¼ã€‚ä½†æ˜¯åƒçƒä½“è¿™æ ·çš„uvå¹¶ä¸è§„åˆ™çš„æ¨¡å‹ï¼Œç”¨ä¸Šè¿°çš„æ–¹æ³•å¹¶ä¸èƒ½å¾—åˆ°å®Œç¾çš„æ·±åº¦æ•ˆæœã€‚ä¸Šé¢å’Œä¸‹é¢å¹³é¢ä½¿ç”¨çš„è´´å›¾æ¥è‡ªQuixelçš„Megascansã€‚\nåè®° åˆè¿…é€Ÿåœ°å†™äº†ä¸€ç¯‡æ–‡ç« ï¼Œè®¡ç®—äº†è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ä¹‹åï¼Œå„ç§å±å¹•ç©ºé—´çš„ç®—æ³•ä¹Ÿéƒ½èƒ½å¤Ÿæ­£å¸¸åœ°ä½¿ç”¨äº†ï¼Œå¾ˆå¥½ã€‚è¯åˆè¯´å›æ¥äº†æˆ‘è¢«LearnOpenGLçš„è´´å›¾å‘äº†ä¸€æ³¢ï¼Œå±…ç„¶æ²¡æœ‰æ„è¯†åˆ°ä¸Šé¢çš„æ³•çº¿å›¾å’Œå¹³å¸¸ä½¿ç”¨çš„æ³•çº¿å›¾æ˜¯ä¸ä¸€æ ·çš„ï¼Œæˆ‘å°±è¯´æ€ä¹ˆçœ‹ä¸Šå»æœ‰ä¸€ç§è¿å’Œæ„Ÿã€‚åæ¥æˆ‘ç›´æ¥åœ¨Blenderé‡Œè‡ªå·±å¯¼å‡ºäº†è¿™ä¸ªToy Boxçš„æ³•çº¿å’Œæ·±åº¦å›¾ï¼Œè¿™æ‰æ„Ÿè§‰ä¸€åˆ‡éƒ½æ­£å¸¸äº†ã€‚\n","wordCount":"1871","inLanguage":"en","image":"https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/posts/images/CorrectDepth_POM_RCSM.png","datePublished":"2024-03-16T12:00:00+08:00","dateModified":"2024-03-16T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/get-correct-depth-from-parallax-occlusion-mapping/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼</h1><div class=post-description>åŒæ—¶é€‚é…æ¨¡å‹æœ¬èº«UVã€ç¼©æ”¾ï¼Œå’Œè´´å›¾çš„å¹³é“º.</div><div class=post-meta><span title="2024-03-16 12:00:00 +0800 CST">March 16, 2024</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/get-correct-depth-from-parallax-occlusion-mapping.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/CorrectDepth_POM_RCSM.png alt="Correct Depth POM & RCSM Cover"><p>Correct Depth POM & RCSM Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä»è§†å·®æ˜ å°„ã€æµ®é›•æ˜ å°„ä¸­è·å–æ­£ç¡®çš„æ·±åº¦å€¼</div></summary><div class=inner><ul><li><a href=#pom%e5%92%8crcsm aria-label=POMå’ŒRCSM>POMå’ŒRCSM</a></li><li><a href=#%e5%9b%9e%e9%a1%bepom%e7%9a%84%e8%ae%a1%e7%ae%97%e8%bf%87%e7%a8%8b aria-label=å›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹>å›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹</a><ul><li><a href=#uvscale%e7%9a%84%e8%ae%a1%e7%ae%97 aria-label=uvScaleçš„è®¡ç®—>uvScaleçš„è®¡ç®—</a></li><li><a href=#%e8%b4%b4%e5%9b%be%e7%a9%ba%e9%97%b4%e5%8f%98%e6%8d%a2 aria-label=è´´å›¾ç©ºé—´å˜æ¢>è´´å›¾ç©ºé—´å˜æ¢</a></li><li><a href=#%e6%b7%b1%e5%ba%a6%e7%9a%84%e8%8e%b7%e5%8f%96 aria-label=æ·±åº¦çš„è·å–>æ·±åº¦çš„è·å–</a></li></ul></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç </a><ul><li><a href=#pomshadershader aria-label=POMShader.shader>POMShader.shader</a></li><li><a href=#rcsmshadershader aria-label=RCSMShader.Shader>RCSMShader.Shader</a></li></ul></li><li><a href=#%e6%9c%80%e7%bb%88%e7%9a%84%e6%95%88%e6%9e%9c aria-label=æœ€ç»ˆçš„æ•ˆæœ>æœ€ç»ˆçš„æ•ˆæœ</a></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=pomå’Œrcsm>POMå’ŒRCSM<a hidden class=anchor aria-hidden=true href=#pomå’Œrcsm>#</a></h2><p>åœ¨æˆ‘ä¹‹å‰çš„æ–‡ç« <a href=https://zznewclear13.github.io/relaxed-cone-step-mapping-in-unity/>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</a>å°±å·²ç»ä»‹ç»è¿‡äº†è§†å·®æ˜ å°„å’Œæ¾æ•£åœ†é”¥æ­¥è¿›æµ®é›•æ˜ å°„çš„è®¡ç®—æ–¹æ³•äº†ï¼Œä½†æ˜¯ä¹‹å‰å¹¶æ²¡æœ‰å¯¹è®¡ç®—æ·±åº¦å€¼åšç›¸åº”çš„ç ”ç©¶ï¼ŒåŒæ—¶ä¹Ÿé™åˆ¶äºç¯‡å¹…çš„åŸå› å°±æ²¡æœ‰å†å±•å¼€äº†ï¼Œè¿™ç¯‡æ–‡ç« ç›¸å½“äºæ˜¯ä¹‹å‰æ–‡ç« çš„åç»­ã€‚ä¸ºäº†ç®€ä¾¿ï¼Œåç»­å°†è¿™ä¸¤ç§è®¡ç®—æ–¹æ³•ç»Ÿç§°ä¸ºè§†å·®æ˜ å°„ã€‚</p><p>åœ¨è§†å·®æ˜ å°„ä¸­è®¡ç®—æ·±åº¦å€¼æ˜¯ä¸€ä¸ªå¾ˆç›´æ¥çš„æƒ³æ³•ï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½ä¼šæœ‰å…¶ä»–ç‰©ä½“è¢«æ”¾ç½®åœ¨è§†å·®æ˜ å°„çš„è¡¨é¢ï¼Œä¸ä¹‹å‘ç”Ÿç©¿æ’ï¼Œå¦‚æœä¸åšç‰¹æ®Šå¤„ç†ï¼Œå°±ä¼šä½¿ç”¨æ¨¡å‹æœ¬èº«çš„æ·±åº¦å€¼è¿›è¡Œæ·±åº¦æ¯”è¾ƒï¼Œå¯¼è‡´åˆ«çš„ç‰©ä½“ä¸èƒ½æœ‰æ­£ç¡®çš„è¢«é®æŒ¡çš„æ•ˆæœï¼Œå‰Šå¼±äº†è§†å·®æ˜ å°„å¸¦æ¥çš„çœŸå®æ„Ÿã€‚ç½‘ä¸Šæˆ‘æ‰¾äº†ä¸€åœˆï¼Œå¹¶æ²¡æœ‰æ‰¾åˆ°å’Œè®¡ç®—è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ç›¸å…³çš„æ–‡ç« ï¼Œå› æ­¤æˆ‘æƒ³ç”¨è¿™ç¯‡æ–‡ç« è¿›è¡Œç›¸å…³çš„ä»‹ç»ã€‚</p><p>Unityçš„é«˜æ¸…ç®¡çº¿ï¼ˆHDRPï¼‰çš„Lit Shaderæ”¯æŒè®¡ç®—åƒç´ æ·±åº¦åç§»ï¼Œæä¾›äº†<code>Primitive Length</code>ï¼Œ<code>Primitive Width</code>ï¼Œå’Œ<code>Amplitude</code>ä¸‰ä¸ªå‚æ•°ã€‚<code>Amplitude</code>å¯ä»¥ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„å¼ºåº¦å€¼ï¼Œè™½ç„¶å…¶ä¸€ä¸ªå•ä½å’Œä¸–ç•Œç©ºé—´çš„ä¸€ç±³å®Œå…¨ä¸èƒ½ç›´æ¥ç­‰åŒèµ·æ¥ï¼Œä½†æ˜¯å€¼è¶Šå¤§è§†å·®çœ‹ä¸Šå»å°±è¶Šæ·±ï¼Œå¯ä»¥æ ¹æ®è§†è§‰å®æ—¶è°ƒæ•´è¿™ä¸ªå‚æ•°ã€‚å¦å¤–ä¸¤ä¸ªå‚æ•°å°±å¾ˆå¥‡æ€ªäº†ï¼Œå±…ç„¶å’Œæ¨¡å‹çš„å¤§å°æœ‰å…³ï¼ŒåŒä¸€ä¸ªæè´¨çƒï¼Œç”¨åœ¨Quadä¸Šè¿™é‡Œå°±è¦å¡«1ï¼Œç”¨åœ¨Planeä¸Šå°±è¦å¡«10ï¼Œå“ªæœ‰è¿™ç§é“ç†ï¼Ÿè™šå¹»å¼•æ“åˆ™æ˜¯æä¾›äº†POMçš„æ¥å£ï¼Œè‡³äºè¾“å…¥å’Œè¾“å‡ºå®Œå…¨éƒ½ç”±ç”¨æˆ·æ§åˆ¶ï¼Œè¿™é‡Œå°±ä¸å¤ªå¥½ç›´æ¥æ¯”è¾ƒäº†ã€‚</p><h2 id=å›é¡¾pomçš„è®¡ç®—è¿‡ç¨‹>å›é¡¾POMçš„è®¡ç®—è¿‡ç¨‹<a hidden class=anchor aria-hidden=true href=#å›é¡¾pomçš„è®¡ç®—è¿‡ç¨‹>#</a></h2><p>è§†å·®æ˜ å°„ä¸€èˆ¬ä¸ä¼šç›´æ¥åœ¨ä¸–ç•Œç©ºé—´æ­¥è¿›ï¼Œè€Œæ˜¯ä¼šå…ˆå°†ä¸–ç•Œç©ºé—´çš„è§†çº¿<code>viewWS</code>è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´<code>viewTS</code>ï¼Œåœ¨åˆ‡çº¿ç©ºé—´æ­¥è¿›ã€‚ç…§å¸¸ç†<code>_ParallaxIntensity</code>æ˜¯ç”¨æ¥æ§åˆ¶è§†å·®æ˜ å°„çš„æ·±åº¦çš„ï¼Œå› æ­¤ä¼šä½¿ç”¨è¿™ä¸ªå‚æ•°æ§åˆ¶zæ–¹å‘æ­¥è¿›çš„è·ç¦»ï¼Œä½†ä¸ºäº†æ–¹ä¾¿å’Œé«˜åº¦å›¾ä¸­è®°è½½çš„é«˜åº¦è¿›è¡Œå¯¹æ¯”ï¼Œä¼šå…ˆå¯¹<code>viewTS</code>çš„zåˆ†é‡è¿›è¡Œå½’ä¸€åŒ–ï¼Œå°†<code>_ParallaxIntensity</code>åœ¨æ­¥è¿›æ—¶ä¹˜åˆ°<code>viewTS</code>çš„xyåˆ†é‡ä¸Šï¼Œä¹‹åå°±æ˜¯å¾ªç¯æ¯”è¾ƒæ·±åº¦è¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯äº†ã€‚</p><p>ä½†æ˜¯ä¸ºä»€ä¹ˆæ˜¯åˆ‡çº¿ç©ºé—´å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºåˆ‡çº¿tangentå’Œå‰¯åˆ‡çº¿bitangentä»£è¡¨äº†è´´å›¾UVçš„xyçš„æ­£æ–¹å‘ï¼Œå°†è§†çº¿è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´ï¼Œå…¶å®ç›®çš„æ˜¯å°†è§†çº¿è½¬åˆ°UVç©ºé—´ï¼Œæˆ–è€…è¯´æ˜¯è´´å›¾ç©ºé—´ï¼ˆTexture Spaceï¼Œå› ä¸ºå…¶ä¸åˆ‡çº¿ç©ºé—´çš„ç›¸ä¼¼æ€§ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç”¨TSæ¥åšç®€å†™ï¼‰ã€‚è¿™é‡Œå°±å‡ºç°äº†æœ€é‡è¦çš„ä¸€ä¸ªé—®é¢˜ï¼ŒUnityä¸­é€šè¿‡<code>GetVertexNormalInputs</code>è·å¾—åˆ°çš„ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿æ˜¯ç»è¿‡å½’ä¸€åŒ–çš„ï¼Œä¸¢å¤±äº†ç‰©ä½“è‡ªèº«çš„ç¼©æ”¾ï¼Œæ‰€ä»¥æˆ‘ä»¬å…¶å®åº”è¯¥å…ˆå°†ä¸–ç•Œåæ ‡çš„è§†çº¿<code>viewWS</code>è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´<code>viewOS</code>ï¼Œç„¶åå†ä½¿ç”¨ç‰©ä½“ç©ºé—´çš„tbnçŸ©é˜µï¼Œå°†<code>viewOS</code>è½¬æ¢åˆ°åˆ‡çº¿ç©ºé—´<code>viewTS</code>ã€‚ä½†åˆå¦‚æˆ‘ä¸Šé¢è¯´åˆ°çš„ï¼Œæˆ‘ä»¬çœŸå®çš„ç›®çš„æ˜¯è´´å›¾ç©ºé—´ï¼Œåˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´æ˜¯å­˜åœ¨å·®å¼‚æ€§çš„ã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆUnityçš„HDRPè¦ä½¿ç”¨é¢å¤–çš„å‚æ•°<code>Primitive Length</code>å’Œ<code>Primitive Width</code>äº†ï¼Œè¿™ä¸¤ä¸ªå‚æ•°çš„ç›®çš„æ˜¯é€šè¿‡é¢å¤–çš„ç¼©æ”¾ï¼Œå°†åˆ‡çº¿ç©ºé—´å’Œè´´å›¾ç©ºé—´å¯¹åº”èµ·æ¥ã€‚</p><p>è¿™ä¸¤ä¸ªå‚æ•°çš„æ„ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ï¼Œè¿™é‡Œæˆ‘ä»¬è®°ä¸º<code>uvScale</code>ã€‚åŒæ—¶æˆ‘ä»¬å¯ä»¥é¡ºç†æˆç« åœ°æ­£å¼å¼•å…¥<code>_ParallaxIntensity</code>è¿™ä¸ªå‚æ•°ï¼Œå®ƒçš„å«ä¹‰åº”å½“æ˜¯ï¼Œè´´å›¾ä¸­é¢œè‰²ä¸º0çš„ç‚¹å¯¹åº”çš„ç‰©ä½“ç©ºé—´çš„æ·±åº¦å€¼ã€‚è´´å›¾ç©ºé—´è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´ï¼Œåªéœ€è¦å¯¹xyzä¸‰ä¸ªåˆ†é‡åˆ†åˆ«ä¹˜ä¸Š<code>uvScale.x</code>ï¼Œ<code>uvScale.y</code>ï¼Œå’Œ<code>_ParallaxIntensity</code>å³å¯ã€‚<code>_ParallaxIntensity</code>è¿™ä¸ªå‚æ•°æˆ‘ä»¬å¯ä»¥ä½œä¸ºæè´¨çƒçš„ä¸€ä¸ªè¾“å…¥è¿›è¡Œæ§åˆ¶ï¼Œ<code>uvScale</code>æ˜¯ä¸€ä¸ªè·Ÿæ¨¡å‹ç›¸å…³çš„å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Geometry Shaderä¸­è®¡ç®—è€Œå¾—ã€‚</p><h3 id=uvscaleçš„è®¡ç®—>uvScaleçš„è®¡ç®—<a hidden class=anchor aria-hidden=true href=#uvscaleçš„è®¡ç®—>#</a></h3><p>å¦‚ä¸Šé¢æ‰€å±ï¼Œ<code>uvScale</code>æŒ‡ä»£çš„æ˜¯è´´å›¾ç©ºé—´çš„xyåˆ†é‡æ¯ä¸€ä¸ªå•ä½åœ¨ç‰©ä½“ç©ºé—´çš„é•¿åº¦ã€‚å¯¹äºä¸¤ä¸ªé¡¶ç‚¹<code>v0</code>å’Œ<code>v1</code>ï¼Œè´´å›¾ç©ºé—´çš„xyåˆ†é‡å…¶å®å°±æ˜¯è¿™ä¸¤ä¸ªé¡¶ç‚¹uvå€¼çš„å·®ï¼Œç‰©ä½“ç©ºé—´çš„é•¿åº¦å…¶å®å°±æ˜¯ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œä¸ºäº†å¯¹åº”åˆ°è´´å›¾ç©ºé—´ä¸Šï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—è¿™æ®µè·ç¦»åœ¨åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ä¸Šçš„æŠ•å½±é•¿åº¦ï¼Œåè€…é™¤ä»¥å‰è€…å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„<code>uvScale</code>äº†ã€‚ç”±äºæ„æˆä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹å¯èƒ½ä¼šå­˜åœ¨æŸä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´uvçš„æŸä¸ªåˆ†é‡çš„å˜åŒ–ç‡ä¸º0ï¼Œå¯¼è‡´æˆ‘ä»¬è®¡ç®—<code>uvScale</code>çš„æ—¶å€™é™¤ä»¥é›¶ï¼Œæˆ‘ä»¬åœ¨æ£€æµ‹åˆ°è¿™ä¸ªæƒ…å†µçš„æ—¶å€™ä½¿ç”¨ç¬¬ä¸‰ä¸ªé¡¶ç‚¹å³å¯ã€‚</p><h3 id=è´´å›¾ç©ºé—´å˜æ¢>è´´å›¾ç©ºé—´å˜æ¢<a hidden class=anchor aria-hidden=true href=#è´´å›¾ç©ºé—´å˜æ¢>#</a></h3><p>åœ¨è·å¾—äº†ç‰©ä½“ç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿ä¹‹åï¼Œä¸ºäº†æ„æˆè´´å›¾ç©ºé—´çš„ä¸‰ä¸ªåŸºå‘é‡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹è¿™ä¸ªå‘é‡ä½¿ç”¨<code>uvScale</code>å’Œ<code>_ParallaxIntensity</code>è¿›è¡Œç¼©æ”¾ã€‚è¿™ä¸ªç¼©æ”¾å¯¼è‡´äº†æˆ‘ä»¬æŒ‰ç…§ä»¥å¾€çš„<code>float3x3(tangentOS * uvScale.x, bitangentOS * uvScale.y, normalOS * _ParallaxIntensity)</code>æ„æˆçš„çŸ©é˜µä¸å†æ˜¯ä¸€ä¸ªæ­£äº¤çŸ©é˜µï¼Œå®ƒå®é™…ä¸Šæ˜¯è´´å›¾ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„å˜æ¢çŸ©é˜µçš„è½¬ç½®ã€‚å› æ­¤å°†ç‰©ä½“ç©ºé—´çš„è§†çº¿<code>viewOS</code>è½¬æ¢åˆ°è´´å›¾ç©ºé—´<code>viewTS</code>æ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®çš„é€†å·¦ä¹˜<code>viewOS</code>ï¼Œå°†è´´å›¾ç©ºé—´çš„è§†çº¿<code>viewTS</code>è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´<code>viewOS</code>æ—¶ï¼Œæˆ‘ä»¬è¦ç”¨è¿™ä¸ªçŸ©é˜µçš„è½¬ç½®å·¦ä¹˜<code>viewTS</code>ã€‚</p><h3 id=æ·±åº¦çš„è·å–>æ·±åº¦çš„è·å–<a hidden class=anchor aria-hidden=true href=#æ·±åº¦çš„è·å–>#</a></h3><p>è¿™ä¸ªå°±ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•äº†ï¼Œæˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„æ—¶å€™ï¼Œå¯ä»¥çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´æ­¥è¿›çš„zæ–¹å‘çš„æ·±åº¦å€¼<code>len</code>ã€‚è€Œç”±äºæˆ‘ä»¬çš„<code>viewTS</code>ä¼šåšé™¤ä»¥zåˆ†é‡çš„å½’ä¸€åŒ–ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å½’ä¸€åŒ–å‰çš„<code>-viewTS</code>ä¹˜ä¸Š<code>len</code>å†é™¤ä»¥zåˆ†é‡ï¼Œå°±èƒ½çŸ¥é“æˆ‘ä»¬åœ¨è´´å›¾ç©ºé—´ä¸­æ€»çš„æ­¥è¿›çš„å‘é‡ï¼Œå°†å…¶è½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´ï¼Œå’Œå½“å‰ç‚¹çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ç›¸åŠ åå†è½¬æ¢åˆ°è£å‰ªç©ºé—´ï¼Œå…¶zåˆ†é‡é™¤ä»¥wåˆ†é‡å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„æ·±åº¦å€¼äº†ã€‚</p><h2 id=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç <a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„ä»£ç >#</a></h2><p>è¿™é‡Œåªåšäº†å¯è¡Œæ€§çš„ç ”ç©¶ï¼Œåº”è¯¥æœ‰ä¸ªæ–¹æ³•èƒ½å¤Ÿç®€åŒ–è®¡ç®—çŸ©é˜µçš„é€†è¿™ä¸€æ­¥æ“ä½œã€‚åœ¨è®¡ç®—ä¸–ç•Œç©ºé—´çš„åˆ‡çº¿ã€å‰¯åˆ‡çº¿å’Œæ³•çº¿çš„æ—¶å€™ï¼Œå¯ä»¥ä¸è¿›è¡Œå½’ä¸€åŒ–ï¼Œè¿™æ ·æˆ‘ä»¬ä¹Ÿå°±ä¸éœ€è¦å…ˆè½¬æ¢åˆ°ç‰©ä½“ç©ºé—´å†è½¬æ¢åˆ°è´´å›¾ç©ºé—´äº†ã€‚</p><h3 id=pomshadershader>POMShader.shader<a hidden class=anchor aria-hidden=true href=#pomshadershader>#</a></h3><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/POMShader&quot;
{
    Properties
    {
        [Toggle(OUTPUT_DEPTH)] _OutputDepth (&quot;Output Depth&quot;, Float) = 1

        _BaseColor(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _HeightMap(&quot;Height Map&quot;, 2D) = &quot;white&quot; {}
        _NormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _NormalIntensity(&quot;Normal Intensity&quot;, Range(0, 2)) = 1

        _ParallaxIntensity (&quot;Parallax Intensity&quot;, Float) = 1
        _ParallaxIteration (&quot;Parallax Iteration&quot;, Float) = 15
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

    #pragma shader_feature OUTPUT_DEPTH

    sampler2D _MainTex;
    sampler2D _HeightMap;
    sampler2D _NormalMap;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float4 _MainTex_ST;
    float _NormalIntensity;
    float _ParallaxIntensity;
    float _ParallaxIteration;
    CBUFFER_END

    struct a2v
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float4 tangentOS    : TANGENT;
        float2 texcoord     : TEXCOORD0;
    };

    struct v2g
    {
        float4 positionCS   : SV_POSITION;
        float3 positionOS   : TEXCOORD0;
        float3 positionWS   : TEXCOORD1;
        float4 tangentOS    : TEXCOORD2;
        float3 bitangentOS  : TEXCOORD3;
        float3 normalOS     : TEXCOORD4;
        float2 texcoord     : TEXCOORD5;
    };
    
    struct g2f
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD1;
        float4 tbnWSPos[3]  : TEXCOORD2; // tbnWS, posWS
        float4 tbnOSView[3] : TEXCOORD5; // tbnOS, viewWS
        float2 uvScale      : TEXCOORD8;
    };
    
    v2g vert(a2v input)
    {
        v2g output = (v2g)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
        output.positionCS = vpi.positionCS;
        output.positionOS = input.positionOS.xyz;
        output.positionWS = vpi.positionWS;
        output.normalOS = input.normalOS;
        output.tangentOS = input.tangentOS;
        output.bitangentOS = cross(input.normalOS, input.tangentOS.xyz) * input.tangentOS.w * GetOddNegativeScale();
        output.texcoord = input.texcoord;
        return output;
    }

    [maxvertexcount(3)]
    void geom(triangle v2g IN[3], inout TriangleStream&lt;g2f&gt; tristream)
    {
        float3 camWS = GetCameraPositionWS();
        g2f output = (g2f)0;

        float3 posDiff01 = IN[1].positionOS - IN[0].positionOS;
        float3 posDiff02 = IN[2].positionOS - IN[0].positionOS;
        float3 tangentOS0 = IN[0].tangentOS.xyz;
        float3 bitangentOS0 = IN[1].bitangentOS;
        
        float2 uvDiff01 = IN[1].texcoord - IN[0].texcoord;
        float2 uvDiff02 = IN[2].texcoord - IN[0].texcoord;
        float2 uvScale;
        if (uvDiff01.x != 0.0f) uvScale.x = dot(posDiff01, tangentOS0) / uvDiff01.x;
        else uvScale.x = dot(posDiff02, tangentOS0) / uvDiff02.x;
        if (uvDiff01.y != 0.0f) uvScale.y = dot(posDiff01, bitangentOS0) / uvDiff01.y;
        else uvScale.y = dot(posDiff02, bitangentOS0) / uvDiff02.y;

        for (int i=0; i&lt;3; ++i)
        {
            v2g input = IN[i];

            VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
            float3 viewWS = camWS - input.positionWS;
            output.positionCS = input.positionCS;
            output.uv = input.texcoord;
            output.tbnWSPos[0] = float4(vni.tangentWS, input.positionWS.x);
            output.tbnWSPos[1] = float4(vni.bitangentWS, input.positionWS.y);
            output.tbnWSPos[2] = float4(vni.normalWS, input.positionWS.z);
            output.tbnOSView[0] = float4(input.tangentOS.xyz, viewWS.x);
            output.tbnOSView[1] = float4(input.bitangentOS, viewWS.y);
            output.tbnOSView[2] = float4(input.normalOS, viewWS.z);
            output.uvScale = uvScale;
            tristream.Append(output);
        }
        tristream.RestartStrip();
    }

    float sampleHeight(float2 uv)
    {
        return 1.0f - tex2D(_HeightMap, uv).r;
    }

    float2 parallax(float2 uv, float3 view, out float len)
    {
        float numLayers = _ParallaxIteration;
        float layerDepth = 1.0f / numLayers;

        float2 p = view.xy;
        float2 deltaUVs = p / numLayers;

        float texd = sampleHeight(uv);
        float d = 0.0f;
        [unroll(30)]
        for (; d &lt; texd; d += layerDepth)
        {
            uv -= deltaUVs;
            texd = sampleHeight(uv);
        }

        float2 lastUVs = uv + deltaUVs;
        float lastD = d - layerDepth;

        float after = texd - d;
        float before = sampleHeight(lastUVs) - d + layerDepth;
        float w = after / (after - before);
        len = lerp(d, lastD, w);

        return lerp(uv, lastUVs, w);
    }

    // Returns the determinant of a 2x2 matrix.
    float spvDet2x2(float a1, float a2, float b1, float b2)
    {
        return a1 * b2 - b1 * a2;
    }
    // Returns the inverse of a matrix, by using the algorithm of calculating the classical
    // adjoint and dividing by the determinant. The contents of the matrix are changed.
    float3x3 spvInverse(float3x3 m)
    {
        float3x3 adj;	// The adjoint matrix (inverse after dividing by determinant)
        // Create the transpose of the cofactors, as the classical adjoint of the matrix.
        adj[0][0] =  spvDet2x2(m[1][1], m[1][2], m[2][1], m[2][2]);
        adj[0][1] = -spvDet2x2(m[0][1], m[0][2], m[2][1], m[2][2]);
        adj[0][2] =  spvDet2x2(m[0][1], m[0][2], m[1][1], m[1][2]);
        adj[1][0] = -spvDet2x2(m[1][0], m[1][2], m[2][0], m[2][2]);
        adj[1][1] =  spvDet2x2(m[0][0], m[0][2], m[2][0], m[2][2]);
        adj[1][2] = -spvDet2x2(m[0][0], m[0][2], m[1][0], m[1][2]);
        adj[2][0] =  spvDet2x2(m[1][0], m[1][1], m[2][0], m[2][1]);
        adj[2][1] = -spvDet2x2(m[0][0], m[0][1], m[2][0], m[2][1]);
        adj[2][2] =  spvDet2x2(m[0][0], m[0][1], m[1][0], m[1][1]);
        // Calculate the determinant as a combination of the cofactors of the first row.
        float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0]);
        // Divide the classical adjoint matrix by the determinant.
        // If determinant is zero, matrix is not invertable, so leave it unchanged.
        return (det != 0.0f) ? (adj * (1.0f / det)) : m;
    }

    float4 frag(g2f input
#if defined(OUTPUT_DEPTH)
    , out float depth : SV_DEPTH
#endif
    ) : SV_TARGET
    {
        float3 tos = input.tbnOSView[0].xyz * input.uvScale.x;
        float3 bos = input.tbnOSView[1].xyz * input.uvScale.y;
        float3 nos = input.tbnOSView[2].xyz * _ParallaxIntensity;
        float3x3 t2wOS = float3x3(tos.x, bos.x, nos.x,
                                    tos.y, bos.y, nos.y,
                                    tos.z, bos.z, nos.z);

        float3 viewWS = float3(input.tbnOSView[0].w, input.tbnOSView[1].w, input.tbnOSView[2].w);
        float3 viewOS = mul((float3x3)UNITY_MATRIX_I_M, viewWS);
        float3 viewTS = mul(spvInverse(t2wOS), viewOS);

        float z = max(abs(viewTS.z), 1e-5) * (viewTS.z &gt;= 0.0f ? 1.0f : -1.0f);
        float len;
        float2 uv = parallax((input.uv * _MainTex_ST.xy + _MainTex_ST.zw), viewTS * float3(_MainTex_ST.xy, 1.0f) / z, len);
#if defined(OUTPUT_DEPTH)
        float3 offsetTS = -viewTS * (len / z);
        float3 offsetOS = mul(t2wOS, offsetTS);
        float3 positionWS = float3(input.tbnWSPos[0].w, input.tbnWSPos[1].w, input.tbnWSPos[2].w);
        float3 posWS = positionWS + mul((float3x3)UNITY_MATRIX_M, offsetOS);
        float4 posCS = mul(UNITY_MATRIX_VP, float4(posWS, 1.0f));
        depth = posCS.z / posCS.w;
#endif

        float4 mainTex = tex2D(_MainTex, uv) * _BaseColor;
        float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
        
        float3 tws = input.tbnWSPos[0].xyz;
        float3 bws = input.tbnWSPos[1].xyz;
        float3 nws = input.tbnWSPos[2].xyz;
        float3 n = normalize(mul(normalTS, float3x3(tws, bws, nws)));
        Light mainLight = GetMainLight();
        float ndotl = max(0.0f, dot(n, mainLight.direction));

        float3 color = mainTex.rgb * mainLight.color * ndotl;
        float alpha = mainTex.a;
        return float4(color, alpha);
    }
            
    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;}
        Cull Back

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma geometry geom
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h3 id=rcsmshadershader>RCSMShader.Shader<a hidden class=anchor aria-hidden=true href=#rcsmshadershader>#</a></h3><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/RCSMShader&quot;
{
    Properties
    {
        [Toggle(OUTPUT_DEPTH)] _OutputDepth (&quot;Output Depth&quot;, Float) = 1

        _BaseColor(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _RCSMTex(&quot;RCSM Texture&quot;, 2D) = &quot;white&quot; {}
        _NormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _NormalIntensity(&quot;Normal Intensity&quot;, Range(0, 2)) = 1

        _ParallaxIntensity(&quot;Parallax Intensity&quot;, Float) = 1
        _ParallaxIteration(&quot;Parallax Iteration&quot;, Float) = 15
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

    #pragma shader_feature OUTPUT_DEPTH

    sampler2D _MainTex;
    sampler2D _NormalMap;
    sampler2D _RCSMTex;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float4 _MainTex_ST;
    float _NormalIntensity;
    float _ParallaxIntensity;
    float _ParallaxIteration;
    CBUFFER_END

    struct a2v
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float4 tangentOS    : TANGENT;
        float2 texcoord     : TEXCOORD0;
    };

    struct v2g
    {
        float4 positionCS   : SV_POSITION;
        float3 positionOS   : TEXCOORD0;
        float3 positionWS   : TEXCOORD1;
        float4 tangentOS    : TEXCOORD2;
        float3 bitangentOS  : TEXCOORD3;
        float3 normalOS     : TEXCOORD4;
        float2 texcoord     : TEXCOORD5;
    };
    
    struct g2f
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD1;
        float4 tbnWSPos[3]  : TEXCOORD2; // tbnWS, posWS
        float4 tbnOSView[3] : TEXCOORD5; // tbnOS, viewWS
        float2 uvScale      : TEXCOORD8;
    };
    
    v2g vert(a2v input)
    {
        v2g output = (v2g)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
        output.positionCS = vpi.positionCS;
        output.positionOS = input.positionOS.xyz;
        output.positionWS = vpi.positionWS;
        output.normalOS = input.normalOS;
        output.tangentOS = input.tangentOS;
        output.bitangentOS = cross(input.normalOS, input.tangentOS.xyz) * input.tangentOS.w * GetOddNegativeScale();
        output.texcoord = input.texcoord;
        return output;
    }

    [maxvertexcount(3)]
    void geom(triangle v2g IN[3], inout TriangleStream&lt;g2f&gt; tristream)
    {
        float3 camWS = GetCameraPositionWS();
        g2f output = (g2f)0;

        float3 posDiff01 = IN[1].positionOS - IN[0].positionOS;
        float3 posDiff02 = IN[2].positionOS - IN[0].positionOS;
        float3 tangentOS0 = IN[0].tangentOS.xyz;
        float3 bitangentOS0 = IN[1].bitangentOS;
        
        float2 uvDiff01 = IN[1].texcoord - IN[0].texcoord;
        float2 uvDiff02 = IN[2].texcoord - IN[0].texcoord;
        float2 uvScale;
        if (uvDiff01.x != 0.0f) uvScale.x = dot(posDiff01, tangentOS0) / uvDiff01.x;
        else uvScale.x = dot(posDiff02, tangentOS0) / uvDiff02.x;
        if (uvDiff01.y != 0.0f) uvScale.y = dot(posDiff01, bitangentOS0) / uvDiff01.y;
        else uvScale.y = dot(posDiff02, bitangentOS0) / uvDiff02.y;

        for (int i=0; i&lt;3; ++i)
        {
            v2g input = IN[i];

            VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
            float3 viewWS = camWS - input.positionWS;
            output.positionCS = input.positionCS;
            output.uv = input.texcoord;
            output.tbnWSPos[0] = float4(vni.tangentWS, input.positionWS.x);
            output.tbnWSPos[1] = float4(vni.bitangentWS, input.positionWS.y);
            output.tbnWSPos[2] = float4(vni.normalWS, input.positionWS.z);
            output.tbnOSView[0] = float4(input.tangentOS.xyz, viewWS.x);
            output.tbnOSView[1] = float4(input.bitangentOS, viewWS.y);
            output.tbnOSView[2] = float4(input.normalOS, viewWS.z);
            output.uvScale = uvScale;
            tristream.Append(output);
        }
        tristream.RestartStrip();
    }

    float2 sampleRCSM(float2 uv)
    {
        float2 rcsm = tex2D(_RCSMTex, uv).xy;
        return float2(1.0f - rcsm.x, rcsm.y);
    }

    float getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight)
    {
        float totalRatio = rayRatio / coneRatio + 1.0f;
        return (sampleHeight - rayHeight) / totalRatio;
    }

    float2 parallax(float2 uv, float3 view, out float len)
    {
        view.xy = -view.xy * _ParallaxIntensity;
        float3 samplePos = float3(uv, 0.0f);
        float2 rcsm = sampleRCSM(samplePos.xy);
        float rayRatio = length(view.xy);
        float coneRatio = rcsm.y;
        float rayHeight = samplePos.z;
        float sampleHeight = rcsm.x;

        float stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);  
        [unroll(30)]
        for (int i = 0; i &lt; _ParallaxIteration; ++i)
        {
            samplePos += stepLength * view;
            rcsm = sampleRCSM(samplePos.xy);
            coneRatio = rcsm.y;
            rayHeight = samplePos.z;
            sampleHeight = rcsm.x;
            if (sampleHeight &lt;= rayHeight) break;
        
            stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);
        }

        stepLength *= 0.5f;
        samplePos -= stepLength * view;

        [unroll]
        for (int j = 0; j &lt; 5; ++j)
        {
            rcsm = sampleRCSM(samplePos.xy);
            stepLength *= 0.5f;
            if (samplePos.z &gt;= rcsm.x)
            {
                samplePos -= stepLength * view;
            }
            else if(samplePos.z &lt; rcsm.x)
            {
                samplePos += stepLength * view;
            }
        }

        len = samplePos.z;
        return samplePos.xy;
    }

    // Returns the determinant of a 2x2 matrix.
    float spvDet2x2(float a1, float a2, float b1, float b2)
    {
        return a1 * b2 - b1 * a2;
    }
    // Returns the inverse of a matrix, by using the algorithm of calculating the classical
    // adjoint and dividing by the determinant. The contents of the matrix are changed.
    float3x3 spvInverse(float3x3 m)
    {
        float3x3 adj;	// The adjoint matrix (inverse after dividing by determinant)
        // Create the transpose of the cofactors, as the classical adjoint of the matrix.
        adj[0][0] =  spvDet2x2(m[1][1], m[1][2], m[2][1], m[2][2]);
        adj[0][1] = -spvDet2x2(m[0][1], m[0][2], m[2][1], m[2][2]);
        adj[0][2] =  spvDet2x2(m[0][1], m[0][2], m[1][1], m[1][2]);
        adj[1][0] = -spvDet2x2(m[1][0], m[1][2], m[2][0], m[2][2]);
        adj[1][1] =  spvDet2x2(m[0][0], m[0][2], m[2][0], m[2][2]);
        adj[1][2] = -spvDet2x2(m[0][0], m[0][2], m[1][0], m[1][2]);
        adj[2][0] =  spvDet2x2(m[1][0], m[1][1], m[2][0], m[2][1]);
        adj[2][1] = -spvDet2x2(m[0][0], m[0][1], m[2][0], m[2][1]);
        adj[2][2] =  spvDet2x2(m[0][0], m[0][1], m[1][0], m[1][1]);
        // Calculate the determinant as a combination of the cofactors of the first row.
        float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0]);
        // Divide the classical adjoint matrix by the determinant.
        // If determinant is zero, matrix is not invertable, so leave it unchanged.
        return (det != 0.0f) ? (adj * (1.0f / det)) : m;
    }

    float4 frag(g2f input
#if defined(OUTPUT_DEPTH)
    , out float depth : SV_DEPTH
#endif
    ) : SV_TARGET
    {
        float3 tos = input.tbnOSView[0].xyz * input.uvScale.x;
        float3 bos = input.tbnOSView[1].xyz * input.uvScale.y;
        float3 nos = input.tbnOSView[2].xyz * _ParallaxIntensity;
        float3x3 t2wOS = float3x3(tos.x, bos.x, nos.x,
                                    tos.y, bos.y, nos.y,
                                    tos.z, bos.z, nos.z);

        float3 viewWS = float3(input.tbnOSView[0].w, input.tbnOSView[1].w, input.tbnOSView[2].w);
        float3 viewOS = mul((float3x3)UNITY_MATRIX_I_M, viewWS);
        float3 viewTS = mul(spvInverse(t2wOS), viewOS);

        float z = max(abs(viewTS.z), 1e-5) * (viewTS.z &gt;= 0.0f ? 1.0f : -1.0f);
        float len;
        float2 uv = parallax((input.uv * _MainTex_ST.xy + _MainTex_ST.zw), viewTS * float3(_MainTex_ST.xy, 1.0f) / z, len);
#if defined(OUTPUT_DEPTH)
        float3 offsetTS = -viewTS * (len / z);
        float3 offsetOS = mul(t2wOS, offsetTS);
        float3 positionWS = float3(input.tbnWSPos[0].w, input.tbnWSPos[1].w, input.tbnWSPos[2].w);
        float3 posWS = positionWS + mul((float3x3)UNITY_MATRIX_M, offsetOS);
        float4 posCS = mul(UNITY_MATRIX_VP, float4(posWS, 1.0f));
        depth = posCS.z / posCS.w;
#endif

        float4 mainTex = tex2D(_MainTex, uv) * _BaseColor;
        float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
        
        float3 tws = input.tbnWSPos[0].xyz;
        float3 bws = input.tbnWSPos[1].xyz;
        float3 nws = input.tbnWSPos[2].xyz;
        float3 n = normalize(mul(normalTS, float3x3(tws, bws, nws)));
        Light mainLight = GetMainLight();
        float ndotl = max(0.0f, dot(n, mainLight.direction));

        float3 color = mainTex.rgb * mainLight.color * ndotl;
        float alpha = mainTex.a;
        return float4(color, alpha);
    }
            
    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;}
        Cull Back

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma geometry geom
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=æœ€ç»ˆçš„æ•ˆæœ>æœ€ç»ˆçš„æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#æœ€ç»ˆçš„æ•ˆæœ>#</a></h2><p>æœ€åçš„æ•ˆæœä¹Ÿå°±å¦‚å°é¢å›¾ä¸€æ ·äº†ï¼Œå·¦è¾¹æ˜¯RCSMåšçš„ï¼Œå…¶ä½™çš„åˆ™æ˜¯æ™®é€šçš„POMæ•ˆæœã€‚ç‰¹åœ°å¯¹æ¨¡å‹åšäº†ç¼©æ”¾ï¼Œå¯¹è´´å›¾çš„å¹³é“ºè¿›è¡Œè°ƒæ•´ï¼Œç”¨æ¥è¡¨æ˜è¿™ä¸ªè®¡ç®—æ–¹å¼çš„æ­£ç¡®æ€§ï¼ŒåŒæ ·çš„æè´¨çƒç”¨åœ¨ä¸åŒçš„æ¨¡å‹ä¸Šä¹Ÿèƒ½å¤Ÿå¾—åˆ°æ­£ç¡®çš„æ·±åº¦å€¼ã€‚ä½†æ˜¯åƒçƒä½“è¿™æ ·çš„uvå¹¶ä¸è§„åˆ™çš„æ¨¡å‹ï¼Œç”¨ä¸Šè¿°çš„æ–¹æ³•å¹¶ä¸èƒ½å¾—åˆ°å®Œç¾çš„æ·±åº¦æ•ˆæœã€‚ä¸Šé¢å’Œä¸‹é¢å¹³é¢ä½¿ç”¨çš„è´´å›¾æ¥è‡ªQuixelçš„Megascansã€‚</p><p><img loading=lazy src=../images/CorrectDepth_POM_RCSM.png#center alt="Correct Depth POM &amp;amp; RCSM"></p><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>åˆè¿…é€Ÿåœ°å†™äº†ä¸€ç¯‡æ–‡ç« ï¼Œè®¡ç®—äº†è§†å·®æ˜ å°„çš„æ·±åº¦å€¼ä¹‹åï¼Œå„ç§å±å¹•ç©ºé—´çš„ç®—æ³•ä¹Ÿéƒ½èƒ½å¤Ÿæ­£å¸¸åœ°ä½¿ç”¨äº†ï¼Œå¾ˆå¥½ã€‚è¯åˆè¯´å›æ¥äº†æˆ‘è¢«LearnOpenGLçš„è´´å›¾å‘äº†ä¸€æ³¢ï¼Œå±…ç„¶æ²¡æœ‰æ„è¯†åˆ°ä¸Šé¢çš„æ³•çº¿å›¾å’Œå¹³å¸¸ä½¿ç”¨çš„æ³•çº¿å›¾æ˜¯ä¸ä¸€æ ·çš„ï¼Œæˆ‘å°±è¯´æ€ä¹ˆçœ‹ä¸Šå»æœ‰ä¸€ç§è¿å’Œæ„Ÿã€‚åæ¥æˆ‘ç›´æ¥åœ¨Blenderé‡Œè‡ªå·±å¯¼å‡ºäº†è¿™ä¸ªToy Boxçš„<a href=../images/Toy_Box_Normal.jpg>æ³•çº¿</a>å’Œ<a href=../images/Toy_Box_Height.jpg>æ·±åº¦å›¾</a>ï¼Œè¿™æ‰æ„Ÿè§‰ä¸€åˆ‡éƒ½æ­£å¸¸äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/relaxed-cone-step-mapping/>Relaxed Cone Step Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/parallax-occlusion-mapping/>Parallax Occlusion Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/space-transformation/>Space Transformation</a></li></ul><nav class=paginav><a class=next href=https://zznewclear13.github.io/posts/screen-space-reflection-en/><span class=title>Next Â»</span><br><span>Screen Space Reflection</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>