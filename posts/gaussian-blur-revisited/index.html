<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å†è®®é«˜æ–¯æ¨¡ç³Š | ZZNEWCLEAR13</title>
<meta name=keywords content="Compute Shader,Group Shared Memory,Blur,Post-Process"><meta name=description content="ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="å†è®®é«˜æ–¯æ¨¡ç³Š"><meta property="og:description" content="ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/"><meta property="og:image" content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-05T12:00:00+08:00"><meta property="article:modified_time" content="2023-04-05T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png"><meta name=twitter:title content="å†è®®é«˜æ–¯æ¨¡ç³Š"><meta name=twitter:description content="ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"å†è®®é«˜æ–¯æ¨¡ç³Š","item":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å†è®®é«˜æ–¯æ¨¡ç³Š","name":"å†è®®é«˜æ–¯æ¨¡ç³Š","description":"ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š.","keywords":["Compute Shader","Group Shared Memory","Blur","Post-Process"],"articleBody":"å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š è™½ç„¶ä¸¤å¹´å‰å·²ç»å†™è¿‡äº†ä½¿ç”¨Group Shared MemoryåŠ é€Ÿé«˜æ–¯æ¨¡ç³Šè¿™ç¯‡æ–‡ç« äº†ã€‚ä½†å½“æ—¶å†™çš„æ—¶å€™ä»æœ‰ä¸€äº›é—æ†¾çš„åœ°æ–¹ï¼Œç”±äºä½¿ç”¨çš„æ˜¯é•¿åº¦ä¸º17çš„é™æ€çš„é«˜æ–¯æ¨¡ç³Šçš„æ•°ç»„ï¼ˆå®é™…ä¸Šåªæœ‰9ä¸ªæƒé‡ï¼‰ï¼Œè™½ç„¶åœ¨ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿè¾¾åˆ°ä»»æ„è°ƒèŠ‚é«˜æ–¯æ¨¡ç³Šçš„ç¨‹åº¦çš„æ•ˆæœï¼Œä½†åœ¨è¾ƒä½ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œæ˜¯é€šè¿‡æ‰‹åŠ¨çº¿æ€§æ’å€¼æ‰¾åˆ°åˆé€‚çš„é‡‡æ ·é¢œè‰²ï¼Œä¸”ä¸€å®šä¼šæœ‰17æ¬¡çš„é¢œè‰²å’Œæƒé‡çš„è¿ç®—ï¼›è€Œåœ¨è¾ƒé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œç”±äºä»…æœ‰åä¸ƒä¸ªæœ‰æ•ˆçš„é¢œè‰²ç‚¹ï¼Œä¼šæœ‰æ˜æ˜¾çš„é‡‡æ ·æ¬¡æ•°ä¸è¶³çš„ç‘•ç–µã€‚\nè€Œè¿™ä¸¤å¹´ä¹‹é—´æˆ‘ä¹Ÿæ›¾è€ƒè™‘ä½¿ç”¨ä¸åŒçš„æ–¹æ³•æ¥åˆ¶ä½œä¸€ä¸ªæ—¢èƒ½æ»¡è¶³å¾ˆé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œåˆèƒ½å…¼é¡¾å¾ˆå°ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œæ€§èƒ½ä¸Šä¹Ÿç›¸å¯¹é«˜æ•ˆï¼Œä¸”ä½¿ç”¨åŒä¸€å¥—é€šç”¨çš„ä»£ç ï¼Œçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚ä¸‹é¢ä¾¿æ˜¯æˆ‘ä¹‹å‰åœ¨Shadertoyä¸Šå†™çš„é€šè¿‡éšæœºé‡‡æ ·å’Œå†å²æ··åˆçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚\nStochastic Gaussian Blur\nä½†éšæœºå¸¦æ¥çš„å™ªå£°å’Œå†å²æ··åˆå¸¦æ¥çš„é™åˆ¶ï¼Œå†³å®šäº†è¿™ç§æ–¹æ³•ç»ˆç©¶ä¸èƒ½çœŸæ­£åœ°ä½¿ç”¨åœ¨é¡¹ç›®ä¸­ï¼Œäºæ˜¯æˆ‘åˆå¼€å§‹å›åˆ°äº†ä½¿ç”¨Compute Shaderå’ŒGroup Shared Memoryæ¥è®¡ç®—é«˜æ–¯æ¨¡ç³Šæ•ˆæœçš„è€è·¯å­ä¸Šã€‚ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä½¿ç”¨äº†Compute BufferæŠŠé«˜æ–¯æ¨¡ç³Šçš„å‚æ•°ä¼ ç»™Shaderï¼Œè¿™æ ·å°±èƒ½ç¡®ä¿èŒƒå›´å†…çš„æ¯ä¸€ä¸ªé‡‡æ ·ç‚¹éƒ½èƒ½å¤Ÿå¯¹æœ€åçš„é¢œè‰²äº§ç”Ÿåº”æœ‰çš„è´¡çŒ®ã€‚\næ­£æ€åˆ†å¸ƒ(Normal Distribution) å’Œä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä»¬è¦å…ˆä»æ­£æ€åˆ†å¸ƒå…¥æ‰‹ï¼Œä»æ­£æ€åˆ†å¸ƒçš„ç‰¹æ€§æ¥è€ƒè™‘æˆ‘ä»¬çš„è®¡ç®—æ–¹å¼ã€‚æ­£æ€åˆ†å¸ƒçš„æ¦‚ç‡å¯†åº¦å‡½æ•°(probability density function)å¦‚ä¸‹æ‰€ç¤ºï¼š $$ f(x) = \\frac 1 {\\sigma \\sqrt{2 \\pi}} e^{- \\frac 1 2 (\\frac {x-\\mu} \\sigma)^2} $$ ä½¿ç”¨æ­£æ€åˆ†å¸ƒå¯¹ä¿¡å·è¿›è¡Œè¿‡æ»¤ï¼Œè¢«ç§°ä½œé«˜æ–¯æ»¤æ³¢å™¨(Gaussian Filter)ã€‚æˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™ä¼šæŠŠ\\(\\mu\\)è®¾æˆ0ï¼Œè¿™æ ·æ°¸è¿œæ˜¯æœ€ä¸­å¿ƒçš„ä¿¡å·å¸¦æ¥æœ€å¤§çš„è´¡çŒ®ã€‚ä½†æ˜¯è¿™ä¸ªæ¦‚ç‡å¯†åº¦å‡½æ•°çš„\\(x\\)çš„èŒƒå›´æ˜¯\\((-\\infin, \\infin)\\)ï¼Œæˆ‘ä»¬ä¸å¯èƒ½å¯¹æ‰€æœ‰çš„ä¿¡å·éƒ½è¿›è¡Œé‡‡æ ·ï¼Œäºæ˜¯æˆ‘ä»¬ä¸€èˆ¬å¯¹\\(3\\sigma\\)èŒƒå›´å†…çš„ä¿¡å·è¿›è¡Œé‡‡æ ·ï¼Œå¯¹1Dçš„æ­£æ€åˆ†å¸ƒæ¥è¯´ï¼Œ\\((-3\\sigma, 3\\sigma)\\)å æ®äº†çº¦99.7%çš„é¢ç§¯ã€‚å› æ­¤æˆ‘ä»¬å¾€å¾€ä½¿ç”¨ä¸‰å€çš„\\(sigma\\)ä½œä¸ºé‡‡æ ·çš„åŠå¾„ï¼Œäº‹å®ä¸Šåœ¨2Dçš„æ—¶å€™ï¼Œå¯èƒ½éœ€è¦æ›´å¤§çš„é‡‡æ ·åŠå¾„æ‰èƒ½æ¶ˆé™¤æ˜æ˜¾çš„é‡‡æ ·åŠå¾„è¿‡å°çš„ç‘•ç–µã€‚\næœ‰ä¸€ç‚¹å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè™½ç„¶æˆ‘å¹¶ä¸ä¼šå…·ä½“çš„å¾®ç§¯åˆ†çš„è®¡ç®—ï¼Œä½†æ®æˆ‘æ‰€çŸ¥å…ˆåæ‰§è¡Œä¸¤ä¸ª\\(\\sigma\\)å€¼åˆ†åˆ«ä¸º\\(x\\)å’Œ\\(y\\)é«˜æ–¯æ¨¡ç³Šï¼Œç­‰ä»·äºæ‰§è¡Œä¸€æ¬¡\\(\\sigma\\)å€¼ä¸º\\(\\sqrt {x^2+y^2}\\)çš„é«˜æ–¯æ¨¡ç³Šã€‚\nå¦ä¸€ä¸ªæœ‰è¶£çš„ç‚¹æ˜¯ï¼Œåœ¨æ™®é€šçš„æ¨¡ç³Šæ“ä½œæ˜¯æˆ‘ä»¬å¾€å¾€ä¼šç”¨é™é‡‡æ ·å†å‡é‡‡æ ·çš„æ–¹å¼æ¥å‡å°‘é‡‡æ ·çš„æ¬¡æ•°ã€‚å¯¹äºåŠåˆ†è¾¨ç‡çš„çº¿æ€§1Dé™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œä¸­å¿ƒåƒç´ ä¿ç•™äº†\\(\\frac 3 8\\)çš„ä¹‹å‰åƒç´ çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°é‚£ä¹ˆä¸€ä¸ª\\(\\sigma\\)çš„å€¼ä½¿å¾—å…¶åœ¨\\((-0.5, 0.5)\\)ä¹‹é—´çš„é¢ç§¯çº¦ç­‰äº\\(\\frac 3 8\\)ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½è¯´æˆ‘ä»¬é€šè¿‡çº¿æ€§é™é‡‡æ ·å’Œå‡é‡‡æ ·åšåˆ°äº†è¿‘ä¼¼å¯¹åº”\\(\\sigma\\)çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœã€‚å¯æƒœè¿™ä¸ª\\(\\sigma\\)ä¸å¤ªå¥½ç®—ï¼Œæœ‰Group Shared Memoryä¹Ÿæ²¡æœ‰å¿…è¦å»åšé¢å¤–çš„é™é‡‡æ ·å’Œå‡é‡‡æ ·äº†ã€‚\nåœ¨æœ¬æ–‡ä¸­ï¼Œä¼šé€šè¿‡æ¨ªç«–ä¸¤ä¸ª1Dé«˜æ–¯æ»¤æ³¢å™¨æ¥ç­‰æ•ˆä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨ï¼Œä½¿ç”¨Group Shared Memoryçš„è¯ï¼Œå€’æ˜¯ä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨æ•ˆç‡æ›´é«˜ä¸€äº›ï¼Œä¸è¿‡ä¸ºäº†åç»­çš„æ‰©å±•æ€§ï¼Œæœ¬æ–‡æ‹†æˆäº†ä¸¤ä¸ªæ»¤æ³¢å™¨ã€‚\nå…·ä½“çš„å®ç°æ–¹æ³• å‰©ä¸‹çš„å°±å’Œä¹‹å‰å¤§åŒå°å¼‚äº†ï¼Œä¸ºäº†ç¡®ä¿æ¯ä¸ªåƒç´ åªä¼šè¿›è¡Œè‡³å¤šä¸¤æ¬¡é‡‡æ ·ï¼Œéœ€è¦é™åˆ¶é«˜æ–¯æ¨¡ç³Šçš„æœ€å¤§åŠå¾„GAUSSIAN_BLUR_MAX_RADIUSä¸ºTHREAD_GROUP_SIZEçš„ä¸€åŠã€‚è€Œä¸ºäº†2Dçš„é«˜æ–¯æ¨¡ç³Šåœ¨æ¯”è¾ƒæç«¯çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æœ‰æ¯”è¾ƒå¥½çš„æ•ˆæœï¼Œæˆ‘çš„é«˜æ–¯æ¨¡ç³Šçš„åŠå¾„ä¼šæ˜¯\\(\\sigma\\)çš„3.8å€å‘ä¸Šå–æ•´ã€‚\nGaussianBlurComputeShader.compute è¿™æ˜¯ä¸€ä¸ªæ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šçš„Compute Shaderï¼Œé€šè¿‡Group Shared Memoryä¼˜åŒ–äº†åŸæœ¬é«˜æ–¯æ¨¡ç³Šçš„æ¯ä¸ªåƒç´ çš„é‡‡æ ·æ“ä½œï¼ˆè‡³å¤šä¸¤æ¬¡ï¼‰ã€‚æœ€å¤§æ¨¡ç³ŠåŠå¾„ä¸º128ä¸ªåƒç´ ã€‚\n#pragma kernel GaussianH #pragma kernel GaussianV Texture2D\u003cfloat4\u003e _SourceTex; RWTexture2D\u003cfloat4\u003e _RW_TargetTex; StructuredBuffer\u003cfloat\u003e _GaussianWeights; float4 _TextureSize; #define GAUSSIAN_BLUR_MAX_RADIUS 128 #define THREAD_GROUP_SIZE 256 const static int CACHED_COLOR_SIZE = THREAD_GROUP_SIZE +GAUSSIAN_BLUR_MAX_RADIUS*2; groupshared half3 cachedColor[CACHED_COLOR_SIZE]; void SetCachedColor(half3 color, int index) { cachedColor[index] = color; } half3 GetCachedColor(int threadPos) { return cachedColor[threadPos + GAUSSIAN_BLUR_MAX_RADIUS]; } void CacheColor(int2 groupCacheStartPos, int cacheIndex, int isHorizontal) { int2 texturePos = groupCacheStartPos + cacheIndex * int2(isHorizontal, 1 - isHorizontal); texturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f); half3 color = _SourceTex.Load(uint3(texturePos, 0)).rgb; SetCachedColor(color, cacheIndex); } half3 Gaussian(uint3 groupID, uint3 groupThreadID, uint groupIndex, uint3 dispatchThreadID, int isHorizontal) { int2 direction = int2(isHorizontal, 1 - isHorizontal); int2 theadGroupSize = (THREAD_GROUP_SIZE - 1) * direction + 1; int2 groupCacheStartPos = groupID.xy * theadGroupSize - GAUSSIAN_BLUR_MAX_RADIUS * direction; int cacheIndex = groupIndex * 2; if (cacheIndex \u003c CACHED_COLOR_SIZE - 1) { CacheColor(groupCacheStartPos, cacheIndex, isHorizontal); CacheColor(groupCacheStartPos, cacheIndex+1, isHorizontal); } GroupMemoryBarrierWithGroupSync(); int sampleRadius = int(_GaussianWeights[0]); uint loadCacheIndex = groupIndex; int threadPos = loadCacheIndex; half3 sumColor = 0.0f; half sumWeight = 0.0f; for (int i=-sampleRadius; i\u003c=sampleRadius; ++i) { half3 color = GetCachedColor(threadPos + i); half weight = _GaussianWeights[abs(i)+1]; sumColor += color * weight; sumWeight += weight; } return sumColor / sumWeight; } [numthreads(THREAD_GROUP_SIZE,1,1)] void GaussianH(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { half3 color = Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, 1); _RW_TargetTex[dispatchThreadID.xy] = half4(color, 1.0f); } [numthreads(1, THREAD_GROUP_SIZE,1)] void GaussianV(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { half3 color = Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, 0); _RW_TargetTex[dispatchThreadID.xy] = half4(color, 1.0f); } GausianBlur.cs è¿™é‡Œè®¾ç½®äº†é‡‡æ ·åŠå¾„ä¸º\\(\\sigma\\)çš„3.8å€ï¼Œå³ä½¿åœ¨æœ‰å¾ˆäº®çš„å…‰æ–‘çš„æƒ…å†µä¸‹ï¼Œä¹Ÿèƒ½æœ‰å¾ˆå¥½çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœï¼ˆä¸å¥½çš„è¯å°±å†æé«˜sigmaçš„å¤§å°ï¼‰ã€‚ä¼šé€šè¿‡\\(\\sigma\\)è®¡ç®—å‡ºé‡‡æ ·åŠå¾„å’Œæ¯ä¸ªåƒç´ çš„æƒé‡ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Gaussian Blur\", typeof(UniversalRenderPipeline))] public sealed class GaussianBlur : VolumeComponent, IPostProcessComponent { static float sigmaRadiusRatio = 3.8f; public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter sigma = new ClampedFloatParameter(0.0f, 0.0f, Mathf.Floor(128.0f / sigmaRadiusRatio)); public bool IsActive() { return isEnabled.value \u0026\u0026 sigma.value \u003e 0.0f; } public bool IsTileCompatible() { return false; } private static float INV_SQRT_2PI = 0.3989422804f; private static float Gaussian(float sigma, float x) { float invSigma = 1.0f / sigma; return INV_SQRT_2PI * invSigma * Mathf.Exp(-0.5f * x * x * invSigma * invSigma); } public static int SigmaToRadius(float sigma) { return Mathf.CeilToInt(sigma * sigmaRadiusRatio); } public static float[] GetGaussianWeights(float sigma) { int length = SigmaToRadius(sigma); float[] weights = new float[length+1]; weights[0] = (float)length; for (int i = 0; i \u003c length; i++) { weights[i+1] = Gaussian(sigma, (float)i); } return weights; } } } GaussianBlurRenderPass.cs è¿™é‡Œæˆ‘è°·æ­Œäº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªæ¯”è¾ƒåˆé€‚çš„é¿å…Unityè¯´æˆ‘æ²¡æœ‰é‡Šæ”¾Compute Bufferçš„åŠæ³•ã€‚å¾ˆæœ´å®æ— åçš„æ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šï¼Œå¦‚æœCamera Color Attachmentèƒ½å¤Ÿæ”¯æŒéšæœºè¯»å†™çš„è¯ï¼Œå°±èƒ½å†èŠ‚çœä¸€æ¬¡Blitã€‚æˆ‘ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ï¼ŒUnityå¾ˆå¥‡æ€ªåœ°ç»™Camera Color Attachmentå‘½åä¸ºâ€œ_CameraColorAttachementAâ€ï¼Œä¸è¿‡æ²¡ä»€ä¹ˆå¤§ç¢ã€‚\nnamespace UnityEngine.Rendering.Universal { public class GaussianBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Gaussian Blur Render Pass\"; private GaussianBlurRendererFeature.GaussianBlurSettings settings; private GaussianBlur gaussianBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); RenderTargetIdentifier cameraColorIden; static readonly string gaussianBlurTextureOneName = \"_GaussianBlurTextureOne\"; static readonly int gaussianBlurTextureOneID = Shader.PropertyToID(gaussianBlurTextureOneName); RenderTargetIdentifier gaussianBlurTextureOneIden; static readonly string gaussianBlurTextureTwoName = \"_GaussianBlurTextureTwo\"; static readonly int gaussianBlurTextureTwoID = Shader.PropertyToID(gaussianBlurTextureTwoName); RenderTargetIdentifier gaussianBlurTextureTwoIden; private ComputeBuffer computeBuffer; private Vector2Int textureSize; private float[] weights; static readonly string HorizontalKernelName = \"GaussianH\"; static readonly string VerticalKernelName = \"GaussianV\"; static readonly int _SourceTex = Shader.PropertyToID(\"_SourceTex\"); static readonly int _RW_TargetTex = Shader.PropertyToID(\"_RW_TargetTex\"); static readonly int _GaussianWeights = Shader.PropertyToID(\"_GaussianWeights\"); static readonly int _TextureSize = Shader.PropertyToID(\"_TextureSize\"); public GaussianBlurRenderPass(GaussianBlurRendererFeature.GaussianBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); gaussianBlurTextureOneIden = new RenderTargetIdentifier(gaussianBlurTextureOneID); gaussianBlurTextureTwoIden = new RenderTargetIdentifier(gaussianBlurTextureTwoID); } public void Setup(GaussianBlur gaussianBlur) { this.gaussianBlur = gaussianBlur; } private void EnsureComputeBuffer(int count, int stride) { if(computeBuffer == null || computeBuffer.count != count || computeBuffer.stride != stride) { if(computeBuffer != null) { computeBuffer.Release(); } computeBuffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData) { weights = GaussianBlur.GetGaussianWeights(gaussianBlur.sigma.value); int count = weights.Length; EnsureComputeBuffer(count, 4); computeBuffer.SetData(weights); } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; cmd.GetTemporaryRT(gaussianBlurTextureOneID, desc); cmd.GetTemporaryRT(gaussianBlurTextureTwoID, desc); } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoGaussianBlur(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier oneid, RenderTargetIdentifier twoid, ComputeShader computeShader) { if (!computeShader) return; { int kernelID = computeShader.FindKernel(HorizontalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, colorid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, oneid); cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } { int kernelID = computeShader.FindKernel(VerticalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, oneid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, twoid); cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } cmd.Blit(twoid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { DoGaussianBlur(cmd, cameraColorIden, gaussianBlurTextureOneIden, gaussianBlurTextureTwoIden, computeShader); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(gaussianBlurTextureOneID); cmd.ReleaseTemporaryRT(gaussianBlurTextureTwoID); } public void Dispose() { if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } } } } GaussianBlurRendererFeature.cs æ²¡å•¥å¥½è¯´çš„äº†ï¼ŒåŠ äº†ä¸€ä¸ªDisposeæ–¹æ³•æ¥åŠæ—¶é‡Šæ”¾Compute Bufferã€‚\nnamespace UnityEngine.Rendering.Universal { public class GaussianBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class GaussianBlurSettings { public RenderPassEvent renderPassEvent; public ComputeShader computeShader; } public GaussianBlurSettings settings = new GaussianBlurSettings(); private GaussianBlurRenderPass gaussianBlurRenderPass; public override void Create() { gaussianBlurRenderPass = new GaussianBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { GaussianBlur gaussianBlur = VolumeManager.instance.stack.GetComponent(); if(gaussianBlur != null \u0026\u0026 gaussianBlur.IsActive()) { gaussianBlurRenderPass.Setup(gaussianBlur); renderer.EnqueuePass(gaussianBlurRenderPass); } } protected override void Dispose(bool disposing) { gaussianBlurRenderPass.Dispose(); base.Dispose(disposing); } } } åè®° 2023å¹´äº†æ€ä¹ˆè¿˜åœ¨åšé«˜æ–¯æ¨¡ç³Šå•Šå–‚ï¼Œæ˜æ˜éƒ½å†™äº†ä¸çŸ¥é“å¤šå°‘éäº†ã€‚ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯EAä¹‹å‰åšè¿‡æ¼”è®²çš„Circular Blurï¼ˆè™½ç„¶ä¹Ÿå†™äº†å¾ˆå¤šéå›ºå®šå¤§å°çš„äº†ï¼‰ã€‚ä»€ä¹ˆæ—¶å€™æ‰èƒ½é‡æ‹¾å‹‡æ°”å»ç®—æ™¯æ·±å‘¢å‘œå‘œå‘œã€‚\n","wordCount":"951","inLanguage":"en","image":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png","datePublished":"2023-04-05T12:00:00+08:00","dateModified":"2023-04-05T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">å†è®®é«˜æ–¯æ¨¡ç³Š</h1><div class=post-description>ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š.</div><div class=post-meta><span title='2023-04-05 12:00:00 +0800 CST'>April 5, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/gaussian-blur-revisited.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GaussianBlurRevisited.png alt="Gaussian Blur Cover"><p>Gaussian Blur Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>å†è®®é«˜æ–¯æ¨¡ç³Š</div></summary><div class=inner><ul><li><a href=#%e5%b0%86%e8%bf%91%e4%b8%a4%e5%b9%b4%e4%b9%8b%e5%90%8e%e5%86%8d%e5%9b%9e%e8%bf%87%e5%a4%b4%e6%9d%a5%e5%88%b6%e4%bd%9c%e9%ab%98%e6%96%af%e6%a8%a1%e7%b3%8a aria-label=å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š>å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š</a></li><li><a href=#%e6%ad%a3%e6%80%81%e5%88%86%e5%b8%83normal-distribution aria-label="æ­£æ€åˆ†å¸ƒ(Normal Distribution)">æ­£æ€åˆ†å¸ƒ(Normal Distribution)</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•</a><ul><li><a href=#gaussianblurcomputeshadercompute aria-label=GaussianBlurComputeShader.compute>GaussianBlurComputeShader.compute</a></li><li><a href=#gausianblurcs aria-label=GausianBlur.cs>GausianBlur.cs</a></li><li><a href=#gaussianblurrenderpasscs aria-label=GaussianBlurRenderPass.cs>GaussianBlurRenderPass.cs</a></li><li><a href=#gaussianblurrendererfeaturecs aria-label=GaussianBlurRendererFeature.cs>GaussianBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š>å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š<a hidden class=anchor aria-hidden=true href=#å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š>#</a></h2><p>è™½ç„¶ä¸¤å¹´å‰å·²ç»å†™è¿‡äº†<a href=/posts/accelerate-gaussian-blur-using-group-shared-memory/>ä½¿ç”¨Group Shared MemoryåŠ é€Ÿé«˜æ–¯æ¨¡ç³Š</a>è¿™ç¯‡æ–‡ç« äº†ã€‚ä½†å½“æ—¶å†™çš„æ—¶å€™ä»æœ‰ä¸€äº›é—æ†¾çš„åœ°æ–¹ï¼Œç”±äºä½¿ç”¨çš„æ˜¯é•¿åº¦ä¸º17çš„é™æ€çš„é«˜æ–¯æ¨¡ç³Šçš„æ•°ç»„ï¼ˆå®é™…ä¸Šåªæœ‰9ä¸ªæƒé‡ï¼‰ï¼Œè™½ç„¶åœ¨ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿè¾¾åˆ°ä»»æ„è°ƒèŠ‚é«˜æ–¯æ¨¡ç³Šçš„ç¨‹åº¦çš„æ•ˆæœï¼Œä½†åœ¨è¾ƒä½ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œæ˜¯é€šè¿‡æ‰‹åŠ¨çº¿æ€§æ’å€¼æ‰¾åˆ°åˆé€‚çš„é‡‡æ ·é¢œè‰²ï¼Œä¸”ä¸€å®šä¼šæœ‰17æ¬¡çš„é¢œè‰²å’Œæƒé‡çš„è¿ç®—ï¼›è€Œåœ¨è¾ƒé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œç”±äºä»…æœ‰åä¸ƒä¸ªæœ‰æ•ˆçš„é¢œè‰²ç‚¹ï¼Œä¼šæœ‰æ˜æ˜¾çš„é‡‡æ ·æ¬¡æ•°ä¸è¶³çš„ç‘•ç–µã€‚</p><p>è€Œè¿™ä¸¤å¹´ä¹‹é—´æˆ‘ä¹Ÿæ›¾è€ƒè™‘ä½¿ç”¨ä¸åŒçš„æ–¹æ³•æ¥åˆ¶ä½œä¸€ä¸ªæ—¢èƒ½æ»¡è¶³å¾ˆé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œåˆèƒ½å…¼é¡¾å¾ˆå°ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œæ€§èƒ½ä¸Šä¹Ÿç›¸å¯¹é«˜æ•ˆï¼Œä¸”ä½¿ç”¨åŒä¸€å¥—é€šç”¨çš„ä»£ç ï¼Œçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚ä¸‹é¢ä¾¿æ˜¯æˆ‘ä¹‹å‰åœ¨Shadertoyä¸Šå†™çš„é€šè¿‡éšæœºé‡‡æ ·å’Œå†å²æ··åˆçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/7tG3zW?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Stochastic Gaussian Blur</p></figure><p>ä½†éšæœºå¸¦æ¥çš„å™ªå£°å’Œå†å²æ··åˆå¸¦æ¥çš„é™åˆ¶ï¼Œå†³å®šäº†è¿™ç§æ–¹æ³•ç»ˆç©¶ä¸èƒ½çœŸæ­£åœ°ä½¿ç”¨åœ¨é¡¹ç›®ä¸­ï¼Œäºæ˜¯æˆ‘åˆå¼€å§‹å›åˆ°äº†ä½¿ç”¨Compute Shaderå’ŒGroup Shared Memoryæ¥è®¡ç®—é«˜æ–¯æ¨¡ç³Šæ•ˆæœçš„è€è·¯å­ä¸Šã€‚ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä½¿ç”¨äº†Compute BufferæŠŠé«˜æ–¯æ¨¡ç³Šçš„å‚æ•°ä¼ ç»™Shaderï¼Œè¿™æ ·å°±èƒ½ç¡®ä¿èŒƒå›´å†…çš„æ¯ä¸€ä¸ªé‡‡æ ·ç‚¹éƒ½èƒ½å¤Ÿå¯¹æœ€åçš„é¢œè‰²äº§ç”Ÿåº”æœ‰çš„è´¡çŒ®ã€‚</p><h2 id=æ­£æ€åˆ†å¸ƒnormal-distribution>æ­£æ€åˆ†å¸ƒ(Normal Distribution)<a hidden class=anchor aria-hidden=true href=#æ­£æ€åˆ†å¸ƒnormal-distribution>#</a></h2><p>å’Œä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä»¬è¦å…ˆä»æ­£æ€åˆ†å¸ƒå…¥æ‰‹ï¼Œä»æ­£æ€åˆ†å¸ƒçš„ç‰¹æ€§æ¥è€ƒè™‘æˆ‘ä»¬çš„è®¡ç®—æ–¹å¼ã€‚æ­£æ€åˆ†å¸ƒçš„æ¦‚ç‡å¯†åº¦å‡½æ•°(probability density function)å¦‚ä¸‹æ‰€ç¤ºï¼š
$$
f(x) = \frac 1 {\sigma \sqrt{2 \pi}} e^{- \frac 1 2 (\frac {x-\mu} \sigma)^2}
$$
ä½¿ç”¨æ­£æ€åˆ†å¸ƒå¯¹ä¿¡å·è¿›è¡Œè¿‡æ»¤ï¼Œè¢«ç§°ä½œé«˜æ–¯æ»¤æ³¢å™¨(Gaussian Filter)ã€‚æˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™ä¼šæŠŠ\(\mu\)è®¾æˆ0ï¼Œè¿™æ ·æ°¸è¿œæ˜¯æœ€ä¸­å¿ƒçš„ä¿¡å·å¸¦æ¥æœ€å¤§çš„è´¡çŒ®ã€‚ä½†æ˜¯è¿™ä¸ªæ¦‚ç‡å¯†åº¦å‡½æ•°çš„\(x\)çš„èŒƒå›´æ˜¯\((-\infin, \infin)\)ï¼Œæˆ‘ä»¬ä¸å¯èƒ½å¯¹æ‰€æœ‰çš„ä¿¡å·éƒ½è¿›è¡Œé‡‡æ ·ï¼Œäºæ˜¯æˆ‘ä»¬ä¸€èˆ¬å¯¹\(3\sigma\)èŒƒå›´å†…çš„ä¿¡å·è¿›è¡Œé‡‡æ ·ï¼Œå¯¹1Dçš„æ­£æ€åˆ†å¸ƒæ¥è¯´ï¼Œ\((-3\sigma, 3\sigma)\)å æ®äº†çº¦99.7%çš„é¢ç§¯ã€‚å› æ­¤æˆ‘ä»¬å¾€å¾€ä½¿ç”¨ä¸‰å€çš„\(sigma\)ä½œä¸ºé‡‡æ ·çš„åŠå¾„ï¼Œäº‹å®ä¸Šåœ¨2Dçš„æ—¶å€™ï¼Œå¯èƒ½éœ€è¦æ›´å¤§çš„é‡‡æ ·åŠå¾„æ‰èƒ½æ¶ˆé™¤æ˜æ˜¾çš„é‡‡æ ·åŠå¾„è¿‡å°çš„ç‘•ç–µã€‚</p><p>æœ‰ä¸€ç‚¹å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè™½ç„¶æˆ‘å¹¶ä¸ä¼šå…·ä½“çš„å¾®ç§¯åˆ†çš„è®¡ç®—ï¼Œä½†æ®æˆ‘æ‰€çŸ¥å…ˆåæ‰§è¡Œä¸¤ä¸ª\(\sigma\)å€¼åˆ†åˆ«ä¸º\(x\)å’Œ\(y\)é«˜æ–¯æ¨¡ç³Šï¼Œç­‰ä»·äºæ‰§è¡Œä¸€æ¬¡\(\sigma\)å€¼ä¸º\(\sqrt {x^2+y^2}\)çš„é«˜æ–¯æ¨¡ç³Šã€‚</p><p>å¦ä¸€ä¸ªæœ‰è¶£çš„ç‚¹æ˜¯ï¼Œåœ¨æ™®é€šçš„æ¨¡ç³Šæ“ä½œæ˜¯æˆ‘ä»¬å¾€å¾€ä¼šç”¨é™é‡‡æ ·å†å‡é‡‡æ ·çš„æ–¹å¼æ¥å‡å°‘é‡‡æ ·çš„æ¬¡æ•°ã€‚å¯¹äºåŠåˆ†è¾¨ç‡çš„çº¿æ€§1Dé™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œä¸­å¿ƒåƒç´ ä¿ç•™äº†\(\frac 3 8\)çš„ä¹‹å‰åƒç´ çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°é‚£ä¹ˆä¸€ä¸ª\(\sigma\)çš„å€¼ä½¿å¾—å…¶åœ¨\((-0.5, 0.5)\)ä¹‹é—´çš„é¢ç§¯çº¦ç­‰äº\(\frac 3 8\)ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½è¯´æˆ‘ä»¬é€šè¿‡çº¿æ€§é™é‡‡æ ·å’Œå‡é‡‡æ ·åšåˆ°äº†è¿‘ä¼¼å¯¹åº”\(\sigma\)çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœã€‚å¯æƒœè¿™ä¸ª\(\sigma\)ä¸å¤ªå¥½ç®—ï¼Œæœ‰Group Shared Memoryä¹Ÿæ²¡æœ‰å¿…è¦å»åšé¢å¤–çš„é™é‡‡æ ·å’Œå‡é‡‡æ ·äº†ã€‚</p><p>åœ¨æœ¬æ–‡ä¸­ï¼Œä¼šé€šè¿‡æ¨ªç«–ä¸¤ä¸ª1Dé«˜æ–¯æ»¤æ³¢å™¨æ¥ç­‰æ•ˆä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨ï¼Œä½¿ç”¨Group Shared Memoryçš„è¯ï¼Œå€’æ˜¯ä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨æ•ˆç‡æ›´é«˜ä¸€äº›ï¼Œä¸è¿‡ä¸ºäº†åç»­çš„æ‰©å±•æ€§ï¼Œæœ¬æ–‡æ‹†æˆäº†ä¸¤ä¸ªæ»¤æ³¢å™¨ã€‚</p><h2 id=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æ–¹æ³•>#</a></h2><p>å‰©ä¸‹çš„å°±å’Œä¹‹å‰å¤§åŒå°å¼‚äº†ï¼Œä¸ºäº†ç¡®ä¿æ¯ä¸ªåƒç´ åªä¼šè¿›è¡Œè‡³å¤šä¸¤æ¬¡é‡‡æ ·ï¼Œéœ€è¦é™åˆ¶é«˜æ–¯æ¨¡ç³Šçš„æœ€å¤§åŠå¾„<code>GAUSSIAN_BLUR_MAX_RADIUS</code>ä¸º<code>THREAD_GROUP_SIZE</code>çš„ä¸€åŠã€‚è€Œä¸ºäº†2Dçš„é«˜æ–¯æ¨¡ç³Šåœ¨æ¯”è¾ƒæç«¯çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æœ‰æ¯”è¾ƒå¥½çš„æ•ˆæœï¼Œæˆ‘çš„é«˜æ–¯æ¨¡ç³Šçš„åŠå¾„ä¼šæ˜¯\(\sigma\)çš„3.8å€å‘ä¸Šå–æ•´ã€‚</p><h3 id=gaussianblurcomputeshadercompute>GaussianBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#gaussianblurcomputeshadercompute>#</a></h3><p>è¿™æ˜¯ä¸€ä¸ªæ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šçš„Compute Shaderï¼Œé€šè¿‡Group Shared Memoryä¼˜åŒ–äº†åŸæœ¬é«˜æ–¯æ¨¡ç³Šçš„æ¯ä¸ªåƒç´ çš„é‡‡æ ·æ“ä½œï¼ˆè‡³å¤šä¸¤æ¬¡ï¼‰ã€‚æœ€å¤§æ¨¡ç³ŠåŠå¾„ä¸º128ä¸ªåƒç´ ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel GaussianH</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel GaussianV</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _SourceTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_TargetTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _GaussianWeights;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GAUSSIAN_BLUR_MAX_RADIUS 128</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define THREAD_GROUP_SIZE 256</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> CACHED_COLOR_SIZE <span style=color:#f92672>=</span> THREAD_GROUP_SIZE <span style=color:#f92672>+</span>GAUSSIAN_BLUR_MAX_RADIUS<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> <span style=color:#66d9ef>half3</span> cachedColor[CACHED_COLOR_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetCachedColor(<span style=color:#66d9ef>half3</span> color, <span style=color:#66d9ef>int</span> index) { cachedColor[index] <span style=color:#f92672>=</span> color; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>half3</span> GetCachedColor(<span style=color:#66d9ef>int</span> threadPos) { <span style=color:#66d9ef>return</span> cachedColor[threadPos <span style=color:#f92672>+</span> GAUSSIAN_BLUR_MAX_RADIUS]; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CacheColor(<span style=color:#66d9ef>int2</span> groupCacheStartPos, <span style=color:#66d9ef>int</span> cacheIndex, <span style=color:#66d9ef>int</span> isHorizontal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> texturePos <span style=color:#f92672>=</span> groupCacheStartPos <span style=color:#f92672>+</span> cacheIndex <span style=color:#f92672>*</span> <span style=color:#66d9ef>int2</span>(isHorizontal, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> isHorizontal);
</span></span><span style=display:flex><span>    texturePos <span style=color:#f92672>=</span> clamp(texturePos, <span style=color:#ae81ff>0</span>, _TextureSize.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> _SourceTex.Load(<span style=color:#66d9ef>uint3</span>(texturePos, <span style=color:#ae81ff>0</span>)).rgb;
</span></span><span style=display:flex><span>    SetCachedColor(color, cacheIndex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>half3</span> Gaussian(<span style=color:#66d9ef>uint3</span> groupID, <span style=color:#66d9ef>uint3</span> groupThreadID, <span style=color:#66d9ef>uint</span> groupIndex, <span style=color:#66d9ef>uint3</span> dispatchThreadID, <span style=color:#66d9ef>int</span> isHorizontal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> direction <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(isHorizontal, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> isHorizontal);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> theadGroupSize <span style=color:#f92672>=</span> (THREAD_GROUP_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> direction <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> groupCacheStartPos <span style=color:#f92672>=</span> groupID.xy <span style=color:#f92672>*</span> theadGroupSize <span style=color:#f92672>-</span> GAUSSIAN_BLUR_MAX_RADIUS <span style=color:#f92672>*</span> direction;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cacheIndex <span style=color:#f92672>&lt;</span> CACHED_COLOR_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheColor(groupCacheStartPos, cacheIndex, isHorizontal);
</span></span><span style=display:flex><span>        CacheColor(groupCacheStartPos, cacheIndex<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, isHorizontal);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sampleRadius <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_GaussianWeights[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> loadCacheIndex <span style=color:#f92672>=</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> threadPos <span style=color:#f92672>=</span> loadCacheIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> sumColor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half</span> sumWeight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=-</span>sampleRadius; i<span style=color:#f92672>&lt;=</span>sampleRadius; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> GetCachedColor(threadPos <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>half</span> weight <span style=color:#f92672>=</span> _GaussianWeights[abs(i)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        sumColor <span style=color:#f92672>+=</span> color <span style=color:#f92672>*</span> weight;
</span></span><span style=display:flex><span>        sumWeight <span style=color:#f92672>+=</span> weight;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sumColor <span style=color:#f92672>/</span> sumWeight;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(THREAD_GROUP_SIZE,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GaussianH(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    _RW_TargetTex[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>half4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>1</span>, THREAD_GROUP_SIZE,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GaussianV(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    _RW_TargetTex[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>half4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gausianblurcs>GausianBlur.cs<a hidden class=anchor aria-hidden=true href=#gausianblurcs>#</a></h3><p>è¿™é‡Œè®¾ç½®äº†é‡‡æ ·åŠå¾„ä¸º\(\sigma\)çš„3.8å€ï¼Œå³ä½¿åœ¨æœ‰å¾ˆäº®çš„å…‰æ–‘çš„æƒ…å†µä¸‹ï¼Œä¹Ÿèƒ½æœ‰å¾ˆå¥½çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœï¼ˆä¸å¥½çš„è¯å°±å†æé«˜sigmaçš„å¤§å°ï¼‰ã€‚ä¼šé€šè¿‡\(\sigma\)è®¡ç®—å‡ºé‡‡æ ·åŠå¾„å’Œæ¯ä¸ªåƒç´ çš„æƒé‡ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Gaussian Blur&#34;, typeof(UniversalRenderPipeline))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlur</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> sigmaRadiusRatio = <span style=color:#ae81ff>3.8f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter sigma = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, Mathf.Floor(<span style=color:#ae81ff>128.0f</span> / sigmaRadiusRatio));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; sigma.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> INV_SQRT_2PI = <span style=color:#ae81ff>0.3989422804f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> Gaussian(<span style=color:#66d9ef>float</span> sigma, <span style=color:#66d9ef>float</span> x)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> invSigma = <span style=color:#ae81ff>1.0f</span> / sigma;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> INV_SQRT_2PI * invSigma * Mathf.Exp(-<span style=color:#ae81ff>0.5f</span> * x * x * invSigma * invSigma);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> SigmaToRadius(<span style=color:#66d9ef>float</span> sigma)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Mathf.CeilToInt(sigma * sigmaRadiusRatio);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span>[] GetGaussianWeights(<span style=color:#66d9ef>float</span> sigma)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> length = SigmaToRadius(sigma);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span>[] weights = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>float</span>[length+<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            weights[<span style=color:#ae81ff>0</span>] = (<span style=color:#66d9ef>float</span>)length;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                weights[i+<span style=color:#ae81ff>1</span>] = Gaussian(sigma, (<span style=color:#66d9ef>float</span>)i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> weights;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gaussianblurrenderpasscs>GaussianBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#gaussianblurrenderpasscs>#</a></h3><p>è¿™é‡Œæˆ‘è°·æ­Œäº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªæ¯”è¾ƒåˆé€‚çš„é¿å…Unityè¯´æˆ‘æ²¡æœ‰é‡Šæ”¾Compute Bufferçš„åŠæ³•ã€‚å¾ˆæœ´å®æ— åçš„æ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šï¼Œå¦‚æœCamera Color Attachmentèƒ½å¤Ÿæ”¯æŒéšæœºè¯»å†™çš„è¯ï¼Œå°±èƒ½å†èŠ‚çœä¸€æ¬¡Blitã€‚æˆ‘ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ï¼ŒUnityå¾ˆå¥‡æ€ªåœ°ç»™Camera Color Attachmentå‘½åä¸ºâ€œ_CameraColorAttachementAâ€ï¼Œä¸è¿‡æ²¡ä»€ä¹ˆå¤§ç¢ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Gaussian Blur Render Pass&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GaussianBlurRendererFeature.GaussianBlurSettings settings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GaussianBlur gaussianBlur;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
</span></span><span style=display:flex><span>        RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gaussianBlurTextureOneName = <span style=color:#e6db74>&#34;_GaussianBlurTextureOne&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gaussianBlurTextureOneID = Shader.PropertyToID(gaussianBlurTextureOneName);
</span></span><span style=display:flex><span>        RenderTargetIdentifier gaussianBlurTextureOneIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gaussianBlurTextureTwoName = <span style=color:#e6db74>&#34;_GaussianBlurTextureTwo&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gaussianBlurTextureTwoID = Shader.PropertyToID(gaussianBlurTextureTwoName);
</span></span><span style=display:flex><span>        RenderTargetIdentifier gaussianBlurTextureTwoIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span>[] weights;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> HorizontalKernelName = <span style=color:#e6db74>&#34;GaussianH&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> VerticalKernelName = <span style=color:#e6db74>&#34;GaussianV&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _SourceTex = Shader.PropertyToID(<span style=color:#e6db74>&#34;_SourceTex&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _RW_TargetTex = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GaussianWeights = Shader.PropertyToID(<span style=color:#e6db74>&#34;_GaussianWeights&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _TextureSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GaussianBlurRenderPass(GaussianBlurRendererFeature.GaussianBlurSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            computeShader = settings.computeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
</span></span><span style=display:flex><span>            gaussianBlurTextureOneIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(gaussianBlurTextureOneID);
</span></span><span style=display:flex><span>            gaussianBlurTextureTwoIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(gaussianBlurTextureTwoID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(GaussianBlur gaussianBlur)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.gaussianBlur = gaussianBlur;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(computeBuffer == <span style=color:#66d9ef>null</span> || computeBuffer.count != count || computeBuffer.stride != stride)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    computeBuffer.Release();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnCameraSetup(CommandBuffer cmd, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            weights = GaussianBlur.GetGaussianWeights(gaussianBlur.sigma.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count = weights.Length;
</span></span><span style=display:flex><span>            EnsureComputeBuffer(count, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>            computeBuffer.SetData(weights);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(gaussianBlurTextureOneID, desc);
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(gaussianBlurTextureTwoID, desc);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoGaussianBlur(CommandBuffer cmd, RenderTargetIdentifier colorid,
</span></span><span style=display:flex><span>                                    RenderTargetIdentifier oneid, RenderTargetIdentifier twoid,
</span></span><span style=display:flex><span>                                    ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(HorizontalKernelName);
</span></span><span style=display:flex><span>                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, colorid);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, oneid);
</span></span><span style=display:flex><span>                cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize));
</span></span><span style=display:flex><span>                cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(VerticalKernelName);
</span></span><span style=display:flex><span>                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, oneid);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, twoid);
</span></span><span style=display:flex><span>                cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize));
</span></span><span style=display:flex><span>                cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cmd.Blit(twoid, colorid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                DoGaussianBlur(cmd, cameraColorIden, gaussianBlurTextureOneIden, gaussianBlurTextureTwoIden, computeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(gaussianBlurTextureOneID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(gaussianBlurTextureTwoID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                computeBuffer.Release();
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gaussianblurrendererfeaturecs>GaussianBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#gaussianblurrendererfeaturecs>#</a></h3><p>æ²¡å•¥å¥½è¯´çš„äº†ï¼ŒåŠ äº†ä¸€ä¸ª<code>Dispose</code>æ–¹æ³•æ¥åŠæ—¶é‡Šæ”¾Compute Bufferã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GaussianBlurSettings settings = <span style=color:#66d9ef>new</span> GaussianBlurSettings();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GaussianBlurRenderPass gaussianBlurRenderPass;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            gaussianBlurRenderPass = <span style=color:#66d9ef>new</span> GaussianBlurRenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GaussianBlur gaussianBlur = VolumeManager.instance.stack.GetComponent&lt;GaussianBlur&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(gaussianBlur != <span style=color:#66d9ef>null</span> &amp;&amp; gaussianBlur.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                gaussianBlurRenderPass.Setup(gaussianBlur);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(gaussianBlurRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            gaussianBlurRenderPass.Dispose();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>base</span>.Dispose(disposing);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>2023å¹´äº†æ€ä¹ˆè¿˜åœ¨åšé«˜æ–¯æ¨¡ç³Šå•Šå–‚ï¼Œæ˜æ˜éƒ½å†™äº†ä¸çŸ¥é“å¤šå°‘éäº†ã€‚ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯EAä¹‹å‰åšè¿‡æ¼”è®²çš„Circular Blurï¼ˆè™½ç„¶ä¹Ÿå†™äº†å¾ˆå¤šéå›ºå®šå¤§å°çš„äº†ï¼‰ã€‚ä»€ä¹ˆæ—¶å€™æ‰èƒ½é‡æ‹¾å‹‡æ°”å»ç®—æ™¯æ·±å‘¢å‘œå‘œå‘œã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li><li><a href=https://zznewclear13.github.io/tags/group-shared-memory/>Group Shared Memory</a></li><li><a href=https://zznewclear13.github.io/tags/blur/>Blur</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><span class=title>Â« Prev</span><br><span>Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š</span>
</a><a class=next href=https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/><span class=title>Next Â»</span><br><span>æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>