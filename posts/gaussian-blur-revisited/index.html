<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å†è®®é«˜æ–¯æ¨¡ç³Š | ZZNEWCLEAR13</title><meta name=keywords content="Compute Shader,Group Shared Memory,Gaussian Blur,Post-Process"><meta name=description content="ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="å†è®®é«˜æ–¯æ¨¡ç³Š"><meta property="og:description" content="ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/"><meta property="og:image" content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-05T12:00:00+08:00"><meta property="article:modified_time" content="2023-04-05T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png"><meta name=twitter:title content="å†è®®é«˜æ–¯æ¨¡ç³Š"><meta name=twitter:description content="ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"å†è®®é«˜æ–¯æ¨¡ç³Š","item":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å†è®®é«˜æ–¯æ¨¡ç³Š","name":"å†è®®é«˜æ–¯æ¨¡ç³Š","description":"ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š.","keywords":["Compute Shader","Group Shared Memory","Gaussian Blur","Post-Process"],"articleBody":"å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š è™½ç„¶ä¸¤å¹´å‰å·²ç»å†™è¿‡äº†ä½¿ç”¨Group Shared MemoryåŠ é€Ÿé«˜æ–¯æ¨¡ç³Šè¿™ç¯‡æ–‡ç« äº†ã€‚ä½†å½“æ—¶å†™çš„æ—¶å€™ä»æœ‰ä¸€äº›é—æ†¾çš„åœ°æ–¹ï¼Œç”±äºä½¿ç”¨çš„æ˜¯é•¿åº¦ä¸º17çš„é™æ€çš„é«˜æ–¯æ¨¡ç³Šçš„æ•°ç»„ï¼ˆå®é™…ä¸Šåªæœ‰9ä¸ªæƒé‡ï¼‰ï¼Œè™½ç„¶åœ¨ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿè¾¾åˆ°ä»»æ„è°ƒèŠ‚é«˜æ–¯æ¨¡ç³Šçš„ç¨‹åº¦çš„æ•ˆæœï¼Œä½†åœ¨è¾ƒä½ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œæ˜¯é€šè¿‡æ‰‹åŠ¨çº¿æ€§æ’å€¼æ‰¾åˆ°åˆé€‚çš„é‡‡æ ·é¢œè‰²ï¼Œä¸”ä¸€å®šä¼šæœ‰17æ¬¡çš„é¢œè‰²å’Œæƒé‡çš„è¿ç®—ï¼›è€Œåœ¨è¾ƒé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œç”±äºä»…æœ‰åä¸ƒä¸ªæœ‰æ•ˆçš„é¢œè‰²ç‚¹ï¼Œä¼šæœ‰æ˜æ˜¾çš„é‡‡æ ·æ¬¡æ•°ä¸è¶³çš„ç‘•ç–µã€‚\nè€Œè¿™ä¸¤å¹´ä¹‹é—´æˆ‘ä¹Ÿæ›¾è€ƒè™‘ä½¿ç”¨ä¸åŒçš„æ–¹æ³•æ¥åˆ¶ä½œä¸€ä¸ªæ—¢èƒ½æ»¡è¶³å¾ˆé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œåˆèƒ½å…¼é¡¾å¾ˆå°ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œæ€§èƒ½ä¸Šä¹Ÿç›¸å¯¹é«˜æ•ˆï¼Œä¸”ä½¿ç”¨åŒä¸€å¥—é€šç”¨çš„ä»£ç ï¼Œçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚ä¸‹é¢ä¾¿æ˜¯æˆ‘ä¹‹å‰åœ¨Shadertoyä¸Šå†™çš„é€šè¿‡éšæœºé‡‡æ ·å’Œå†å²æ··åˆçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚\n\rStochastic Gaussian Blur\n\rä½†éšæœºå¸¦æ¥çš„å™ªå£°å’Œå†å²æ··åˆå¸¦æ¥çš„é™åˆ¶ï¼Œå†³å®šäº†è¿™ç§æ–¹æ³•ç»ˆç©¶ä¸èƒ½çœŸæ­£åœ°ä½¿ç”¨åœ¨é¡¹ç›®ä¸­ï¼Œäºæ˜¯æˆ‘åˆå¼€å§‹å›åˆ°äº†ä½¿ç”¨Compute Shaderå’ŒGroup Shared Memoryæ¥è®¡ç®—é«˜æ–¯æ¨¡ç³Šæ•ˆæœçš„è€è·¯å­ä¸Šã€‚ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä½¿ç”¨äº†Compute BufferæŠŠé«˜æ–¯æ¨¡ç³Šçš„å‚æ•°ä¼ ç»™Shaderï¼Œè¿™æ ·å°±èƒ½ç¡®ä¿èŒƒå›´å†…çš„æ¯ä¸€ä¸ªé‡‡æ ·ç‚¹éƒ½èƒ½å¤Ÿå¯¹æœ€åçš„é¢œè‰²äº§ç”Ÿåº”æœ‰çš„è´¡çŒ®ã€‚\næ­£æ€åˆ†å¸ƒ(Normal Distribution) å’Œä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä»¬è¦å…ˆä»æ­£æ€åˆ†å¸ƒå…¥æ‰‹ï¼Œä»æ­£æ€åˆ†å¸ƒçš„ç‰¹æ€§æ¥è€ƒè™‘æˆ‘ä»¬çš„è®¡ç®—æ–¹å¼ã€‚æ­£æ€åˆ†å¸ƒçš„æ¦‚ç‡å¯†åº¦å‡½æ•°(probability density function)å¦‚ä¸‹æ‰€ç¤ºï¼š $$ f(x) = \\frac 1 {\\sigma \\sqrt{2 \\pi}} e^{- \\frac 1 2 (\\frac {x-\\mu} \\sigma)^2} $$ ä½¿ç”¨æ­£æ€åˆ†å¸ƒå¯¹ä¿¡å·è¿›è¡Œè¿‡æ»¤ï¼Œè¢«ç§°ä½œé«˜æ–¯æ»¤æ³¢å™¨(Gaussian Filter)ã€‚æˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™ä¼šæŠŠ\\(\\mu\\)è®¾æˆ0ï¼Œè¿™æ ·æ°¸è¿œæ˜¯æœ€ä¸­å¿ƒçš„ä¿¡å·å¸¦æ¥æœ€å¤§çš„è´¡çŒ®ã€‚ä½†æ˜¯è¿™ä¸ªæ¦‚ç‡å¯†åº¦å‡½æ•°çš„\\(x\\)çš„èŒƒå›´æ˜¯\\((-\\infin, \\infin)\\)ï¼Œæˆ‘ä»¬ä¸å¯èƒ½å¯¹æ‰€æœ‰çš„ä¿¡å·éƒ½è¿›è¡Œé‡‡æ ·ï¼Œäºæ˜¯æˆ‘ä»¬ä¸€èˆ¬å¯¹\\(3\\sigma\\)èŒƒå›´å†…çš„ä¿¡å·è¿›è¡Œé‡‡æ ·ï¼Œå¯¹1Dçš„æ­£æ€åˆ†å¸ƒæ¥è¯´ï¼Œ\\((-3\\sigma, 3\\sigma)\\)å æ®äº†çº¦99.7%çš„é¢ç§¯ã€‚å› æ­¤æˆ‘ä»¬å¾€å¾€ä½¿ç”¨ä¸‰å€çš„\\(sigma\\)ä½œä¸ºé‡‡æ ·çš„åŠå¾„ï¼Œäº‹å®ä¸Šåœ¨2Dçš„æ—¶å€™ï¼Œå¯èƒ½éœ€è¦æ›´å¤§çš„é‡‡æ ·åŠå¾„æ‰èƒ½æ¶ˆé™¤æ˜æ˜¾çš„é‡‡æ ·åŠå¾„è¿‡å°çš„ç‘•ç–µã€‚\næœ‰ä¸€ç‚¹å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè™½ç„¶æˆ‘å¹¶ä¸ä¼šå…·ä½“çš„å¾®ç§¯åˆ†çš„è®¡ç®—ï¼Œä½†æ®æˆ‘æ‰€çŸ¥å…ˆåæ‰§è¡Œä¸¤ä¸ª\\(\\sigma\\)å€¼åˆ†åˆ«ä¸º\\(x\\)å’Œ\\(y\\)é«˜æ–¯æ¨¡ç³Šï¼Œç­‰ä»·äºæ‰§è¡Œä¸€æ¬¡\\(\\sigma\\)å€¼ä¸º\\(\\sqrt {x^2+y^2}\\)çš„é«˜æ–¯æ¨¡ç³Šã€‚\nå¦ä¸€ä¸ªæœ‰è¶£çš„ç‚¹æ˜¯ï¼Œåœ¨æ™®é€šçš„æ¨¡ç³Šæ“ä½œæ˜¯æˆ‘ä»¬å¾€å¾€ä¼šç”¨é™é‡‡æ ·å†å‡é‡‡æ ·çš„æ–¹å¼æ¥å‡å°‘é‡‡æ ·çš„æ¬¡æ•°ã€‚å¯¹äºåŠåˆ†è¾¨ç‡çš„çº¿æ€§1Dé™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œä¸­å¿ƒåƒç´ ä¿ç•™äº†\\(\\frac 3 8\\)çš„ä¹‹å‰åƒç´ çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°é‚£ä¹ˆä¸€ä¸ª\\(\\sigma\\)çš„å€¼ä½¿å¾—å…¶åœ¨\\((-0.5, 0.5)\\)ä¹‹é—´çš„é¢ç§¯çº¦ç­‰äº\\(\\frac 3 8\\)ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½è¯´æˆ‘ä»¬é€šè¿‡çº¿æ€§é™é‡‡æ ·å’Œå‡é‡‡æ ·åšåˆ°äº†è¿‘ä¼¼å¯¹åº”\\(\\sigma\\)çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœã€‚å¯æƒœè¿™ä¸ª\\(\\sigma\\)ä¸å¤ªå¥½ç®—ï¼Œæœ‰Group Shared Memoryä¹Ÿæ²¡æœ‰å¿…è¦å»åšé¢å¤–çš„é™é‡‡æ ·å’Œå‡é‡‡æ ·äº†ã€‚\nåœ¨æœ¬æ–‡ä¸­ï¼Œä¼šé€šè¿‡æ¨ªç«–ä¸¤ä¸ª1Dé«˜æ–¯æ»¤æ³¢å™¨æ¥ç­‰æ•ˆä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨ï¼Œä½¿ç”¨Group Shared Memoryçš„è¯ï¼Œå€’æ˜¯ä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨æ•ˆç‡æ›´é«˜ä¸€äº›ï¼Œä¸è¿‡ä¸ºäº†åç»­çš„æ‰©å±•æ€§ï¼Œæœ¬æ–‡æ‹†æˆäº†ä¸¤ä¸ªæ»¤æ³¢å™¨ã€‚\nå…·ä½“çš„å®ç°æ–¹æ³• å‰©ä¸‹çš„å°±å’Œä¹‹å‰å¤§åŒå°å¼‚äº†ï¼Œä¸ºäº†ç¡®ä¿æ¯ä¸ªåƒç´ åªä¼šè¿›è¡Œè‡³å¤šä¸¤æ¬¡é‡‡æ ·ï¼Œéœ€è¦é™åˆ¶é«˜æ–¯æ¨¡ç³Šçš„æœ€å¤§åŠå¾„GAUSSIAN_BLUR_MAX_RADIUSä¸ºTHREAD_GROUP_SIZEçš„ä¸€åŠã€‚è€Œä¸ºäº†2Dçš„é«˜æ–¯æ¨¡ç³Šåœ¨æ¯”è¾ƒæç«¯çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æœ‰æ¯”è¾ƒå¥½çš„æ•ˆæœï¼Œæˆ‘çš„é«˜æ–¯æ¨¡ç³Šçš„åŠå¾„ä¼šæ˜¯\\(\\sigma\\)çš„3.8å€å‘ä¸Šå–æ•´ã€‚\nGaussianBlurComputeShader.compute è¿™æ˜¯ä¸€ä¸ªæ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šçš„Compute Shaderï¼Œé€šè¿‡Group Shared Memoryä¼˜åŒ–äº†åŸæœ¬é«˜æ–¯æ¨¡ç³Šçš„æ¯ä¸ªåƒç´ çš„é‡‡æ ·æ“ä½œï¼ˆè‡³å¤šä¸¤æ¬¡ï¼‰ã€‚æœ€å¤§æ¨¡ç³ŠåŠå¾„ä¸º128ä¸ªåƒç´ ã€‚\n#pragma kernel GaussianH\r#pragma kernel GaussianV\rTexture2D _SourceTex;\rRWTexture2D _RW_TargetTex;\rStructuredBuffer _GaussianWeights;\rfloat4 _TextureSize;\r#define GAUSSIAN_BLUR_MAX_RADIUS 128\r#define THREAD_GROUP_SIZE 256\rconst static int CACHED_COLOR_SIZE = THREAD_GROUP_SIZE +GAUSSIAN_BLUR_MAX_RADIUS*2;\rgroupshared half3 cachedColor[CACHED_COLOR_SIZE];\rvoid SetCachedColor(half3 color, int index) { cachedColor[index] = color; }\rhalf3 GetCachedColor(int threadPos) { return cachedColor[threadPos + GAUSSIAN_BLUR_MAX_RADIUS]; }\rvoid CacheColor(int2 groupCacheStartPos, int cacheIndex, int isHorizontal)\r{\rint2 texturePos = groupCacheStartPos + cacheIndex * int2(isHorizontal, 1 - isHorizontal);\rtexturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f);\rhalf3 color = _SourceTex.Load(uint3(texturePos, 0)).rgb;\rSetCachedColor(color, cacheIndex);\r}\rhalf3 Gaussian(uint3 groupID, uint3 groupThreadID, uint groupIndex, uint3 dispatchThreadID, int isHorizontal)\r{\rint2 direction = int2(isHorizontal, 1 - isHorizontal);\rint2 theadGroupSize = (THREAD_GROUP_SIZE - 1) * direction + 1;\rint2 groupCacheStartPos = groupID.xy * theadGroupSize - GAUSSIAN_BLUR_MAX_RADIUS * direction;\rint cacheIndex = groupIndex * 2;\rif (cacheIndex GausianBlur.cs è¿™é‡Œè®¾ç½®äº†é‡‡æ ·åŠå¾„ä¸º\\(\\sigma\\)çš„3.8å€ï¼Œå³ä½¿åœ¨æœ‰å¾ˆäº®çš„å…‰æ–‘çš„æƒ…å†µä¸‹ï¼Œä¹Ÿèƒ½æœ‰å¾ˆå¥½çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœï¼ˆä¸å¥½çš„è¯å°±å†æé«˜sigmaçš„å¤§å°ï¼‰ã€‚ä¼šé€šè¿‡\\(\\sigma\\)è®¡ç®—å‡ºé‡‡æ ·åŠå¾„å’Œæ¯ä¸ªåƒç´ çš„æƒé‡ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Gaussian Blur\", typeof(UniversalRenderPipeline))] public sealed class GaussianBlur : VolumeComponent, IPostProcessComponent { static float sigmaRadiusRatio = 3.8f; public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter sigma = new ClampedFloatParameter(0.0f, 0.0f, Mathf.Floor(128.0f / sigmaRadiusRatio)); public bool IsActive() { return isEnabled.value \u0026\u0026 sigma.value  0.0f; } public bool IsTileCompatible() { return false; } private static float INV_SQRT_2PI = 0.3989422804f; private static float Gaussian(float sigma, float x) { float invSigma = 1.0f / sigma; return INV_SQRT_2PI * invSigma * Mathf.Exp(-0.5f * x * x * invSigma * invSigma); } public static int SigmaToRadius(float sigma) { return Mathf.CeilToInt(sigma * sigmaRadiusRatio); } public static float[] GetGaussianWeights(float sigma) { int length = SigmaToRadius(sigma); float[] weights = new float[length+1]; weights[0] = (float)length; for (int i = 0; i 1] = Gaussian(sigma, (float)i); } return weights; } } } GaussianBlurRenderPass.cs è¿™é‡Œæˆ‘è°·æ­Œäº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªæ¯”è¾ƒåˆé€‚çš„é¿å…Unityè¯´æˆ‘æ²¡æœ‰é‡Šæ”¾Compute Bufferçš„åŠæ³•ã€‚å¾ˆæœ´å®æ— åçš„æ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šï¼Œå¦‚æœCamera Color Attachmentèƒ½å¤Ÿæ”¯æŒéšæœºè¯»å†™çš„è¯ï¼Œå°±èƒ½å†èŠ‚çœä¸€æ¬¡Blitã€‚æˆ‘ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ï¼ŒUnityå¾ˆå¥‡æ€ªåœ°ç»™Camera Color Attachmentå‘½åä¸ºâ€œ_CameraColorAttachementAâ€ï¼Œä¸è¿‡æ²¡ä»€ä¹ˆå¤§ç¢ã€‚\nnamespace UnityEngine.Rendering.Universal { public class GaussianBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Gaussian Blur Render Pass\"; private GaussianBlurRendererFeature.GaussianBlurSettings settings; private GaussianBlur gaussianBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); RenderTargetIdentifier cameraColorIden; static readonly string gaussianBlurTextureOneName = \"_GaussianBlurTextureOne\"; static readonly int gaussianBlurTextureOneID = Shader.PropertyToID(gaussianBlurTextureOneName); RenderTargetIdentifier gaussianBlurTextureOneIden; static readonly string gaussianBlurTextureTwoName = \"_GaussianBlurTextureTwo\"; static readonly int gaussianBlurTextureTwoID = Shader.PropertyToID(gaussianBlurTextureTwoName); RenderTargetIdentifier gaussianBlurTextureTwoIden; private ComputeBuffer computeBuffer; private Vector2Int textureSize; private float[] weights; static readonly string HorizontalKernelName = \"GaussianH\"; static readonly string VerticalKernelName = \"GaussianV\"; static readonly int _SourceTex = Shader.PropertyToID(\"_SourceTex\"); static readonly int _RW_TargetTex = Shader.PropertyToID(\"_RW_TargetTex\"); static readonly int _GaussianWeights = Shader.PropertyToID(\"_GaussianWeights\"); static readonly int _TextureSize = Shader.PropertyToID(\"_TextureSize\"); public GaussianBlurRenderPass(GaussianBlurRendererFeature.GaussianBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); gaussianBlurTextureOneIden = new RenderTargetIdentifier(gaussianBlurTextureOneID); gaussianBlurTextureTwoIden = new RenderTargetIdentifier(gaussianBlurTextureTwoID); } public void Setup(GaussianBlur gaussianBlur) { this.gaussianBlur = gaussianBlur; } private void EnsureComputeBuffer(int count, int stride) { if(computeBuffer == null || computeBuffer.count != count || computeBuffer.stride != stride) { if(computeBuffer != null) { computeBuffer.Release(); } computeBuffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData) { weights = GaussianBlur.GetGaussianWeights(gaussianBlur.sigma.value); int count = weights.Length; EnsureComputeBuffer(count, 4); computeBuffer.SetData(weights); } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; cmd.GetTemporaryRT(gaussianBlurTextureOneID, desc); cmd.GetTemporaryRT(gaussianBlurTextureTwoID, desc); } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoGaussianBlur(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier oneid, RenderTargetIdentifier twoid, ComputeShader computeShader) { if (!computeShader) return; { int kernelID = computeShader.FindKernel(HorizontalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, colorid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, oneid); cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } { int kernelID = computeShader.FindKernel(VerticalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, oneid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, twoid); cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } cmd.Blit(twoid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { DoGaussianBlur(cmd, cameraColorIden, gaussianBlurTextureOneIden, gaussianBlurTextureTwoIden, computeShader); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(gaussianBlurTextureOneID); cmd.ReleaseTemporaryRT(gaussianBlurTextureTwoID); } public void Dispose() { if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } } } } GaussianBlurRendererFeature.cs æ²¡å•¥å¥½è¯´çš„äº†ï¼ŒåŠ äº†ä¸€ä¸ªDisposeæ–¹æ³•æ¥åŠæ—¶é‡Šæ”¾Compute Bufferã€‚\nnamespace UnityEngine.Rendering.Universal { public class GaussianBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class GaussianBlurSettings { public RenderPassEvent renderPassEvent; public ComputeShader computeShader; } public GaussianBlurSettings settings = new GaussianBlurSettings(); private GaussianBlurRenderPass gaussianBlurRenderPass; public override void Create() { gaussianBlurRenderPass = new GaussianBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { GaussianBlur gaussianBlur = VolumeManager.instance.stack.GetComponent(); if(gaussianBlur != null \u0026\u0026 gaussianBlur.IsActive()) { gaussianBlurRenderPass.Setup(gaussianBlur); renderer.EnqueuePass(gaussianBlurRenderPass); } } protected override void Dispose(bool disposing) { gaussianBlurRenderPass.Dispose(); base.Dispose(disposing); } } } åè®° 2023å¹´äº†æ€ä¹ˆè¿˜åœ¨åšé«˜æ–¯æ¨¡ç³Šå•Šå–‚ï¼Œæ˜æ˜éƒ½å†™äº†ä¸çŸ¥é“å¤šå°‘éäº†ã€‚ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯EAä¹‹å‰åšè¿‡æ¼”è®²çš„Circular Blurï¼ˆè™½ç„¶ä¹Ÿå†™äº†å¾ˆå¤šéå›ºå®šå¤§å°çš„äº†ï¼‰ã€‚ä»€ä¹ˆæ—¶å€™æ‰èƒ½é‡æ‹¾å‹‡æ°”å»ç®—æ™¯æ·±å‘¢å‘œå‘œå‘œã€‚\n","wordCount":"951","inLanguage":"en","image":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png","datePublished":"2023-04-05T12:00:00+08:00","dateModified":"2023-04-05T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">å†è®®é«˜æ–¯æ¨¡ç³Š</h1><div class=post-description>ä½¿ç”¨StructuredBufferè¿›è¡Œä»»æ„å¤§å°çš„é«˜æ–¯æ¨¡ç³Š.</div><div class=post-meta><span title="2023-04-05 12:00:00 +0800 CST">April 5, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/gaussian-blur-revisited.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GaussianBlurRevisited.png alt="Gaussian Blur Cover"><p>Gaussian Blur Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>å†è®®é«˜æ–¯æ¨¡ç³Š</div></summary><div class=inner><ul><li><a href=#%e5%b0%86%e8%bf%91%e4%b8%a4%e5%b9%b4%e4%b9%8b%e5%90%8e%e5%86%8d%e5%9b%9e%e8%bf%87%e5%a4%b4%e6%9d%a5%e5%88%b6%e4%bd%9c%e9%ab%98%e6%96%af%e6%a8%a1%e7%b3%8a aria-label=å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š>å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š</a></li><li><a href=#%e6%ad%a3%e6%80%81%e5%88%86%e5%b8%83normal-distribution aria-label="æ­£æ€åˆ†å¸ƒ(Normal Distribution)">æ­£æ€åˆ†å¸ƒ(Normal Distribution)</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•</a><ul><li><a href=#gaussianblurcomputeshadercompute aria-label=GaussianBlurComputeShader.compute>GaussianBlurComputeShader.compute</a></li><li><a href=#gausianblurcs aria-label=GausianBlur.cs>GausianBlur.cs</a></li><li><a href=#gaussianblurrenderpasscs aria-label=GaussianBlurRenderPass.cs>GaussianBlurRenderPass.cs</a></li><li><a href=#gaussianblurrendererfeaturecs aria-label=GaussianBlurRendererFeature.cs>GaussianBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š>å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š<a hidden class=anchor aria-hidden=true href=#å°†è¿‘ä¸¤å¹´ä¹‹åå†å›è¿‡å¤´æ¥åˆ¶ä½œé«˜æ–¯æ¨¡ç³Š>#</a></h2><p>è™½ç„¶ä¸¤å¹´å‰å·²ç»å†™è¿‡äº†<a href=/posts/accelerate-gaussian-blur-using-group-shared-memory/>ä½¿ç”¨Group Shared MemoryåŠ é€Ÿé«˜æ–¯æ¨¡ç³Š</a>è¿™ç¯‡æ–‡ç« äº†ã€‚ä½†å½“æ—¶å†™çš„æ—¶å€™ä»æœ‰ä¸€äº›é—æ†¾çš„åœ°æ–¹ï¼Œç”±äºä½¿ç”¨çš„æ˜¯é•¿åº¦ä¸º17çš„é™æ€çš„é«˜æ–¯æ¨¡ç³Šçš„æ•°ç»„ï¼ˆå®é™…ä¸Šåªæœ‰9ä¸ªæƒé‡ï¼‰ï¼Œè™½ç„¶åœ¨ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿè¾¾åˆ°ä»»æ„è°ƒèŠ‚é«˜æ–¯æ¨¡ç³Šçš„ç¨‹åº¦çš„æ•ˆæœï¼Œä½†åœ¨è¾ƒä½ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œæ˜¯é€šè¿‡æ‰‹åŠ¨çº¿æ€§æ’å€¼æ‰¾åˆ°åˆé€‚çš„é‡‡æ ·é¢œè‰²ï¼Œä¸”ä¸€å®šä¼šæœ‰17æ¬¡çš„é¢œè‰²å’Œæƒé‡çš„è¿ç®—ï¼›è€Œåœ¨è¾ƒé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œç”±äºä»…æœ‰åä¸ƒä¸ªæœ‰æ•ˆçš„é¢œè‰²ç‚¹ï¼Œä¼šæœ‰æ˜æ˜¾çš„é‡‡æ ·æ¬¡æ•°ä¸è¶³çš„ç‘•ç–µã€‚</p><p>è€Œè¿™ä¸¤å¹´ä¹‹é—´æˆ‘ä¹Ÿæ›¾è€ƒè™‘ä½¿ç”¨ä¸åŒçš„æ–¹æ³•æ¥åˆ¶ä½œä¸€ä¸ªæ—¢èƒ½æ»¡è¶³å¾ˆé«˜ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œåˆèƒ½å…¼é¡¾å¾ˆå°ç¨‹åº¦çš„é«˜æ–¯æ¨¡ç³Šï¼Œæ€§èƒ½ä¸Šä¹Ÿç›¸å¯¹é«˜æ•ˆï¼Œä¸”ä½¿ç”¨åŒä¸€å¥—é€šç”¨çš„ä»£ç ï¼Œçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚ä¸‹é¢ä¾¿æ˜¯æˆ‘ä¹‹å‰åœ¨Shadertoyä¸Šå†™çš„é€šè¿‡éšæœºé‡‡æ ·å’Œå†å²æ··åˆçš„é«˜æ–¯æ¨¡ç³Šæ•ˆæœã€‚</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/7tG3zW?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Stochastic Gaussian Blur</p></figure><p>ä½†éšæœºå¸¦æ¥çš„å™ªå£°å’Œå†å²æ··åˆå¸¦æ¥çš„é™åˆ¶ï¼Œå†³å®šäº†è¿™ç§æ–¹æ³•ç»ˆç©¶ä¸èƒ½çœŸæ­£åœ°ä½¿ç”¨åœ¨é¡¹ç›®ä¸­ï¼Œäºæ˜¯æˆ‘åˆå¼€å§‹å›åˆ°äº†ä½¿ç”¨Compute Shaderå’ŒGroup Shared Memoryæ¥è®¡ç®—é«˜æ–¯æ¨¡ç³Šæ•ˆæœçš„è€è·¯å­ä¸Šã€‚ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä½¿ç”¨äº†Compute BufferæŠŠé«˜æ–¯æ¨¡ç³Šçš„å‚æ•°ä¼ ç»™Shaderï¼Œè¿™æ ·å°±èƒ½ç¡®ä¿èŒƒå›´å†…çš„æ¯ä¸€ä¸ªé‡‡æ ·ç‚¹éƒ½èƒ½å¤Ÿå¯¹æœ€åçš„é¢œè‰²äº§ç”Ÿåº”æœ‰çš„è´¡çŒ®ã€‚</p><h2 id=æ­£æ€åˆ†å¸ƒnormal-distribution>æ­£æ€åˆ†å¸ƒ(Normal Distribution)<a hidden class=anchor aria-hidden=true href=#æ­£æ€åˆ†å¸ƒnormal-distribution>#</a></h2><p>å’Œä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œè¿™æ¬¡æˆ‘ä»¬è¦å…ˆä»æ­£æ€åˆ†å¸ƒå…¥æ‰‹ï¼Œä»æ­£æ€åˆ†å¸ƒçš„ç‰¹æ€§æ¥è€ƒè™‘æˆ‘ä»¬çš„è®¡ç®—æ–¹å¼ã€‚æ­£æ€åˆ†å¸ƒçš„æ¦‚ç‡å¯†åº¦å‡½æ•°(probability density function)å¦‚ä¸‹æ‰€ç¤ºï¼š
$$
f(x) = \frac 1 {\sigma \sqrt{2 \pi}} e^{- \frac 1 2 (\frac {x-\mu} \sigma)^2}
$$
ä½¿ç”¨æ­£æ€åˆ†å¸ƒå¯¹ä¿¡å·è¿›è¡Œè¿‡æ»¤ï¼Œè¢«ç§°ä½œé«˜æ–¯æ»¤æ³¢å™¨(Gaussian Filter)ã€‚æˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™ä¼šæŠŠ\(\mu\)è®¾æˆ0ï¼Œè¿™æ ·æ°¸è¿œæ˜¯æœ€ä¸­å¿ƒçš„ä¿¡å·å¸¦æ¥æœ€å¤§çš„è´¡çŒ®ã€‚ä½†æ˜¯è¿™ä¸ªæ¦‚ç‡å¯†åº¦å‡½æ•°çš„\(x\)çš„èŒƒå›´æ˜¯\((-\infin, \infin)\)ï¼Œæˆ‘ä»¬ä¸å¯èƒ½å¯¹æ‰€æœ‰çš„ä¿¡å·éƒ½è¿›è¡Œé‡‡æ ·ï¼Œäºæ˜¯æˆ‘ä»¬ä¸€èˆ¬å¯¹\(3\sigma\)èŒƒå›´å†…çš„ä¿¡å·è¿›è¡Œé‡‡æ ·ï¼Œå¯¹1Dçš„æ­£æ€åˆ†å¸ƒæ¥è¯´ï¼Œ\((-3\sigma, 3\sigma)\)å æ®äº†çº¦99.7%çš„é¢ç§¯ã€‚å› æ­¤æˆ‘ä»¬å¾€å¾€ä½¿ç”¨ä¸‰å€çš„\(sigma\)ä½œä¸ºé‡‡æ ·çš„åŠå¾„ï¼Œäº‹å®ä¸Šåœ¨2Dçš„æ—¶å€™ï¼Œå¯èƒ½éœ€è¦æ›´å¤§çš„é‡‡æ ·åŠå¾„æ‰èƒ½æ¶ˆé™¤æ˜æ˜¾çš„é‡‡æ ·åŠå¾„è¿‡å°çš„ç‘•ç–µã€‚</p><p>æœ‰ä¸€ç‚¹å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè™½ç„¶æˆ‘å¹¶ä¸ä¼šå…·ä½“çš„å¾®ç§¯åˆ†çš„è®¡ç®—ï¼Œä½†æ®æˆ‘æ‰€çŸ¥å…ˆåæ‰§è¡Œä¸¤ä¸ª\(\sigma\)å€¼åˆ†åˆ«ä¸º\(x\)å’Œ\(y\)é«˜æ–¯æ¨¡ç³Šï¼Œç­‰ä»·äºæ‰§è¡Œä¸€æ¬¡\(\sigma\)å€¼ä¸º\(\sqrt {x^2+y^2}\)çš„é«˜æ–¯æ¨¡ç³Šã€‚</p><p>å¦ä¸€ä¸ªæœ‰è¶£çš„ç‚¹æ˜¯ï¼Œåœ¨æ™®é€šçš„æ¨¡ç³Šæ“ä½œæ˜¯æˆ‘ä»¬å¾€å¾€ä¼šç”¨é™é‡‡æ ·å†å‡é‡‡æ ·çš„æ–¹å¼æ¥å‡å°‘é‡‡æ ·çš„æ¬¡æ•°ã€‚å¯¹äºåŠåˆ†è¾¨ç‡çš„çº¿æ€§1Dé™é‡‡æ ·å’Œå‡é‡‡æ ·ï¼Œä¸­å¿ƒåƒç´ ä¿ç•™äº†\(\frac 3 8\)çš„ä¹‹å‰åƒç´ çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°é‚£ä¹ˆä¸€ä¸ª\(\sigma\)çš„å€¼ä½¿å¾—å…¶åœ¨\((-0.5, 0.5)\)ä¹‹é—´çš„é¢ç§¯çº¦ç­‰äº\(\frac 3 8\)ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½è¯´æˆ‘ä»¬é€šè¿‡çº¿æ€§é™é‡‡æ ·å’Œå‡é‡‡æ ·åšåˆ°äº†è¿‘ä¼¼å¯¹åº”\(\sigma\)çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœã€‚å¯æƒœè¿™ä¸ª\(\sigma\)ä¸å¤ªå¥½ç®—ï¼Œæœ‰Group Shared Memoryä¹Ÿæ²¡æœ‰å¿…è¦å»åšé¢å¤–çš„é™é‡‡æ ·å’Œå‡é‡‡æ ·äº†ã€‚</p><p>åœ¨æœ¬æ–‡ä¸­ï¼Œä¼šé€šè¿‡æ¨ªç«–ä¸¤ä¸ª1Dé«˜æ–¯æ»¤æ³¢å™¨æ¥ç­‰æ•ˆä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨ï¼Œä½¿ç”¨Group Shared Memoryçš„è¯ï¼Œå€’æ˜¯ä¸€ä¸ª2Dçš„é«˜æ–¯æ»¤æ³¢å™¨æ•ˆç‡æ›´é«˜ä¸€äº›ï¼Œä¸è¿‡ä¸ºäº†åç»­çš„æ‰©å±•æ€§ï¼Œæœ¬æ–‡æ‹†æˆäº†ä¸¤ä¸ªæ»¤æ³¢å™¨ã€‚</p><h2 id=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æ–¹æ³•>#</a></h2><p>å‰©ä¸‹çš„å°±å’Œä¹‹å‰å¤§åŒå°å¼‚äº†ï¼Œä¸ºäº†ç¡®ä¿æ¯ä¸ªåƒç´ åªä¼šè¿›è¡Œè‡³å¤šä¸¤æ¬¡é‡‡æ ·ï¼Œéœ€è¦é™åˆ¶é«˜æ–¯æ¨¡ç³Šçš„æœ€å¤§åŠå¾„<code>GAUSSIAN_BLUR_MAX_RADIUS</code>ä¸º<code>THREAD_GROUP_SIZE</code>çš„ä¸€åŠã€‚è€Œä¸ºäº†2Dçš„é«˜æ–¯æ¨¡ç³Šåœ¨æ¯”è¾ƒæç«¯çš„æƒ…å†µä¸‹ä¹Ÿèƒ½æœ‰æ¯”è¾ƒå¥½çš„æ•ˆæœï¼Œæˆ‘çš„é«˜æ–¯æ¨¡ç³Šçš„åŠå¾„ä¼šæ˜¯\(\sigma\)çš„3.8å€å‘ä¸Šå–æ•´ã€‚</p><h3 id=gaussianblurcomputeshadercompute>GaussianBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#gaussianblurcomputeshadercompute>#</a></h3><p>è¿™æ˜¯ä¸€ä¸ªæ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šçš„Compute Shaderï¼Œé€šè¿‡Group Shared Memoryä¼˜åŒ–äº†åŸæœ¬é«˜æ–¯æ¨¡ç³Šçš„æ¯ä¸ªåƒç´ çš„é‡‡æ ·æ“ä½œï¼ˆè‡³å¤šä¸¤æ¬¡ï¼‰ã€‚æœ€å¤§æ¨¡ç³ŠåŠå¾„ä¸º128ä¸ªåƒç´ ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel GaussianH
#pragma kernel GaussianV

Texture2D&lt;float4&gt; _SourceTex;
RWTexture2D&lt;float4&gt; _RW_TargetTex;
StructuredBuffer&lt;float&gt; _GaussianWeights;
float4 _TextureSize;

#define GAUSSIAN_BLUR_MAX_RADIUS 128
#define THREAD_GROUP_SIZE 256
const static int CACHED_COLOR_SIZE = THREAD_GROUP_SIZE +GAUSSIAN_BLUR_MAX_RADIUS*2;
groupshared half3 cachedColor[CACHED_COLOR_SIZE];
void SetCachedColor(half3 color, int index) { cachedColor[index] = color; }
half3 GetCachedColor(int threadPos) { return cachedColor[threadPos + GAUSSIAN_BLUR_MAX_RADIUS]; }
void CacheColor(int2 groupCacheStartPos, int cacheIndex, int isHorizontal)
{
    int2 texturePos = groupCacheStartPos + cacheIndex * int2(isHorizontal, 1 - isHorizontal);
    texturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f);
    half3 color = _SourceTex.Load(uint3(texturePos, 0)).rgb;
    SetCachedColor(color, cacheIndex);
}

half3 Gaussian(uint3 groupID, uint3 groupThreadID, uint groupIndex, uint3 dispatchThreadID, int isHorizontal)
{
    int2 direction = int2(isHorizontal, 1 - isHorizontal);
    int2 theadGroupSize = (THREAD_GROUP_SIZE - 1) * direction + 1;
    int2 groupCacheStartPos = groupID.xy * theadGroupSize - GAUSSIAN_BLUR_MAX_RADIUS * direction;
    int cacheIndex = groupIndex * 2;
    if (cacheIndex &lt; CACHED_COLOR_SIZE - 1)
    {
        CacheColor(groupCacheStartPos, cacheIndex, isHorizontal);
        CacheColor(groupCacheStartPos, cacheIndex+1, isHorizontal);
    }
    GroupMemoryBarrierWithGroupSync();

    int sampleRadius = int(_GaussianWeights[0]);
    uint loadCacheIndex = groupIndex;
    int threadPos = loadCacheIndex;
    half3 sumColor = 0.0f;
    half sumWeight = 0.0f;
    for (int i=-sampleRadius; i&lt;=sampleRadius; ++i)
    {
        half3 color = GetCachedColor(threadPos + i);
        half weight = _GaussianWeights[abs(i)+1];
        sumColor += color * weight;
        sumWeight += weight;
    }
    return sumColor / sumWeight;
}

[numthreads(THREAD_GROUP_SIZE,1,1)]
void GaussianH(uint3 groupID : SV_GroupID,
                uint3 groupThreadID : SV_GroupThreadID,
                uint groupIndex : SV_GroupIndex,
                uint3 dispatchThreadID : SV_DispatchThreadID)
{
    half3 color = Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, 1);
    _RW_TargetTex[dispatchThreadID.xy] = half4(color, 1.0f);
}

[numthreads(1, THREAD_GROUP_SIZE,1)]
void GaussianV(uint3 groupID : SV_GroupID,
                uint3 groupThreadID : SV_GroupThreadID,
                uint groupIndex : SV_GroupIndex,
                uint3 dispatchThreadID : SV_DispatchThreadID)
{
    half3 color = Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, 0);
    _RW_TargetTex[dispatchThreadID.xy] = half4(color, 1.0f);
}
</code></pre><h3 id=gausianblurcs>GausianBlur.cs<a hidden class=anchor aria-hidden=true href=#gausianblurcs>#</a></h3><p>è¿™é‡Œè®¾ç½®äº†é‡‡æ ·åŠå¾„ä¸º\(\sigma\)çš„3.8å€ï¼Œå³ä½¿åœ¨æœ‰å¾ˆäº®çš„å…‰æ–‘çš„æƒ…å†µä¸‹ï¼Œä¹Ÿèƒ½æœ‰å¾ˆå¥½çš„é«˜æ–¯æ¨¡ç³Šçš„æ•ˆæœï¼ˆä¸å¥½çš„è¯å°±å†æé«˜sigmaçš„å¤§å°ï¼‰ã€‚ä¼šé€šè¿‡\(\sigma\)è®¡ç®—å‡ºé‡‡æ ·åŠå¾„å’Œæ¯ä¸ªåƒç´ çš„æƒé‡ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Gaussian Blur&#34;, typeof(UniversalRenderPipeline))]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlur</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> sigmaRadiusRatio = <span style=color:#ae81ff>3.8f</span>;
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter sigma = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, Mathf.Floor(<span style=color:#ae81ff>128.0f</span> / sigmaRadiusRatio));

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; sigma.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> INV_SQRT_2PI = <span style=color:#ae81ff>0.3989422804f</span>;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> Gaussian(<span style=color:#66d9ef>float</span> sigma, <span style=color:#66d9ef>float</span> x)
        {
            <span style=color:#66d9ef>float</span> invSigma = <span style=color:#ae81ff>1.0f</span> / sigma;
            <span style=color:#66d9ef>return</span> INV_SQRT_2PI * invSigma * Mathf.Exp(-<span style=color:#ae81ff>0.5f</span> * x * x * invSigma * invSigma);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> SigmaToRadius(<span style=color:#66d9ef>float</span> sigma)
        {
            <span style=color:#66d9ef>return</span> Mathf.CeilToInt(sigma * sigmaRadiusRatio);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span>[] GetGaussianWeights(<span style=color:#66d9ef>float</span> sigma)
        {
            <span style=color:#66d9ef>int</span> length = SigmaToRadius(sigma);
            <span style=color:#66d9ef>float</span>[] weights = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>float</span>[length+<span style=color:#ae81ff>1</span>];
            weights[<span style=color:#ae81ff>0</span>] = (<span style=color:#66d9ef>float</span>)length;
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; length; i++)
            {
                weights[i+<span style=color:#ae81ff>1</span>] = Gaussian(sigma, (<span style=color:#66d9ef>float</span>)i);
            }
            <span style=color:#66d9ef>return</span> weights;
        }
    }
}
</code></pre></div><h3 id=gaussianblurrenderpasscs>GaussianBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#gaussianblurrenderpasscs>#</a></h3><p>è¿™é‡Œæˆ‘è°·æ­Œäº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªæ¯”è¾ƒåˆé€‚çš„é¿å…Unityè¯´æˆ‘æ²¡æœ‰é‡Šæ”¾Compute Bufferçš„åŠæ³•ã€‚å¾ˆæœ´å®æ— åçš„æ¨ªç«–ä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šï¼Œå¦‚æœCamera Color Attachmentèƒ½å¤Ÿæ”¯æŒéšæœºè¯»å†™çš„è¯ï¼Œå°±èƒ½å†èŠ‚çœä¸€æ¬¡Blitã€‚æˆ‘ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ï¼ŒUnityå¾ˆå¥‡æ€ªåœ°ç»™Camera Color Attachmentå‘½åä¸ºâ€œ_CameraColorAttachementAâ€ï¼Œä¸è¿‡æ²¡ä»€ä¹ˆå¤§ç¢ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Gaussian Blur Render Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> GaussianBlurRendererFeature.GaussianBlurSettings settings;
        <span style=color:#66d9ef>private</span> GaussianBlur gaussianBlur;
        <span style=color:#66d9ef>private</span> ComputeShader computeShader;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
        RenderTargetIdentifier cameraColorIden;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gaussianBlurTextureOneName = <span style=color:#e6db74>&#34;_GaussianBlurTextureOne&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gaussianBlurTextureOneID = Shader.PropertyToID(gaussianBlurTextureOneName);
        RenderTargetIdentifier gaussianBlurTextureOneIden;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gaussianBlurTextureTwoName = <span style=color:#e6db74>&#34;_GaussianBlurTextureTwo&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gaussianBlurTextureTwoID = Shader.PropertyToID(gaussianBlurTextureTwoName);
        RenderTargetIdentifier gaussianBlurTextureTwoIden;

        <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span>[] weights;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> HorizontalKernelName = <span style=color:#e6db74>&#34;GaussianH&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> VerticalKernelName = <span style=color:#e6db74>&#34;GaussianV&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>SourceTex = Shader.PropertyToID(<span style=color:#e6db74>&#34;_SourceTex&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>RW_TargetTex = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>GaussianWeights = Shader.PropertyToID(<span style=color:#e6db74>&#34;_GaussianWeights&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>TextureSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);

        <span style=color:#66d9ef>public</span> GaussianBlurRenderPass(GaussianBlurRendererFeature.GaussianBlurSettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);

            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            computeShader = settings.computeShader;

            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
            gaussianBlurTextureOneIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(gaussianBlurTextureOneID);
            gaussianBlurTextureTwoIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(gaussianBlurTextureTwoID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(GaussianBlur gaussianBlur)
        {
            <span style=color:#66d9ef>this</span>.gaussianBlur = gaussianBlur;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
        {
            <span style=color:#66d9ef>if</span>(computeBuffer == <span style=color:#66d9ef>null</span> || computeBuffer.count != count || computeBuffer.stride != stride)
            {
                <span style=color:#66d9ef>if</span>(computeBuffer != <span style=color:#66d9ef>null</span>)
                {
                    computeBuffer.Release();
                }
                computeBuffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnCameraSetup(CommandBuffer cmd, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            weights = GaussianBlur.GetGaussianWeights(gaussianBlur.sigma.<span style=color:#66d9ef>value</span>);
            <span style=color:#66d9ef>int</span> count = weights.Length;
            EnsureComputeBuffer(count, <span style=color:#ae81ff>4</span>);
            computeBuffer.SetData(weights);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
            RenderTextureDescriptor desc = cameraTextureDescriptor;
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;

            cmd.GetTemporaryRT(gaussianBlurTextureOneID, desc);
            cmd.GetTemporaryRT(gaussianBlurTextureTwoID, desc);
        }

        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
        }
        
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoGaussianBlur(CommandBuffer cmd, RenderTargetIdentifier colorid,
                                    RenderTargetIdentifier oneid, RenderTargetIdentifier twoid,
                                    ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;

            {
                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(HorizontalKernelName);
                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>SourceTex, colorid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RW_TargetTex, oneid);
                cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>GaussianWeights, computeBuffer);
                cmd.SetComputeVectorParam(computeShader, <span style=color:#ae81ff>_</span>TextureSize, GetTextureSizeParams(textureSize));
                cmd.DispatchCompute(computeShader, kernelID,
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
                    <span style=color:#ae81ff>1</span>);
            }
            {
                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(VerticalKernelName);
                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>SourceTex, oneid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RW_TargetTex, twoid);
                cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>GaussianWeights, computeBuffer);
                cmd.SetComputeVectorParam(computeShader, <span style=color:#ae81ff>_</span>TextureSize, GetTextureSizeParams(textureSize));
                cmd.DispatchCompute(computeShader, kernelID,
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
                    <span style=color:#ae81ff>1</span>);
            }
            cmd.Blit(twoid, colorid);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get();
            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                DoGaussianBlur(cmd, cameraColorIden, gaussianBlurTextureOneIden, gaussianBlurTextureTwoIden, computeShader);
            }
            context.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
        {
            cmd.ReleaseTemporaryRT(gaussianBlurTextureOneID);
            cmd.ReleaseTemporaryRT(gaussianBlurTextureTwoID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
        {
            <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
            {
                computeBuffer.Release();
                computeBuffer = <span style=color:#66d9ef>null</span>;
            }
        }
    }
}
</code></pre></div><h3 id=gaussianblurrendererfeaturecs>GaussianBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#gaussianblurrendererfeaturecs>#</a></h3><p>æ²¡å•¥å¥½è¯´çš„äº†ï¼ŒåŠ äº†ä¸€ä¸ª<code>Dispose</code>æ–¹æ³•æ¥åŠæ—¶é‡Šæ”¾Compute Bufferã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent;
            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        }

        <span style=color:#66d9ef>public</span> GaussianBlurSettings settings = <span style=color:#66d9ef>new</span> GaussianBlurSettings();
        <span style=color:#66d9ef>private</span> GaussianBlurRenderPass gaussianBlurRenderPass;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            gaussianBlurRenderPass = <span style=color:#66d9ef>new</span> GaussianBlurRenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            GaussianBlur gaussianBlur = VolumeManager.instance.stack.GetComponent&lt;GaussianBlur&gt;();
            <span style=color:#66d9ef>if</span>(gaussianBlur != <span style=color:#66d9ef>null</span> &amp;&amp; gaussianBlur.IsActive())
            {
                gaussianBlurRenderPass.Setup(gaussianBlur);
                renderer.EnqueuePass(gaussianBlurRenderPass);
            }
        }

        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
        {
            gaussianBlurRenderPass.Dispose();
            <span style=color:#66d9ef>base</span>.Dispose(disposing);
        }
    }
}
</code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>2023å¹´äº†æ€ä¹ˆè¿˜åœ¨åšé«˜æ–¯æ¨¡ç³Šå•Šå–‚ï¼Œæ˜æ˜éƒ½å†™äº†ä¸çŸ¥é“å¤šå°‘éäº†ã€‚ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯EAä¹‹å‰åšè¿‡æ¼”è®²çš„Circular Blurï¼ˆè™½ç„¶ä¹Ÿå†™äº†å¾ˆå¤šéå›ºå®šå¤§å°çš„äº†ï¼‰ã€‚ä»€ä¹ˆæ—¶å€™æ‰èƒ½é‡æ‹¾å‹‡æ°”å»ç®—æ™¯æ·±å‘¢å‘œå‘œå‘œã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li><li><a href=https://zznewclear13.github.io/tags/group-shared-memory/>Group Shared Memory</a></li><li><a href=https://zznewclear13.github.io/tags/gaussian-blur/>Gaussian Blur</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><span class=title>Â« Prev</span><br><span>Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š</span></a>
<a class=next href=https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/><span class=title>Next Â»</span><br><span>æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>