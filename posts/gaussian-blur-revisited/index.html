<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>再议高斯模糊 | ZZNEWCLEAR13</title>
<meta name=keywords content="Compute Shader,Group Shared Memory,Blur,Post-Process"><meta name=description content="使用StructuredBuffer进行任意大小的高斯模糊."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="再议高斯模糊"><meta property="og:description" content="使用StructuredBuffer进行任意大小的高斯模糊."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/"><meta property="og:image" content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-05T12:00:00+08:00"><meta property="article:modified_time" content="2023-04-05T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png"><meta name=twitter:title content="再议高斯模糊"><meta name=twitter:description content="使用StructuredBuffer进行任意大小的高斯模糊."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"再议高斯模糊","item":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"再议高斯模糊","name":"再议高斯模糊","description":"使用StructuredBuffer进行任意大小的高斯模糊.","keywords":["Compute Shader","Group Shared Memory","Blur","Post-Process"],"articleBody":"将近两年之后再回过头来制作高斯模糊 虽然两年前已经写过了使用Group Shared Memory加速高斯模糊这篇文章了。但当时写的时候仍有一些遗憾的地方，由于使用的是长度为17的静态的高斯模糊的数组（实际上只有9个权重），虽然在一定程度上能够达到任意调节高斯模糊的程度的效果，但在较低程度的高斯模糊时，是通过手动线性插值找到合适的采样颜色，且一定会有17次的颜色和权重的运算；而在较高程度的高斯模糊时，由于仅有十七个有效的颜色点，会有明显的采样次数不足的瑕疵。\n而这两年之间我也曾考虑使用不同的方法来制作一个既能满足很高程度的高斯模糊，又能兼顾很小程度的高斯模糊，性能上也相对高效，且使用同一套通用的代码，的高斯模糊效果。下面便是我之前在Shadertoy上写的通过随机采样和历史混合的高斯模糊效果。\nStochastic Gaussian Blur\n但随机带来的噪声和历史混合带来的限制，决定了这种方法终究不能真正地使用在项目中，于是我又开始回到了使用Compute Shader和Group Shared Memory来计算高斯模糊效果的老路子上。不同的是，这次我使用了Compute Buffer把高斯模糊的参数传给Shader，这样就能确保范围内的每一个采样点都能够对最后的颜色产生应有的贡献。\n正态分布(Normal Distribution) 和之前不同的是，这次我们要先从正态分布入手，从正态分布的特性来考虑我们的计算方式。正态分布的概率密度函数(probability density function)如下所示： $$ f(x) = \\frac 1 {\\sigma \\sqrt{2 \\pi}} e^{- \\frac 1 2 (\\frac {x-\\mu} \\sigma)^2} $$ 使用正态分布对信号进行过滤，被称作高斯滤波器(Gaussian Filter)。我们在使用的时候会把\\(\\mu\\)设成0，这样永远是最中心的信号带来最大的贡献。但是这个概率密度函数的\\(x\\)的范围是\\((-\\infin, \\infin)\\)，我们不可能对所有的信号都进行采样，于是我们一般对\\(3\\sigma\\)范围内的信号进行采样，对1D的正态分布来说，\\((-3\\sigma, 3\\sigma)\\)占据了约99.7%的面积。因此我们往往使用三倍的\\(sigma\\)作为采样的半径，事实上在2D的时候，可能需要更大的采样半径才能消除明显的采样半径过小的瑕疵。\n有一点值得一提的是，虽然我并不会具体的微积分的计算，但据我所知先后执行两个\\(\\sigma\\)值分别为\\(x\\)和\\(y\\)高斯模糊，等价于执行一次\\(\\sigma\\)值为\\(\\sqrt {x^2+y^2}\\)的高斯模糊。\n另一个有趣的点是，在普通的模糊操作是我们往往会用降采样再升采样的方式来减少采样的次数。对于半分辨率的线性1D降采样和升采样，中心像素保留了\\(\\frac 3 8\\)的之前像素的信息，我们可以找到那么一个\\(\\sigma\\)的值使得其在\\((-0.5, 0.5)\\)之间的面积约等于\\(\\frac 3 8\\)，这样我们就能说我们通过线性降采样和升采样做到了近似对应\\(\\sigma\\)的高斯模糊的效果。可惜这个\\(\\sigma\\)不太好算，有Group Shared Memory也没有必要去做额外的降采样和升采样了。\n在本文中，会通过横竖两个1D高斯滤波器来等效一个2D的高斯滤波器，使用Group Shared Memory的话，倒是一个2D的高斯滤波器效率更高一些，不过为了后续的扩展性，本文拆成了两个滤波器。\n具体的实现方法 剩下的就和之前大同小异了，为了确保每个像素只会进行至多两次采样，需要限制高斯模糊的最大半径GAUSSIAN_BLUR_MAX_RADIUS为THREAD_GROUP_SIZE的一半。而为了2D的高斯模糊在比较极端的情况下也能有比较好的效果，我的高斯模糊的半径会是\\(\\sigma\\)的3.8倍向上取整。\nGaussianBlurComputeShader.compute 这是一个横竖两次高斯模糊的Compute Shader，通过Group Shared Memory优化了原本高斯模糊的每个像素的采样操作（至多两次）。最大模糊半径为128个像素。\n#pragma kernel GaussianH #pragma kernel GaussianV Texture2D\u003cfloat4\u003e _SourceTex; RWTexture2D\u003cfloat4\u003e _RW_TargetTex; StructuredBuffer\u003cfloat\u003e _GaussianWeights; float4 _TextureSize; #define GAUSSIAN_BLUR_MAX_RADIUS 128 #define THREAD_GROUP_SIZE 256 const static int CACHED_COLOR_SIZE = THREAD_GROUP_SIZE +GAUSSIAN_BLUR_MAX_RADIUS*2; groupshared half3 cachedColor[CACHED_COLOR_SIZE]; void SetCachedColor(half3 color, int index) { cachedColor[index] = color; } half3 GetCachedColor(int threadPos) { return cachedColor[threadPos + GAUSSIAN_BLUR_MAX_RADIUS]; } void CacheColor(int2 groupCacheStartPos, int cacheIndex, int isHorizontal) { int2 texturePos = groupCacheStartPos + cacheIndex * int2(isHorizontal, 1 - isHorizontal); texturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f); half3 color = _SourceTex.Load(uint3(texturePos, 0)).rgb; SetCachedColor(color, cacheIndex); } half3 Gaussian(uint3 groupID, uint3 groupThreadID, uint groupIndex, uint3 dispatchThreadID, int isHorizontal) { int2 direction = int2(isHorizontal, 1 - isHorizontal); int2 theadGroupSize = (THREAD_GROUP_SIZE - 1) * direction + 1; int2 groupCacheStartPos = groupID.xy * theadGroupSize - GAUSSIAN_BLUR_MAX_RADIUS * direction; int cacheIndex = groupIndex * 2; if (cacheIndex \u003c CACHED_COLOR_SIZE - 1) { CacheColor(groupCacheStartPos, cacheIndex, isHorizontal); CacheColor(groupCacheStartPos, cacheIndex+1, isHorizontal); } GroupMemoryBarrierWithGroupSync(); int sampleRadius = int(_GaussianWeights[0]); uint loadCacheIndex = groupIndex; int threadPos = loadCacheIndex; half3 sumColor = 0.0f; half sumWeight = 0.0f; for (int i=-sampleRadius; i\u003c=sampleRadius; ++i) { half3 color = GetCachedColor(threadPos + i); half weight = _GaussianWeights[abs(i)+1]; sumColor += color * weight; sumWeight += weight; } return sumColor / sumWeight; } [numthreads(THREAD_GROUP_SIZE,1,1)] void GaussianH(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { half3 color = Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, 1); _RW_TargetTex[dispatchThreadID.xy] = half4(color, 1.0f); } [numthreads(1, THREAD_GROUP_SIZE,1)] void GaussianV(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { half3 color = Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, 0); _RW_TargetTex[dispatchThreadID.xy] = half4(color, 1.0f); } GausianBlur.cs 这里设置了采样半径为\\(\\sigma\\)的3.8倍，即使在有很亮的光斑的情况下，也能有很好的高斯模糊的效果（不好的话就再提高sigma的大小）。会通过\\(\\sigma\\)计算出采样半径和每个像素的权重。\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Gaussian Blur\", typeof(UniversalRenderPipeline))] public sealed class GaussianBlur : VolumeComponent, IPostProcessComponent { static float sigmaRadiusRatio = 3.8f; public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter sigma = new ClampedFloatParameter(0.0f, 0.0f, Mathf.Floor(128.0f / sigmaRadiusRatio)); public bool IsActive() { return isEnabled.value \u0026\u0026 sigma.value \u003e 0.0f; } public bool IsTileCompatible() { return false; } private static float INV_SQRT_2PI = 0.3989422804f; private static float Gaussian(float sigma, float x) { float invSigma = 1.0f / sigma; return INV_SQRT_2PI * invSigma * Mathf.Exp(-0.5f * x * x * invSigma * invSigma); } public static int SigmaToRadius(float sigma) { return Mathf.CeilToInt(sigma * sigmaRadiusRatio); } public static float[] GetGaussianWeights(float sigma) { int length = SigmaToRadius(sigma); float[] weights = new float[length+1]; weights[0] = (float)length; for (int i = 0; i \u003c length; i++) { weights[i+1] = Gaussian(sigma, (float)i); } return weights; } } } GaussianBlurRenderPass.cs 这里我谷歌了一下，找到了一个比较合适的避免Unity说我没有释放Compute Buffer的办法。很朴实无华的横竖两次高斯模糊，如果Camera Color Attachment能够支持随机读写的话，就能再节省一次Blit。我使用的是Unity 2021.3.19f1c1，Unity很奇怪地给Camera Color Attachment命名为“_CameraColorAttachementA”，不过没什么大碍。\nnamespace UnityEngine.Rendering.Universal { public class GaussianBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Gaussian Blur Render Pass\"; private GaussianBlurRendererFeature.GaussianBlurSettings settings; private GaussianBlur gaussianBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); RenderTargetIdentifier cameraColorIden; static readonly string gaussianBlurTextureOneName = \"_GaussianBlurTextureOne\"; static readonly int gaussianBlurTextureOneID = Shader.PropertyToID(gaussianBlurTextureOneName); RenderTargetIdentifier gaussianBlurTextureOneIden; static readonly string gaussianBlurTextureTwoName = \"_GaussianBlurTextureTwo\"; static readonly int gaussianBlurTextureTwoID = Shader.PropertyToID(gaussianBlurTextureTwoName); RenderTargetIdentifier gaussianBlurTextureTwoIden; private ComputeBuffer computeBuffer; private Vector2Int textureSize; private float[] weights; static readonly string HorizontalKernelName = \"GaussianH\"; static readonly string VerticalKernelName = \"GaussianV\"; static readonly int _SourceTex = Shader.PropertyToID(\"_SourceTex\"); static readonly int _RW_TargetTex = Shader.PropertyToID(\"_RW_TargetTex\"); static readonly int _GaussianWeights = Shader.PropertyToID(\"_GaussianWeights\"); static readonly int _TextureSize = Shader.PropertyToID(\"_TextureSize\"); public GaussianBlurRenderPass(GaussianBlurRendererFeature.GaussianBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); gaussianBlurTextureOneIden = new RenderTargetIdentifier(gaussianBlurTextureOneID); gaussianBlurTextureTwoIden = new RenderTargetIdentifier(gaussianBlurTextureTwoID); } public void Setup(GaussianBlur gaussianBlur) { this.gaussianBlur = gaussianBlur; } private void EnsureComputeBuffer(int count, int stride) { if(computeBuffer == null || computeBuffer.count != count || computeBuffer.stride != stride) { if(computeBuffer != null) { computeBuffer.Release(); } computeBuffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData) { weights = GaussianBlur.GetGaussianWeights(gaussianBlur.sigma.value); int count = weights.Length; EnsureComputeBuffer(count, 4); computeBuffer.SetData(weights); } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; cmd.GetTemporaryRT(gaussianBlurTextureOneID, desc); cmd.GetTemporaryRT(gaussianBlurTextureTwoID, desc); } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoGaussianBlur(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier oneid, RenderTargetIdentifier twoid, ComputeShader computeShader) { if (!computeShader) return; { int kernelID = computeShader.FindKernel(HorizontalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, colorid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, oneid); cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } { int kernelID = computeShader.FindKernel(VerticalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, oneid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, twoid); cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } cmd.Blit(twoid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { DoGaussianBlur(cmd, cameraColorIden, gaussianBlurTextureOneIden, gaussianBlurTextureTwoIden, computeShader); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(gaussianBlurTextureOneID); cmd.ReleaseTemporaryRT(gaussianBlurTextureTwoID); } public void Dispose() { if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } } } } GaussianBlurRendererFeature.cs 没啥好说的了，加了一个Dispose方法来及时释放Compute Buffer。\nnamespace UnityEngine.Rendering.Universal { public class GaussianBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class GaussianBlurSettings { public RenderPassEvent renderPassEvent; public ComputeShader computeShader; } public GaussianBlurSettings settings = new GaussianBlurSettings(); private GaussianBlurRenderPass gaussianBlurRenderPass; public override void Create() { gaussianBlurRenderPass = new GaussianBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { GaussianBlur gaussianBlur = VolumeManager.instance.stack.GetComponent(); if(gaussianBlur != null \u0026\u0026 gaussianBlur.IsActive()) { gaussianBlurRenderPass.Setup(gaussianBlur); renderer.EnqueuePass(gaussianBlurRenderPass); } } protected override void Dispose(bool disposing) { gaussianBlurRenderPass.Dispose(); base.Dispose(disposing); } } } 后记 2023年了怎么还在做高斯模糊啊喂，明明都写了不知道多少遍了。下一个目标是EA之前做过演讲的Circular Blur（虽然也写了很多遍固定大小的了）。什么时候才能重拾勇气去算景深呢呜呜呜。\n","wordCount":"951","inLanguage":"en","image":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/posts/images/GaussianBlurRevisited.png","datePublished":"2023-04-05T12:00:00+08:00","dateModified":"2023-04-05T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/gaussian-blur-revisited/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">再议高斯模糊</h1><div class=post-description>使用StructuredBuffer进行任意大小的高斯模糊.</div><div class=post-meta><span title='2023-04-05 12:00:00 +0800 CST'>April 5, 2023</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/gaussian-blur-revisited.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GaussianBlurRevisited.png alt="Gaussian Blur Cover"><p>Gaussian Blur Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>再议高斯模糊</div></summary><div class=inner><ul><li><a href=#%e5%b0%86%e8%bf%91%e4%b8%a4%e5%b9%b4%e4%b9%8b%e5%90%8e%e5%86%8d%e5%9b%9e%e8%bf%87%e5%a4%b4%e6%9d%a5%e5%88%b6%e4%bd%9c%e9%ab%98%e6%96%af%e6%a8%a1%e7%b3%8a aria-label=将近两年之后再回过头来制作高斯模糊>将近两年之后再回过头来制作高斯模糊</a></li><li><a href=#%e6%ad%a3%e6%80%81%e5%88%86%e5%b8%83normal-distribution aria-label="正态分布(Normal Distribution)">正态分布(Normal Distribution)</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=具体的实现方法>具体的实现方法</a><ul><li><a href=#gaussianblurcomputeshadercompute aria-label=GaussianBlurComputeShader.compute>GaussianBlurComputeShader.compute</a></li><li><a href=#gausianblurcs aria-label=GausianBlur.cs>GausianBlur.cs</a></li><li><a href=#gaussianblurrenderpasscs aria-label=GaussianBlurRenderPass.cs>GaussianBlurRenderPass.cs</a></li><li><a href=#gaussianblurrendererfeaturecs aria-label=GaussianBlurRendererFeature.cs>GaussianBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=将近两年之后再回过头来制作高斯模糊>将近两年之后再回过头来制作高斯模糊<a hidden class=anchor aria-hidden=true href=#将近两年之后再回过头来制作高斯模糊>#</a></h2><p>虽然两年前已经写过了<a href=/posts/accelerate-gaussian-blur-using-group-shared-memory/>使用Group Shared Memory加速高斯模糊</a>这篇文章了。但当时写的时候仍有一些遗憾的地方，由于使用的是长度为17的静态的高斯模糊的数组（实际上只有9个权重），虽然在一定程度上能够达到任意调节高斯模糊的程度的效果，但在较低程度的高斯模糊时，是通过手动线性插值找到合适的采样颜色，且一定会有17次的颜色和权重的运算；而在较高程度的高斯模糊时，由于仅有十七个有效的颜色点，会有明显的采样次数不足的瑕疵。</p><p>而这两年之间我也曾考虑使用不同的方法来制作一个既能满足很高程度的高斯模糊，又能兼顾很小程度的高斯模糊，性能上也相对高效，且使用同一套通用的代码，的高斯模糊效果。下面便是我之前在Shadertoy上写的通过随机采样和历史混合的高斯模糊效果。</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/7tG3zW?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Stochastic Gaussian Blur</p></figure><p>但随机带来的噪声和历史混合带来的限制，决定了这种方法终究不能真正地使用在项目中，于是我又开始回到了使用Compute Shader和Group Shared Memory来计算高斯模糊效果的老路子上。不同的是，这次我使用了Compute Buffer把高斯模糊的参数传给Shader，这样就能确保范围内的每一个采样点都能够对最后的颜色产生应有的贡献。</p><h2 id=正态分布normal-distribution>正态分布(Normal Distribution)<a hidden class=anchor aria-hidden=true href=#正态分布normal-distribution>#</a></h2><p>和之前不同的是，这次我们要先从正态分布入手，从正态分布的特性来考虑我们的计算方式。正态分布的概率密度函数(probability density function)如下所示：
$$
f(x) = \frac 1 {\sigma \sqrt{2 \pi}} e^{- \frac 1 2 (\frac {x-\mu} \sigma)^2}
$$
使用正态分布对信号进行过滤，被称作高斯滤波器(Gaussian Filter)。我们在使用的时候会把\(\mu\)设成0，这样永远是最中心的信号带来最大的贡献。但是这个概率密度函数的\(x\)的范围是\((-\infin, \infin)\)，我们不可能对所有的信号都进行采样，于是我们一般对\(3\sigma\)范围内的信号进行采样，对1D的正态分布来说，\((-3\sigma, 3\sigma)\)占据了约99.7%的面积。因此我们往往使用三倍的\(sigma\)作为采样的半径，事实上在2D的时候，可能需要更大的采样半径才能消除明显的采样半径过小的瑕疵。</p><p>有一点值得一提的是，虽然我并不会具体的微积分的计算，但据我所知先后执行两个\(\sigma\)值分别为\(x\)和\(y\)高斯模糊，等价于执行一次\(\sigma\)值为\(\sqrt {x^2+y^2}\)的高斯模糊。</p><p>另一个有趣的点是，在普通的模糊操作是我们往往会用降采样再升采样的方式来减少采样的次数。对于半分辨率的线性1D降采样和升采样，中心像素保留了\(\frac 3 8\)的之前像素的信息，我们可以找到那么一个\(\sigma\)的值使得其在\((-0.5, 0.5)\)之间的面积约等于\(\frac 3 8\)，这样我们就能说我们通过线性降采样和升采样做到了近似对应\(\sigma\)的高斯模糊的效果。可惜这个\(\sigma\)不太好算，有Group Shared Memory也没有必要去做额外的降采样和升采样了。</p><p>在本文中，会通过横竖两个1D高斯滤波器来等效一个2D的高斯滤波器，使用Group Shared Memory的话，倒是一个2D的高斯滤波器效率更高一些，不过为了后续的扩展性，本文拆成了两个滤波器。</p><h2 id=具体的实现方法>具体的实现方法<a hidden class=anchor aria-hidden=true href=#具体的实现方法>#</a></h2><p>剩下的就和之前大同小异了，为了确保每个像素只会进行至多两次采样，需要限制高斯模糊的最大半径<code>GAUSSIAN_BLUR_MAX_RADIUS</code>为<code>THREAD_GROUP_SIZE</code>的一半。而为了2D的高斯模糊在比较极端的情况下也能有比较好的效果，我的高斯模糊的半径会是\(\sigma\)的3.8倍向上取整。</p><h3 id=gaussianblurcomputeshadercompute>GaussianBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#gaussianblurcomputeshadercompute>#</a></h3><p>这是一个横竖两次高斯模糊的Compute Shader，通过Group Shared Memory优化了原本高斯模糊的每个像素的采样操作（至多两次）。最大模糊半径为128个像素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel GaussianH</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel GaussianV</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _SourceTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_TargetTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _GaussianWeights;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GAUSSIAN_BLUR_MAX_RADIUS 128</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define THREAD_GROUP_SIZE 256</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> CACHED_COLOR_SIZE <span style=color:#f92672>=</span> THREAD_GROUP_SIZE <span style=color:#f92672>+</span>GAUSSIAN_BLUR_MAX_RADIUS<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> <span style=color:#66d9ef>half3</span> cachedColor[CACHED_COLOR_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetCachedColor(<span style=color:#66d9ef>half3</span> color, <span style=color:#66d9ef>int</span> index) { cachedColor[index] <span style=color:#f92672>=</span> color; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>half3</span> GetCachedColor(<span style=color:#66d9ef>int</span> threadPos) { <span style=color:#66d9ef>return</span> cachedColor[threadPos <span style=color:#f92672>+</span> GAUSSIAN_BLUR_MAX_RADIUS]; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CacheColor(<span style=color:#66d9ef>int2</span> groupCacheStartPos, <span style=color:#66d9ef>int</span> cacheIndex, <span style=color:#66d9ef>int</span> isHorizontal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> texturePos <span style=color:#f92672>=</span> groupCacheStartPos <span style=color:#f92672>+</span> cacheIndex <span style=color:#f92672>*</span> <span style=color:#66d9ef>int2</span>(isHorizontal, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> isHorizontal);
</span></span><span style=display:flex><span>    texturePos <span style=color:#f92672>=</span> clamp(texturePos, <span style=color:#ae81ff>0</span>, _TextureSize.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> _SourceTex.Load(<span style=color:#66d9ef>uint3</span>(texturePos, <span style=color:#ae81ff>0</span>)).rgb;
</span></span><span style=display:flex><span>    SetCachedColor(color, cacheIndex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>half3</span> Gaussian(<span style=color:#66d9ef>uint3</span> groupID, <span style=color:#66d9ef>uint3</span> groupThreadID, <span style=color:#66d9ef>uint</span> groupIndex, <span style=color:#66d9ef>uint3</span> dispatchThreadID, <span style=color:#66d9ef>int</span> isHorizontal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> direction <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(isHorizontal, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> isHorizontal);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> theadGroupSize <span style=color:#f92672>=</span> (THREAD_GROUP_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> direction <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> groupCacheStartPos <span style=color:#f92672>=</span> groupID.xy <span style=color:#f92672>*</span> theadGroupSize <span style=color:#f92672>-</span> GAUSSIAN_BLUR_MAX_RADIUS <span style=color:#f92672>*</span> direction;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cacheIndex <span style=color:#f92672>&lt;</span> CACHED_COLOR_SIZE <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheColor(groupCacheStartPos, cacheIndex, isHorizontal);
</span></span><span style=display:flex><span>        CacheColor(groupCacheStartPos, cacheIndex<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, isHorizontal);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sampleRadius <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(_GaussianWeights[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> loadCacheIndex <span style=color:#f92672>=</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> threadPos <span style=color:#f92672>=</span> loadCacheIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> sumColor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half</span> sumWeight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=-</span>sampleRadius; i<span style=color:#f92672>&lt;=</span>sampleRadius; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> GetCachedColor(threadPos <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>half</span> weight <span style=color:#f92672>=</span> _GaussianWeights[abs(i)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        sumColor <span style=color:#f92672>+=</span> color <span style=color:#f92672>*</span> weight;
</span></span><span style=display:flex><span>        sumWeight <span style=color:#f92672>+=</span> weight;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sumColor <span style=color:#f92672>/</span> sumWeight;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(THREAD_GROUP_SIZE,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GaussianH(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    _RW_TargetTex[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>half4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>1</span>, THREAD_GROUP_SIZE,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GaussianV(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>half3</span> color <span style=color:#f92672>=</span> Gaussian(groupID, groupThreadID, groupIndex, dispatchThreadID, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    _RW_TargetTex[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>half4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gausianblurcs>GausianBlur.cs<a hidden class=anchor aria-hidden=true href=#gausianblurcs>#</a></h3><p>这里设置了采样半径为\(\sigma\)的3.8倍，即使在有很亮的光斑的情况下，也能有很好的高斯模糊的效果（不好的话就再提高sigma的大小）。会通过\(\sigma\)计算出采样半径和每个像素的权重。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Gaussian Blur&#34;, typeof(UniversalRenderPipeline))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlur</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> sigmaRadiusRatio = <span style=color:#ae81ff>3.8f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter sigma = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, Mathf.Floor(<span style=color:#ae81ff>128.0f</span> / sigmaRadiusRatio));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; sigma.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> INV_SQRT_2PI = <span style=color:#ae81ff>0.3989422804f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> Gaussian(<span style=color:#66d9ef>float</span> sigma, <span style=color:#66d9ef>float</span> x)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> invSigma = <span style=color:#ae81ff>1.0f</span> / sigma;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> INV_SQRT_2PI * invSigma * Mathf.Exp(-<span style=color:#ae81ff>0.5f</span> * x * x * invSigma * invSigma);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> SigmaToRadius(<span style=color:#66d9ef>float</span> sigma)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Mathf.CeilToInt(sigma * sigmaRadiusRatio);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span>[] GetGaussianWeights(<span style=color:#66d9ef>float</span> sigma)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> length = SigmaToRadius(sigma);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span>[] weights = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>float</span>[length+<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            weights[<span style=color:#ae81ff>0</span>] = (<span style=color:#66d9ef>float</span>)length;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                weights[i+<span style=color:#ae81ff>1</span>] = Gaussian(sigma, (<span style=color:#66d9ef>float</span>)i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> weights;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gaussianblurrenderpasscs>GaussianBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#gaussianblurrenderpasscs>#</a></h3><p>这里我谷歌了一下，找到了一个比较合适的避免Unity说我没有释放Compute Buffer的办法。很朴实无华的横竖两次高斯模糊，如果Camera Color Attachment能够支持随机读写的话，就能再节省一次Blit。我使用的是Unity 2021.3.19f1c1，Unity很奇怪地给Camera Color Attachment命名为“_CameraColorAttachementA”，不过没什么大碍。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Gaussian Blur Render Pass&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GaussianBlurRendererFeature.GaussianBlurSettings settings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GaussianBlur gaussianBlur;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
</span></span><span style=display:flex><span>        RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gaussianBlurTextureOneName = <span style=color:#e6db74>&#34;_GaussianBlurTextureOne&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gaussianBlurTextureOneID = Shader.PropertyToID(gaussianBlurTextureOneName);
</span></span><span style=display:flex><span>        RenderTargetIdentifier gaussianBlurTextureOneIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gaussianBlurTextureTwoName = <span style=color:#e6db74>&#34;_GaussianBlurTextureTwo&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gaussianBlurTextureTwoID = Shader.PropertyToID(gaussianBlurTextureTwoName);
</span></span><span style=display:flex><span>        RenderTargetIdentifier gaussianBlurTextureTwoIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span>[] weights;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> HorizontalKernelName = <span style=color:#e6db74>&#34;GaussianH&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> VerticalKernelName = <span style=color:#e6db74>&#34;GaussianV&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _SourceTex = Shader.PropertyToID(<span style=color:#e6db74>&#34;_SourceTex&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _RW_TargetTex = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GaussianWeights = Shader.PropertyToID(<span style=color:#e6db74>&#34;_GaussianWeights&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _TextureSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GaussianBlurRenderPass(GaussianBlurRendererFeature.GaussianBlurSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            computeShader = settings.computeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
</span></span><span style=display:flex><span>            gaussianBlurTextureOneIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(gaussianBlurTextureOneID);
</span></span><span style=display:flex><span>            gaussianBlurTextureTwoIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(gaussianBlurTextureTwoID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(GaussianBlur gaussianBlur)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.gaussianBlur = gaussianBlur;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(computeBuffer == <span style=color:#66d9ef>null</span> || computeBuffer.count != count || computeBuffer.stride != stride)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    computeBuffer.Release();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnCameraSetup(CommandBuffer cmd, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            weights = GaussianBlur.GetGaussianWeights(gaussianBlur.sigma.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count = weights.Length;
</span></span><span style=display:flex><span>            EnsureComputeBuffer(count, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>            computeBuffer.SetData(weights);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(gaussianBlurTextureOneID, desc);
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(gaussianBlurTextureTwoID, desc);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoGaussianBlur(CommandBuffer cmd, RenderTargetIdentifier colorid,
</span></span><span style=display:flex><span>                                    RenderTargetIdentifier oneid, RenderTargetIdentifier twoid,
</span></span><span style=display:flex><span>                                    ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(HorizontalKernelName);
</span></span><span style=display:flex><span>                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, colorid);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, oneid);
</span></span><span style=display:flex><span>                cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize));
</span></span><span style=display:flex><span>                cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(VerticalKernelName);
</span></span><span style=display:flex><span>                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _SourceTex, oneid);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, _RW_TargetTex, twoid);
</span></span><span style=display:flex><span>                cmd.SetComputeBufferParam(computeShader, kernelID, _GaussianWeights, computeBuffer);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize));
</span></span><span style=display:flex><span>                cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cmd.Blit(twoid, colorid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                DoGaussianBlur(cmd, cameraColorIden, gaussianBlurTextureOneIden, gaussianBlurTextureTwoIden, computeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(gaussianBlurTextureOneID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(gaussianBlurTextureTwoID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                computeBuffer.Release();
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gaussianblurrendererfeaturecs>GaussianBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#gaussianblurrendererfeaturecs>#</a></h3><p>没啥好说的了，加了一个<code>Dispose</code>方法来及时释放Compute Buffer。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GaussianBlurSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GaussianBlurSettings settings = <span style=color:#66d9ef>new</span> GaussianBlurSettings();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GaussianBlurRenderPass gaussianBlurRenderPass;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            gaussianBlurRenderPass = <span style=color:#66d9ef>new</span> GaussianBlurRenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GaussianBlur gaussianBlur = VolumeManager.instance.stack.GetComponent&lt;GaussianBlur&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(gaussianBlur != <span style=color:#66d9ef>null</span> &amp;&amp; gaussianBlur.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                gaussianBlurRenderPass.Setup(gaussianBlur);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(gaussianBlurRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            gaussianBlurRenderPass.Dispose();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>base</span>.Dispose(disposing);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>2023年了怎么还在做高斯模糊啊喂，明明都写了不知道多少遍了。下一个目标是EA之前做过演讲的Circular Blur（虽然也写了很多遍固定大小的了）。什么时候才能重拾勇气去算景深呢呜呜呜。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li><li><a href=https://zznewclear13.github.io/tags/group-shared-memory/>Group Shared Memory</a></li><li><a href=https://zznewclear13.github.io/tags/blur/>Blur</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><span class=title>« Prev</span><br><span>Unity两个Pass的圆形模糊</span>
</a><a class=next href=https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/><span class=title>Next »</span><br><span>模仿缺氧的瓦片渲染方法</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>