<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš® | ZZNEWCLEAR13</title>
<meta name=keywords content="GPU Skinning"><meta name=description content="è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ…."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®"><meta property="og:description" content="è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ…."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-11T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-11T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta name=twitter:title content="æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®"><meta name=twitter:description content="è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ…."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®","item":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®","name":"æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®","description":"è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ….","keywords":["GPU Skinning"],"articleBody":"ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš® å¯¹äºä¸€ä¸ªSkinnedMeshRendererï¼Œåœ¨åšè’™çš®çš„æ—¶å€™ï¼Œå¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ï¼Œä¼šå…ˆè®¡ç®—å‡ºè¿™ä¸ªé¡¶ç‚¹å¯¹åº”çš„å››æ ¹éª¨éª¼çš„ä»éª¨éª¼ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„çŸ©é˜µ\\(M_{bone\\localtoobject}\\)ï¼Œç„¶åä½¿ç”¨\\(M{bone\\localtoobject} * M{bone\\bindpose} * Vertex{objectspace}\\)å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å››ä¸ªå¸¦æƒé‡çš„é¡¶ç‚¹æ•°æ®ä½ç½®å’Œåˆ‡çº¿ï¼Œå¯¹äºæ³•çº¿åˆ™æ˜¯ä½¿ç”¨ä¸Šé¢çŸ©é˜µçš„é€†çŸ©é˜µçš„è½¬ç½®ã€‚ç„¶åå¯¹è·å¾—çš„ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œç”¨æƒé‡è®¡ç®—å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å®é™…çš„é¡¶ç‚¹ä¿¡æ¯ã€‚åœ¨é€šå¸¸çš„æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œä¸Šè¿°æ“ä½œæ˜¯åœ¨CPUä¸­è¿›è¡Œçš„ï¼Œæœ€åæŠŠé¡¶ç‚¹æ•°æ®ä¼ é€’ç»™GPUä¸­è¿›è¡Œæ¸²æŸ“ã€‚åœ¨é¡¶ç‚¹æ•°è¾ƒå¤šä¸”ä¸»è¦æ˜¯çŸ©é˜µè¿ç®—çš„æƒ…å†µä¸‹ï¼ŒCPUè¿›è¡Œè’™çš®çš„æ•ˆç‡å°±ä¸å¦‚é«˜å¹¶è¡Œçš„GPUäº†ï¼Œå› æ­¤ä¼šè€ƒè™‘åˆ°åœ¨GPUä¸­è¿›è¡Œè’™çš®å¤„ç†ã€‚\nGPUè’™çš®çš„ä¸€äº›æƒ³æ³• ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œè¦ä»CPUä¸­ä¼ ç»™GPUçš„æ•°æ®æœ‰ä»¥ä¸‹å‡ ç§ï¼šä¸€æ˜¯\\(M_{bone\\localtoobject} * M{bone\\_bindpose}\\)è¿™æ ·éª¨éª¼æ•°ä¸ªfloat4x4çš„çŸ©é˜µï¼Œä½†æ˜¯ç”±äºå…¶æœ€åä¸€è¡Œæ˜¯(0, 0, 0, 1)ï¼Œåœ¨ä¼ é€’æ—¶å¯ä»¥ç®€åŒ–æˆéª¨éª¼æ•°ä¸ªfloat3x4çŸ©é˜µï¼Œè¿™äº›çŸ©é˜µæ¯ä¸€å¸§éƒ½è¦ä¼ é€’ä¸€æ¬¡ï¼›äºŒæ˜¯æ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„éª¨éª¼ç¼–å·å’Œéª¨éª¼çš„æƒé‡ï¼Œéª¨éª¼ç¼–å·ç”¨æ¥æŸ¥è¯¢éª¨éª¼çŸ©é˜µä¸­å¯¹åº”çš„çŸ©é˜µï¼Œæ˜¯ä¸€ä¸ªæ•´å‹çš„æ•°æ®ï¼Œéª¨éª¼æƒé‡æ˜¯ä¸€ä¸ª[0, 1]çš„å°æ•°ï¼Œå¯ä»¥ç”¨\\(BoneIndex + BoneWeight * 0.5\\)çš„æ–¹å¼ï¼ŒæŠŠç¼–å·å’Œæƒé‡ç»“åˆæˆä¸€ä¸ªfloatçš„æ•°æ®ï¼Œè¿™æ ·æ¯ä¸ªé¡¶ç‚¹çš„éª¨éª¼ç¼–å·å’Œæƒé‡æ•°æ®æ˜¯ä¸€ä¸ªfloat4çš„æ•°æ®ï¼Œå¯ä»¥ä¿å­˜åœ¨UVä¸­ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°ç»„çš„æ–¹å¼ä¼ é€’ç»™GPUï¼Œè¿™äº›é¡¶ç‚¹æ•°ä¸ªfloat4çš„æ•°æ®ï¼Œåªéœ€è¦ä¼ é€’ä¸€æ¬¡å°±å¯ä»¥äº†ï¼›å†æœ‰å°±æ˜¯æ¨¡å‹æœ¬èº«çš„é¡¶ç‚¹ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œè¿™äº›å¼•æ“ä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬ä¼ é€’ç»™GPUã€‚\nåœ¨å®é™…æ“ä½œä¸­ï¼Œç½‘ä¸Šé€šå¸¸æ‰¾åˆ°çš„æ–¹æ¡ˆæ˜¯æŠŠåŠ¨ç”»ä¿å­˜åœ¨ä¸€å¼ è´´å›¾æˆ–è€…æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„æ•°æ®ç»“æ„ä¸­ï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥ä¿å­˜é¡¶ç‚¹æ•°æ®ï¼Œç”šè‡³ä¸éœ€è¦åœ¨GPUä¸­åšè’™çš®çš„æ“ä½œï¼Œä½†æ˜¯éšç€é¡¶ç‚¹æ•°å¢åŠ ä¼šå ç”¨å¤§é‡çš„ç©ºé—´ï¼›æˆ–è€…æ˜¯ä¿å­˜éª¨éª¼çš„å˜æ¢çŸ©é˜µï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®ï¼Œç›¸å¯¹æ¥è¯´å‚¨å­˜ç©ºé—´ä¼šå°å¾ˆå¤šã€‚ç„¶è€Œæˆ‘è®¤ä¸ºè¿™ä¸¤ç§éƒ½ä¸æ˜¯å¾ˆå¥½çš„åšGPU skinningçš„æ–¹æ³•ï¼Œå°†åŠ¨ç”»ä¿¡æ¯ä¿å­˜åˆ°è´´å›¾æˆ–è€…æ•°æ®ç»“æ„ä¸­ï¼Œä¼šå¾ˆå¤§ç¨‹åº¦ä¸Šå¤±å»Animator Controllerçš„åŠŸèƒ½ï¼Œå¦‚ä¸¤ä¸ªåŠ¨ä½œä¹‹é—´çš„æ’å€¼ã€è§¦å‘äº‹ä»¶ç­‰ï¼Œå¯¹äºåŠ¨ç”»æ¥è¯´ç”šè‡³æ˜¯å¾—ä¸å¿å¤±çš„ä¸€ç§æ•ˆæœã€‚å› æ­¤ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿä¿ç•™Animator Controllerçš„ç‰¹æ€§ï¼Œå®æ—¶çš„æŠŠéª¨éª¼æ•°æ®ä¼ é€ç»™GPUï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®æ“ä½œã€‚\nGPUè’™çš®çš„æ“ä½œ æˆ‘çš„æƒ³æ³•æ˜¯ï¼Œå…ˆç¦»çº¿ä»SkinnedMeshRendererä¸­è·å¾—éª¨éª¼çš„IDå’Œæƒé‡ï¼Œç„¶åå®æ—¶çš„ä»Animator Controllerå¯¹åº”çš„éª¨éª¼ä¸­è·å–æ¯æ ¹éª¨éª¼çš„éª¨éª¼çŸ©é˜µï¼Œå†ç»Ÿä¸€ä¼ ç»™ä¸€ä¸ªæ™®é€šçš„MeshRendererï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®çš„æ“ä½œã€‚è¿™ä¸­é—´æœ‰ä¸€ä¸ªå°å‘ï¼ŒUnityåŒä¸€ä¸ªæ¨¡å‹çš„SkinnedMeshRendererå’ŒMeshRendererï¼Œä»–ä»¬è™½ç„¶éƒ½èƒ½è·å–åˆ°boneweightå’Œbindposeï¼Œä½†æ˜¯SkinnedMeshRendererå’ŒMeshRnedererçš„éª¨éª¼çš„é¡ºåºæœ‰æ—¶å€™ä¼šæœ‰ä¸€äº›å·®å¼‚ï¼Œå› æ­¤æœ€å¥½çš„åŠæ³•æ˜¯ï¼ŒæŠ›å¼ƒè¿™ä¸¤è€…çš„éª¨éª¼é¡ºåºï¼Œç”¨Hierarchyä¸­çš„éª¨éª¼é¡ºåºæ¥ç¡®å®šæˆ‘ä»¬ä¼ ç»™GPUçš„boneindexï¼Œboneweightå’Œbonematrixæ˜¯ä¸€è‡´çš„ã€‚\nè¿™é‡Œä½¿ç”¨çš„æ¨¡å‹åŠåŠ¨ä½œæ˜¯mixamoçš„hip hop dancingèµ„æºã€‚\nBoneMatchInfo.cs è¿™ä¸ªè„šæœ¬çš„ä½œç”¨æ˜¯ï¼Œåœ¨ç¦»çº¿æ—¶æŠŠä¸€ä¸ªGameObjectRootä¸‹çš„æ‰€æœ‰SkinnedMeshRendererå’ŒHierarchyä¸­çš„éª¨éª¼çš„ä¿¡æ¯ç»“åˆèµ·æ¥ï¼Œä¿å­˜æˆä¸€ä¸ªAssetï¼Œç”¨äºå®æ—¶çš„GPU Skinningã€‚è¿™ä¸ªAssetåŒ…å«ä¸¤éƒ¨åˆ†çš„ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯BoneMatchNodeç”¨äºè®°å½•Hierarchyéª¨éª¼åˆ—è¡¨ä¸­éª¨éª¼çš„åç§°å’Œå…¶bindposeï¼Œå¦ä¸€ä¸ªæ˜¯BindIndexç”¨äºè®°å½•æ‰€æœ‰SkinnedMeshRendererçš„éª¨éª¼åœ¨Hierarchyéª¨éª¼åˆ—è¡¨ä¸­çš„é¡ºåºã€‚\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System; using System.IO; namespace GPUSkinning { [System.Serializable] public class BoneMatchNode { //[HideInInspector] public string boneName; //åœ¨æŸ¥æ‰¾ä½äºæ‰€æœ‰Transfomçš„ä½ç½®æ—¶ï¼Œè®¾ç½®å¹¶ä½¿ç”¨boneIndex public int boneIndex = 0; public Matrix4x4 bindPose; public BoneMatchNode(string _boneName) { boneName = _boneName; bindPose = Matrix4x4.identity; } } [System.Serializable] public class BindList { //[HideInInspector] public string skinnedMeshName; public int[] bindIndexs; public BindList(string _skinnedMeshName) { skinnedMeshName = _skinnedMeshName; } } public class BoneMatchInfo : ScriptableObject { public BoneMatchNode[] boneMatchNodes; public BindList[] bindLists; } public class GenerateBoneMatchInfo : EditorWindow { public Transform rootBone; public Transform skinnedParent; public int skinnedMeshCount = 0; public SkinnedMeshRenderer[] smrArray; public BoneMatchInfo boneMatchInfo; private Rect topToolBarRect { get { return new Rect(20, 10, position.width - 40, position.height - 20); } } [MenuItem(\"zznewclear13/Generate Bone Match Info\")] public static GenerateBoneMatchInfo GetWindow() { GenerateBoneMatchInfo window = GetWindow(); window.titleContent = new GUIContent(\"Generate Bone Match Info\"); window.Focus(); window.Repaint(); return window; } void OnGUI() { TopToolBar(topToolBarRect); } private void TopToolBar(Rect rect) { GUILayout.BeginArea(rect); rootBone = (Transform)EditorGUILayout.ObjectField(\"Root Bone Transform\", rootBone, typeof(Transform), true); skinnedParent = (Transform)EditorGUILayout.ObjectField(\"Skinned Parent Transform\", skinnedParent, typeof(Transform), true); if(skinnedParent!=null) { smrArray = skinnedParent.GetComponentsInChildren(); if(smrArray != null) { using (new EditorGUI.DisabledGroupScope(true)) { EditorGUILayout.ObjectField(\"Skinned Mesh Renderers\", smrArray[0], typeof(SkinnedMeshRenderer), false); for (int i = 1; i \u003c smrArray.Length; i++) { EditorGUILayout.ObjectField(\" \", smrArray[i], typeof(SkinnedMeshRenderer), false); } } using (new EditorGUI.DisabledGroupScope(smrArray.Length \u003c= 0)) { if (GUILayout.Button(\"Generate Animator Map\", new GUILayoutOption[] { GUILayout.Height(30f) })) { boneMatchInfo = CompareBones(); //LogBindPoses(); Save(); } } } } GUILayout.EndArea(); } private BoneMatchInfo CompareBones() { BoneMatchInfo tempInfo = new BoneMatchInfo(); Transform[] boneTrans = rootBone.GetComponentsInChildren(); List boneMatchNodeList = new List(); List bindLists = new List(); List\u003cint[]\u003e tempIntLists = new List\u003cint[]\u003e(); List smrBoneTransList = new List(); List smrBindPoseList = new List(); foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; smrBoneTransList.Add(smrBoneTrans); smrBindPoseList.Add(smrBindPos); tempIntLists.Add(new int[smr.bones.Length]); } int boneTranIndex = 0; foreach (Transform boneTran in boneTrans) { BoneMatchNode bmn = new BoneMatchNode(boneTran.name); bool isInSMRBones = false; for (int i = 0; i \u003c smrBoneTransList.Count; i++) { int index = Array.IndexOf(smrBoneTransList[i], boneTran); if (index \u003e= 0) { isInSMRBones = true; bmn.bindPose = smrBindPoseList[i][index]; tempIntLists[i][index] = boneTranIndex; } } if (isInSMRBones) { bmn.boneIndex = boneTranIndex; boneMatchNodeList.Add(bmn); boneTranIndex++; } } for (int i = 0; i \u003c smrArray.Length; i++) { bindLists.Add(new BindList(smrArray[i].name)); bindLists[i].bindIndexs = tempIntLists[i]; } tempInfo.boneMatchNodes = boneMatchNodeList.ToArray(); tempInfo.bindLists = bindLists.ToArray(); return tempInfo; } private void LogBindPoses() { using(StreamWriter sw = new StreamWriter(\"Assets/GPUSkinning/BindPoses.txt\")) { foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; for (int j = 0; j \u003c smrBoneTrans.Length; j++) { sw.WriteLine(smr.name + \"\\t\" + smrBoneTrans[j].name + \"\\r\\n\" + smrBindPos[j].ToString()); } } } } private void Save() { AssetDatabase.CreateAsset(boneMatchInfo, \"Assets/GPUSkinning/BoneMatchInfo.asset\"); AssetDatabase.Refresh(); Debug.Log(\"","wordCount":"1728","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg","datePublished":"2021-07-11T19:00:00+08:00","dateModified":"2021-07-11T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®</h1><div class=post-description>è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ….</div><div class=post-meta><span title='2021-07-11 19:00:00 +0800 CST'>July 11, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-gpu-skinning-with-animator-controller.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GPUSkinning.jpg alt="GPU Skinning Cover"><p>GPU Skinning example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8gpu%e6%9d%a5%e8%bf%9b%e8%a1%8c%e8%92%99%e7%9a%ae aria-label=ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš®>ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš®</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e4%b8%80%e4%ba%9b%e6%83%b3%e6%b3%95 aria-label=GPUè’™çš®çš„ä¸€äº›æƒ³æ³•>GPUè’™çš®çš„ä¸€äº›æƒ³æ³•</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=GPUè’™çš®çš„æ“ä½œ>GPUè’™çš®çš„æ“ä½œ</a><ul><li><a href=#bonematchinfocs aria-label=BoneMatchInfo.cs>BoneMatchInfo.cs</a></li><li><a href=#bonegpuskinningcs aria-label=BoneGPUSkinning.cs>BoneGPUSkinning.cs</a></li><li><a href=#bonecomputeshadercompute aria-label=BoneComputeShader.compute>BoneComputeShader.compute</a></li><li><a href=#bonegpuskinninghlsl aria-label=BoneGPUSkinning.hlsl>BoneGPUSkinning.hlsl</a></li><li><a href=#bonegpuskinningshadershader aria-label=BoneGPUSkinningShader.shader>BoneGPUSkinningShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=ä¸ºä»€ä¹ˆè¦ç”¨gpuæ¥è¿›è¡Œè’™çš®>ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš®<a hidden class=anchor aria-hidden=true href=#ä¸ºä»€ä¹ˆè¦ç”¨gpuæ¥è¿›è¡Œè’™çš®>#</a></h2><p>å¯¹äºä¸€ä¸ªSkinnedMeshRendererï¼Œåœ¨åšè’™çš®çš„æ—¶å€™ï¼Œå¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ï¼Œä¼šå…ˆè®¡ç®—å‡ºè¿™ä¸ªé¡¶ç‚¹å¯¹åº”çš„å››æ ¹éª¨éª¼çš„ä»éª¨éª¼ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„çŸ©é˜µ\(M_{bone\<em>localtoobject}\)ï¼Œç„¶åä½¿ç”¨\(M</em>{bone\<em>localtoobject} * M</em>{bone\<em>bindpose} * Vertex</em>{objectspace}\)å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å››ä¸ªå¸¦æƒé‡çš„é¡¶ç‚¹æ•°æ®ä½ç½®å’Œåˆ‡çº¿ï¼Œå¯¹äºæ³•çº¿åˆ™æ˜¯ä½¿ç”¨ä¸Šé¢çŸ©é˜µçš„é€†çŸ©é˜µçš„è½¬ç½®ã€‚ç„¶åå¯¹è·å¾—çš„ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œç”¨æƒé‡è®¡ç®—å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å®é™…çš„é¡¶ç‚¹ä¿¡æ¯ã€‚åœ¨é€šå¸¸çš„æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œä¸Šè¿°æ“ä½œæ˜¯åœ¨CPUä¸­è¿›è¡Œçš„ï¼Œæœ€åæŠŠé¡¶ç‚¹æ•°æ®ä¼ é€’ç»™GPUä¸­è¿›è¡Œæ¸²æŸ“ã€‚åœ¨é¡¶ç‚¹æ•°è¾ƒå¤šä¸”ä¸»è¦æ˜¯çŸ©é˜µè¿ç®—çš„æƒ…å†µä¸‹ï¼ŒCPUè¿›è¡Œè’™çš®çš„æ•ˆç‡å°±ä¸å¦‚é«˜å¹¶è¡Œçš„GPUäº†ï¼Œå› æ­¤ä¼šè€ƒè™‘åˆ°åœ¨GPUä¸­è¿›è¡Œè’™çš®å¤„ç†ã€‚</p><h2 id=gpuè’™çš®çš„ä¸€äº›æƒ³æ³•>GPUè’™çš®çš„ä¸€äº›æƒ³æ³•<a hidden class=anchor aria-hidden=true href=#gpuè’™çš®çš„ä¸€äº›æƒ³æ³•>#</a></h2><p>ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œè¦ä»CPUä¸­ä¼ ç»™GPUçš„æ•°æ®æœ‰ä»¥ä¸‹å‡ ç§ï¼šä¸€æ˜¯\(M_{bone\<em>localtoobject} * M</em>{bone\_bindpose}\)è¿™æ ·éª¨éª¼æ•°ä¸ªfloat4x4çš„çŸ©é˜µï¼Œä½†æ˜¯ç”±äºå…¶æœ€åä¸€è¡Œæ˜¯(0, 0, 0, 1)ï¼Œåœ¨ä¼ é€’æ—¶å¯ä»¥ç®€åŒ–æˆéª¨éª¼æ•°ä¸ªfloat3x4çŸ©é˜µï¼Œè¿™äº›çŸ©é˜µæ¯ä¸€å¸§éƒ½è¦ä¼ é€’ä¸€æ¬¡ï¼›äºŒæ˜¯æ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„éª¨éª¼ç¼–å·å’Œéª¨éª¼çš„æƒé‡ï¼Œéª¨éª¼ç¼–å·ç”¨æ¥æŸ¥è¯¢éª¨éª¼çŸ©é˜µä¸­å¯¹åº”çš„çŸ©é˜µï¼Œæ˜¯ä¸€ä¸ªæ•´å‹çš„æ•°æ®ï¼Œéª¨éª¼æƒé‡æ˜¯ä¸€ä¸ª[0, 1]çš„å°æ•°ï¼Œå¯ä»¥ç”¨\(BoneIndex + BoneWeight * 0.5\)çš„æ–¹å¼ï¼ŒæŠŠç¼–å·å’Œæƒé‡ç»“åˆæˆä¸€ä¸ªfloatçš„æ•°æ®ï¼Œè¿™æ ·æ¯ä¸ªé¡¶ç‚¹çš„éª¨éª¼ç¼–å·å’Œæƒé‡æ•°æ®æ˜¯ä¸€ä¸ªfloat4çš„æ•°æ®ï¼Œå¯ä»¥ä¿å­˜åœ¨UVä¸­ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°ç»„çš„æ–¹å¼ä¼ é€’ç»™GPUï¼Œè¿™äº›é¡¶ç‚¹æ•°ä¸ªfloat4çš„æ•°æ®ï¼Œåªéœ€è¦ä¼ é€’ä¸€æ¬¡å°±å¯ä»¥äº†ï¼›å†æœ‰å°±æ˜¯æ¨¡å‹æœ¬èº«çš„é¡¶ç‚¹ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œè¿™äº›å¼•æ“ä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬ä¼ é€’ç»™GPUã€‚</p><p>åœ¨å®é™…æ“ä½œä¸­ï¼Œç½‘ä¸Šé€šå¸¸æ‰¾åˆ°çš„æ–¹æ¡ˆæ˜¯æŠŠåŠ¨ç”»ä¿å­˜åœ¨ä¸€å¼ è´´å›¾æˆ–è€…æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„æ•°æ®ç»“æ„ä¸­ï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥ä¿å­˜é¡¶ç‚¹æ•°æ®ï¼Œç”šè‡³ä¸éœ€è¦åœ¨GPUä¸­åšè’™çš®çš„æ“ä½œï¼Œä½†æ˜¯éšç€é¡¶ç‚¹æ•°å¢åŠ ä¼šå ç”¨å¤§é‡çš„ç©ºé—´ï¼›æˆ–è€…æ˜¯ä¿å­˜éª¨éª¼çš„å˜æ¢çŸ©é˜µï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®ï¼Œç›¸å¯¹æ¥è¯´å‚¨å­˜ç©ºé—´ä¼šå°å¾ˆå¤šã€‚ç„¶è€Œæˆ‘è®¤ä¸ºè¿™ä¸¤ç§éƒ½ä¸æ˜¯å¾ˆå¥½çš„åšGPU skinningçš„æ–¹æ³•ï¼Œå°†åŠ¨ç”»ä¿¡æ¯ä¿å­˜åˆ°è´´å›¾æˆ–è€…æ•°æ®ç»“æ„ä¸­ï¼Œä¼šå¾ˆå¤§ç¨‹åº¦ä¸Šå¤±å»Animator Controllerçš„åŠŸèƒ½ï¼Œå¦‚ä¸¤ä¸ªåŠ¨ä½œä¹‹é—´çš„æ’å€¼ã€è§¦å‘äº‹ä»¶ç­‰ï¼Œå¯¹äºåŠ¨ç”»æ¥è¯´ç”šè‡³æ˜¯å¾—ä¸å¿å¤±çš„ä¸€ç§æ•ˆæœã€‚å› æ­¤ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿä¿ç•™Animator Controllerçš„ç‰¹æ€§ï¼Œå®æ—¶çš„æŠŠéª¨éª¼æ•°æ®ä¼ é€ç»™GPUï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®æ“ä½œã€‚</p><h2 id=gpuè’™çš®çš„æ“ä½œ>GPUè’™çš®çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#gpuè’™çš®çš„æ“ä½œ>#</a></h2><p>æˆ‘çš„æƒ³æ³•æ˜¯ï¼Œå…ˆç¦»çº¿ä»SkinnedMeshRendererä¸­è·å¾—éª¨éª¼çš„IDå’Œæƒé‡ï¼Œç„¶åå®æ—¶çš„ä»Animator Controllerå¯¹åº”çš„éª¨éª¼ä¸­è·å–æ¯æ ¹éª¨éª¼çš„éª¨éª¼çŸ©é˜µï¼Œå†ç»Ÿä¸€ä¼ ç»™ä¸€ä¸ªæ™®é€šçš„MeshRendererï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®çš„æ“ä½œã€‚è¿™ä¸­é—´æœ‰ä¸€ä¸ªå°å‘ï¼ŒUnityåŒä¸€ä¸ªæ¨¡å‹çš„SkinnedMeshRendererå’ŒMeshRendererï¼Œä»–ä»¬è™½ç„¶éƒ½èƒ½è·å–åˆ°boneweightå’Œbindposeï¼Œä½†æ˜¯SkinnedMeshRendererå’ŒMeshRnedererçš„éª¨éª¼çš„é¡ºåºæœ‰æ—¶å€™ä¼šæœ‰ä¸€äº›å·®å¼‚ï¼Œå› æ­¤æœ€å¥½çš„åŠæ³•æ˜¯ï¼ŒæŠ›å¼ƒè¿™ä¸¤è€…çš„éª¨éª¼é¡ºåºï¼Œç”¨Hierarchyä¸­çš„éª¨éª¼é¡ºåºæ¥ç¡®å®šæˆ‘ä»¬ä¼ ç»™GPUçš„boneindexï¼Œboneweightå’Œbonematrixæ˜¯ä¸€è‡´çš„ã€‚</p><p>è¿™é‡Œä½¿ç”¨çš„æ¨¡å‹åŠåŠ¨ä½œæ˜¯<a href=https://www.mixamo.com/>mixamo</a>çš„hip hop dancingèµ„æºã€‚</p><h3 id=bonematchinfocs>BoneMatchInfo.cs<a hidden class=anchor aria-hidden=true href=#bonematchinfocs>#</a></h3><p>è¿™ä¸ªè„šæœ¬çš„ä½œç”¨æ˜¯ï¼Œåœ¨ç¦»çº¿æ—¶æŠŠä¸€ä¸ªGameObjectRootä¸‹çš„æ‰€æœ‰SkinnedMeshRendererå’ŒHierarchyä¸­çš„éª¨éª¼çš„ä¿¡æ¯ç»“åˆèµ·æ¥ï¼Œä¿å­˜æˆä¸€ä¸ªAssetï¼Œç”¨äºå®æ—¶çš„GPU Skinningã€‚è¿™ä¸ªAssetåŒ…å«ä¸¤éƒ¨åˆ†çš„ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯BoneMatchNodeç”¨äºè®°å½•Hierarchyéª¨éª¼åˆ—è¡¨ä¸­éª¨éª¼çš„åç§°å’Œå…¶bindposeï¼Œå¦ä¸€ä¸ªæ˜¯BindIndexç”¨äºè®°å½•æ‰€æœ‰SkinnedMeshRendererçš„éª¨éª¼åœ¨Hierarchyéª¨éª¼åˆ—è¡¨ä¸­çš„é¡ºåºã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> GPUSkinning
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [System.Serializable]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchNode</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//[HideInInspector]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> boneName;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//åœ¨æŸ¥æ‰¾ä½äºæ‰€æœ‰Transfomçš„ä½ç½®æ—¶ï¼Œè®¾ç½®å¹¶ä½¿ç”¨boneIndex</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> boneIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Matrix4x4 bindPose;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchNode(<span style=color:#66d9ef>string</span> _boneName)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            boneName = _boneName;
</span></span><span style=display:flex><span>            bindPose = Matrix4x4.identity;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [System.Serializable]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BindList</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//[HideInInspector]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> skinnedMeshName;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span>[] bindIndexs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BindList(<span style=color:#66d9ef>string</span> _skinnedMeshName)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            skinnedMeshName = _skinnedMeshName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchInfo</span> : ScriptableObject
</span></span><span style=display:flex><span>    {   
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchNode[] boneMatchNodes;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BindList[] bindLists;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GenerateBoneMatchInfo</span> : EditorWindow
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Transform rootBone;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Transform skinnedParent;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> skinnedMeshCount = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> SkinnedMeshRenderer[] smrArray;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Rect topToolBarRect
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>, position.width - <span style=color:#ae81ff>40</span>, position.height - <span style=color:#ae81ff>20</span>); }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [MenuItem(&#34;zznewclear13/Generate Bone Match Info&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GenerateBoneMatchInfo GetWindow()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GenerateBoneMatchInfo window = GetWindow&lt;GenerateBoneMatchInfo&gt;();
</span></span><span style=display:flex><span>            window.titleContent = <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;Generate Bone Match Info&#34;</span>);
</span></span><span style=display:flex><span>            window.Focus();
</span></span><span style=display:flex><span>            window.Repaint();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            TopToolBar(topToolBarRect);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TopToolBar(Rect rect)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GUILayout.BeginArea(rect);
</span></span><span style=display:flex><span>            rootBone = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Root Bone Transform&#34;</span>, rootBone, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            skinnedParent = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Parent Transform&#34;</span>, skinnedParent, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(skinnedParent!=<span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                smrArray = skinnedParent.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(smrArray != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(<span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Mesh Renderers&#34;</span>, smrArray[<span style=color:#ae81ff>0</span>], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; smrArray.Length; i++)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34; &#34;</span>, smrArray[i], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(smrArray.Length &lt;= <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Generate Animator Map&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30f</span>) }))
</span></span><span style=display:flex><span>                        {                           
</span></span><span style=display:flex><span>                            boneMatchInfo = CompareBones();
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//LogBindPoses();</span>
</span></span><span style=display:flex><span>                            Save();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            GUILayout.EndArea();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> BoneMatchInfo CompareBones()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            BoneMatchInfo tempInfo = <span style=color:#66d9ef>new</span> BoneMatchInfo();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Transform[] boneTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
</span></span><span style=display:flex><span>            List&lt;BoneMatchNode&gt; boneMatchNodeList = <span style=color:#66d9ef>new</span> List&lt;BoneMatchNode&gt;();
</span></span><span style=display:flex><span>            List&lt;BindList&gt; bindLists = <span style=color:#66d9ef>new</span> List&lt;BindList&gt;();
</span></span><span style=display:flex><span>            List&lt;<span style=color:#66d9ef>int</span>[]&gt; tempIntLists = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>[]&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            List&lt;Transform[]&gt; smrBoneTransList = <span style=color:#66d9ef>new</span> List&lt;Transform[]&gt;();
</span></span><span style=display:flex><span>            List&lt;Matrix4x4[]&gt; smrBindPoseList = <span style=color:#66d9ef>new</span> List&lt;Matrix4x4[]&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Transform[] smrBoneTrans = smr.bones;
</span></span><span style=display:flex><span>                Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
</span></span><span style=display:flex><span>                smrBoneTransList.Add(smrBoneTrans);
</span></span><span style=display:flex><span>                smrBindPoseList.Add(smrBindPos);
</span></span><span style=display:flex><span>                tempIntLists.Add(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[smr.bones.Length]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> boneTranIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (Transform boneTran <span style=color:#66d9ef>in</span> boneTrans)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                BoneMatchNode bmn = <span style=color:#66d9ef>new</span> BoneMatchNode(boneTran.name);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bool</span> isInSMRBones = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrBoneTransList.Count; i++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> index = Array.IndexOf(smrBoneTransList[i], boneTran);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (index &gt;= <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        isInSMRBones = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        bmn.bindPose = smrBindPoseList[i][index];
</span></span><span style=display:flex><span>                        tempIntLists[i][index] = boneTranIndex;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (isInSMRBones)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    bmn.boneIndex = boneTranIndex;
</span></span><span style=display:flex><span>                    boneMatchNodeList.Add(bmn);
</span></span><span style=display:flex><span>                    boneTranIndex++;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrArray.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                bindLists.Add(<span style=color:#66d9ef>new</span> BindList(smrArray[i].name));
</span></span><span style=display:flex><span>                bindLists[i].bindIndexs = tempIntLists[i];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            tempInfo.boneMatchNodes = boneMatchNodeList.ToArray();
</span></span><span style=display:flex><span>            tempInfo.bindLists = bindLists.ToArray();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> tempInfo;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> LogBindPoses()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            using(StreamWriter sw = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;Assets/GPUSkinning/BindPoses.txt&#34;</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Transform[] smrBoneTrans = smr.bones;
</span></span><span style=display:flex><span>                    Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; smrBoneTrans.Length; j++)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        sw.WriteLine(smr.name + <span style=color:#e6db74>&#34;\t&#34;</span> + smrBoneTrans[j].name + <span style=color:#e6db74>&#34;\r\n&#34;</span> + smrBindPos[j].ToString());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Save()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            AssetDatabase.CreateAsset(boneMatchInfo, <span style=color:#e6db74>&#34;Assets/GPUSkinning/BoneMatchInfo.asset&#34;</span>);
</span></span><span style=display:flex><span>            AssetDatabase.Refresh();
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;&lt;color=blue&gt;Bone Match Info has been saved to Assets/GPUSkinning/BoneMatchInfo.asset.&lt;/color&gt;&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>æœ€åå¾—åˆ°çš„<code>BoneMatchInfo.asset</code>å’ŒHierarchyçš„å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼Œéƒ¨åˆ†ä¸å‚ä¸å®é™…è’™çš®çš„éª¨éª¼ï¼Œå°±ä¸éœ€è¦è®°å½•åˆ°<code>BoneMatchInfo.asset</code>ä¸­äº†ï¼š</p><p><img loading=lazy src=../images/BoneMatchInfo.jpg#center alt=BoneMatchInfo></p><h3 id=bonegpuskinningcs>BoneGPUSkinning.cs<a hidden class=anchor aria-hidden=true href=#bonegpuskinningcs>#</a></h3><p>åœ¨<code>BoneGPUSkinning.cs</code>è¿™ä¸ªè„šæœ¬ä¸­ï¼Œè¦åšçš„äº‹æƒ…æ˜¯ï¼šæŠŠéª¨éª¼çš„ç¼–å·å’Œæƒé‡å†™åˆ°UVä¸­ï¼Œåªç”¨æ‰§è¡Œä¸€æ¬¡ï¼›æŠŠéª¨éª¼çŸ©é˜µå’Œbindposeçš„ä¹˜ç§¯ä¼ åˆ°GPUä¸­ï¼Œæ¯å¸§æ‰§è¡Œä¸€æ¬¡ï¼Œæˆ‘æŠŠè¿™ä¸ªæ“ä½œæ”¾åœ¨äº†compute shaderä¸­è¿›è¡Œè®¡ç®—ã€‚æ ¹æ®å‰é¢çš„æè¿°ï¼Œæˆ‘ä»¬éœ€è¦è·å–\(M_{bone\<em>localtoobject}\)ï¼Œè¿™ä¸ªå€¼ç­‰ä»·äº\(M</em>{object\<em>worldtolocal} * M</em>{bone\<em>localtoworld}\)ã€‚ä½†æ˜¯åœ¨å®é™…çš„æ“ä½œä¸­ï¼Œè·å–ä¸€æ ¹éª¨éª¼çš„\(M</em>{bone\_localtoworld}\)çŸ©é˜µä¼šå¯¼è‡´é¢å¤–çš„è¿ç®—ï¼Œä½¿å¾—GPU Skinningçš„æ•ˆç‡å—åˆ°äº†å¾ˆå¤§çš„é™åˆ¶ã€‚è¿™é‡Œæœ‰å¯èƒ½æ˜¯æˆ‘ä¸å¤Ÿç†Ÿæ‚‰Unityçš„APIçš„åŸå› ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯Unityæœ¬èº«å°±æ²¡å¼€æ”¾ç›¸å…³çš„APIçš„åŸå› ã€‚ç…§ç†æ¥è¯´ï¼ŒUnityè¦æŠŠAnimatorçš„å¹³ç§»æ—‹è½¬ç¼©æ”¾åŠ¨ç”»åº”ç”¨åˆ°æ¯ä¸€ä¸ªéª¨éª¼ä¸Šæ—¶ï¼Œå·²ç»è®¡ç®—è¿‡äº†æ¯æ ¹éª¨éª¼çš„localToWorldMatrixï¼Œè·å–è¿™ä¸ªçŸ©é˜µåº”è¯¥èƒ½åšåˆ°æ²¡æœ‰ä»»ä½•æ¶ˆè€—çš„ã€‚ä½†æ˜¯æ²¡æœ‰åŠæ³•ï¼Œæˆ‘åªèƒ½è¯•å›¾ä½¿ç”¨<code>Unity Jobs</code>å’Œ<code>Unity Burst</code>æ¥åŠ é€Ÿè·å–localToWorldMatrixçš„è¿‡ç¨‹ï¼Œåœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œç›¸æ¯”äºç›´æ¥ç”¨forå¾ªç¯è·å–å¤§æ¦‚èƒ½æœ‰è‡³å°‘50%çš„é€Ÿåº¦æå‡ï¼ˆè®°ä¸å¤ªæ¸…äº†ï¼‰ï¼Œç„¶è€Œå¯¹äºæ•´ä¸ªGPU Skinningçš„è¿‡ç¨‹æ¥è¯´ï¼Œæ¶ˆè€—è¿˜æ˜¯å¤ªé«˜äº†ã€‚</p><p>å› ä¸ºæ˜¯æ¯”è¾ƒä¹…ä¹‹å‰å†™çš„ä»£ç äº†ï¼Œä¹Ÿæ‡’å¾—å»å†ä»”ç»†åœ°ä¿®æ­£ï¼Œ<code>[ExecuteInEditMode]</code>åœ¨è®¾ç½®å¥½å„ä¸ªå¼•ç”¨ä¹‹å‰ä¼šç–¯ç‹‚çš„æŠ¥é”™ï¼Œä¸è¿‡åœ¨è®¾ç½®å¥½æ­£ç¡®çš„å¼•ç”¨ä¹‹åé‡æ–°å¯ç”¨è„šæœ¬å°±ä¸ä¼šæœ‰ä»»ä½•çš„é—®é¢˜äº†ã€‚ä¼¼ä¹æ“ä½œä¸å½“ä¹Ÿä¼šå‡ºç°å†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œä¸è¿‡æ— ä¼¤å¤§é›…ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Jobs;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.Jobs;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Burst;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> GPUSkinning
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [ExecuteInEditMode]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneGPUSkinning</span> : MonoBehaviour
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> BONE_WEIGHT_DECODE_VALUE = <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> BONE_WEIGHT_INVERSE_DECODE_VALUE = <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Transform rootBone;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> List&lt;MeshRenderer&gt; meshRenderers;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [SerializeField]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> boneSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Transform[] minBoneTrans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TransformAccessArray transformAccessArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#region</span> ComputeShader
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4[] bindPosesArray;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4[] LTWMatrixArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> bindPoseID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneBindPoseBuffer&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> LTWMatrixID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneLTWMatrixBuffer&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> outputBufferID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneOutputBuffer&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer outputBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer bindPoseBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer ltwMatrixBuffer;
</span></span><span style=display:flex><span>        <span style=color:#75715e>#endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#region</span> InitializeFunction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Initialize();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// å…¨éƒ¨çš„åˆå§‹åŒ–</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            InitializeBoneTrans();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            InitializeBoneUV(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            InitializeComputeShader();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// æ•´åˆæ‰€æœ‰meshç»‘å®šçš„éª¨éª¼ï¼Œä»rootBoneçš„å­ç‰©ä»¶ä¸­æ‰¾å‡ºminBoneTrans</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeBoneTrans()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//æ ‡è®°æ¯ä¸ªmeshå¯¹åº”çš„éª¨éª¼</span>
</span></span><span style=display:flex><span>            Transform[] allTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
</span></span><span style=display:flex><span>            Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt; allTransDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (Transform tran <span style=color:#66d9ef>in</span> allTrans)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                allTransDict.Add(tran.name, tran);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            boneSize = boneMatchInfo.boneMatchNodes.Length;
</span></span><span style=display:flex><span>            minBoneTrans = <span style=color:#66d9ef>new</span> Transform[boneSize];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Transform tempTran = allTransDict[boneMatchInfo.boneMatchNodes[i].boneName];
</span></span><span style=display:flex><span>                boneMatchInfo.boneMatchNodes[i].boneIndex = i;
</span></span><span style=display:flex><span>                minBoneTrans[i] = tempTran;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            transformAccessArray = <span style=color:#66d9ef>new</span> TransformAccessArray(minBoneTrans);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// æŠŠéª¨éª¼çš„ç¼–å·å’Œæƒé‡å†™å…¥åˆ°targetUVIndexå¯¹åº”çš„UVä¸­</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;param name=&#34;targetUVIndex&#34;&gt;&lt;/param&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> InitializeBoneUV(<span style=color:#66d9ef>int</span> targetUVIndex)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt; bindListDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneMatchInfo.bindLists.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                bindListDict.Add(boneMatchInfo.bindLists[i].skinnedMeshName, boneMatchInfo.bindLists[i]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                BindList tempBindList;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bool</span> hasBindList = bindListDict.TryGetValue(meshRenderers[i].name, <span style=color:#66d9ef>out</span> tempBindList);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(!hasBindList)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentException(String.Format(<span style=color:#e6db74>&#34;SkinnedMeshName:{0}åœ¨BoneMatchInfoä¸­æ‰¾ä¸åˆ°ï¼&#34;</span>,
</span></span><span style=display:flex><span>                                                boneMatchInfo.bindLists[i].skinnedMeshName));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Mesh mesh = meshRenderers[i].GetComponent&lt;MeshFilter&gt;().sharedMesh;
</span></span><span style=display:flex><span>                BoneWeight[] boneWeights = mesh.boneWeights;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                List&lt;Vector4&gt; boneAndWeights = <span style=color:#66d9ef>new</span> List&lt;Vector4&gt;();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span>[] bindIndexes = tempBindList.bindIndexs;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (BoneWeight weight <span style=color:#66d9ef>in</span> boneWeights)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Vector4 boneAndWeight = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Shaderä¸­ä¸ªBoneUVéƒ½ä¼šæŸ¥æ‰¾å…¨å±€çš„éª¨éª¼ç¼–å·</span>
</span></span><span style=display:flex><span>                    boneAndWeight.x = bindIndexes[weight.boneIndex0] + weight.weight0 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeight.y = bindIndexes[weight.boneIndex1] + weight.weight1 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeight.z = bindIndexes[weight.boneIndex2] + weight.weight2 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeight.w = bindIndexes[weight.boneIndex3] + weight.weight3 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeights.Add(boneAndWeight);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                mesh.SetUVs(targetUVIndex, boneAndWeights.ToArray());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (buffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                buffer.Release();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// åˆå§‹åŒ–ComputeShaderï¼Œç”¨äºè®¡ç®—æ¯æ ¹éª¨éª¼çš„çŸ©é˜µå’Œbindposçš„ä¹˜ç§¯</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeComputeShader()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            bindPosesArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
</span></span><span style=display:flex><span>            LTWMatrixArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
</span></span><span style=display:flex><span>            Debug.Log(LTWMatrixArray.Length);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                bindPosesArray[i] = boneMatchInfo.boneMatchNodes[i].bindPose;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;MatCompute&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> outputBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> bindPoseBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ltwMatrixBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            bindPoseBuffer.SetData(bindPosesArray);
</span></span><span style=display:flex><span>            computeShader.SetBuffer(kernel, bindPoseID, bindPoseBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            computeShader.SetBuffer(kernel, outputBufferID, outputBuffer);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#region</span> Update Function
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            InvokeComputeShader();
</span></span><span style=display:flex><span>            PassMeshRendererMatrix();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [BurstCompile(CompileSynchronously = true)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GetLocalToWorldMatrixStructJob</span> : IJobParallelForTransform
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> NativeArray&lt;Matrix4x4&gt; matArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i, TransformAccess transform)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                matArray[i] = transform.localToWorldMatrix;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InvokeComputeShader()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(computeShader)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//NativeList&lt;JobHandle&gt; jobHandleList = new NativeList&lt;JobHandle&gt;(Allocator.Temp);</span>
</span></span><span style=display:flex><span>                NativeArray&lt;Matrix4x4&gt; matArray = <span style=color:#66d9ef>new</span> NativeArray&lt;Matrix4x4&gt;(boneSize, Allocator.Persistent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                GetLocalToWorldMatrixStructJob job = <span style=color:#66d9ef>new</span> GetLocalToWorldMatrixStructJob
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    matArray = matArray
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                JobHandle jobHandle = IJobParallelForTransformExtensions.Schedule(job, transformAccessArray);<span style=color:#75715e>// job.Schedule(transformAccessArray);</span>
</span></span><span style=display:flex><span>                jobHandle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                ltwMatrixBuffer.SetData(matArray);
</span></span><span style=display:flex><span>                matArray.Dispose();
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    LTWMatrixArray[i] = minBoneTrans[i].localToWorldMatrix;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ltwMatrixBuffer.SetData(LTWMatrixArray);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                computeShader.SetBuffer(kernel, LTWMatrixID, ltwMatrixBuffer);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> dispatchCount = Mathf.CeilToInt(boneSize / <span style=color:#ae81ff>64f</span>);
</span></span><span style=display:flex><span>                computeShader.Dispatch(kernel, dispatchCount, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                Shader.SetGlobalBuffer(<span style=color:#e6db74>&#34;_BoneMatArray&#34;</span>, outputBuffer);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PassMeshRendererMatrix()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (Material mat <span style=color:#66d9ef>in</span> meshRenderers[i].sharedMaterials)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    mat.SetMatrix(<span style=color:#e6db74>&#34;_BoneTransformMatrix&#34;</span>, meshRenderers[i].transform.worldToLocalMatrix);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            outputBuffer.Release();
</span></span><span style=display:flex><span>            outputBuffer = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            transformAccessArray.Dispose();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bonecomputeshadercompute>BoneComputeShader.compute<a hidden class=anchor aria-hidden=true href=#bonecomputeshadercompute>#</a></h3><p>è¿™ä¸ªcompute shaderä»…ä»…åšäº†çŸ©é˜µçš„è¿ç®—ï¼Œç”šè‡³éƒ½ä¸è§å¾—æ¯”åœ¨CPUä¸­è¿ç®—è¦å¿«ï¼Œä¸è¿‡è¿™è¾¹è¿˜æ˜¯ä½¿ç”¨äº†compute shaderæ¥åšè¿™ä¸ªè¿ç®—ï¼Œç¨å¾®è¿˜èƒ½ä¼˜åŒ–çš„æ˜¯float4x4å¯ä»¥æ”¹æˆfloat3x4ï¼Œä¸è¿‡è¿™æ ·CPUçš„ä»£ç å†™èµ·æ¥ç¨ä¹±ä¸€äº›ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel MatCompute</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneBindPoseBuffer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneLTWMatrixBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWStructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneOutputBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>64</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> MatCompute(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _BoneOutputBuffer[id.x] <span style=color:#f92672>=</span> mul(_BoneLTWMatrixBuffer[id.x], _BoneBindPoseBuffer[id.x]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bonegpuskinninghlsl>BoneGPUSkinning.hlsl<a hidden class=anchor aria-hidden=true href=#bonegpuskinninghlsl>#</a></h3><p>æ“ä½œæµç¨‹æ˜¯è¿™æ ·çš„ï¼Œå¯¹æ¯ä¸€ä¸ªé¡¶ç‚¹å®šä¹‰ä¸€ä¸ªç»“æ„ä½“<code>VertexInputStructure</code>ï¼Œè¯»å–MeshRendererçš„åŸå§‹æ•°æ®ä¸­çš„ä½ç½®ã€æ³•çº¿ã€åˆ‡çº¿å’Œæˆ‘ä»¬ä¼ å…¥çš„éª¨éª¼ç¼–å·å’Œæƒé‡ã€‚ä½¿ç”¨ç¼–å·å»å¯»æ‰¾<code>_BoneMatArray</code>ä¸­å¯¹åº”çš„\(M_{bone\<em>localtoworld}\)ï¼Œå†å·¦ä¹˜<code>_BoneTransformMatrix</code>ä¹Ÿå°±æ˜¯ä¹‹å‰è¯´è¿‡\(M</em>{object\_worldtolocal}\)ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªçŸ©é˜µçš„ä¹˜ç§¯å°±èƒ½åˆ†åˆ«è®¡ç®—è’™çš®åçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿äº†ï¼Œè¦æ³¨æ„çš„æ˜¯æ³•çº¿éœ€è¦åšä¸€æ¬¡é€†çŸ©é˜µçš„è½¬ç½®ã€‚æœ€åå¯¹å››å¯¹é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿è¿›è¡ŒåŠ æƒè®¡ç®—ï¼Œè·å¾—æœ€ç»ˆçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#ifndef BONE_GPU_SKINNING</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BONE_GPU_SKINNING</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BONE_WEIGHT_DECODE_VALUE 2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneMatArray;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4x4</span> _BoneTransformMatrix;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> VertexInputStructure
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> tangentOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> boneUV;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> VertexOutputStructure
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> tangentOS;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float3x3</span> InverseTranspose(<span style=color:#66d9ef>float3x3</span> mat)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> determinant <span style=color:#f92672>=</span> mat._m00 <span style=color:#f92672>*</span> (mat._m11 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m12 <span style=color:#f92672>*</span> mat._m21)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>-</span> mat._m01 <span style=color:#f92672>*</span> (mat._m10 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m12 <span style=color:#f92672>*</span> mat._m20)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> mat._m02 <span style=color:#f92672>*</span> (mat._m10 <span style=color:#f92672>*</span> mat._m21 <span style=color:#f92672>-</span> mat._m11 <span style=color:#f92672>*</span> mat._m20);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vec0 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(mat._m11 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m12 <span style=color:#f92672>*</span> mat._m21,
</span></span><span style=display:flex><span>                        mat._m12 <span style=color:#f92672>*</span> mat._m20 <span style=color:#f92672>-</span> mat._m10 <span style=color:#f92672>*</span> mat._m22,
</span></span><span style=display:flex><span>                        mat._m10 <span style=color:#f92672>*</span> mat._m21 <span style=color:#f92672>-</span> mat._m11 <span style=color:#f92672>*</span> mat._m20);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vec1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(mat._m02 <span style=color:#f92672>*</span> mat._m21 <span style=color:#f92672>-</span> mat._m01 <span style=color:#f92672>*</span> mat._m22,
</span></span><span style=display:flex><span>                        mat._m00 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m02 <span style=color:#f92672>*</span> mat._m20,
</span></span><span style=display:flex><span>                        mat._m01 <span style=color:#f92672>*</span> mat._m20 <span style=color:#f92672>-</span> mat._m00 <span style=color:#f92672>*</span> mat._m21);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vec2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(mat._m01 <span style=color:#f92672>*</span> mat._m12 <span style=color:#f92672>-</span> mat._m02 <span style=color:#f92672>*</span> mat._m11,
</span></span><span style=display:flex><span>                        mat._m02 <span style=color:#f92672>*</span> mat._m10 <span style=color:#f92672>-</span> mat._m00 <span style=color:#f92672>*</span> mat._m12,
</span></span><span style=display:flex><span>                        mat._m00 <span style=color:#f92672>*</span> mat._m11 <span style=color:#f92672>-</span> mat._m01 <span style=color:#f92672>*</span> mat._m10);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> returnMat;
</span></span><span style=display:flex><span>    returnMat._m00_m01_m02 <span style=color:#f92672>=</span> vec0;
</span></span><span style=display:flex><span>    returnMat._m10_m11_m12 <span style=color:#f92672>=</span> vec1;
</span></span><span style=display:flex><span>    returnMat._m20_m21_m22 <span style=color:#f92672>=</span> vec2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> returnMat <span style=color:#f92672>/</span> determinant;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float3x3</span> InverseTransposeVec(<span style=color:#66d9ef>float3</span> vec0, <span style=color:#66d9ef>float3</span> vec1, <span style=color:#66d9ef>float3</span> vec2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> mat;
</span></span><span style=display:flex><span>    mat._m00_m01_m02 <span style=color:#f92672>=</span> vec0;
</span></span><span style=display:flex><span>    mat._m10_m11_m12 <span style=color:#f92672>=</span> vec1;
</span></span><span style=display:flex><span>    mat._m20_m21_m22 <span style=color:#f92672>=</span> vec2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> InverseTranspose(mat);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float4x4</span> ReadBoneInfos(<span style=color:#66d9ef>uint</span> boneIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mul(_BoneTransformMatrix, _BoneMatArray[boneIndex]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> VertexOutputStructure BlendBonesPosNormalTangent(VertexInputStructure input)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionOS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.positionOS, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOS <span style=color:#f92672>=</span> input.normalOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> tangentOS <span style=color:#f92672>=</span> input.tangentOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> boneUV <span style=color:#f92672>=</span> input.boneUV;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexOne <span style=color:#f92672>=</span> floor(boneUV.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightOne <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexTwo <span style=color:#f92672>=</span> floor(boneUV.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightTwo <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexThree <span style=color:#f92672>=</span> floor(boneUV.z);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightThree <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexFour <span style=color:#f92672>=</span> floor(boneUV.w);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightFour <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matOne <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexOne);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matTwo <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexTwo);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matThree <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexThree);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matFour <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexFour);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//blend position</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posOne <span style=color:#f92672>=</span> mul(matOne, positionOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posTwo <span style=color:#f92672>=</span> mul(matTwo, positionOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posThree <span style=color:#f92672>=</span> mul(matThree, positionOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posFour <span style=color:#f92672>=</span> mul(matFour, positionOS).xyz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> returnPos <span style=color:#f92672>=</span> posOne <span style=color:#f92672>*</span> boneWeightOne
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> posTwo <span style=color:#f92672>*</span> boneWeightTwo
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> posThree <span style=color:#f92672>*</span> boneWeightThree
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> posFour <span style=color:#f92672>*</span> boneWeightFour;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//blend normal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatOne <span style=color:#f92672>=</span> InverseTransposeVec(matOne._m00_m01_m02, matOne._m10_m11_m12, matOne._m20_m21_m22);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatTwo <span style=color:#f92672>=</span> InverseTransposeVec(matTwo._m00_m01_m02, matTwo._m10_m11_m12, matTwo._m20_m21_m22);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatThree <span style=color:#f92672>=</span> InverseTransposeVec(matThree._m00_m01_m02, matThree._m10_m11_m12, matThree._m20_m21_m22);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatFour <span style=color:#f92672>=</span> InverseTransposeVec(matFour._m00_m01_m02, matFour._m10_m11_m12, matFour._m20_m21_m22);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOne <span style=color:#f92672>=</span> mul(newMatOne, normalOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalTwo <span style=color:#f92672>=</span> mul(newMatTwo, normalOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalThree <span style=color:#f92672>=</span> mul(newMatThree, normalOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalFour <span style=color:#f92672>=</span> mul(newMatFour, normalOS).xyz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> returnNormal <span style=color:#f92672>=</span> normalOne <span style=color:#f92672>*</span> boneWeightOne
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> normalTwo <span style=color:#f92672>*</span> boneWeightTwo
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> normalThree <span style=color:#f92672>*</span> boneWeightThree
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> normalFour <span style=color:#f92672>*</span> boneWeightFour;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    returnNormal <span style=color:#f92672>=</span> normalize(returnNormal);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//blend tangent</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentOne <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matOne, tangentOS.xyz);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentTwo <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matTwo, tangentOS.xyz);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentThree <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matThree, tangentOS.xyz);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentFour <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matFour, tangentOS.xyz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tempTangent <span style=color:#f92672>=</span> tangentOne <span style=color:#f92672>*</span> boneWeightOne
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> tangentTwo <span style=color:#f92672>*</span> boneWeightTwo
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> tangentThree <span style=color:#f92672>*</span> boneWeightThree
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> tangentFour <span style=color:#f92672>*</span> boneWeightFour;
</span></span><span style=display:flex><span>    tempTangent <span style=color:#f92672>=</span> normalize(tempTangent);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> returnTangent <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(tempTangent, tangentOS.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    VertexOutputStructure output;
</span></span><span style=display:flex><span>    output.positionOS <span style=color:#f92672>=</span> returnPos;
</span></span><span style=display:flex><span>    output.normalOS <span style=color:#f92672>=</span> returnNormal;
</span></span><span style=display:flex><span>    output.tangentOS <span style=color:#f92672>=</span> returnTangent;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><h3 id=bonegpuskinningshadershader>BoneGPUSkinningShader.shader<a hidden class=anchor aria-hidden=true href=#bonegpuskinningshadershader>#</a></h3><p>ç”¨äºæ¸²æŸ“çš„shaderä¸­ï¼Œè¦åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­è°ƒç”¨<code>BoneGPUSkinning.hlsl</code>ä¸­çš„æ–¹æ³•è·å–è’™çš®åçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿ã€‚æˆ‘è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„æ¸²æŸ“ï¼Œç»™æ¨¡å‹ä¸€ç‚¹åŸºç¡€çš„å…‰å½±ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœéœ€è¦æ­£ç¡®çš„é˜´å½±çš„è¯ï¼Œåœ¨<code>ShadowCaster</code>è¿™ä¸ªpassä¸­è¿˜éœ€è¦è®¡ç®—ä¸€éé¡¶ç‚¹ä½ç½®ï¼Œè¿™é‡Œå°±æš‚ä¸”å¿½ç•¥äº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/BoneGPUSkinningShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _Color (<span style=color:#e6db74>&#34;Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Albedo (RGB)&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;RenderPipeline&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UniversalPipeline&#34;</span> <span style=color:#e6db74>&#34;IgnoreProjector&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;True&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HLSLINCLUDE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Assets/GPUSkinning/BoneGPUSkinning.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sampler2D _MainTex;
</span></span><span style=display:flex><span>        CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> _Color;
</span></span><span style=display:flex><span>        CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> a2v
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> vertex   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uv       <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> boneUV   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> normal   <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> tangent  <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> v2f
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> pos          <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> tempColor    <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> normalWS     <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> tangentWS    <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> eyeVec       <span style=color:#f92672>:</span> TEXCOORD4;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        v2f animVert(a2v v)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            v2f o;
</span></span><span style=display:flex><span>            VertexInputStructure inputStructure;
</span></span><span style=display:flex><span>            inputStructure.positionOS <span style=color:#f92672>=</span> v.vertex;
</span></span><span style=display:flex><span>            inputStructure.normalOS <span style=color:#f92672>=</span> v.normal;
</span></span><span style=display:flex><span>            inputStructure.tangentOS <span style=color:#f92672>=</span> v.tangent;
</span></span><span style=display:flex><span>            inputStructure.boneUV <span style=color:#f92672>=</span> v.boneUV;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            VertexOutputStructure outputStructure <span style=color:#f92672>=</span> BlendBonesPosNormalTangent(inputStructure);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> vertexPos <span style=color:#f92672>=</span> outputStructure.positionOS;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> vertexNormal <span style=color:#f92672>=</span> outputStructure.normalOS;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> vertexTangent <span style=color:#f92672>=</span> outputStructure.tangentOS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            o.pos <span style=color:#f92672>=</span> TransformObjectToHClip(vertexPos);
</span></span><span style=display:flex><span>            o.normalWS <span style=color:#f92672>=</span> TransformObjectToWorldNormal(vertexNormal);
</span></span><span style=display:flex><span>            o.tangentWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(TransformObjectToWorldDir(vertexTangent), v.tangent.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            o.uv <span style=color:#f92672>=</span> v.uv;
</span></span><span style=display:flex><span>            o.tempColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> worldPos <span style=color:#f92672>=</span> TransformObjectToWorld(<span style=color:#66d9ef>float4</span>(vertexPos, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            o.eyeVec <span style=color:#f92672>=</span> GetCameraPositionWS() <span style=color:#f92672>-</span> worldPos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> o;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> animFrag(v2f i) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> viewDir <span style=color:#f92672>=</span> normalize(i.eyeVec);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> lightDir <span style=color:#f92672>=</span> normalize(<span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> halfVec <span style=color:#f92672>=</span> normalize(lightDir <span style=color:#f92672>+</span> viewDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> normalWS <span style=color:#f92672>=</span> normalize(i.normalWS);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> NdotL <span style=color:#f92672>=</span> dot(normalWS, lightDir) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.6</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.4</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> NdotH <span style=color:#f92672>=</span> saturate(dot(normalWS, halfVec));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> diffuseColor <span style=color:#f92672>=</span> _Color.xyz <span style=color:#f92672>*</span> NdotL;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> specularColor <span style=color:#f92672>=</span> pow(NdotH, <span style=color:#ae81ff>30</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(diffuseColor <span style=color:#f92672>+</span> specularColor, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ENDHLSL
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Tags{ <span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UniversalForward&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex animVert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment animFrag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#æœ€åçš„æ€è€ƒ>#</a></h2><p>æ€»çš„æ¥è¯´ï¼Œä¸Šé¢çš„æ“ä½œå·²ç»åŸºæœ¬å®Œæˆäº†GPU Skinningçš„éœ€æ±‚ï¼Œè€Œä¸”èƒ½å¤Ÿæ­£ç¡®çš„ä¸Animatorç»„ä»¶ç›¸ç»“åˆã€‚å½“ç„¶ä»æœ‰ä¼˜åŒ–çš„ç©ºé—´ï¼Œæ¯”å¦‚è¯´æŠŠæ‰€æœ‰è¦åšGPU Skinningçš„meshä½¿ç”¨åŒä¸€ä¸ªUpdateçš„æ–¹æ³•æ¥æ›´æ–°ï¼Œç­‰ç­‰ã€‚ä½†æ˜¯ç¾ä¸­ä¸è¶³çš„æ˜¯ä¹‹å‰æåˆ°çš„è·å–localToWorldMatrixçš„é—®é¢˜ï¼Œç›´æ¥å¯¼è‡´äº†ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ä¸å¦‚Unityè‡ªå¸¦çš„GPU Skinningæ•ˆç‡é«˜ï¼Œè‡ªå¸¦çš„GPUè’™çš®åº”è¯¥æ˜¯ç”¨åˆ°äº†Unityåº•å±‚çš„ä¸€äº›ä¼˜åŒ–å§ï¼Œä½†æ˜¯æ ¸å¿ƒçš„æ“ä½œåº”è¯¥å’Œæˆ‘è¿™é‡Œåšçš„å·®ä¸å¤šã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/gpu-skinning/>GPU Skinning</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><span class=title>Â« Prev</span><br><span>åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ</span>
</a><a class=next href=https://zznewclear13.github.io/posts/get-world-space-position-from-depth-texture/><span class=title>Next Â»</span><br><span>ä»æ·±åº¦å›¾ä¸­è·å–ä¸–ç•Œç©ºé—´çš„åæ ‡</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>