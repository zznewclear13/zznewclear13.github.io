<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš® | ZZNEWCLEAR13</title><meta name=keywords content="GPU Skinning"><meta name=description content="è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ…."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®"><meta property="og:description" content="è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ…."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-11T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-11T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta name=twitter:title content="æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®"><meta name=twitter:description content="è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ…."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®","item":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®","name":"æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®","description":"è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ….","keywords":["GPU Skinning"],"articleBody":"ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš® å¯¹äºä¸€ä¸ªSkinnedMeshRendererï¼Œåœ¨åšè’™çš®çš„æ—¶å€™ï¼Œå¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ï¼Œä¼šå…ˆè®¡ç®—å‡ºè¿™ä¸ªé¡¶ç‚¹å¯¹åº”çš„å››æ ¹éª¨éª¼çš„ä»éª¨éª¼ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„çŸ©é˜µ\\(M_{bone\\_localtoobject}\\)ï¼Œç„¶åä½¿ç”¨\\(M_{bone\\_localtoobject} * M_{bone\\_bindpose} * Vertex_{objectspace}\\)å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å››ä¸ªå¸¦æƒé‡çš„é¡¶ç‚¹æ•°æ®ä½ç½®å’Œåˆ‡çº¿ï¼Œå¯¹äºæ³•çº¿åˆ™æ˜¯ä½¿ç”¨ä¸Šé¢çŸ©é˜µçš„é€†çŸ©é˜µçš„è½¬ç½®ã€‚ç„¶åå¯¹è·å¾—çš„ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œç”¨æƒé‡è®¡ç®—å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å®é™…çš„é¡¶ç‚¹ä¿¡æ¯ã€‚åœ¨é€šå¸¸çš„æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œä¸Šè¿°æ“ä½œæ˜¯åœ¨CPUä¸­è¿›è¡Œçš„ï¼Œæœ€åæŠŠé¡¶ç‚¹æ•°æ®ä¼ é€’ç»™GPUä¸­è¿›è¡Œæ¸²æŸ“ã€‚åœ¨é¡¶ç‚¹æ•°è¾ƒå¤šä¸”ä¸»è¦æ˜¯çŸ©é˜µè¿ç®—çš„æƒ…å†µä¸‹ï¼ŒCPUè¿›è¡Œè’™çš®çš„æ•ˆç‡å°±ä¸å¦‚é«˜å¹¶è¡Œçš„GPUäº†ï¼Œå› æ­¤ä¼šè€ƒè™‘åˆ°åœ¨GPUä¸­è¿›è¡Œè’™çš®å¤„ç†ã€‚\nGPUè’™çš®çš„ä¸€äº›æƒ³æ³• ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œè¦ä»CPUä¸­ä¼ ç»™GPUçš„æ•°æ®æœ‰ä»¥ä¸‹å‡ ç§ï¼šä¸€æ˜¯\\(M_{bone\\_localtoobject} * M_{bone\\_bindpose}\\)è¿™æ ·éª¨éª¼æ•°ä¸ªfloat4x4çš„çŸ©é˜µï¼Œä½†æ˜¯ç”±äºå…¶æœ€åä¸€è¡Œæ˜¯(0, 0, 0, 1)ï¼Œåœ¨ä¼ é€’æ—¶å¯ä»¥ç®€åŒ–æˆéª¨éª¼æ•°ä¸ªfloat3x4çŸ©é˜µï¼Œè¿™äº›çŸ©é˜µæ¯ä¸€å¸§éƒ½è¦ä¼ é€’ä¸€æ¬¡ï¼›äºŒæ˜¯æ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„éª¨éª¼ç¼–å·å’Œéª¨éª¼çš„æƒé‡ï¼Œéª¨éª¼ç¼–å·ç”¨æ¥æŸ¥è¯¢éª¨éª¼çŸ©é˜µä¸­å¯¹åº”çš„çŸ©é˜µï¼Œæ˜¯ä¸€ä¸ªæ•´å‹çš„æ•°æ®ï¼Œéª¨éª¼æƒé‡æ˜¯ä¸€ä¸ª[0, 1]çš„å°æ•°ï¼Œå¯ä»¥ç”¨\\(BoneIndex + BoneWeight * 0.5\\)çš„æ–¹å¼ï¼ŒæŠŠç¼–å·å’Œæƒé‡ç»“åˆæˆä¸€ä¸ªfloatçš„æ•°æ®ï¼Œè¿™æ ·æ¯ä¸ªé¡¶ç‚¹çš„éª¨éª¼ç¼–å·å’Œæƒé‡æ•°æ®æ˜¯ä¸€ä¸ªfloat4çš„æ•°æ®ï¼Œå¯ä»¥ä¿å­˜åœ¨UVä¸­ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°ç»„çš„æ–¹å¼ä¼ é€’ç»™GPUï¼Œè¿™äº›é¡¶ç‚¹æ•°ä¸ªfloat4çš„æ•°æ®ï¼Œåªéœ€è¦ä¼ é€’ä¸€æ¬¡å°±å¯ä»¥äº†ï¼›å†æœ‰å°±æ˜¯æ¨¡å‹æœ¬èº«çš„é¡¶ç‚¹ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œè¿™äº›å¼•æ“ä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬ä¼ é€’ç»™GPUã€‚\nåœ¨å®é™…æ“ä½œä¸­ï¼Œç½‘ä¸Šé€šå¸¸æ‰¾åˆ°çš„æ–¹æ¡ˆæ˜¯æŠŠåŠ¨ç”»ä¿å­˜åœ¨ä¸€å¼ è´´å›¾æˆ–è€…æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„æ•°æ®ç»“æ„ä¸­ï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥ä¿å­˜é¡¶ç‚¹æ•°æ®ï¼Œç”šè‡³ä¸éœ€è¦åœ¨GPUä¸­åšè’™çš®çš„æ“ä½œï¼Œä½†æ˜¯éšç€é¡¶ç‚¹æ•°å¢åŠ ä¼šå ç”¨å¤§é‡çš„ç©ºé—´ï¼›æˆ–è€…æ˜¯ä¿å­˜éª¨éª¼çš„å˜æ¢çŸ©é˜µï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®ï¼Œç›¸å¯¹æ¥è¯´å‚¨å­˜ç©ºé—´ä¼šå°å¾ˆå¤šã€‚ç„¶è€Œæˆ‘è®¤ä¸ºè¿™ä¸¤ç§éƒ½ä¸æ˜¯å¾ˆå¥½çš„åšGPU skinningçš„æ–¹æ³•ï¼Œå°†åŠ¨ç”»ä¿¡æ¯ä¿å­˜åˆ°è´´å›¾æˆ–è€…æ•°æ®ç»“æ„ä¸­ï¼Œä¼šå¾ˆå¤§ç¨‹åº¦ä¸Šå¤±å»Animator Controllerçš„åŠŸèƒ½ï¼Œå¦‚ä¸¤ä¸ªåŠ¨ä½œä¹‹é—´çš„æ’å€¼ã€è§¦å‘äº‹ä»¶ç­‰ï¼Œå¯¹äºåŠ¨ç”»æ¥è¯´ç”šè‡³æ˜¯å¾—ä¸å¿å¤±çš„ä¸€ç§æ•ˆæœã€‚å› æ­¤ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿä¿ç•™Animator Controllerçš„ç‰¹æ€§ï¼Œå®æ—¶çš„æŠŠéª¨éª¼æ•°æ®ä¼ é€ç»™GPUï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®æ“ä½œã€‚\nGPUè’™çš®çš„æ“ä½œ æˆ‘çš„æƒ³æ³•æ˜¯ï¼Œå…ˆç¦»çº¿ä»SkinnedMeshRendererä¸­è·å¾—éª¨éª¼çš„IDå’Œæƒé‡ï¼Œç„¶åå®æ—¶çš„ä»Animator Controllerå¯¹åº”çš„éª¨éª¼ä¸­è·å–æ¯æ ¹éª¨éª¼çš„éª¨éª¼çŸ©é˜µï¼Œå†ç»Ÿä¸€ä¼ ç»™ä¸€ä¸ªæ™®é€šçš„MeshRendererï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®çš„æ“ä½œã€‚è¿™ä¸­é—´æœ‰ä¸€ä¸ªå°å‘ï¼ŒUnityåŒä¸€ä¸ªæ¨¡å‹çš„SkinnedMeshRendererå’ŒMeshRendererï¼Œä»–ä»¬è™½ç„¶éƒ½èƒ½è·å–åˆ°boneweightå’Œbindposeï¼Œä½†æ˜¯SkinnedMeshRendererå’ŒMeshRnedererçš„éª¨éª¼çš„é¡ºåºæœ‰æ—¶å€™ä¼šæœ‰ä¸€äº›å·®å¼‚ï¼Œå› æ­¤æœ€å¥½çš„åŠæ³•æ˜¯ï¼ŒæŠ›å¼ƒè¿™ä¸¤è€…çš„éª¨éª¼é¡ºåºï¼Œç”¨Hierarchyä¸­çš„éª¨éª¼é¡ºåºæ¥ç¡®å®šæˆ‘ä»¬ä¼ ç»™GPUçš„boneindexï¼Œboneweightå’Œbonematrixæ˜¯ä¸€è‡´çš„ã€‚\nè¿™é‡Œä½¿ç”¨çš„æ¨¡å‹åŠåŠ¨ä½œæ˜¯mixamoçš„hip hop dancingèµ„æºã€‚\nBoneMatchInfo.cs è¿™ä¸ªè„šæœ¬çš„ä½œç”¨æ˜¯ï¼Œåœ¨ç¦»çº¿æ—¶æŠŠä¸€ä¸ªGameObjectRootä¸‹çš„æ‰€æœ‰SkinnedMeshRendererå’ŒHierarchyä¸­çš„éª¨éª¼çš„ä¿¡æ¯ç»“åˆèµ·æ¥ï¼Œä¿å­˜æˆä¸€ä¸ªAssetï¼Œç”¨äºå®æ—¶çš„GPU Skinningã€‚è¿™ä¸ªAssetåŒ…å«ä¸¤éƒ¨åˆ†çš„ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯BoneMatchNodeç”¨äºè®°å½•Hierarchyéª¨éª¼åˆ—è¡¨ä¸­éª¨éª¼çš„åç§°å’Œå…¶bindposeï¼Œå¦ä¸€ä¸ªæ˜¯BindIndexç”¨äºè®°å½•æ‰€æœ‰SkinnedMeshRendererçš„éª¨éª¼åœ¨Hierarchyéª¨éª¼åˆ—è¡¨ä¸­çš„é¡ºåºã€‚\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System; using System.IO; namespace GPUSkinning { [System.Serializable] public class BoneMatchNode { //[HideInInspector]  public string boneName; //åœ¨æŸ¥æ‰¾ä½äºæ‰€æœ‰Transfomçš„ä½ç½®æ—¶ï¼Œè®¾ç½®å¹¶ä½¿ç”¨boneIndex  public int boneIndex = 0; public Matrix4x4 bindPose; public BoneMatchNode(string _boneName) { boneName = _boneName; bindPose = Matrix4x4.identity; } } [System.Serializable] public class BindList { //[HideInInspector]  public string skinnedMeshName; public int[] bindIndexs; public BindList(string _skinnedMeshName) { skinnedMeshName = _skinnedMeshName; } } public class BoneMatchInfo : ScriptableObject { public BoneMatchNode[] boneMatchNodes; public BindList[] bindLists; } public class GenerateBoneMatchInfo : EditorWindow { public Transform rootBone; public Transform skinnedParent; public int skinnedMeshCount = 0; public SkinnedMeshRenderer[] smrArray; public BoneMatchInfo boneMatchInfo; private Rect topToolBarRect { get { return new Rect(20, 10, position.width - 40, position.height - 20); } } [MenuItem(\"zznewclear13/Generate Bone Match Info\")] public static GenerateBoneMatchInfo GetWindow() { GenerateBoneMatchInfo window = GetWindow(); window.titleContent = new GUIContent(\"Generate Bone Match Info\"); window.Focus(); window.Repaint(); return window; } void OnGUI() { TopToolBar(topToolBarRect); } private void TopToolBar(Rect rect) { GUILayout.BeginArea(rect); rootBone = (Transform)EditorGUILayout.ObjectField(\"Root Bone Transform\", rootBone, typeof(Transform), true); skinnedParent = (Transform)EditorGUILayout.ObjectField(\"Skinned Parent Transform\", skinnedParent, typeof(Transform), true); if(skinnedParent!=null) { smrArray = skinnedParent.GetComponentsInChildren(); if(smrArray != null) { using (new EditorGUI.DisabledGroupScope(true)) { EditorGUILayout.ObjectField(\"Skinned Mesh Renderers\", smrArray[0], typeof(SkinnedMeshRenderer), false); for (int i = 1; i \" \", smrArray[i], typeof(SkinnedMeshRenderer), false); } } using (new EditorGUI.DisabledGroupScope(smrArray.Length 0)) { if (GUILayout.Button(\"Generate Animator Map\", new GUILayoutOption[] { GUILayout.Height(30f) })) { boneMatchInfo = CompareBones(); //LogBindPoses();  Save(); } } } } GUILayout.EndArea(); } private BoneMatchInfo CompareBones() { BoneMatchInfo tempInfo = new BoneMatchInfo(); Transform[] boneTrans = rootBone.GetComponentsInChildren(); List boneMatchNodeList = new List(); List bindLists = new List(); Listint[] tempIntLists = new Listint[](); List smrBoneTransList = new List(); List smrBindPoseList = new List(); foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; smrBoneTransList.Add(smrBoneTrans); smrBindPoseList.Add(smrBindPos); tempIntLists.Add(new int[smr.bones.Length]); } int boneTranIndex = 0; foreach (Transform boneTran in boneTrans) { BoneMatchNode bmn = new BoneMatchNode(boneTran.name); bool isInSMRBones = false; for (int i = 0; i int index = Array.IndexOf(smrBoneTransList[i], boneTran); if (index = 0) { isInSMRBones = true; bmn.bindPose = smrBindPoseList[i][index]; tempIntLists[i][index] = boneTranIndex; } } if (isInSMRBones) { bmn.boneIndex = boneTranIndex; boneMatchNodeList.Add(bmn); boneTranIndex++; } } for (int i = 0; i new BindList(smrArray[i].name)); bindLists[i].bindIndexs = tempIntLists[i]; } tempInfo.boneMatchNodes = boneMatchNodeList.ToArray(); tempInfo.bindLists = bindLists.ToArray(); return tempInfo; } private void LogBindPoses() { using(StreamWriter sw = new StreamWriter(\"Assets/GPUSkinning/BindPoses.txt\")) { foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; for (int j = 0; j \"\\t\" + smrBoneTrans[j].name + \"\\r\\n\" + smrBindPos[j].ToString()); } } } } private void Save() { AssetDatabase.CreateAsset(boneMatchInfo, \"Assets/GPUSkinning/BoneMatchInfo.asset\"); AssetDatabase.Refresh(); Debug.Log(\"Bone Match Info has been saved to Assets/GPUSkinning/BoneMatchInfo.asset.\"); } } } æœ€åå¾—åˆ°çš„BoneMatchInfo.assetå’ŒHierarchyçš„å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼Œéƒ¨åˆ†ä¸å‚ä¸å®é™…è’™çš®çš„éª¨éª¼ï¼Œå°±ä¸éœ€è¦è®°å½•åˆ°BoneMatchInfo.assetä¸­äº†ï¼š\nBoneGPUSkinning.cs åœ¨BoneGPUSkinning.csè¿™ä¸ªè„šæœ¬ä¸­ï¼Œè¦åšçš„äº‹æƒ…æ˜¯ï¼šæŠŠéª¨éª¼çš„ç¼–å·å’Œæƒé‡å†™åˆ°UVä¸­ï¼Œåªç”¨æ‰§è¡Œä¸€æ¬¡ï¼›æŠŠéª¨éª¼çŸ©é˜µå’Œbindposeçš„ä¹˜ç§¯ä¼ åˆ°GPUä¸­ï¼Œæ¯å¸§æ‰§è¡Œä¸€æ¬¡ï¼Œæˆ‘æŠŠè¿™ä¸ªæ“ä½œæ”¾åœ¨äº†compute shaderä¸­è¿›è¡Œè®¡ç®—ã€‚æ ¹æ®å‰é¢çš„æè¿°ï¼Œæˆ‘ä»¬éœ€è¦è·å–\\(M_{bone\\_localtoobject}\\)ï¼Œè¿™ä¸ªå€¼ç­‰ä»·äº\\(M_{object\\_worldtolocal} * M_{bone\\_localtoworld}\\)ã€‚ä½†æ˜¯åœ¨å®é™…çš„æ“ä½œä¸­ï¼Œè·å–ä¸€æ ¹éª¨éª¼çš„\\(M_{bone\\_localtoworld}\\)çŸ©é˜µä¼šå¯¼è‡´é¢å¤–çš„è¿ç®—ï¼Œä½¿å¾—GPU Skinningçš„æ•ˆç‡å—åˆ°äº†å¾ˆå¤§çš„é™åˆ¶ã€‚è¿™é‡Œæœ‰å¯èƒ½æ˜¯æˆ‘ä¸å¤Ÿç†Ÿæ‚‰Unityçš„APIçš„åŸå› ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯Unityæœ¬èº«å°±æ²¡å¼€æ”¾ç›¸å…³çš„APIçš„åŸå› ã€‚ç…§ç†æ¥è¯´ï¼ŒUnityè¦æŠŠAnimatorçš„å¹³ç§»æ—‹è½¬ç¼©æ”¾åŠ¨ç”»åº”ç”¨åˆ°æ¯ä¸€ä¸ªéª¨éª¼ä¸Šæ—¶ï¼Œå·²ç»è®¡ç®—è¿‡äº†æ¯æ ¹éª¨éª¼çš„localToWorldMatrixï¼Œè·å–è¿™ä¸ªçŸ©é˜µåº”è¯¥èƒ½åšåˆ°æ²¡æœ‰ä»»ä½•æ¶ˆè€—çš„ã€‚ä½†æ˜¯æ²¡æœ‰åŠæ³•ï¼Œæˆ‘åªèƒ½è¯•å›¾ä½¿ç”¨Unity Jobså’ŒUnity Burstæ¥åŠ é€Ÿè·å–localToWorldMatrixçš„è¿‡ç¨‹ï¼Œåœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œç›¸æ¯”äºç›´æ¥ç”¨forå¾ªç¯è·å–å¤§æ¦‚èƒ½æœ‰è‡³å°‘50%çš„é€Ÿåº¦æå‡ï¼ˆè®°ä¸å¤ªæ¸…äº†ï¼‰ï¼Œç„¶è€Œå¯¹äºæ•´ä¸ªGPU Skinningçš„è¿‡ç¨‹æ¥è¯´ï¼Œæ¶ˆè€—è¿˜æ˜¯å¤ªé«˜äº†ã€‚\nå› ä¸ºæ˜¯æ¯”è¾ƒä¹…ä¹‹å‰å†™çš„ä»£ç äº†ï¼Œä¹Ÿæ‡’å¾—å»å†ä»”ç»†åœ°ä¿®æ­£ï¼Œ[ExecuteInEditMode]åœ¨è®¾ç½®å¥½å„ä¸ªå¼•ç”¨ä¹‹å‰ä¼šç–¯ç‹‚çš„æŠ¥é”™ï¼Œä¸è¿‡åœ¨è®¾ç½®å¥½æ­£ç¡®çš„å¼•ç”¨ä¹‹åé‡æ–°å¯ç”¨è„šæœ¬å°±ä¸ä¼šæœ‰ä»»ä½•çš„é—®é¢˜äº†ã€‚ä¼¼ä¹æ“ä½œä¸å½“ä¹Ÿä¼šå‡ºç°å†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œä¸è¿‡æ— ä¼¤å¤§é›…ã€‚\nusing System.Collections.Generic; using UnityEngine; using System; using Unity.Collections; using Unity.Jobs; using UnityEngine.Jobs; using Unity.Burst; namespace GPUSkinning { [ExecuteInEditMode] public class BoneGPUSkinning : MonoBehaviour { public const int BONE_WEIGHT_DECODE_VALUE = 2; public const float BONE_WEIGHT_INVERSE_DECODE_VALUE = 0.5f; public ComputeShader computeShader; public Transform rootBone; public BoneMatchInfo boneMatchInfo; public List meshRenderers; [SerializeField] private int boneSize; private Transform[] minBoneTrans; private TransformAccessArray transformAccessArray; #region ComputeShader  int kernel; private Matrix4x4[] bindPosesArray; private Matrix4x4[] LTWMatrixArray; readonly int bindPoseID = Shader.PropertyToID(\"_BoneBindPoseBuffer\"); readonly int LTWMatrixID = Shader.PropertyToID(\"_BoneLTWMatrixBuffer\"); readonly int outputBufferID = Shader.PropertyToID(\"_BoneOutputBuffer\"); private ComputeBuffer outputBuffer; private ComputeBuffer bindPoseBuffer; private ComputeBuffer ltwMatrixBuffer; #endregion  #region InitializeFunction  void OnEnable() { Initialize(); } ///   /// å…¨éƒ¨çš„åˆå§‹åŒ–  ///   public void Initialize() { InitializeBoneTrans(); InitializeBoneUV(1); InitializeComputeShader(); } ///   /// æ•´åˆæ‰€æœ‰meshç»‘å®šçš„éª¨éª¼ï¼Œä»rootBoneçš„å­ç‰©ä»¶ä¸­æ‰¾å‡ºminBoneTrans  ///   private void InitializeBoneTrans() { //æ ‡è®°æ¯ä¸ªmeshå¯¹åº”çš„éª¨éª¼  Transform[] allTrans = rootBone.GetComponentsInChildren(); Dictionarystring, Transform allTransDict = new Dictionarystring, Transform(); foreach (Transform tran in allTrans) { allTransDict.Add(tran.name, tran); } boneSize = boneMatchInfo.boneMatchNodes.Length; minBoneTrans = new Transform[boneSize]; for (int i = 0; i new TransformAccessArray(minBoneTrans); } ///   /// æŠŠéª¨éª¼çš„ç¼–å·å’Œæƒé‡å†™å…¥åˆ°targetUVIndexå¯¹åº”çš„UVä¸­  ///   ///   public void InitializeBoneUV(int targetUVIndex) { Dictionarystring, BindList bindListDict = new Dictionarystring, BindList(); for (int i = 0; i for (int i = 0; i bool hasBindList = bindListDict.TryGetValue(meshRenderers[i].name, out tempBindList); if(!hasBindList) { throw new ArgumentException(String.Format(\"SkinnedMeshName:{0}åœ¨BoneMatchInfoä¸­æ‰¾ä¸åˆ°ï¼\", boneMatchInfo.bindLists[i].skinnedMeshName)); } Mesh mesh = meshRenderers[i].GetComponent().sharedMesh; BoneWeight[] boneWeights = mesh.boneWeights; List boneAndWeights = new List(); int[] bindIndexes = tempBindList.bindIndexs; foreach (BoneWeight weight in boneWeights) { Vector4 boneAndWeight = new Vector4(0, 0, 0, 0); //Shaderä¸­ä¸ªBoneUVéƒ½ä¼šæŸ¥æ‰¾å…¨å±€çš„éª¨éª¼ç¼–å·  boneAndWeight.x = bindIndexes[weight.boneIndex0] + weight.weight0 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeight.y = bindIndexes[weight.boneIndex1] + weight.weight1 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeight.z = bindIndexes[weight.boneIndex2] + weight.weight2 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeight.w = bindIndexes[weight.boneIndex3] + weight.weight3 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeights.Add(boneAndWeight); } mesh.SetUVs(targetUVIndex, boneAndWeights.ToArray()); } } private void EnsureComputeBuffer(ref ComputeBuffer buffer, int count, int stride) { if (buffer != null) { buffer.Release(); } buffer = new ComputeBuffer(count, stride); } ///   /// åˆå§‹åŒ–ComputeShaderï¼Œç”¨äºè®¡ç®—æ¯æ ¹éª¨éª¼çš„çŸ©é˜µå’Œbindposçš„ä¹˜ç§¯  ///   private void InitializeComputeShader() { bindPosesArray = new Matrix4x4[boneSize]; LTWMatrixArray = new Matrix4x4[boneSize]; Debug.Log(LTWMatrixArray.Length); for (int i = 0; i \"MatCompute\"); EnsureComputeBuffer(ref outputBuffer, boneSize, sizeof(float) * 16); EnsureComputeBuffer(ref bindPoseBuffer, boneSize, sizeof(float) * 16); EnsureComputeBuffer(ref ltwMatrixBuffer, boneSize, sizeof(float) * 16); bindPoseBuffer.SetData(bindPosesArray); computeShader.SetBuffer(kernel, bindPoseID, bindPoseBuffer); computeShader.SetBuffer(kernel, outputBufferID, outputBuffer); } #endregion  #region Update Function  void Update() { InvokeComputeShader(); PassMeshRendererMatrix(); } [BurstCompile(CompileSynchronously = true)] struct GetLocalToWorldMatrixStructJob : IJobParallelForTransform { public NativeArray matArray; public void Execute(int i, TransformAccess transform) { matArray[i] = transform.localToWorldMatrix; } } private void InvokeComputeShader() { if(computeShader) { #if true  //NativeList jobHandleList = new NativeList(Allocator.Temp);  NativeArray matArray = new NativeArray(boneSize, Allocator.Persistent); GetLocalToWorldMatrixStructJob job = new GetLocalToWorldMatrixStructJob { matArray = matArray }; JobHandle jobHandle = IJobParallelForTransformExtensions.Schedule(job, transformAccessArray);// job.Schedule(transformAccessArray);  jobHandle.Complete(); ltwMatrixBuffer.SetData(matArray); matArray.Dispose(); #else  for (int i = 0; i #endif  computeShader.SetBuffer(kernel, LTWMatrixID, ltwMatrixBuffer); int dispatchCount = Mathf.CeilToInt(boneSize / 64f); computeShader.Dispatch(kernel, dispatchCount, 1, 1); Shader.SetGlobalBuffer(\"_BoneMatArray\", outputBuffer); } } private void PassMeshRendererMatrix() { for (int i = 0; i foreach (Material mat in meshRenderers[i].sharedMaterials) { mat.SetMatrix(\"_BoneTransformMatrix\", meshRenderers[i].transform.worldToLocalMatrix); } } } #endregion  private void OnDisable() { outputBuffer.Release(); outputBuffer = null; transformAccessArray.Dispose(); } } } BoneComputeShader.compute è¿™ä¸ªcompute shaderä»…ä»…åšäº†çŸ©é˜µçš„è¿ç®—ï¼Œç”šè‡³éƒ½ä¸è§å¾—æ¯”åœ¨CPUä¸­è¿ç®—è¦å¿«ï¼Œä¸è¿‡è¿™è¾¹è¿˜æ˜¯ä½¿ç”¨äº†compute shaderæ¥åšè¿™ä¸ªè¿ç®—ï¼Œç¨å¾®è¿˜èƒ½ä¼˜åŒ–çš„æ˜¯float4x4å¯ä»¥æ”¹æˆfloat3x4ï¼Œä¸è¿‡è¿™æ ·CPUçš„ä»£ç å†™èµ·æ¥ç¨ä¹±ä¸€äº›ã€‚\n#pragma kernel MatCompute\rStructuredBuffer _BoneBindPoseBuffer;\rStructuredBuffer _BoneLTWMatrixBuffer;\rRWStructuredBuffer _BoneOutputBuffer;\r[numthreads(64, 1, 1)]\rvoid MatCompute(uint3 id : SV_DispatchThreadID)\r{\r_BoneOutputBuffer[id.x] = mul(_BoneLTWMatrixBuffer[id.x], _BoneBindPoseBuffer[id.x]);\r}\rBoneGPUSkinning.hlsl æ“ä½œæµç¨‹æ˜¯è¿™æ ·çš„ï¼Œå¯¹æ¯ä¸€ä¸ªé¡¶ç‚¹å®šä¹‰ä¸€ä¸ªç»“æ„ä½“VertexInputStructureï¼Œè¯»å–MeshRendererçš„åŸå§‹æ•°æ®ä¸­çš„ä½ç½®ã€æ³•çº¿ã€åˆ‡çº¿å’Œæˆ‘ä»¬ä¼ å…¥çš„éª¨éª¼ç¼–å·å’Œæƒé‡ã€‚ä½¿ç”¨ç¼–å·å»å¯»æ‰¾_BoneMatArrayä¸­å¯¹åº”çš„\\(M_{bone\\_localtoworld}\\)ï¼Œå†å·¦ä¹˜_BoneTransformMatrixä¹Ÿå°±æ˜¯ä¹‹å‰è¯´è¿‡\\(M_{object\\_worldtolocal}\\)ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªçŸ©é˜µçš„ä¹˜ç§¯å°±èƒ½åˆ†åˆ«è®¡ç®—è’™çš®åçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿äº†ï¼Œè¦æ³¨æ„çš„æ˜¯æ³•çº¿éœ€è¦åšä¸€æ¬¡é€†çŸ©é˜µçš„è½¬ç½®ã€‚æœ€åå¯¹å››å¯¹é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿è¿›è¡ŒåŠ æƒè®¡ç®—ï¼Œè·å¾—æœ€ç»ˆçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿ã€‚\n#ifndef BONE_GPU_SKINNING\r#define BONE_GPU_SKINNING\r#define BONE_WEIGHT_DECODE_VALUE 2\rStructuredBuffer _BoneMatArray;\rfloat4x4 _BoneTransformMatrix;\rstruct VertexInputStructure\r{\rfloat3 positionOS;\rfloat3 normalOS;\rfloat4 tangentOS;\rfloat4 boneUV;\r};\rstruct VertexOutputStructure\r{\rfloat3 positionOS;\rfloat3 normalOS;\rfloat4 tangentOS;\r};\rinline float3x3 InverseTranspose(float3x3 mat)\r{\rfloat determinant = mat._m00 * (mat._m11 * mat._m22 - mat._m12 * mat._m21)\r- mat._m01 * (mat._m10 * mat._m22 - mat._m12 * mat._m20)\r+ mat._m02 * (mat._m10 * mat._m21 - mat._m11 * mat._m20);\rfloat3 vec0 = float3(mat._m11 * mat._m22 - mat._m12 * mat._m21,\rmat._m12 * mat._m20 - mat._m10 * mat._m22,\rmat._m10 * mat._m21 - mat._m11 * mat._m20);\rfloat3 vec1 = float3(mat._m02 * mat._m21 - mat._m01 * mat._m22,\rmat._m00 * mat._m22 - mat._m02 * mat._m20,\rmat._m01 * mat._m20 - mat._m00 * mat._m21);\rfloat3 vec2 = float3(mat._m01 * mat._m12 - mat._m02 * mat._m11,\rmat._m02 * mat._m10 - mat._m00 * mat._m12,\rmat._m00 * mat._m11 - mat._m01 * mat._m10);\rfloat3x3 returnMat;\rreturnMat._m00_m01_m02 = vec0;\rreturnMat._m10_m11_m12 = vec1;\rreturnMat._m20_m21_m22 = vec2;\rreturn returnMat / determinant;\r}\rinline float3x3 InverseTransposeVec(float3 vec0, float3 vec1, float3 vec2)\r{\rfloat3x3 mat;\rmat._m00_m01_m02 = vec0;\rmat._m10_m11_m12 = vec1;\rmat._m20_m21_m22 = vec2;\rreturn InverseTranspose(mat);\r}\rinline float4x4 ReadBoneInfos(uint boneIndex)\r{\rreturn mul(_BoneTransformMatrix, _BoneMatArray[boneIndex]);\r}\rinline VertexOutputStructure BlendBonesPosNormalTangent(VertexInputStructure input)\r{\rfloat4 positionOS = float4(input.positionOS, 1);\rfloat3 normalOS = input.normalOS;\rfloat4 tangentOS = input.tangentOS;\rfloat4 boneUV = input.boneUV;\ruint boneIndexOne = floor(boneUV.x);\rfloat boneWeightOne = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.x);\ruint boneIndexTwo = floor(boneUV.y);\rfloat boneWeightTwo = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.y);\ruint boneIndexThree = floor(boneUV.z);\rfloat boneWeightThree = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.z);\ruint boneIndexFour = floor(boneUV.w);\rfloat boneWeightFour = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.w);\rfloat4x4 matOne = ReadBoneInfos(boneIndexOne);\rfloat4x4 matTwo = ReadBoneInfos(boneIndexTwo);\rfloat4x4 matThree = ReadBoneInfos(boneIndexThree);\rfloat4x4 matFour = ReadBoneInfos(boneIndexFour);\r//blend position\rfloat3 posOne = mul(matOne, positionOS).xyz;\rfloat3 posTwo = mul(matTwo, positionOS).xyz;\rfloat3 posThree = mul(matThree, positionOS).xyz;\rfloat3 posFour = mul(matFour, positionOS).xyz;\rfloat3 returnPos = posOne * boneWeightOne\r+ posTwo * boneWeightTwo\r+ posThree * boneWeightThree\r+ posFour * boneWeightFour;\r//blend normal\rfloat3x3 newMatOne = InverseTransposeVec(matOne._m00_m01_m02, matOne._m10_m11_m12, matOne._m20_m21_m22);\rfloat3x3 newMatTwo = InverseTransposeVec(matTwo._m00_m01_m02, matTwo._m10_m11_m12, matTwo._m20_m21_m22);\rfloat3x3 newMatThree = InverseTransposeVec(matThree._m00_m01_m02, matThree._m10_m11_m12, matThree._m20_m21_m22);\rfloat3x3 newMatFour = InverseTransposeVec(matFour._m00_m01_m02, matFour._m10_m11_m12, matFour._m20_m21_m22);\rfloat3 normalOne = mul(newMatOne, normalOS).xyz;\rfloat3 normalTwo = mul(newMatTwo, normalOS).xyz;\rfloat3 normalThree = mul(newMatThree, normalOS).xyz;\rfloat3 normalFour = mul(newMatFour, normalOS).xyz;\rfloat3 returnNormal = normalOne * boneWeightOne\r+ normalTwo * boneWeightTwo\r+ normalThree * boneWeightThree\r+ normalFour * boneWeightFour;\rreturnNormal = normalize(returnNormal);\r//blend tangent\rfloat3 tangentOne = mul((float3x3)matOne, tangentOS.xyz);\rfloat3 tangentTwo = mul((float3x3)matTwo, tangentOS.xyz);\rfloat3 tangentThree = mul((float3x3)matThree, tangentOS.xyz);\rfloat3 tangentFour = mul((float3x3)matFour, tangentOS.xyz);\rfloat3 tempTangent = tangentOne * boneWeightOne\r+ tangentTwo * boneWeightTwo\r+ tangentThree * boneWeightThree\r+ tangentFour * boneWeightFour;\rtempTangent = normalize(tempTangent);\rfloat4 returnTangent = float4(tempTangent, tangentOS.w);\rVertexOutputStructure output;\routput.positionOS = returnPos;\routput.normalOS = returnNormal;\routput.tangentOS = returnTangent;\rreturn output;\r}\r#endif\rBoneGPUSkinningShader.shader ç”¨äºæ¸²æŸ“çš„shaderä¸­ï¼Œè¦åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­è°ƒç”¨BoneGPUSkinning.hlslä¸­çš„æ–¹æ³•è·å–è’™çš®åçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿ã€‚æˆ‘è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„æ¸²æŸ“ï¼Œç»™æ¨¡å‹ä¸€ç‚¹åŸºç¡€çš„å…‰å½±ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœéœ€è¦æ­£ç¡®çš„é˜´å½±çš„è¯ï¼Œåœ¨ShadowCasterè¿™ä¸ªpassä¸­è¿˜éœ€è¦è®¡ç®—ä¸€éé¡¶ç‚¹ä½ç½®ï¼Œè¿™é‡Œå°±æš‚ä¸”å¿½ç•¥äº†ã€‚\nShader \"zznewclear13/BoneGPUSkinningShader\"\r{\rProperties\r{\r_Color (\"Color\", Color) = (1,1,1,1)\r_MainTex (\"Albedo (RGB)\", 2D) = \"white\" {}\r}\rSubShader\r{\rTags { \"RenderType\" = \"Opaque\" \"RenderPipeline\" = \"UniversalPipeline\" \"IgnoreProjector\" = \"True\" }\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Assets/GPUSkinning/BoneGPUSkinning.hlsl\"\rsampler2D _MainTex;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _Color;\rCBUFFER_END\rstruct a2v\r{\rfloat4 vertex : POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 boneUV : TEXCOORD1;\rfloat3 normal : NORMAL;\rfloat4 tangent : TANGENT;\r};\rstruct v2f\r{\rfloat4 pos : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 tempColor : TEXCOORD1;\rfloat3 normalWS : TEXCOORD2;\rfloat4 tangentWS : TEXCOORD3;\rfloat3 eyeVec : TEXCOORD4;\r};\rv2f animVert(a2v v)\r{\rv2f o;\rVertexInputStructure inputStructure;\rinputStructure.positionOS = v.vertex;\rinputStructure.normalOS = v.normal;\rinputStructure.tangentOS = v.tangent;\rinputStructure.boneUV = v.boneUV;\rVertexOutputStructure outputStructure = BlendBonesPosNormalTangent(inputStructure);\rfloat3 vertexPos = outputStructure.positionOS;\rfloat3 vertexNormal = outputStructure.normalOS;\rfloat3 vertexTangent = outputStructure.tangentOS;\ro.pos = TransformObjectToHClip(vertexPos);\ro.normalWS = TransformObjectToWorldNormal(vertexNormal);\ro.tangentWS = float4(TransformObjectToWorldDir(vertexTangent), v.tangent.w);\ro.uv = v.uv;\ro.tempColor = float4(1, 1, 1, 1);\rfloat3 worldPos = TransformObjectToWorld(float4(vertexPos, 1));\ro.eyeVec = GetCameraPositionWS() - worldPos;\rreturn o;\r}\rfloat4 animFrag(v2f i) : SV_TARGET\r{\rfloat3 viewDir = normalize(i.eyeVec);\rfloat3 lightDir = normalize(float3(1, 1, 1));\rfloat3 halfVec = normalize(lightDir + viewDir);\rfloat3 normalWS = normalize(i.normalWS);\rfloat NdotL = dot(normalWS, lightDir) * 0.6 + 0.4;\rfloat NdotH = saturate(dot(normalWS, halfVec));\rfloat3 diffuseColor = _Color.xyz * NdotL;\rfloat3 specularColor = pow(NdotH, 30);\rreturn float4(diffuseColor + specularColor, 1);\r}\rENDHLSL\rpass\r{\rTags{ \"LightMode\" = \"UniversalForward\" }\rHLSLPROGRAM\r#pragma vertex animVert\r#pragma fragment animFrag\rENDHLSL\r}\r}\r}\ræœ€åçš„æ€è€ƒ æ€»çš„æ¥è¯´ï¼Œä¸Šé¢çš„æ“ä½œå·²ç»åŸºæœ¬å®Œæˆäº†GPU Skinningçš„éœ€æ±‚ï¼Œè€Œä¸”èƒ½å¤Ÿæ­£ç¡®çš„ä¸Animatorç»„ä»¶ç›¸ç»“åˆã€‚å½“ç„¶ä»æœ‰ä¼˜åŒ–çš„ç©ºé—´ï¼Œæ¯”å¦‚è¯´æŠŠæ‰€æœ‰è¦åšGPU Skinningçš„meshä½¿ç”¨åŒä¸€ä¸ªUpdateçš„æ–¹æ³•æ¥æ›´æ–°ï¼Œç­‰ç­‰ã€‚ä½†æ˜¯ç¾ä¸­ä¸è¶³çš„æ˜¯ä¹‹å‰æåˆ°çš„è·å–localToWorldMatrixçš„é—®é¢˜ï¼Œç›´æ¥å¯¼è‡´äº†ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ä¸å¦‚Unityè‡ªå¸¦çš„GPU Skinningæ•ˆç‡é«˜ï¼Œè‡ªå¸¦çš„GPUè’™çš®åº”è¯¥æ˜¯ç”¨åˆ°äº†Unityåº•å±‚çš„ä¸€äº›ä¼˜åŒ–å§ï¼Œä½†æ˜¯æ ¸å¿ƒçš„æ“ä½œåº”è¯¥å’Œæˆ‘è¿™é‡Œåšçš„å·®ä¸å¤šã€‚\n","wordCount":"1728","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg","datePublished":"2021-07-11T19:00:00+08:00","dateModified":"2021-07-11T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®</h1><div class=post-description>è™½ç„¶ä¸æ˜¯ç‰¹åˆ«å®Œå–„ï¼Œä½†å¥½æ­¹è®°å½•ä¸€ä¸‹åšè¿‡çš„äº‹æƒ….</div><div class=post-meta><span title="2021-07-11 19:00:00 +0800 CST">July 11, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-gpu-skinning-with-animator-controller.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GPUSkinning.jpg alt="GPU Skinning Cover"><p>GPU Skinning example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8gpu%e6%9d%a5%e8%bf%9b%e8%a1%8c%e8%92%99%e7%9a%ae aria-label=ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš®>ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš®</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e4%b8%80%e4%ba%9b%e6%83%b3%e6%b3%95 aria-label=GPUè’™çš®çš„ä¸€äº›æƒ³æ³•>GPUè’™çš®çš„ä¸€äº›æƒ³æ³•</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=GPUè’™çš®çš„æ“ä½œ>GPUè’™çš®çš„æ“ä½œ</a><ul><li><a href=#bonematchinfocs aria-label=BoneMatchInfo.cs>BoneMatchInfo.cs</a></li><li><a href=#bonegpuskinningcs aria-label=BoneGPUSkinning.cs>BoneGPUSkinning.cs</a></li><li><a href=#bonecomputeshadercompute aria-label=BoneComputeShader.compute>BoneComputeShader.compute</a></li><li><a href=#bonegpuskinninghlsl aria-label=BoneGPUSkinning.hlsl>BoneGPUSkinning.hlsl</a></li><li><a href=#bonegpuskinningshadershader aria-label=BoneGPUSkinningShader.shader>BoneGPUSkinningShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=ä¸ºä»€ä¹ˆè¦ç”¨gpuæ¥è¿›è¡Œè’™çš®>ä¸ºä»€ä¹ˆè¦ç”¨GPUæ¥è¿›è¡Œè’™çš®<a hidden class=anchor aria-hidden=true href=#ä¸ºä»€ä¹ˆè¦ç”¨gpuæ¥è¿›è¡Œè’™çš®>#</a></h2><p>å¯¹äºä¸€ä¸ªSkinnedMeshRendererï¼Œåœ¨åšè’™çš®çš„æ—¶å€™ï¼Œå¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ï¼Œä¼šå…ˆè®¡ç®—å‡ºè¿™ä¸ªé¡¶ç‚¹å¯¹åº”çš„å››æ ¹éª¨éª¼çš„ä»éª¨éª¼ç©ºé—´åˆ°ç‰©ä½“ç©ºé—´çš„çŸ©é˜µ\(M_{bone\_localtoobject}\)ï¼Œç„¶åä½¿ç”¨\(M_{bone\_localtoobject} * M_{bone\_bindpose} * Vertex_{objectspace}\)å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å››ä¸ªå¸¦æƒé‡çš„é¡¶ç‚¹æ•°æ®ä½ç½®å’Œåˆ‡çº¿ï¼Œå¯¹äºæ³•çº¿åˆ™æ˜¯ä½¿ç”¨ä¸Šé¢çŸ©é˜µçš„é€†çŸ©é˜µçš„è½¬ç½®ã€‚ç„¶åå¯¹è·å¾—çš„ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œç”¨æƒé‡è®¡ç®—å¾—åˆ°ç»è¿‡éª¨éª¼å¹³ç§»æ—‹è½¬ç¼©æ”¾åçš„å®é™…çš„é¡¶ç‚¹ä¿¡æ¯ã€‚åœ¨é€šå¸¸çš„æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œä¸Šè¿°æ“ä½œæ˜¯åœ¨CPUä¸­è¿›è¡Œçš„ï¼Œæœ€åæŠŠé¡¶ç‚¹æ•°æ®ä¼ é€’ç»™GPUä¸­è¿›è¡Œæ¸²æŸ“ã€‚åœ¨é¡¶ç‚¹æ•°è¾ƒå¤šä¸”ä¸»è¦æ˜¯çŸ©é˜µè¿ç®—çš„æƒ…å†µä¸‹ï¼ŒCPUè¿›è¡Œè’™çš®çš„æ•ˆç‡å°±ä¸å¦‚é«˜å¹¶è¡Œçš„GPUäº†ï¼Œå› æ­¤ä¼šè€ƒè™‘åˆ°åœ¨GPUä¸­è¿›è¡Œè’™çš®å¤„ç†ã€‚</p><h2 id=gpuè’™çš®çš„ä¸€äº›æƒ³æ³•>GPUè’™çš®çš„ä¸€äº›æƒ³æ³•<a hidden class=anchor aria-hidden=true href=#gpuè’™çš®çš„ä¸€äº›æƒ³æ³•>#</a></h2><p>ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œè¦ä»CPUä¸­ä¼ ç»™GPUçš„æ•°æ®æœ‰ä»¥ä¸‹å‡ ç§ï¼šä¸€æ˜¯\(M_{bone\_localtoobject} * M_{bone\_bindpose}\)è¿™æ ·éª¨éª¼æ•°ä¸ªfloat4x4çš„çŸ©é˜µï¼Œä½†æ˜¯ç”±äºå…¶æœ€åä¸€è¡Œæ˜¯(0, 0, 0, 1)ï¼Œåœ¨ä¼ é€’æ—¶å¯ä»¥ç®€åŒ–æˆéª¨éª¼æ•°ä¸ªfloat3x4çŸ©é˜µï¼Œè¿™äº›çŸ©é˜µæ¯ä¸€å¸§éƒ½è¦ä¼ é€’ä¸€æ¬¡ï¼›äºŒæ˜¯æ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„éª¨éª¼ç¼–å·å’Œéª¨éª¼çš„æƒé‡ï¼Œéª¨éª¼ç¼–å·ç”¨æ¥æŸ¥è¯¢éª¨éª¼çŸ©é˜µä¸­å¯¹åº”çš„çŸ©é˜µï¼Œæ˜¯ä¸€ä¸ªæ•´å‹çš„æ•°æ®ï¼Œéª¨éª¼æƒé‡æ˜¯ä¸€ä¸ª[0, 1]çš„å°æ•°ï¼Œå¯ä»¥ç”¨\(BoneIndex + BoneWeight * 0.5\)çš„æ–¹å¼ï¼ŒæŠŠç¼–å·å’Œæƒé‡ç»“åˆæˆä¸€ä¸ªfloatçš„æ•°æ®ï¼Œè¿™æ ·æ¯ä¸ªé¡¶ç‚¹çš„éª¨éª¼ç¼–å·å’Œæƒé‡æ•°æ®æ˜¯ä¸€ä¸ªfloat4çš„æ•°æ®ï¼Œå¯ä»¥ä¿å­˜åœ¨UVä¸­ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°ç»„çš„æ–¹å¼ä¼ é€’ç»™GPUï¼Œè¿™äº›é¡¶ç‚¹æ•°ä¸ªfloat4çš„æ•°æ®ï¼Œåªéœ€è¦ä¼ é€’ä¸€æ¬¡å°±å¯ä»¥äº†ï¼›å†æœ‰å°±æ˜¯æ¨¡å‹æœ¬èº«çš„é¡¶ç‚¹ä½ç½®ã€æ³•çº¿å’Œåˆ‡çº¿ï¼Œè¿™äº›å¼•æ“ä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬ä¼ é€’ç»™GPUã€‚</p><p>åœ¨å®é™…æ“ä½œä¸­ï¼Œç½‘ä¸Šé€šå¸¸æ‰¾åˆ°çš„æ–¹æ¡ˆæ˜¯æŠŠåŠ¨ç”»ä¿å­˜åœ¨ä¸€å¼ è´´å›¾æˆ–è€…æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„æ•°æ®ç»“æ„ä¸­ï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥ä¿å­˜é¡¶ç‚¹æ•°æ®ï¼Œç”šè‡³ä¸éœ€è¦åœ¨GPUä¸­åšè’™çš®çš„æ“ä½œï¼Œä½†æ˜¯éšç€é¡¶ç‚¹æ•°å¢åŠ ä¼šå ç”¨å¤§é‡çš„ç©ºé—´ï¼›æˆ–è€…æ˜¯ä¿å­˜éª¨éª¼çš„å˜æ¢çŸ©é˜µï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®ï¼Œç›¸å¯¹æ¥è¯´å‚¨å­˜ç©ºé—´ä¼šå°å¾ˆå¤šã€‚ç„¶è€Œæˆ‘è®¤ä¸ºè¿™ä¸¤ç§éƒ½ä¸æ˜¯å¾ˆå¥½çš„åšGPU skinningçš„æ–¹æ³•ï¼Œå°†åŠ¨ç”»ä¿¡æ¯ä¿å­˜åˆ°è´´å›¾æˆ–è€…æ•°æ®ç»“æ„ä¸­ï¼Œä¼šå¾ˆå¤§ç¨‹åº¦ä¸Šå¤±å»Animator Controllerçš„åŠŸèƒ½ï¼Œå¦‚ä¸¤ä¸ªåŠ¨ä½œä¹‹é—´çš„æ’å€¼ã€è§¦å‘äº‹ä»¶ç­‰ï¼Œå¯¹äºåŠ¨ç”»æ¥è¯´ç”šè‡³æ˜¯å¾—ä¸å¿å¤±çš„ä¸€ç§æ•ˆæœã€‚å› æ­¤ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿä¿ç•™Animator Controllerçš„ç‰¹æ€§ï¼Œå®æ—¶çš„æŠŠéª¨éª¼æ•°æ®ä¼ é€ç»™GPUï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®æ“ä½œã€‚</p><h2 id=gpuè’™çš®çš„æ“ä½œ>GPUè’™çš®çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#gpuè’™çš®çš„æ“ä½œ>#</a></h2><p>æˆ‘çš„æƒ³æ³•æ˜¯ï¼Œå…ˆç¦»çº¿ä»SkinnedMeshRendererä¸­è·å¾—éª¨éª¼çš„IDå’Œæƒé‡ï¼Œç„¶åå®æ—¶çš„ä»Animator Controllerå¯¹åº”çš„éª¨éª¼ä¸­è·å–æ¯æ ¹éª¨éª¼çš„éª¨éª¼çŸ©é˜µï¼Œå†ç»Ÿä¸€ä¼ ç»™ä¸€ä¸ªæ™®é€šçš„MeshRendererï¼Œåœ¨GPUä¸­è¿›è¡Œè’™çš®çš„æ“ä½œã€‚è¿™ä¸­é—´æœ‰ä¸€ä¸ªå°å‘ï¼ŒUnityåŒä¸€ä¸ªæ¨¡å‹çš„SkinnedMeshRendererå’ŒMeshRendererï¼Œä»–ä»¬è™½ç„¶éƒ½èƒ½è·å–åˆ°boneweightå’Œbindposeï¼Œä½†æ˜¯SkinnedMeshRendererå’ŒMeshRnedererçš„éª¨éª¼çš„é¡ºåºæœ‰æ—¶å€™ä¼šæœ‰ä¸€äº›å·®å¼‚ï¼Œå› æ­¤æœ€å¥½çš„åŠæ³•æ˜¯ï¼ŒæŠ›å¼ƒè¿™ä¸¤è€…çš„éª¨éª¼é¡ºåºï¼Œç”¨Hierarchyä¸­çš„éª¨éª¼é¡ºåºæ¥ç¡®å®šæˆ‘ä»¬ä¼ ç»™GPUçš„boneindexï¼Œboneweightå’Œbonematrixæ˜¯ä¸€è‡´çš„ã€‚</p><p>è¿™é‡Œä½¿ç”¨çš„æ¨¡å‹åŠåŠ¨ä½œæ˜¯<a href=https://www.mixamo.com/>mixamo</a>çš„hip hop dancingèµ„æºã€‚</p><h3 id=bonematchinfocs>BoneMatchInfo.cs<a hidden class=anchor aria-hidden=true href=#bonematchinfocs>#</a></h3><p>è¿™ä¸ªè„šæœ¬çš„ä½œç”¨æ˜¯ï¼Œåœ¨ç¦»çº¿æ—¶æŠŠä¸€ä¸ªGameObjectRootä¸‹çš„æ‰€æœ‰SkinnedMeshRendererå’ŒHierarchyä¸­çš„éª¨éª¼çš„ä¿¡æ¯ç»“åˆèµ·æ¥ï¼Œä¿å­˜æˆä¸€ä¸ªAssetï¼Œç”¨äºå®æ—¶çš„GPU Skinningã€‚è¿™ä¸ªAssetåŒ…å«ä¸¤éƒ¨åˆ†çš„ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯BoneMatchNodeç”¨äºè®°å½•Hierarchyéª¨éª¼åˆ—è¡¨ä¸­éª¨éª¼çš„åç§°å’Œå…¶bindposeï¼Œå¦ä¸€ä¸ªæ˜¯BindIndexç”¨äºè®°å½•æ‰€æœ‰SkinnedMeshRendererçš„éª¨éª¼åœ¨Hierarchyéª¨éª¼åˆ—è¡¨ä¸­çš„é¡ºåºã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections;
<span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> UnityEditor;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.IO;

<span style=color:#66d9ef>namespace</span> GPUSkinning
{
<span style=color:#a6e22e>    [System.Serializable]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchNode</span>
    {
        <span style=color:#75715e>//[HideInInspector]
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> boneName;
        <span style=color:#75715e>//åœ¨æŸ¥æ‰¾ä½äºæ‰€æœ‰Transfomçš„ä½ç½®æ—¶ï¼Œè®¾ç½®å¹¶ä½¿ç”¨boneIndex
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> boneIndex = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>public</span> Matrix4x4 bindPose;

        <span style=color:#66d9ef>public</span> BoneMatchNode(<span style=color:#66d9ef>string</span> <span style=color:#ae81ff>_</span>boneName)
        {
            boneName = <span style=color:#ae81ff>_</span>boneName;
            bindPose = Matrix4x4.identity;
        }
    }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [System.Serializable]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BindList</span>
    {
        <span style=color:#75715e>//[HideInInspector]
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> skinnedMeshName;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span>[] bindIndexs;

        <span style=color:#66d9ef>public</span> BindList(<span style=color:#66d9ef>string</span> <span style=color:#ae81ff>_</span>skinnedMeshName)
        {
            skinnedMeshName = <span style=color:#ae81ff>_</span>skinnedMeshName;
        }
    }


    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchInfo</span> : ScriptableObject
    {   
        <span style=color:#66d9ef>public</span> BoneMatchNode[] boneMatchNodes;
        <span style=color:#66d9ef>public</span> BindList[] bindLists;
    }


    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GenerateBoneMatchInfo</span> : EditorWindow
    {
        <span style=color:#66d9ef>public</span> Transform rootBone;
        <span style=color:#66d9ef>public</span> Transform skinnedParent;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> skinnedMeshCount = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>public</span> SkinnedMeshRenderer[] smrArray;
        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;

        <span style=color:#66d9ef>private</span> Rect topToolBarRect
        {
            <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>, position.width - <span style=color:#ae81ff>40</span>, position.height - <span style=color:#ae81ff>20</span>); }
        }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [MenuItem(&#34;zznewclear13/Generate Bone Match Info&#34;)]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GenerateBoneMatchInfo GetWindow()
        {
            GenerateBoneMatchInfo window = GetWindow&lt;GenerateBoneMatchInfo&gt;();
            window.titleContent = <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;Generate Bone Match Info&#34;</span>);
            window.Focus();
            window.Repaint();
            <span style=color:#66d9ef>return</span> window;
        }

        <span style=color:#66d9ef>void</span> OnGUI()
        {
            TopToolBar(topToolBarRect);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TopToolBar(Rect rect)
        {
            GUILayout.BeginArea(rect);
            rootBone = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Root Bone Transform&#34;</span>, rootBone, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);
            skinnedParent = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Parent Transform&#34;</span>, skinnedParent, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);

            <span style=color:#66d9ef>if</span>(skinnedParent!=<span style=color:#66d9ef>null</span>)
            {
                smrArray = skinnedParent.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();
                <span style=color:#66d9ef>if</span>(smrArray != <span style=color:#66d9ef>null</span>)
                {
                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(<span style=color:#66d9ef>true</span>))
                    {
                        EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Mesh Renderers&#34;</span>, smrArray[<span style=color:#ae81ff>0</span>], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
                        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; smrArray.Length; i++)
                        {
                            EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34; &#34;</span>, smrArray[i], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
                        }
                    }

                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(smrArray.Length &lt;= <span style=color:#ae81ff>0</span>))
                    {
                        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Generate Animator Map&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30f</span>) }))
                        {                           
                            boneMatchInfo = CompareBones();
                            <span style=color:#75715e>//LogBindPoses();
</span><span style=color:#75715e></span>                            Save();
                        }
                    }
                }
            }

            GUILayout.EndArea();
        }

        <span style=color:#66d9ef>private</span> BoneMatchInfo CompareBones()
        {
            BoneMatchInfo tempInfo = <span style=color:#66d9ef>new</span> BoneMatchInfo();

            Transform[] boneTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
            List&lt;BoneMatchNode&gt; boneMatchNodeList = <span style=color:#66d9ef>new</span> List&lt;BoneMatchNode&gt;();
            List&lt;BindList&gt; bindLists = <span style=color:#66d9ef>new</span> List&lt;BindList&gt;();
            List&lt;<span style=color:#66d9ef>int</span>[]&gt; tempIntLists = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>[]&gt;();

            List&lt;Transform[]&gt; smrBoneTransList = <span style=color:#66d9ef>new</span> List&lt;Transform[]&gt;();
            List&lt;Matrix4x4[]&gt; smrBindPoseList = <span style=color:#66d9ef>new</span> List&lt;Matrix4x4[]&gt;();
            <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
            {
                Transform[] smrBoneTrans = smr.bones;
                Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
                smrBoneTransList.Add(smrBoneTrans);
                smrBindPoseList.Add(smrBindPos);
                tempIntLists.Add(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[smr.bones.Length]);
            }

            <span style=color:#66d9ef>int</span> boneTranIndex = <span style=color:#ae81ff>0</span>;
            <span style=color:#66d9ef>foreach</span> (Transform boneTran <span style=color:#66d9ef>in</span> boneTrans)
            {
                BoneMatchNode bmn = <span style=color:#66d9ef>new</span> BoneMatchNode(boneTran.name);
                <span style=color:#66d9ef>bool</span> isInSMRBones = <span style=color:#66d9ef>false</span>;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrBoneTransList.Count; i++)
                {
                    <span style=color:#66d9ef>int</span> index = Array.IndexOf(smrBoneTransList[i], boneTran);
                    <span style=color:#66d9ef>if</span> (index &gt;= <span style=color:#ae81ff>0</span>)
                    {
                        isInSMRBones = <span style=color:#66d9ef>true</span>;
                        bmn.bindPose = smrBindPoseList[i][index];
                        tempIntLists[i][index] = boneTranIndex;
                    }
                }

                <span style=color:#66d9ef>if</span> (isInSMRBones)
                {
                    bmn.boneIndex = boneTranIndex;
                    boneMatchNodeList.Add(bmn);
                    boneTranIndex++;
                }
            }

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrArray.Length; i++)
            {
                bindLists.Add(<span style=color:#66d9ef>new</span> BindList(smrArray[i].name));
                bindLists[i].bindIndexs = tempIntLists[i];
            }

            tempInfo.boneMatchNodes = boneMatchNodeList.ToArray();
            tempInfo.bindLists = bindLists.ToArray();
            <span style=color:#66d9ef>return</span> tempInfo;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> LogBindPoses()
        {
            using(StreamWriter sw = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;Assets/GPUSkinning/BindPoses.txt&#34;</span>))
            {
                <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
                {
                    Transform[] smrBoneTrans = smr.bones;
                    Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; smrBoneTrans.Length; j++)
                    {
                        sw.WriteLine(smr.name + <span style=color:#e6db74>&#34;\t&#34;</span> + smrBoneTrans[j].name + <span style=color:#e6db74>&#34;\r\n&#34;</span> + smrBindPos[j].ToString());
                    }
                }
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Save()
        {
            AssetDatabase.CreateAsset(boneMatchInfo, <span style=color:#e6db74>&#34;Assets/GPUSkinning/BoneMatchInfo.asset&#34;</span>);
            AssetDatabase.Refresh();
            Debug.Log(<span style=color:#e6db74>&#34;&lt;color=blue&gt;Bone Match Info has been saved to Assets/GPUSkinning/BoneMatchInfo.asset.&lt;/color&gt;&#34;</span>);
        }
    }
}
</code></pre></div><p>æœ€åå¾—åˆ°çš„<code>BoneMatchInfo.asset</code>å’ŒHierarchyçš„å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼Œéƒ¨åˆ†ä¸å‚ä¸å®é™…è’™çš®çš„éª¨éª¼ï¼Œå°±ä¸éœ€è¦è®°å½•åˆ°<code>BoneMatchInfo.asset</code>ä¸­äº†ï¼š</p><p><img loading=lazy src=../images/BoneMatchInfo.jpg#center alt=BoneMatchInfo></p><h3 id=bonegpuskinningcs>BoneGPUSkinning.cs<a hidden class=anchor aria-hidden=true href=#bonegpuskinningcs>#</a></h3><p>åœ¨<code>BoneGPUSkinning.cs</code>è¿™ä¸ªè„šæœ¬ä¸­ï¼Œè¦åšçš„äº‹æƒ…æ˜¯ï¼šæŠŠéª¨éª¼çš„ç¼–å·å’Œæƒé‡å†™åˆ°UVä¸­ï¼Œåªç”¨æ‰§è¡Œä¸€æ¬¡ï¼›æŠŠéª¨éª¼çŸ©é˜µå’Œbindposeçš„ä¹˜ç§¯ä¼ åˆ°GPUä¸­ï¼Œæ¯å¸§æ‰§è¡Œä¸€æ¬¡ï¼Œæˆ‘æŠŠè¿™ä¸ªæ“ä½œæ”¾åœ¨äº†compute shaderä¸­è¿›è¡Œè®¡ç®—ã€‚æ ¹æ®å‰é¢çš„æè¿°ï¼Œæˆ‘ä»¬éœ€è¦è·å–\(M_{bone\_localtoobject}\)ï¼Œè¿™ä¸ªå€¼ç­‰ä»·äº\(M_{object\_worldtolocal} * M_{bone\_localtoworld}\)ã€‚ä½†æ˜¯åœ¨å®é™…çš„æ“ä½œä¸­ï¼Œè·å–ä¸€æ ¹éª¨éª¼çš„\(M_{bone\_localtoworld}\)çŸ©é˜µä¼šå¯¼è‡´é¢å¤–çš„è¿ç®—ï¼Œä½¿å¾—GPU Skinningçš„æ•ˆç‡å—åˆ°äº†å¾ˆå¤§çš„é™åˆ¶ã€‚è¿™é‡Œæœ‰å¯èƒ½æ˜¯æˆ‘ä¸å¤Ÿç†Ÿæ‚‰Unityçš„APIçš„åŸå› ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯Unityæœ¬èº«å°±æ²¡å¼€æ”¾ç›¸å…³çš„APIçš„åŸå› ã€‚ç…§ç†æ¥è¯´ï¼ŒUnityè¦æŠŠAnimatorçš„å¹³ç§»æ—‹è½¬ç¼©æ”¾åŠ¨ç”»åº”ç”¨åˆ°æ¯ä¸€ä¸ªéª¨éª¼ä¸Šæ—¶ï¼Œå·²ç»è®¡ç®—è¿‡äº†æ¯æ ¹éª¨éª¼çš„localToWorldMatrixï¼Œè·å–è¿™ä¸ªçŸ©é˜µåº”è¯¥èƒ½åšåˆ°æ²¡æœ‰ä»»ä½•æ¶ˆè€—çš„ã€‚ä½†æ˜¯æ²¡æœ‰åŠæ³•ï¼Œæˆ‘åªèƒ½è¯•å›¾ä½¿ç”¨<code>Unity Jobs</code>å’Œ<code>Unity Burst</code>æ¥åŠ é€Ÿè·å–localToWorldMatrixçš„è¿‡ç¨‹ï¼Œåœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œç›¸æ¯”äºç›´æ¥ç”¨forå¾ªç¯è·å–å¤§æ¦‚èƒ½æœ‰è‡³å°‘50%çš„é€Ÿåº¦æå‡ï¼ˆè®°ä¸å¤ªæ¸…äº†ï¼‰ï¼Œç„¶è€Œå¯¹äºæ•´ä¸ªGPU Skinningçš„è¿‡ç¨‹æ¥è¯´ï¼Œæ¶ˆè€—è¿˜æ˜¯å¤ªé«˜äº†ã€‚</p><p>å› ä¸ºæ˜¯æ¯”è¾ƒä¹…ä¹‹å‰å†™çš„ä»£ç äº†ï¼Œä¹Ÿæ‡’å¾—å»å†ä»”ç»†åœ°ä¿®æ­£ï¼Œ<code>[ExecuteInEditMode]</code>åœ¨è®¾ç½®å¥½å„ä¸ªå¼•ç”¨ä¹‹å‰ä¼šç–¯ç‹‚çš„æŠ¥é”™ï¼Œä¸è¿‡åœ¨è®¾ç½®å¥½æ­£ç¡®çš„å¼•ç”¨ä¹‹åé‡æ–°å¯ç”¨è„šæœ¬å°±ä¸ä¼šæœ‰ä»»ä½•çš„é—®é¢˜äº†ã€‚ä¼¼ä¹æ“ä½œä¸å½“ä¹Ÿä¼šå‡ºç°å†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œä¸è¿‡æ— ä¼¤å¤§é›…ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> Unity.Collections;
<span style=color:#66d9ef>using</span> Unity.Jobs;
<span style=color:#66d9ef>using</span> UnityEngine.Jobs;
<span style=color:#66d9ef>using</span> Unity.Burst;


<span style=color:#66d9ef>namespace</span> GPUSkinning
{
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [ExecuteInEditMode]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneGPUSkinning</span> : MonoBehaviour
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> BONE_WEIGHT_DECODE_VALUE = <span style=color:#ae81ff>2</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> BONE_WEIGHT_INVERSE_DECODE_VALUE = <span style=color:#ae81ff>0.5f</span>;

        <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        <span style=color:#66d9ef>public</span> Transform rootBone;
        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;
        <span style=color:#66d9ef>public</span> List&lt;MeshRenderer&gt; meshRenderers;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [SerializeField]</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> boneSize;
        <span style=color:#66d9ef>private</span> Transform[] minBoneTrans;

        <span style=color:#66d9ef>private</span> TransformAccessArray transformAccessArray;

        <span style=color:#75715e>#region ComputeShader
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> kernel;

        <span style=color:#66d9ef>private</span> Matrix4x4[] bindPosesArray;
        <span style=color:#66d9ef>private</span> Matrix4x4[] LTWMatrixArray;

        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> bindPoseID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneBindPoseBuffer&#34;</span>);
        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> LTWMatrixID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneLTWMatrixBuffer&#34;</span>);
        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> outputBufferID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneOutputBuffer&#34;</span>);
        <span style=color:#66d9ef>private</span> ComputeBuffer outputBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer bindPoseBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer ltwMatrixBuffer;
        <span style=color:#75715e>#endregion
</span><span style=color:#75715e></span>
        <span style=color:#75715e>#region InitializeFunction
</span><span style=color:#75715e></span>
        <span style=color:#66d9ef>void</span> OnEnable()
        {
            Initialize();
        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// å…¨éƒ¨çš„åˆå§‹åŒ–
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
        {

            InitializeBoneTrans();

            InitializeBoneUV(<span style=color:#ae81ff>1</span>);

            InitializeComputeShader();

        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// æ•´åˆæ‰€æœ‰meshç»‘å®šçš„éª¨éª¼ï¼Œä»rootBoneçš„å­ç‰©ä»¶ä¸­æ‰¾å‡ºminBoneTrans
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeBoneTrans()
        {
            <span style=color:#75715e>//æ ‡è®°æ¯ä¸ªmeshå¯¹åº”çš„éª¨éª¼
</span><span style=color:#75715e></span>            Transform[] allTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
            Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt; allTransDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt;();
            <span style=color:#66d9ef>foreach</span> (Transform tran <span style=color:#66d9ef>in</span> allTrans)
            {
                allTransDict.Add(tran.name, tran);
            }
            boneSize = boneMatchInfo.boneMatchNodes.Length;
            minBoneTrans = <span style=color:#66d9ef>new</span> Transform[boneSize];

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
            {
                Transform tempTran = allTransDict[boneMatchInfo.boneMatchNodes[i].boneName];
                boneMatchInfo.boneMatchNodes[i].boneIndex = i;
                minBoneTrans[i] = tempTran;
            }

            transformAccessArray = <span style=color:#66d9ef>new</span> TransformAccessArray(minBoneTrans);
        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// æŠŠéª¨éª¼çš„ç¼–å·å’Œæƒé‡å†™å…¥åˆ°targetUVIndexå¯¹åº”çš„UVä¸­
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;param name=&#34;targetUVIndex&#34;&gt;&lt;/param&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> InitializeBoneUV(<span style=color:#66d9ef>int</span> targetUVIndex)
        {
            Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt; bindListDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt;();
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneMatchInfo.bindLists.Length; i++)
            {
                bindListDict.Add(boneMatchInfo.bindLists[i].skinnedMeshName, boneMatchInfo.bindLists[i]);
            }
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
            {
                BindList tempBindList;
                <span style=color:#66d9ef>bool</span> hasBindList = bindListDict.TryGetValue(meshRenderers[i].name, <span style=color:#66d9ef>out</span> tempBindList);
                <span style=color:#66d9ef>if</span>(!hasBindList)
                {
                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentException(String.Format(<span style=color:#e6db74>&#34;SkinnedMeshName:{0}åœ¨BoneMatchInfoä¸­æ‰¾ä¸åˆ°ï¼&#34;</span>,
                                                boneMatchInfo.bindLists[i].skinnedMeshName));
                }

                Mesh mesh = meshRenderers[i].GetComponent&lt;MeshFilter&gt;().sharedMesh;
                BoneWeight[] boneWeights = mesh.boneWeights;

                List&lt;Vector4&gt; boneAndWeights = <span style=color:#66d9ef>new</span> List&lt;Vector4&gt;();
                <span style=color:#66d9ef>int</span>[] bindIndexes = tempBindList.bindIndexs;
                <span style=color:#66d9ef>foreach</span> (BoneWeight weight <span style=color:#66d9ef>in</span> boneWeights)
                {
                    Vector4 boneAndWeight = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);

                    <span style=color:#75715e>//Shaderä¸­ä¸ªBoneUVéƒ½ä¼šæŸ¥æ‰¾å…¨å±€çš„éª¨éª¼ç¼–å·
</span><span style=color:#75715e></span>                    boneAndWeight.x = bindIndexes[weight.boneIndex0] + weight.weight0 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeight.y = bindIndexes[weight.boneIndex1] + weight.weight1 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeight.z = bindIndexes[weight.boneIndex2] + weight.weight2 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeight.w = bindIndexes[weight.boneIndex3] + weight.weight3 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeights.Add(boneAndWeight);
                }
                mesh.SetUVs(targetUVIndex, boneAndWeights.ToArray());
            }
        }


        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
        {
            <span style=color:#66d9ef>if</span> (buffer != <span style=color:#66d9ef>null</span>)
            {
                buffer.Release();
            }

            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride);
        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// åˆå§‹åŒ–ComputeShaderï¼Œç”¨äºè®¡ç®—æ¯æ ¹éª¨éª¼çš„çŸ©é˜µå’Œbindposçš„ä¹˜ç§¯
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeComputeShader()
        {
            bindPosesArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
            LTWMatrixArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
            Debug.Log(LTWMatrixArray.Length);
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
            {
                bindPosesArray[i] = boneMatchInfo.boneMatchNodes[i].bindPose;
            }

            kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;MatCompute&#34;</span>);

            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> outputBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> bindPoseBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ltwMatrixBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);

            bindPoseBuffer.SetData(bindPosesArray);
            computeShader.SetBuffer(kernel, bindPoseID, bindPoseBuffer);

            computeShader.SetBuffer(kernel, outputBufferID, outputBuffer);
        }

        <span style=color:#75715e>#endregion
</span><span style=color:#75715e></span>
        <span style=color:#75715e>#region Update Function
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> Update()
        {
            InvokeComputeShader();
            PassMeshRendererMatrix();
        }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [BurstCompile(CompileSynchronously = true)]</span>
        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GetLocalToWorldMatrixStructJob</span> : IJobParallelForTransform
        {
            <span style=color:#66d9ef>public</span> NativeArray&lt;Matrix4x4&gt; matArray;

            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i, TransformAccess transform)
            {
                matArray[i] = transform.localToWorldMatrix;
            }
        }


        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InvokeComputeShader()
        {
            <span style=color:#66d9ef>if</span>(computeShader)
            {
<span style=color:#75715e>#if true
</span><span style=color:#75715e></span>                <span style=color:#75715e>//NativeList&lt;JobHandle&gt; jobHandleList = new NativeList&lt;JobHandle&gt;(Allocator.Temp);
</span><span style=color:#75715e></span>                NativeArray&lt;Matrix4x4&gt; matArray = <span style=color:#66d9ef>new</span> NativeArray&lt;Matrix4x4&gt;(boneSize, Allocator.Persistent);

                GetLocalToWorldMatrixStructJob job = <span style=color:#66d9ef>new</span> GetLocalToWorldMatrixStructJob
                {
                    matArray = matArray
                };
                JobHandle jobHandle = IJobParallelForTransformExtensions.Schedule(job, transformAccessArray);<span style=color:#75715e>// job.Schedule(transformAccessArray);
</span><span style=color:#75715e></span>                jobHandle.Complete();

                ltwMatrixBuffer.SetData(matArray);
                matArray.Dispose();
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
                {
                    LTWMatrixArray[i] = minBoneTrans[i].localToWorldMatrix;
                }
                ltwMatrixBuffer.SetData(LTWMatrixArray);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
                computeShader.SetBuffer(kernel, LTWMatrixID, ltwMatrixBuffer);
                <span style=color:#66d9ef>int</span> dispatchCount = Mathf.CeilToInt(boneSize / <span style=color:#ae81ff>64f</span>);
                computeShader.Dispatch(kernel, dispatchCount, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
                Shader.SetGlobalBuffer(<span style=color:#e6db74>&#34;_BoneMatArray&#34;</span>, outputBuffer);
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PassMeshRendererMatrix()
        {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
            {
                <span style=color:#66d9ef>foreach</span> (Material mat <span style=color:#66d9ef>in</span> meshRenderers[i].sharedMaterials)
                {
                    mat.SetMatrix(<span style=color:#e6db74>&#34;_BoneTransformMatrix&#34;</span>, meshRenderers[i].transform.worldToLocalMatrix);
                }
            }

        }

<span style=color:#75715e>#endregion
</span><span style=color:#75715e></span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
        {
            outputBuffer.Release();
            outputBuffer = <span style=color:#66d9ef>null</span>;
            transformAccessArray.Dispose();
        }
    }

}
</code></pre></div><h3 id=bonecomputeshadercompute>BoneComputeShader.compute<a hidden class=anchor aria-hidden=true href=#bonecomputeshadercompute>#</a></h3><p>è¿™ä¸ªcompute shaderä»…ä»…åšäº†çŸ©é˜µçš„è¿ç®—ï¼Œç”šè‡³éƒ½ä¸è§å¾—æ¯”åœ¨CPUä¸­è¿ç®—è¦å¿«ï¼Œä¸è¿‡è¿™è¾¹è¿˜æ˜¯ä½¿ç”¨äº†compute shaderæ¥åšè¿™ä¸ªè¿ç®—ï¼Œç¨å¾®è¿˜èƒ½ä¼˜åŒ–çš„æ˜¯float4x4å¯ä»¥æ”¹æˆfloat3x4ï¼Œä¸è¿‡è¿™æ ·CPUçš„ä»£ç å†™èµ·æ¥ç¨ä¹±ä¸€äº›ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel MatCompute

StructuredBuffer&lt;float4x4&gt; _BoneBindPoseBuffer;
StructuredBuffer&lt;float4x4&gt; _BoneLTWMatrixBuffer;

RWStructuredBuffer&lt;float4x4&gt; _BoneOutputBuffer;

[numthreads(64, 1, 1)]
void MatCompute(uint3 id : SV_DispatchThreadID)
{
    _BoneOutputBuffer[id.x] = mul(_BoneLTWMatrixBuffer[id.x], _BoneBindPoseBuffer[id.x]);
}
</code></pre><h3 id=bonegpuskinninghlsl>BoneGPUSkinning.hlsl<a hidden class=anchor aria-hidden=true href=#bonegpuskinninghlsl>#</a></h3><p>æ“ä½œæµç¨‹æ˜¯è¿™æ ·çš„ï¼Œå¯¹æ¯ä¸€ä¸ªé¡¶ç‚¹å®šä¹‰ä¸€ä¸ªç»“æ„ä½“<code>VertexInputStructure</code>ï¼Œè¯»å–MeshRendererçš„åŸå§‹æ•°æ®ä¸­çš„ä½ç½®ã€æ³•çº¿ã€åˆ‡çº¿å’Œæˆ‘ä»¬ä¼ å…¥çš„éª¨éª¼ç¼–å·å’Œæƒé‡ã€‚ä½¿ç”¨ç¼–å·å»å¯»æ‰¾<code>_BoneMatArray</code>ä¸­å¯¹åº”çš„\(M_{bone\_localtoworld}\)ï¼Œå†å·¦ä¹˜<code>_BoneTransformMatrix</code>ä¹Ÿå°±æ˜¯ä¹‹å‰è¯´è¿‡\(M_{object\_worldtolocal}\)ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªçŸ©é˜µçš„ä¹˜ç§¯å°±èƒ½åˆ†åˆ«è®¡ç®—è’™çš®åçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿äº†ï¼Œè¦æ³¨æ„çš„æ˜¯æ³•çº¿éœ€è¦åšä¸€æ¬¡é€†çŸ©é˜µçš„è½¬ç½®ã€‚æœ€åå¯¹å››å¯¹é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿è¿›è¡ŒåŠ æƒè®¡ç®—ï¼Œè·å¾—æœ€ç»ˆçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#ifndef BONE_GPU_SKINNING
#define BONE_GPU_SKINNING

#define BONE_WEIGHT_DECODE_VALUE 2

StructuredBuffer&lt;float4x4&gt; _BoneMatArray;
float4x4 _BoneTransformMatrix;

struct VertexInputStructure
{
    float3 positionOS;
    float3 normalOS;
    float4 tangentOS;
    float4 boneUV;
};

struct VertexOutputStructure
{
    float3 positionOS;
    float3 normalOS;
    float4 tangentOS;
};

inline float3x3 InverseTranspose(float3x3 mat)
{

    float determinant = mat._m00 * (mat._m11 * mat._m22 - mat._m12 * mat._m21)
                        - mat._m01 * (mat._m10 * mat._m22 - mat._m12 * mat._m20)
                        + mat._m02 * (mat._m10 * mat._m21 - mat._m11 * mat._m20);
    float3 vec0 = float3(mat._m11 * mat._m22 - mat._m12 * mat._m21,
                        mat._m12 * mat._m20 - mat._m10 * mat._m22,
                        mat._m10 * mat._m21 - mat._m11 * mat._m20);
    float3 vec1 = float3(mat._m02 * mat._m21 - mat._m01 * mat._m22,
                        mat._m00 * mat._m22 - mat._m02 * mat._m20,
                        mat._m01 * mat._m20 - mat._m00 * mat._m21);
    float3 vec2 = float3(mat._m01 * mat._m12 - mat._m02 * mat._m11,
                        mat._m02 * mat._m10 - mat._m00 * mat._m12,
                        mat._m00 * mat._m11 - mat._m01 * mat._m10);
    float3x3 returnMat;
    returnMat._m00_m01_m02 = vec0;
    returnMat._m10_m11_m12 = vec1;
    returnMat._m20_m21_m22 = vec2;
    return returnMat / determinant;
}

inline float3x3 InverseTransposeVec(float3 vec0, float3 vec1, float3 vec2)
{
    float3x3 mat;
    mat._m00_m01_m02 = vec0;
    mat._m10_m11_m12 = vec1;
    mat._m20_m21_m22 = vec2;
    return InverseTranspose(mat);
}

inline float4x4 ReadBoneInfos(uint boneIndex)
{
    return mul(_BoneTransformMatrix, _BoneMatArray[boneIndex]);
}

inline VertexOutputStructure BlendBonesPosNormalTangent(VertexInputStructure input)
{
    float4 positionOS = float4(input.positionOS, 1);
    float3 normalOS = input.normalOS;
    float4 tangentOS = input.tangentOS;
    float4 boneUV = input.boneUV;

    uint boneIndexOne = floor(boneUV.x);
    float boneWeightOne = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.x);

    uint boneIndexTwo = floor(boneUV.y);
    float boneWeightTwo = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.y);

    uint boneIndexThree = floor(boneUV.z);
    float boneWeightThree = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.z);

    uint boneIndexFour = floor(boneUV.w);
    float boneWeightFour = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.w);

    float4x4 matOne = ReadBoneInfos(boneIndexOne);
    float4x4 matTwo = ReadBoneInfos(boneIndexTwo);
    float4x4 matThree = ReadBoneInfos(boneIndexThree);
    float4x4 matFour = ReadBoneInfos(boneIndexFour);

    //blend position
    float3 posOne = mul(matOne, positionOS).xyz;
    float3 posTwo = mul(matTwo, positionOS).xyz;
    float3 posThree = mul(matThree, positionOS).xyz;
    float3 posFour = mul(matFour, positionOS).xyz;

    float3 returnPos = posOne * boneWeightOne
        + posTwo * boneWeightTwo
        + posThree * boneWeightThree
        + posFour * boneWeightFour;

    //blend normal
    float3x3 newMatOne = InverseTransposeVec(matOne._m00_m01_m02, matOne._m10_m11_m12, matOne._m20_m21_m22);
    float3x3 newMatTwo = InverseTransposeVec(matTwo._m00_m01_m02, matTwo._m10_m11_m12, matTwo._m20_m21_m22);
    float3x3 newMatThree = InverseTransposeVec(matThree._m00_m01_m02, matThree._m10_m11_m12, matThree._m20_m21_m22);
    float3x3 newMatFour = InverseTransposeVec(matFour._m00_m01_m02, matFour._m10_m11_m12, matFour._m20_m21_m22);

    float3 normalOne = mul(newMatOne, normalOS).xyz;
    float3 normalTwo = mul(newMatTwo, normalOS).xyz;
    float3 normalThree = mul(newMatThree, normalOS).xyz;
    float3 normalFour = mul(newMatFour, normalOS).xyz;

    float3 returnNormal = normalOne * boneWeightOne
        + normalTwo * boneWeightTwo
        + normalThree * boneWeightThree
        + normalFour * boneWeightFour;

    returnNormal = normalize(returnNormal);

    //blend tangent
    float3 tangentOne = mul((float3x3)matOne, tangentOS.xyz);
    float3 tangentTwo = mul((float3x3)matTwo, tangentOS.xyz);
    float3 tangentThree = mul((float3x3)matThree, tangentOS.xyz);
    float3 tangentFour = mul((float3x3)matFour, tangentOS.xyz);

    float3 tempTangent = tangentOne * boneWeightOne
                        + tangentTwo * boneWeightTwo
                        + tangentThree * boneWeightThree
                        + tangentFour * boneWeightFour;
    tempTangent = normalize(tempTangent);
    float4 returnTangent = float4(tempTangent, tangentOS.w);

    VertexOutputStructure output;
    output.positionOS = returnPos;
    output.normalOS = returnNormal;
    output.tangentOS = returnTangent;
    return output;
}
#endif
</code></pre><h3 id=bonegpuskinningshadershader>BoneGPUSkinningShader.shader<a hidden class=anchor aria-hidden=true href=#bonegpuskinningshadershader>#</a></h3><p>ç”¨äºæ¸²æŸ“çš„shaderä¸­ï¼Œè¦åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­è°ƒç”¨<code>BoneGPUSkinning.hlsl</code>ä¸­çš„æ–¹æ³•è·å–è’™çš®åçš„é¡¶ç‚¹ä½ç½®ã€åˆ‡çº¿å’Œæ³•çº¿ã€‚æˆ‘è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„æ¸²æŸ“ï¼Œç»™æ¨¡å‹ä¸€ç‚¹åŸºç¡€çš„å…‰å½±ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœéœ€è¦æ­£ç¡®çš„é˜´å½±çš„è¯ï¼Œåœ¨<code>ShadowCaster</code>è¿™ä¸ªpassä¸­è¿˜éœ€è¦è®¡ç®—ä¸€éé¡¶ç‚¹ä½ç½®ï¼Œè¿™é‡Œå°±æš‚ä¸”å¿½ç•¥äº†ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/BoneGPUSkinningShader&quot;
{
    Properties
    {
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; &quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; }

        HLSLINCLUDE

#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
#include &quot;Assets/GPUSkinning/BoneGPUSkinning.hlsl&quot;

        sampler2D _MainTex;
        CBUFFER_START(UnityPerMaterial)
        float4 _Color;
        CBUFFER_END

        struct a2v
        {
            float4 vertex   : POSITION;
            float2 uv       : TEXCOORD0;
            float4 boneUV   : TEXCOORD1;
            float3 normal   : NORMAL;
            float4 tangent  : TANGENT;
        };

        struct v2f
        {
            float4 pos          : SV_POSITION;
            float2 uv           : TEXCOORD0;
            float4 tempColor    : TEXCOORD1;
            float3 normalWS     : TEXCOORD2;
            float4 tangentWS    : TEXCOORD3;
            float3 eyeVec       : TEXCOORD4;
        };

        v2f animVert(a2v v)
        {
            v2f o;
            VertexInputStructure inputStructure;
            inputStructure.positionOS = v.vertex;
            inputStructure.normalOS = v.normal;
            inputStructure.tangentOS = v.tangent;
            inputStructure.boneUV = v.boneUV;

            VertexOutputStructure outputStructure = BlendBonesPosNormalTangent(inputStructure);
            float3 vertexPos = outputStructure.positionOS;
            float3 vertexNormal = outputStructure.normalOS;
            float3 vertexTangent = outputStructure.tangentOS;

            o.pos = TransformObjectToHClip(vertexPos);
            o.normalWS = TransformObjectToWorldNormal(vertexNormal);
            o.tangentWS = float4(TransformObjectToWorldDir(vertexTangent), v.tangent.w);

            o.uv = v.uv;
            o.tempColor = float4(1, 1, 1, 1);
            float3 worldPos = TransformObjectToWorld(float4(vertexPos, 1));
            o.eyeVec = GetCameraPositionWS() - worldPos;

            return o;
        }

        float4 animFrag(v2f i) : SV_TARGET
        {
            float3 viewDir = normalize(i.eyeVec);
            float3 lightDir = normalize(float3(1, 1, 1));
            float3 halfVec = normalize(lightDir + viewDir);

            float3 normalWS = normalize(i.normalWS);
            float NdotL = dot(normalWS, lightDir) * 0.6 + 0.4;
            float NdotH = saturate(dot(normalWS, halfVec));

            float3 diffuseColor = _Color.xyz * NdotL;
            float3 specularColor = pow(NdotH, 30);
            return float4(diffuseColor + specularColor, 1);
        }

        ENDHLSL
        pass
        {
            Tags{ &quot;LightMode&quot; = &quot;UniversalForward&quot; }

            HLSLPROGRAM
            #pragma vertex animVert
            #pragma fragment animFrag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=æœ€åçš„æ€è€ƒ>æœ€åçš„æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#æœ€åçš„æ€è€ƒ>#</a></h2><p>æ€»çš„æ¥è¯´ï¼Œä¸Šé¢çš„æ“ä½œå·²ç»åŸºæœ¬å®Œæˆäº†GPU Skinningçš„éœ€æ±‚ï¼Œè€Œä¸”èƒ½å¤Ÿæ­£ç¡®çš„ä¸Animatorç»„ä»¶ç›¸ç»“åˆã€‚å½“ç„¶ä»æœ‰ä¼˜åŒ–çš„ç©ºé—´ï¼Œæ¯”å¦‚è¯´æŠŠæ‰€æœ‰è¦åšGPU Skinningçš„meshä½¿ç”¨åŒä¸€ä¸ªUpdateçš„æ–¹æ³•æ¥æ›´æ–°ï¼Œç­‰ç­‰ã€‚ä½†æ˜¯ç¾ä¸­ä¸è¶³çš„æ˜¯ä¹‹å‰æåˆ°çš„è·å–localToWorldMatrixçš„é—®é¢˜ï¼Œç›´æ¥å¯¼è‡´äº†ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ä¸å¦‚Unityè‡ªå¸¦çš„GPU Skinningæ•ˆç‡é«˜ï¼Œè‡ªå¸¦çš„GPUè’™çš®åº”è¯¥æ˜¯ç”¨åˆ°äº†Unityåº•å±‚çš„ä¸€äº›ä¼˜åŒ–å§ï¼Œä½†æ˜¯æ ¸å¿ƒçš„æ“ä½œåº”è¯¥å’Œæˆ‘è¿™é‡Œåšçš„å·®ä¸å¤šã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/gpu-skinning/>GPU Skinning</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><span class=title>Â« Prev</span><br><span>åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ</span></a>
<a class=next href=https://zznewclear13.github.io/posts/get-world-space-position-from-depth-texture/><span class=title>Next Â»</span><br><span>ä»æ·±åº¦å›¾ä¸­è·å–ä¸–ç•Œç©ºé—´çš„åæ ‡</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const b=document.getElementById('comments');let c=currentHugoTheme=='dark'?'photon-dark':'github-light',a=document.createElement('script');a.src='https://utteranc.es/client.js',a.setAttribute('repo','zznewclear13/zznewclear13.github.io'),a.setAttribute('issue-term','pathname'),a.setAttribute('label','utterances'),a.setAttribute('theme',c),a.setAttribute('crossorigin','anonymous'),a.setAttribute('async',''),b.innerHTML='',b.appendChild(a)}loadComment(),document.getElementById('theme-toggle').onclick=async()=>{await new Promise(a=>setTimeout(a,200));let a=window.localStorage.getItem('pref-theme');a!=currentHugoTheme&&(currentHugoTheme=a,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>