<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>支持Animator Controller的实时GPU蒙皮 | ZZNEWCLEAR13</title>
<meta name=keywords content="GPU Skinning"><meta name=description content="虽然不是特别完善，但好歹记录一下做过的事情."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="支持Animator Controller的实时GPU蒙皮"><meta property="og:description" content="虽然不是特别完善，但好歹记录一下做过的事情."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-11T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-11T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta name=twitter:title content="支持Animator Controller的实时GPU蒙皮"><meta name=twitter:description content="虽然不是特别完善，但好歹记录一下做过的事情."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"支持Animator Controller的实时GPU蒙皮","item":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"支持Animator Controller的实时GPU蒙皮","name":"支持Animator Controller的实时GPU蒙皮","description":"虽然不是特别完善，但好歹记录一下做过的事情.","keywords":["GPU Skinning"],"articleBody":"为什么要用GPU来进行蒙皮 对于一个SkinnedMeshRenderer，在做蒙皮的时候，对于每一个顶点，会先计算出这个顶点对应的四根骨骼的从骨骼空间到物体空间的矩阵\\(M_{bone\\localtoobject}\\)，然后使用\\(M{bone\\localtoobject} * M{bone\\bindpose} * Vertex{objectspace}\\)得到经过骨骼平移旋转缩放后的四个带权重的顶点数据位置和切线，对于法线则是使用上面矩阵的逆矩阵的转置。然后对获得的位置、法线和切线，用权重计算得到经过骨骼平移旋转缩放后的实际的顶点信息。在通常的渲染过程中，上述操作是在CPU中进行的，最后把顶点数据传递给GPU中进行渲染。在顶点数较多且主要是矩阵运算的情况下，CPU进行蒙皮的效率就不如高并行的GPU了，因此会考虑到在GPU中进行蒙皮处理。\nGPU蒙皮的一些想法 从上面可以看到，要从CPU中传给GPU的数据有以下几种：一是\\(M_{bone\\localtoobject} * M{bone\\_bindpose}\\)这样骨骼数个float4x4的矩阵，但是由于其最后一行是(0, 0, 0, 1)，在传递时可以简化成骨骼数个float3x4矩阵，这些矩阵每一帧都要传递一次；二是每个顶点对应的骨骼编号和骨骼的权重，骨骼编号用来查询骨骼矩阵中对应的矩阵，是一个整型的数据，骨骼权重是一个[0, 1]的小数，可以用\\(BoneIndex + BoneWeight * 0.5\\)的方式，把编号和权重结合成一个float的数据，这样每个顶点的骨骼编号和权重数据是一个float4的数据，可以保存在UV中，也可以用数组的方式传递给GPU，这些顶点数个float4的数据，只需要传递一次就可以了；再有就是模型本身的顶点位置、法线和切线，这些引擎会自动为我们传递给GPU。\n在实际操作中，网上通常找到的方案是把动画保存在一张贴图或者是一个自定义的数据结构中，这里可以直接保存顶点数据，甚至不需要在GPU中做蒙皮的操作，但是随着顶点数增加会占用大量的空间；或者是保存骨骼的变换矩阵，在GPU中进行蒙皮，相对来说储存空间会小很多。然而我认为这两种都不是很好的做GPU skinning的方法，将动画信息保存到贴图或者数据结构中，会很大程度上失去Animator Controller的功能，如两个动作之间的插值、触发事件等，对于动画来说甚至是得不偿失的一种效果。因此，我希望能够保留Animator Controller的特性，实时的把骨骼数据传送给GPU，在GPU中进行蒙皮操作。\nGPU蒙皮的操作 我的想法是，先离线从SkinnedMeshRenderer中获得骨骼的ID和权重，然后实时的从Animator Controller对应的骨骼中获取每根骨骼的骨骼矩阵，再统一传给一个普通的MeshRenderer，在GPU中进行蒙皮的操作。这中间有一个小坑，Unity同一个模型的SkinnedMeshRenderer和MeshRenderer，他们虽然都能获取到boneweight和bindpose，但是SkinnedMeshRenderer和MeshRnederer的骨骼的顺序有时候会有一些差异，因此最好的办法是，抛弃这两者的骨骼顺序，用Hierarchy中的骨骼顺序来确定我们传给GPU的boneindex，boneweight和bonematrix是一致的。\n这里使用的模型及动作是mixamo的hip hop dancing资源。\nBoneMatchInfo.cs 这个脚本的作用是，在离线时把一个GameObjectRoot下的所有SkinnedMeshRenderer和Hierarchy中的骨骼的信息结合起来，保存成一个Asset，用于实时的GPU Skinning。这个Asset包含两部分的信息，一个是BoneMatchNode用于记录Hierarchy骨骼列表中骨骼的名称和其bindpose，另一个是BindIndex用于记录所有SkinnedMeshRenderer的骨骼在Hierarchy骨骼列表中的顺序。\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System; using System.IO; namespace GPUSkinning { [System.Serializable] public class BoneMatchNode { //[HideInInspector] public string boneName; //在查找位于所有Transfom的位置时，设置并使用boneIndex public int boneIndex = 0; public Matrix4x4 bindPose; public BoneMatchNode(string _boneName) { boneName = _boneName; bindPose = Matrix4x4.identity; } } [System.Serializable] public class BindList { //[HideInInspector] public string skinnedMeshName; public int[] bindIndexs; public BindList(string _skinnedMeshName) { skinnedMeshName = _skinnedMeshName; } } public class BoneMatchInfo : ScriptableObject { public BoneMatchNode[] boneMatchNodes; public BindList[] bindLists; } public class GenerateBoneMatchInfo : EditorWindow { public Transform rootBone; public Transform skinnedParent; public int skinnedMeshCount = 0; public SkinnedMeshRenderer[] smrArray; public BoneMatchInfo boneMatchInfo; private Rect topToolBarRect { get { return new Rect(20, 10, position.width - 40, position.height - 20); } } [MenuItem(\"zznewclear13/Generate Bone Match Info\")] public static GenerateBoneMatchInfo GetWindow() { GenerateBoneMatchInfo window = GetWindow(); window.titleContent = new GUIContent(\"Generate Bone Match Info\"); window.Focus(); window.Repaint(); return window; } void OnGUI() { TopToolBar(topToolBarRect); } private void TopToolBar(Rect rect) { GUILayout.BeginArea(rect); rootBone = (Transform)EditorGUILayout.ObjectField(\"Root Bone Transform\", rootBone, typeof(Transform), true); skinnedParent = (Transform)EditorGUILayout.ObjectField(\"Skinned Parent Transform\", skinnedParent, typeof(Transform), true); if(skinnedParent!=null) { smrArray = skinnedParent.GetComponentsInChildren(); if(smrArray != null) { using (new EditorGUI.DisabledGroupScope(true)) { EditorGUILayout.ObjectField(\"Skinned Mesh Renderers\", smrArray[0], typeof(SkinnedMeshRenderer), false); for (int i = 1; i \u003c smrArray.Length; i++) { EditorGUILayout.ObjectField(\" \", smrArray[i], typeof(SkinnedMeshRenderer), false); } } using (new EditorGUI.DisabledGroupScope(smrArray.Length \u003c= 0)) { if (GUILayout.Button(\"Generate Animator Map\", new GUILayoutOption[] { GUILayout.Height(30f) })) { boneMatchInfo = CompareBones(); //LogBindPoses(); Save(); } } } } GUILayout.EndArea(); } private BoneMatchInfo CompareBones() { BoneMatchInfo tempInfo = new BoneMatchInfo(); Transform[] boneTrans = rootBone.GetComponentsInChildren(); List boneMatchNodeList = new List(); List bindLists = new List(); List\u003cint[]\u003e tempIntLists = new List\u003cint[]\u003e(); List smrBoneTransList = new List(); List smrBindPoseList = new List(); foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; smrBoneTransList.Add(smrBoneTrans); smrBindPoseList.Add(smrBindPos); tempIntLists.Add(new int[smr.bones.Length]); } int boneTranIndex = 0; foreach (Transform boneTran in boneTrans) { BoneMatchNode bmn = new BoneMatchNode(boneTran.name); bool isInSMRBones = false; for (int i = 0; i \u003c smrBoneTransList.Count; i++) { int index = Array.IndexOf(smrBoneTransList[i], boneTran); if (index \u003e= 0) { isInSMRBones = true; bmn.bindPose = smrBindPoseList[i][index]; tempIntLists[i][index] = boneTranIndex; } } if (isInSMRBones) { bmn.boneIndex = boneTranIndex; boneMatchNodeList.Add(bmn); boneTranIndex++; } } for (int i = 0; i \u003c smrArray.Length; i++) { bindLists.Add(new BindList(smrArray[i].name)); bindLists[i].bindIndexs = tempIntLists[i]; } tempInfo.boneMatchNodes = boneMatchNodeList.ToArray(); tempInfo.bindLists = bindLists.ToArray(); return tempInfo; } private void LogBindPoses() { using(StreamWriter sw = new StreamWriter(\"Assets/GPUSkinning/BindPoses.txt\")) { foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; for (int j = 0; j \u003c smrBoneTrans.Length; j++) { sw.WriteLine(smr.name + \"\\t\" + smrBoneTrans[j].name + \"\\r\\n\" + smrBindPos[j].ToString()); } } } } private void Save() { AssetDatabase.CreateAsset(boneMatchInfo, \"Assets/GPUSkinning/BoneMatchInfo.asset\"); AssetDatabase.Refresh(); Debug.Log(\"","wordCount":"1728","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg","datePublished":"2021-07-11T19:00:00+08:00","dateModified":"2021-07-11T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">支持Animator Controller的实时GPU蒙皮</h1><div class=post-description>虽然不是特别完善，但好歹记录一下做过的事情.</div><div class=post-meta><span title='2021-07-11 19:00:00 +0800 CST'>July 11, 2021</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-gpu-skinning-with-animator-controller.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GPUSkinning.jpg alt="GPU Skinning Cover"><p>GPU Skinning example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>支持Animator Controller的实时GPU蒙皮</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8gpu%e6%9d%a5%e8%bf%9b%e8%a1%8c%e8%92%99%e7%9a%ae aria-label=为什么要用GPU来进行蒙皮>为什么要用GPU来进行蒙皮</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e4%b8%80%e4%ba%9b%e6%83%b3%e6%b3%95 aria-label=GPU蒙皮的一些想法>GPU蒙皮的一些想法</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=GPU蒙皮的操作>GPU蒙皮的操作</a><ul><li><a href=#bonematchinfocs aria-label=BoneMatchInfo.cs>BoneMatchInfo.cs</a></li><li><a href=#bonegpuskinningcs aria-label=BoneGPUSkinning.cs>BoneGPUSkinning.cs</a></li><li><a href=#bonecomputeshadercompute aria-label=BoneComputeShader.compute>BoneComputeShader.compute</a></li><li><a href=#bonegpuskinninghlsl aria-label=BoneGPUSkinning.hlsl>BoneGPUSkinning.hlsl</a></li><li><a href=#bonegpuskinningshadershader aria-label=BoneGPUSkinningShader.shader>BoneGPUSkinningShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=最后的思考>最后的思考</a></li></ul></div></details></div><div class=post-content><h2 id=为什么要用gpu来进行蒙皮>为什么要用GPU来进行蒙皮<a hidden class=anchor aria-hidden=true href=#为什么要用gpu来进行蒙皮>#</a></h2><p>对于一个SkinnedMeshRenderer，在做蒙皮的时候，对于每一个顶点，会先计算出这个顶点对应的四根骨骼的从骨骼空间到物体空间的矩阵\(M_{bone\<em>localtoobject}\)，然后使用\(M</em>{bone\<em>localtoobject} * M</em>{bone\<em>bindpose} * Vertex</em>{objectspace}\)得到经过骨骼平移旋转缩放后的四个带权重的顶点数据位置和切线，对于法线则是使用上面矩阵的逆矩阵的转置。然后对获得的位置、法线和切线，用权重计算得到经过骨骼平移旋转缩放后的实际的顶点信息。在通常的渲染过程中，上述操作是在CPU中进行的，最后把顶点数据传递给GPU中进行渲染。在顶点数较多且主要是矩阵运算的情况下，CPU进行蒙皮的效率就不如高并行的GPU了，因此会考虑到在GPU中进行蒙皮处理。</p><h2 id=gpu蒙皮的一些想法>GPU蒙皮的一些想法<a hidden class=anchor aria-hidden=true href=#gpu蒙皮的一些想法>#</a></h2><p>从上面可以看到，要从CPU中传给GPU的数据有以下几种：一是\(M_{bone\<em>localtoobject} * M</em>{bone\_bindpose}\)这样骨骼数个float4x4的矩阵，但是由于其最后一行是(0, 0, 0, 1)，在传递时可以简化成骨骼数个float3x4矩阵，这些矩阵每一帧都要传递一次；二是每个顶点对应的骨骼编号和骨骼的权重，骨骼编号用来查询骨骼矩阵中对应的矩阵，是一个整型的数据，骨骼权重是一个[0, 1]的小数，可以用\(BoneIndex + BoneWeight * 0.5\)的方式，把编号和权重结合成一个float的数据，这样每个顶点的骨骼编号和权重数据是一个float4的数据，可以保存在UV中，也可以用数组的方式传递给GPU，这些顶点数个float4的数据，只需要传递一次就可以了；再有就是模型本身的顶点位置、法线和切线，这些引擎会自动为我们传递给GPU。</p><p>在实际操作中，网上通常找到的方案是把动画保存在一张贴图或者是一个自定义的数据结构中，这里可以直接保存顶点数据，甚至不需要在GPU中做蒙皮的操作，但是随着顶点数增加会占用大量的空间；或者是保存骨骼的变换矩阵，在GPU中进行蒙皮，相对来说储存空间会小很多。然而我认为这两种都不是很好的做GPU skinning的方法，将动画信息保存到贴图或者数据结构中，会很大程度上失去Animator Controller的功能，如两个动作之间的插值、触发事件等，对于动画来说甚至是得不偿失的一种效果。因此，我希望能够保留Animator Controller的特性，实时的把骨骼数据传送给GPU，在GPU中进行蒙皮操作。</p><h2 id=gpu蒙皮的操作>GPU蒙皮的操作<a hidden class=anchor aria-hidden=true href=#gpu蒙皮的操作>#</a></h2><p>我的想法是，先离线从SkinnedMeshRenderer中获得骨骼的ID和权重，然后实时的从Animator Controller对应的骨骼中获取每根骨骼的骨骼矩阵，再统一传给一个普通的MeshRenderer，在GPU中进行蒙皮的操作。这中间有一个小坑，Unity同一个模型的SkinnedMeshRenderer和MeshRenderer，他们虽然都能获取到boneweight和bindpose，但是SkinnedMeshRenderer和MeshRnederer的骨骼的顺序有时候会有一些差异，因此最好的办法是，抛弃这两者的骨骼顺序，用Hierarchy中的骨骼顺序来确定我们传给GPU的boneindex，boneweight和bonematrix是一致的。</p><p>这里使用的模型及动作是<a href=https://www.mixamo.com/>mixamo</a>的hip hop dancing资源。</p><h3 id=bonematchinfocs>BoneMatchInfo.cs<a hidden class=anchor aria-hidden=true href=#bonematchinfocs>#</a></h3><p>这个脚本的作用是，在离线时把一个GameObjectRoot下的所有SkinnedMeshRenderer和Hierarchy中的骨骼的信息结合起来，保存成一个Asset，用于实时的GPU Skinning。这个Asset包含两部分的信息，一个是BoneMatchNode用于记录Hierarchy骨骼列表中骨骼的名称和其bindpose，另一个是BindIndex用于记录所有SkinnedMeshRenderer的骨骼在Hierarchy骨骼列表中的顺序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> GPUSkinning
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [System.Serializable]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchNode</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//[HideInInspector]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> boneName;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//在查找位于所有Transfom的位置时，设置并使用boneIndex</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> boneIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Matrix4x4 bindPose;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchNode(<span style=color:#66d9ef>string</span> _boneName)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            boneName = _boneName;
</span></span><span style=display:flex><span>            bindPose = Matrix4x4.identity;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [System.Serializable]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BindList</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//[HideInInspector]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> skinnedMeshName;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span>[] bindIndexs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BindList(<span style=color:#66d9ef>string</span> _skinnedMeshName)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            skinnedMeshName = _skinnedMeshName;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchInfo</span> : ScriptableObject
</span></span><span style=display:flex><span>    {   
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchNode[] boneMatchNodes;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BindList[] bindLists;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GenerateBoneMatchInfo</span> : EditorWindow
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Transform rootBone;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Transform skinnedParent;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> skinnedMeshCount = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> SkinnedMeshRenderer[] smrArray;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Rect topToolBarRect
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>, position.width - <span style=color:#ae81ff>40</span>, position.height - <span style=color:#ae81ff>20</span>); }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [MenuItem(&#34;zznewclear13/Generate Bone Match Info&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GenerateBoneMatchInfo GetWindow()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GenerateBoneMatchInfo window = GetWindow&lt;GenerateBoneMatchInfo&gt;();
</span></span><span style=display:flex><span>            window.titleContent = <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;Generate Bone Match Info&#34;</span>);
</span></span><span style=display:flex><span>            window.Focus();
</span></span><span style=display:flex><span>            window.Repaint();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> window;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            TopToolBar(topToolBarRect);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TopToolBar(Rect rect)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GUILayout.BeginArea(rect);
</span></span><span style=display:flex><span>            rootBone = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Root Bone Transform&#34;</span>, rootBone, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            skinnedParent = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Parent Transform&#34;</span>, skinnedParent, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(skinnedParent!=<span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                smrArray = skinnedParent.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(smrArray != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(<span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Mesh Renderers&#34;</span>, smrArray[<span style=color:#ae81ff>0</span>], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; smrArray.Length; i++)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34; &#34;</span>, smrArray[i], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(smrArray.Length &lt;= <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Generate Animator Map&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30f</span>) }))
</span></span><span style=display:flex><span>                        {                           
</span></span><span style=display:flex><span>                            boneMatchInfo = CompareBones();
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//LogBindPoses();</span>
</span></span><span style=display:flex><span>                            Save();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            GUILayout.EndArea();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> BoneMatchInfo CompareBones()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            BoneMatchInfo tempInfo = <span style=color:#66d9ef>new</span> BoneMatchInfo();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Transform[] boneTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
</span></span><span style=display:flex><span>            List&lt;BoneMatchNode&gt; boneMatchNodeList = <span style=color:#66d9ef>new</span> List&lt;BoneMatchNode&gt;();
</span></span><span style=display:flex><span>            List&lt;BindList&gt; bindLists = <span style=color:#66d9ef>new</span> List&lt;BindList&gt;();
</span></span><span style=display:flex><span>            List&lt;<span style=color:#66d9ef>int</span>[]&gt; tempIntLists = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>[]&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            List&lt;Transform[]&gt; smrBoneTransList = <span style=color:#66d9ef>new</span> List&lt;Transform[]&gt;();
</span></span><span style=display:flex><span>            List&lt;Matrix4x4[]&gt; smrBindPoseList = <span style=color:#66d9ef>new</span> List&lt;Matrix4x4[]&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Transform[] smrBoneTrans = smr.bones;
</span></span><span style=display:flex><span>                Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
</span></span><span style=display:flex><span>                smrBoneTransList.Add(smrBoneTrans);
</span></span><span style=display:flex><span>                smrBindPoseList.Add(smrBindPos);
</span></span><span style=display:flex><span>                tempIntLists.Add(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[smr.bones.Length]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> boneTranIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (Transform boneTran <span style=color:#66d9ef>in</span> boneTrans)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                BoneMatchNode bmn = <span style=color:#66d9ef>new</span> BoneMatchNode(boneTran.name);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bool</span> isInSMRBones = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrBoneTransList.Count; i++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> index = Array.IndexOf(smrBoneTransList[i], boneTran);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (index &gt;= <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        isInSMRBones = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        bmn.bindPose = smrBindPoseList[i][index];
</span></span><span style=display:flex><span>                        tempIntLists[i][index] = boneTranIndex;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (isInSMRBones)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    bmn.boneIndex = boneTranIndex;
</span></span><span style=display:flex><span>                    boneMatchNodeList.Add(bmn);
</span></span><span style=display:flex><span>                    boneTranIndex++;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrArray.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                bindLists.Add(<span style=color:#66d9ef>new</span> BindList(smrArray[i].name));
</span></span><span style=display:flex><span>                bindLists[i].bindIndexs = tempIntLists[i];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            tempInfo.boneMatchNodes = boneMatchNodeList.ToArray();
</span></span><span style=display:flex><span>            tempInfo.bindLists = bindLists.ToArray();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> tempInfo;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> LogBindPoses()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            using(StreamWriter sw = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;Assets/GPUSkinning/BindPoses.txt&#34;</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Transform[] smrBoneTrans = smr.bones;
</span></span><span style=display:flex><span>                    Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; smrBoneTrans.Length; j++)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        sw.WriteLine(smr.name + <span style=color:#e6db74>&#34;\t&#34;</span> + smrBoneTrans[j].name + <span style=color:#e6db74>&#34;\r\n&#34;</span> + smrBindPos[j].ToString());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Save()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            AssetDatabase.CreateAsset(boneMatchInfo, <span style=color:#e6db74>&#34;Assets/GPUSkinning/BoneMatchInfo.asset&#34;</span>);
</span></span><span style=display:flex><span>            AssetDatabase.Refresh();
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;&lt;color=blue&gt;Bone Match Info has been saved to Assets/GPUSkinning/BoneMatchInfo.asset.&lt;/color&gt;&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后得到的<code>BoneMatchInfo.asset</code>和Hierarchy的关系如图所示，部分不参与实际蒙皮的骨骼，就不需要记录到<code>BoneMatchInfo.asset</code>中了：</p><p><img loading=lazy src=../images/BoneMatchInfo.jpg#center alt=BoneMatchInfo></p><h3 id=bonegpuskinningcs>BoneGPUSkinning.cs<a hidden class=anchor aria-hidden=true href=#bonegpuskinningcs>#</a></h3><p>在<code>BoneGPUSkinning.cs</code>这个脚本中，要做的事情是：把骨骼的编号和权重写到UV中，只用执行一次；把骨骼矩阵和bindpose的乘积传到GPU中，每帧执行一次，我把这个操作放在了compute shader中进行计算。根据前面的描述，我们需要获取\(M_{bone\<em>localtoobject}\)，这个值等价于\(M</em>{object\<em>worldtolocal} * M</em>{bone\<em>localtoworld}\)。但是在实际的操作中，获取一根骨骼的\(M</em>{bone\_localtoworld}\)矩阵会导致额外的运算，使得GPU Skinning的效率受到了很大的限制。这里有可能是我不够熟悉Unity的API的原因，当然也有可能是Unity本身就没开放相关的API的原因。照理来说，Unity要把Animator的平移旋转缩放动画应用到每一个骨骼上时，已经计算过了每根骨骼的localToWorldMatrix，获取这个矩阵应该能做到没有任何消耗的。但是没有办法，我只能试图使用<code>Unity Jobs</code>和<code>Unity Burst</code>来加速获取localToWorldMatrix的过程，在我的测试中，相比于直接用for循环获取大概能有至少50%的速度提升（记不太清了），然而对于整个GPU Skinning的过程来说，消耗还是太高了。</p><p>因为是比较久之前写的代码了，也懒得去再仔细地修正，<code>[ExecuteInEditMode]</code>在设置好各个引用之前会疯狂的报错，不过在设置好正确的引用之后重新启用脚本就不会有任何的问题了。似乎操作不当也会出现内存泄漏的问题，不过无伤大雅。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Jobs;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.Jobs;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Burst;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> GPUSkinning
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [ExecuteInEditMode]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneGPUSkinning</span> : MonoBehaviour
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> BONE_WEIGHT_DECODE_VALUE = <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> BONE_WEIGHT_INVERSE_DECODE_VALUE = <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Transform rootBone;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> List&lt;MeshRenderer&gt; meshRenderers;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [SerializeField]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> boneSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Transform[] minBoneTrans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TransformAccessArray transformAccessArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#region</span> ComputeShader
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4[] bindPosesArray;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4[] LTWMatrixArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> bindPoseID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneBindPoseBuffer&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> LTWMatrixID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneLTWMatrixBuffer&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> outputBufferID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneOutputBuffer&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer outputBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer bindPoseBuffer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer ltwMatrixBuffer;
</span></span><span style=display:flex><span>        <span style=color:#75715e>#endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#region</span> InitializeFunction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Initialize();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// 全部的初始化</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            InitializeBoneTrans();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            InitializeBoneUV(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            InitializeComputeShader();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// 整合所有mesh绑定的骨骼，从rootBone的子物件中找出minBoneTrans</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeBoneTrans()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//标记每个mesh对应的骨骼</span>
</span></span><span style=display:flex><span>            Transform[] allTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
</span></span><span style=display:flex><span>            Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt; allTransDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (Transform tran <span style=color:#66d9ef>in</span> allTrans)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                allTransDict.Add(tran.name, tran);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            boneSize = boneMatchInfo.boneMatchNodes.Length;
</span></span><span style=display:flex><span>            minBoneTrans = <span style=color:#66d9ef>new</span> Transform[boneSize];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Transform tempTran = allTransDict[boneMatchInfo.boneMatchNodes[i].boneName];
</span></span><span style=display:flex><span>                boneMatchInfo.boneMatchNodes[i].boneIndex = i;
</span></span><span style=display:flex><span>                minBoneTrans[i] = tempTran;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            transformAccessArray = <span style=color:#66d9ef>new</span> TransformAccessArray(minBoneTrans);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// 把骨骼的编号和权重写入到targetUVIndex对应的UV中</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;param name=&#34;targetUVIndex&#34;&gt;&lt;/param&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> InitializeBoneUV(<span style=color:#66d9ef>int</span> targetUVIndex)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt; bindListDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneMatchInfo.bindLists.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                bindListDict.Add(boneMatchInfo.bindLists[i].skinnedMeshName, boneMatchInfo.bindLists[i]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                BindList tempBindList;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bool</span> hasBindList = bindListDict.TryGetValue(meshRenderers[i].name, <span style=color:#66d9ef>out</span> tempBindList);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(!hasBindList)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentException(String.Format(<span style=color:#e6db74>&#34;SkinnedMeshName:{0}在BoneMatchInfo中找不到！&#34;</span>,
</span></span><span style=display:flex><span>                                                boneMatchInfo.bindLists[i].skinnedMeshName));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Mesh mesh = meshRenderers[i].GetComponent&lt;MeshFilter&gt;().sharedMesh;
</span></span><span style=display:flex><span>                BoneWeight[] boneWeights = mesh.boneWeights;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                List&lt;Vector4&gt; boneAndWeights = <span style=color:#66d9ef>new</span> List&lt;Vector4&gt;();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span>[] bindIndexes = tempBindList.bindIndexs;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (BoneWeight weight <span style=color:#66d9ef>in</span> boneWeights)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Vector4 boneAndWeight = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//Shader中个BoneUV都会查找全局的骨骼编号</span>
</span></span><span style=display:flex><span>                    boneAndWeight.x = bindIndexes[weight.boneIndex0] + weight.weight0 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeight.y = bindIndexes[weight.boneIndex1] + weight.weight1 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeight.z = bindIndexes[weight.boneIndex2] + weight.weight2 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeight.w = bindIndexes[weight.boneIndex3] + weight.weight3 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
</span></span><span style=display:flex><span>                    boneAndWeights.Add(boneAndWeight);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                mesh.SetUVs(targetUVIndex, boneAndWeights.ToArray());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (buffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                buffer.Release();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// 初始化ComputeShader，用于计算每根骨骼的矩阵和bindpos的乘积</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeComputeShader()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            bindPosesArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
</span></span><span style=display:flex><span>            LTWMatrixArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
</span></span><span style=display:flex><span>            Debug.Log(LTWMatrixArray.Length);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                bindPosesArray[i] = boneMatchInfo.boneMatchNodes[i].bindPose;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;MatCompute&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> outputBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> bindPoseBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ltwMatrixBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            bindPoseBuffer.SetData(bindPosesArray);
</span></span><span style=display:flex><span>            computeShader.SetBuffer(kernel, bindPoseID, bindPoseBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            computeShader.SetBuffer(kernel, outputBufferID, outputBuffer);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#region</span> Update Function
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            InvokeComputeShader();
</span></span><span style=display:flex><span>            PassMeshRendererMatrix();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [BurstCompile(CompileSynchronously = true)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GetLocalToWorldMatrixStructJob</span> : IJobParallelForTransform
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> NativeArray&lt;Matrix4x4&gt; matArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i, TransformAccess transform)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                matArray[i] = transform.localToWorldMatrix;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InvokeComputeShader()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(computeShader)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//NativeList&lt;JobHandle&gt; jobHandleList = new NativeList&lt;JobHandle&gt;(Allocator.Temp);</span>
</span></span><span style=display:flex><span>                NativeArray&lt;Matrix4x4&gt; matArray = <span style=color:#66d9ef>new</span> NativeArray&lt;Matrix4x4&gt;(boneSize, Allocator.Persistent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                GetLocalToWorldMatrixStructJob job = <span style=color:#66d9ef>new</span> GetLocalToWorldMatrixStructJob
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    matArray = matArray
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                JobHandle jobHandle = IJobParallelForTransformExtensions.Schedule(job, transformAccessArray);<span style=color:#75715e>// job.Schedule(transformAccessArray);</span>
</span></span><span style=display:flex><span>                jobHandle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                ltwMatrixBuffer.SetData(matArray);
</span></span><span style=display:flex><span>                matArray.Dispose();
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    LTWMatrixArray[i] = minBoneTrans[i].localToWorldMatrix;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ltwMatrixBuffer.SetData(LTWMatrixArray);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                computeShader.SetBuffer(kernel, LTWMatrixID, ltwMatrixBuffer);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> dispatchCount = Mathf.CeilToInt(boneSize / <span style=color:#ae81ff>64f</span>);
</span></span><span style=display:flex><span>                computeShader.Dispatch(kernel, dispatchCount, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                Shader.SetGlobalBuffer(<span style=color:#e6db74>&#34;_BoneMatArray&#34;</span>, outputBuffer);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PassMeshRendererMatrix()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (Material mat <span style=color:#66d9ef>in</span> meshRenderers[i].sharedMaterials)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    mat.SetMatrix(<span style=color:#e6db74>&#34;_BoneTransformMatrix&#34;</span>, meshRenderers[i].transform.worldToLocalMatrix);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            outputBuffer.Release();
</span></span><span style=display:flex><span>            outputBuffer = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            transformAccessArray.Dispose();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bonecomputeshadercompute>BoneComputeShader.compute<a hidden class=anchor aria-hidden=true href=#bonecomputeshadercompute>#</a></h3><p>这个compute shader仅仅做了矩阵的运算，甚至都不见得比在CPU中运算要快，不过这边还是使用了compute shader来做这个运算，稍微还能优化的是float4x4可以改成float3x4，不过这样CPU的代码写起来稍乱一些。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel MatCompute</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneBindPoseBuffer;
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneLTWMatrixBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWStructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneOutputBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>64</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> MatCompute(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _BoneOutputBuffer[id.x] <span style=color:#f92672>=</span> mul(_BoneLTWMatrixBuffer[id.x], _BoneBindPoseBuffer[id.x]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bonegpuskinninghlsl>BoneGPUSkinning.hlsl<a hidden class=anchor aria-hidden=true href=#bonegpuskinninghlsl>#</a></h3><p>操作流程是这样的，对每一个顶点定义一个结构体<code>VertexInputStructure</code>，读取MeshRenderer的原始数据中的位置、法线、切线和我们传入的骨骼编号和权重。使用编号去寻找<code>_BoneMatArray</code>中对应的\(M_{bone\<em>localtoworld}\)，再左乘<code>_BoneTransformMatrix</code>也就是之前说过\(M</em>{object\_worldtolocal}\)，使用这两个矩阵的乘积就能分别计算蒙皮后的顶点位置、切线和法线了，要注意的是法线需要做一次逆矩阵的转置。最后对四对顶点位置、切线和法线进行加权计算，获得最终的顶点位置、切线和法线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#ifndef BONE_GPU_SKINNING</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BONE_GPU_SKINNING</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BONE_WEIGHT_DECODE_VALUE 2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4x4</span><span style=color:#f92672>&gt;</span> _BoneMatArray;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4x4</span> _BoneTransformMatrix;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> VertexInputStructure
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> tangentOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> boneUV;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> VertexOutputStructure
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> tangentOS;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float3x3</span> InverseTranspose(<span style=color:#66d9ef>float3x3</span> mat)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> determinant <span style=color:#f92672>=</span> mat._m00 <span style=color:#f92672>*</span> (mat._m11 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m12 <span style=color:#f92672>*</span> mat._m21)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>-</span> mat._m01 <span style=color:#f92672>*</span> (mat._m10 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m12 <span style=color:#f92672>*</span> mat._m20)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> mat._m02 <span style=color:#f92672>*</span> (mat._m10 <span style=color:#f92672>*</span> mat._m21 <span style=color:#f92672>-</span> mat._m11 <span style=color:#f92672>*</span> mat._m20);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vec0 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(mat._m11 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m12 <span style=color:#f92672>*</span> mat._m21,
</span></span><span style=display:flex><span>                        mat._m12 <span style=color:#f92672>*</span> mat._m20 <span style=color:#f92672>-</span> mat._m10 <span style=color:#f92672>*</span> mat._m22,
</span></span><span style=display:flex><span>                        mat._m10 <span style=color:#f92672>*</span> mat._m21 <span style=color:#f92672>-</span> mat._m11 <span style=color:#f92672>*</span> mat._m20);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vec1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(mat._m02 <span style=color:#f92672>*</span> mat._m21 <span style=color:#f92672>-</span> mat._m01 <span style=color:#f92672>*</span> mat._m22,
</span></span><span style=display:flex><span>                        mat._m00 <span style=color:#f92672>*</span> mat._m22 <span style=color:#f92672>-</span> mat._m02 <span style=color:#f92672>*</span> mat._m20,
</span></span><span style=display:flex><span>                        mat._m01 <span style=color:#f92672>*</span> mat._m20 <span style=color:#f92672>-</span> mat._m00 <span style=color:#f92672>*</span> mat._m21);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vec2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(mat._m01 <span style=color:#f92672>*</span> mat._m12 <span style=color:#f92672>-</span> mat._m02 <span style=color:#f92672>*</span> mat._m11,
</span></span><span style=display:flex><span>                        mat._m02 <span style=color:#f92672>*</span> mat._m10 <span style=color:#f92672>-</span> mat._m00 <span style=color:#f92672>*</span> mat._m12,
</span></span><span style=display:flex><span>                        mat._m00 <span style=color:#f92672>*</span> mat._m11 <span style=color:#f92672>-</span> mat._m01 <span style=color:#f92672>*</span> mat._m10);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> returnMat;
</span></span><span style=display:flex><span>    returnMat._m00_m01_m02 <span style=color:#f92672>=</span> vec0;
</span></span><span style=display:flex><span>    returnMat._m10_m11_m12 <span style=color:#f92672>=</span> vec1;
</span></span><span style=display:flex><span>    returnMat._m20_m21_m22 <span style=color:#f92672>=</span> vec2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> returnMat <span style=color:#f92672>/</span> determinant;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float3x3</span> InverseTransposeVec(<span style=color:#66d9ef>float3</span> vec0, <span style=color:#66d9ef>float3</span> vec1, <span style=color:#66d9ef>float3</span> vec2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> mat;
</span></span><span style=display:flex><span>    mat._m00_m01_m02 <span style=color:#f92672>=</span> vec0;
</span></span><span style=display:flex><span>    mat._m10_m11_m12 <span style=color:#f92672>=</span> vec1;
</span></span><span style=display:flex><span>    mat._m20_m21_m22 <span style=color:#f92672>=</span> vec2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> InverseTranspose(mat);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float4x4</span> ReadBoneInfos(<span style=color:#66d9ef>uint</span> boneIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mul(_BoneTransformMatrix, _BoneMatArray[boneIndex]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> VertexOutputStructure BlendBonesPosNormalTangent(VertexInputStructure input)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionOS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(input.positionOS, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOS <span style=color:#f92672>=</span> input.normalOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> tangentOS <span style=color:#f92672>=</span> input.tangentOS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> boneUV <span style=color:#f92672>=</span> input.boneUV;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexOne <span style=color:#f92672>=</span> floor(boneUV.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightOne <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexTwo <span style=color:#f92672>=</span> floor(boneUV.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightTwo <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexThree <span style=color:#f92672>=</span> floor(boneUV.z);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightThree <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> boneIndexFour <span style=color:#f92672>=</span> floor(boneUV.w);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> boneWeightFour <span style=color:#f92672>=</span> BONE_WEIGHT_DECODE_VALUE <span style=color:#f92672>*</span> frac(boneUV.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matOne <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexOne);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matTwo <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexTwo);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matThree <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexThree);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> matFour <span style=color:#f92672>=</span> ReadBoneInfos(boneIndexFour);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//blend position</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posOne <span style=color:#f92672>=</span> mul(matOne, positionOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posTwo <span style=color:#f92672>=</span> mul(matTwo, positionOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posThree <span style=color:#f92672>=</span> mul(matThree, positionOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> posFour <span style=color:#f92672>=</span> mul(matFour, positionOS).xyz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> returnPos <span style=color:#f92672>=</span> posOne <span style=color:#f92672>*</span> boneWeightOne
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> posTwo <span style=color:#f92672>*</span> boneWeightTwo
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> posThree <span style=color:#f92672>*</span> boneWeightThree
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> posFour <span style=color:#f92672>*</span> boneWeightFour;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//blend normal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatOne <span style=color:#f92672>=</span> InverseTransposeVec(matOne._m00_m01_m02, matOne._m10_m11_m12, matOne._m20_m21_m22);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatTwo <span style=color:#f92672>=</span> InverseTransposeVec(matTwo._m00_m01_m02, matTwo._m10_m11_m12, matTwo._m20_m21_m22);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatThree <span style=color:#f92672>=</span> InverseTransposeVec(matThree._m00_m01_m02, matThree._m10_m11_m12, matThree._m20_m21_m22);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3x3</span> newMatFour <span style=color:#f92672>=</span> InverseTransposeVec(matFour._m00_m01_m02, matFour._m10_m11_m12, matFour._m20_m21_m22);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalOne <span style=color:#f92672>=</span> mul(newMatOne, normalOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalTwo <span style=color:#f92672>=</span> mul(newMatTwo, normalOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalThree <span style=color:#f92672>=</span> mul(newMatThree, normalOS).xyz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalFour <span style=color:#f92672>=</span> mul(newMatFour, normalOS).xyz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> returnNormal <span style=color:#f92672>=</span> normalOne <span style=color:#f92672>*</span> boneWeightOne
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> normalTwo <span style=color:#f92672>*</span> boneWeightTwo
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> normalThree <span style=color:#f92672>*</span> boneWeightThree
</span></span><span style=display:flex><span>        <span style=color:#f92672>+</span> normalFour <span style=color:#f92672>*</span> boneWeightFour;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    returnNormal <span style=color:#f92672>=</span> normalize(returnNormal);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//blend tangent</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentOne <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matOne, tangentOS.xyz);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentTwo <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matTwo, tangentOS.xyz);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentThree <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matThree, tangentOS.xyz);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tangentFour <span style=color:#f92672>=</span> mul((<span style=color:#66d9ef>float3x3</span>)matFour, tangentOS.xyz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> tempTangent <span style=color:#f92672>=</span> tangentOne <span style=color:#f92672>*</span> boneWeightOne
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> tangentTwo <span style=color:#f92672>*</span> boneWeightTwo
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> tangentThree <span style=color:#f92672>*</span> boneWeightThree
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> tangentFour <span style=color:#f92672>*</span> boneWeightFour;
</span></span><span style=display:flex><span>    tempTangent <span style=color:#f92672>=</span> normalize(tempTangent);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> returnTangent <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(tempTangent, tangentOS.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    VertexOutputStructure output;
</span></span><span style=display:flex><span>    output.positionOS <span style=color:#f92672>=</span> returnPos;
</span></span><span style=display:flex><span>    output.normalOS <span style=color:#f92672>=</span> returnNormal;
</span></span><span style=display:flex><span>    output.tangentOS <span style=color:#f92672>=</span> returnTangent;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><h3 id=bonegpuskinningshadershader>BoneGPUSkinningShader.shader<a hidden class=anchor aria-hidden=true href=#bonegpuskinningshadershader>#</a></h3><p>用于渲染的shader中，要在顶点着色器中调用<code>BoneGPUSkinning.hlsl</code>中的方法获取蒙皮后的顶点位置、切线和法线。我这里使用了一个比较简单的渲染，给模型一点基础的光影。要注意的是，如果需要正确的阴影的话，在<code>ShadowCaster</code>这个pass中还需要计算一遍顶点位置，这里就暂且忽略了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/BoneGPUSkinningShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _Color (<span style=color:#e6db74>&#34;Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Albedo (RGB)&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;RenderPipeline&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UniversalPipeline&#34;</span> <span style=color:#e6db74>&#34;IgnoreProjector&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;True&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HLSLINCLUDE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Assets/GPUSkinning/BoneGPUSkinning.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sampler2D _MainTex;
</span></span><span style=display:flex><span>        CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> _Color;
</span></span><span style=display:flex><span>        CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> a2v
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> vertex   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uv       <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> boneUV   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> normal   <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> tangent  <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> v2f
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> pos          <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> tempColor    <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> normalWS     <span style=color:#f92672>:</span> TEXCOORD2;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> tangentWS    <span style=color:#f92672>:</span> TEXCOORD3;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> eyeVec       <span style=color:#f92672>:</span> TEXCOORD4;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        v2f animVert(a2v v)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            v2f o;
</span></span><span style=display:flex><span>            VertexInputStructure inputStructure;
</span></span><span style=display:flex><span>            inputStructure.positionOS <span style=color:#f92672>=</span> v.vertex;
</span></span><span style=display:flex><span>            inputStructure.normalOS <span style=color:#f92672>=</span> v.normal;
</span></span><span style=display:flex><span>            inputStructure.tangentOS <span style=color:#f92672>=</span> v.tangent;
</span></span><span style=display:flex><span>            inputStructure.boneUV <span style=color:#f92672>=</span> v.boneUV;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            VertexOutputStructure outputStructure <span style=color:#f92672>=</span> BlendBonesPosNormalTangent(inputStructure);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> vertexPos <span style=color:#f92672>=</span> outputStructure.positionOS;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> vertexNormal <span style=color:#f92672>=</span> outputStructure.normalOS;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> vertexTangent <span style=color:#f92672>=</span> outputStructure.tangentOS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            o.pos <span style=color:#f92672>=</span> TransformObjectToHClip(vertexPos);
</span></span><span style=display:flex><span>            o.normalWS <span style=color:#f92672>=</span> TransformObjectToWorldNormal(vertexNormal);
</span></span><span style=display:flex><span>            o.tangentWS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(TransformObjectToWorldDir(vertexTangent), v.tangent.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            o.uv <span style=color:#f92672>=</span> v.uv;
</span></span><span style=display:flex><span>            o.tempColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> worldPos <span style=color:#f92672>=</span> TransformObjectToWorld(<span style=color:#66d9ef>float4</span>(vertexPos, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            o.eyeVec <span style=color:#f92672>=</span> GetCameraPositionWS() <span style=color:#f92672>-</span> worldPos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> o;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> animFrag(v2f i) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> viewDir <span style=color:#f92672>=</span> normalize(i.eyeVec);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> lightDir <span style=color:#f92672>=</span> normalize(<span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> halfVec <span style=color:#f92672>=</span> normalize(lightDir <span style=color:#f92672>+</span> viewDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> normalWS <span style=color:#f92672>=</span> normalize(i.normalWS);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> NdotL <span style=color:#f92672>=</span> dot(normalWS, lightDir) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.6</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.4</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> NdotH <span style=color:#f92672>=</span> saturate(dot(normalWS, halfVec));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> diffuseColor <span style=color:#f92672>=</span> _Color.xyz <span style=color:#f92672>*</span> NdotL;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> specularColor <span style=color:#f92672>=</span> pow(NdotH, <span style=color:#ae81ff>30</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(diffuseColor <span style=color:#f92672>+</span> specularColor, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ENDHLSL
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Tags{ <span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UniversalForward&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex animVert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment animFrag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=最后的思考>最后的思考<a hidden class=anchor aria-hidden=true href=#最后的思考>#</a></h2><p>总的来说，上面的操作已经基本完成了GPU Skinning的需求，而且能够正确的与Animator组件相结合。当然仍有优化的空间，比如说把所有要做GPU Skinning的mesh使用同一个Update的方法来更新，等等。但是美中不足的是之前提到的获取localToWorldMatrix的问题，直接导致了使用这个方法不如Unity自带的GPU Skinning效率高，自带的GPU蒙皮应该是用到了Unity底层的一些优化吧，但是核心的操作应该和我这里做的差不多。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/gpu-skinning/>GPU Skinning</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><span class=title>« Prev</span><br><span>在Unity SRP中实现TAA效果</span>
</a><a class=next href=https://zznewclear13.github.io/posts/get-world-space-position-from-depth-texture/><span class=title>Next »</span><br><span>从深度图中获取世界空间的坐标</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>