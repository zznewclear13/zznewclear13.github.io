<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>支持Animator Controller的实时GPU蒙皮 | ZZNEWCLEAR13</title><meta name=keywords content="GPU Skinning"><meta name=description content="虽然不是特别完善，但好歹记录一下做过的事情."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><link crossorigin=anonymous href=/assets/css/stylesheet.min.05062af87031756c80e5d65f0cc75e37e589bbf77383569463393b1f73d94f87.css integrity="sha256-BQYq+HAxdWyA5dZfDMdeN+WJu/dzg1aUYzk7H3PZT4c=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="支持Animator Controller的实时GPU蒙皮"><meta property="og:description" content="虽然不是特别完善，但好歹记录一下做过的事情."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-11T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-11T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg"><meta name=twitter:title content="支持Animator Controller的实时GPU蒙皮"><meta name=twitter:description content="虽然不是特别完善，但好歹记录一下做过的事情."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"支持Animator Controller的实时GPU蒙皮","item":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"支持Animator Controller的实时GPU蒙皮","name":"支持Animator Controller的实时GPU蒙皮","description":"虽然不是特别完善，但好歹记录一下做过的事情.","keywords":["GPU Skinning"],"articleBody":"为什么要用GPU来进行蒙皮 对于一个SkinnedMeshRenderer，在做蒙皮的时候，对于每一个顶点，会先计算出这个顶点对应的四根骨骼的从骨骼空间到物体空间的矩阵\\(M_{bone\\_localtoobject}\\)，然后使用\\(M_{bone\\_localtoobject} * M_{bone\\_bindpose} * Vertex_{objectspace}\\)得到经过骨骼平移旋转缩放后的四个带权重的顶点数据位置和切线，对于法线则是使用上面矩阵的逆矩阵的转置。然后对获得的位置、法线和切线，用权重计算得到经过骨骼平移旋转缩放后的实际的顶点信息。在通常的渲染过程中，上述操作是在CPU中进行的，最后把顶点数据传递给GPU中进行渲染。在顶点数较多且主要是矩阵运算的情况下，CPU进行蒙皮的效率就不如高并行的GPU了，因此会考虑到在GPU中进行蒙皮处理。\nGPU蒙皮的一些想法 从上面可以看到，要从CPU中传给GPU的数据有以下几种：一是\\(M_{bone\\_localtoobject} * M_{bone\\_bindpose}\\)这样骨骼数个float4x4的矩阵，但是由于其最后一行是(0, 0, 0, 1)，在传递时可以简化成骨骼数个float3x4矩阵，这些矩阵每一帧都要传递一次；二是每个顶点对应的骨骼编号和骨骼的权重，骨骼编号用来查询骨骼矩阵中对应的矩阵，是一个整型的数据，骨骼权重是一个[0, 1]的小数，可以用\\(BoneIndex + BoneWeight * 0.5\\)的方式，把编号和权重结合成一个float的数据，这样每个顶点的骨骼编号和权重数据是一个float4的数据，可以保存在UV中，也可以用数组的方式传递给GPU，这些顶点数个float4的数据，只需要传递一次就可以了；再有就是模型本身的顶点位置、法线和切线，这些引擎会自动为我们传递给GPU。\n在实际操作中，网上通常找到的方案是把动画保存在一张贴图或者是一个自定义的数据结构中，这里可以直接保存顶点数据，甚至不需要在GPU中做蒙皮的操作，但是随着顶点数增加会占用大量的空间；或者是保存骨骼的变换矩阵，在GPU中进行蒙皮，相对来说储存空间会小很多。然而我认为这两种都不是很好的做GPU skinning的方法，将动画信息保存到贴图或者数据结构中，会很大程度上失去Animator Controller的功能，如两个动作之间的插值、触发事件等，对于动画来说甚至是得不偿失的一种效果。因此，我希望能够保留Animator Controller的特性，实时的把骨骼数据传送给GPU，在GPU中进行蒙皮操作。\nGPU蒙皮的操作 我的想法是，先离线从SkinnedMeshRenderer中获得骨骼的ID和权重，然后实时的从Animator Controller对应的骨骼中获取每根骨骼的骨骼矩阵，再统一传给一个普通的MeshRenderer，在GPU中进行蒙皮的操作。这中间有一个小坑，Unity同一个模型的SkinnedMeshRenderer和MeshRenderer，他们虽然都能获取到boneweight和bindpose，但是SkinnedMeshRenderer和MeshRnederer的骨骼的顺序有时候会有一些差异，因此最好的办法是，抛弃这两者的骨骼顺序，用Hierarchy中的骨骼顺序来确定我们传给GPU的boneindex，boneweight和bonematrix是一致的。\n这里使用的模型及动作是mixamo的hip hop dancing资源。\nBoneMatchInfo.cs 这个脚本的作用是，在离线时把一个GameObjectRoot下的所有SkinnedMeshRenderer和Hierarchy中的骨骼的信息结合起来，保存成一个Asset，用于实时的GPU Skinning。这个Asset包含两部分的信息，一个是BoneMatchNode用于记录Hierarchy骨骼列表中骨骼的名称和其bindpose，另一个是BindIndex用于记录所有SkinnedMeshRenderer的骨骼在Hierarchy骨骼列表中的顺序。\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System; using System.IO; namespace GPUSkinning { [System.Serializable] public class BoneMatchNode { //[HideInInspector]  public string boneName; //在查找位于所有Transfom的位置时，设置并使用boneIndex  public int boneIndex = 0; public Matrix4x4 bindPose; public BoneMatchNode(string _boneName) { boneName = _boneName; bindPose = Matrix4x4.identity; } } [System.Serializable] public class BindList { //[HideInInspector]  public string skinnedMeshName; public int[] bindIndexs; public BindList(string _skinnedMeshName) { skinnedMeshName = _skinnedMeshName; } } public class BoneMatchInfo : ScriptableObject { public BoneMatchNode[] boneMatchNodes; public BindList[] bindLists; } public class GenerateBoneMatchInfo : EditorWindow { public Transform rootBone; public Transform skinnedParent; public int skinnedMeshCount = 0; public SkinnedMeshRenderer[] smrArray; public BoneMatchInfo boneMatchInfo; private Rect topToolBarRect { get { return new Rect(20, 10, position.width - 40, position.height - 20); } } [MenuItem(\"zznewclear13/Generate Bone Match Info\")] public static GenerateBoneMatchInfo GetWindow() { GenerateBoneMatchInfo window = GetWindow(); window.titleContent = new GUIContent(\"Generate Bone Match Info\"); window.Focus(); window.Repaint(); return window; } void OnGUI() { TopToolBar(topToolBarRect); } private void TopToolBar(Rect rect) { GUILayout.BeginArea(rect); rootBone = (Transform)EditorGUILayout.ObjectField(\"Root Bone Transform\", rootBone, typeof(Transform), true); skinnedParent = (Transform)EditorGUILayout.ObjectField(\"Skinned Parent Transform\", skinnedParent, typeof(Transform), true); if(skinnedParent!=null) { smrArray = skinnedParent.GetComponentsInChildren(); if(smrArray != null) { using (new EditorGUI.DisabledGroupScope(true)) { EditorGUILayout.ObjectField(\"Skinned Mesh Renderers\", smrArray[0], typeof(SkinnedMeshRenderer), false); for (int i = 1; i \" \", smrArray[i], typeof(SkinnedMeshRenderer), false); } } using (new EditorGUI.DisabledGroupScope(smrArray.Length 0)) { if (GUILayout.Button(\"Generate Animator Map\", new GUILayoutOption[] { GUILayout.Height(30f) })) { boneMatchInfo = CompareBones(); //LogBindPoses();  Save(); } } } } GUILayout.EndArea(); } private BoneMatchInfo CompareBones() { BoneMatchInfo tempInfo = new BoneMatchInfo(); Transform[] boneTrans = rootBone.GetComponentsInChildren(); List boneMatchNodeList = new List(); List bindLists = new List(); Listint[] tempIntLists = new Listint[](); List smrBoneTransList = new List(); List smrBindPoseList = new List(); foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; smrBoneTransList.Add(smrBoneTrans); smrBindPoseList.Add(smrBindPos); tempIntLists.Add(new int[smr.bones.Length]); } int boneTranIndex = 0; foreach (Transform boneTran in boneTrans) { BoneMatchNode bmn = new BoneMatchNode(boneTran.name); bool isInSMRBones = false; for (int i = 0; i int index = Array.IndexOf(smrBoneTransList[i], boneTran); if (index = 0) { isInSMRBones = true; bmn.bindPose = smrBindPoseList[i][index]; tempIntLists[i][index] = boneTranIndex; } } if (isInSMRBones) { bmn.boneIndex = boneTranIndex; boneMatchNodeList.Add(bmn); boneTranIndex++; } } for (int i = 0; i new BindList(smrArray[i].name)); bindLists[i].bindIndexs = tempIntLists[i]; } tempInfo.boneMatchNodes = boneMatchNodeList.ToArray(); tempInfo.bindLists = bindLists.ToArray(); return tempInfo; } private void LogBindPoses() { using(StreamWriter sw = new StreamWriter(\"Assets/GPUSkinning/BindPoses.txt\")) { foreach (SkinnedMeshRenderer smr in smrArray) { Transform[] smrBoneTrans = smr.bones; Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes; for (int j = 0; j \"\\t\" + smrBoneTrans[j].name + \"\\r\\n\" + smrBindPos[j].ToString()); } } } } private void Save() { AssetDatabase.CreateAsset(boneMatchInfo, \"Assets/GPUSkinning/BoneMatchInfo.asset\"); AssetDatabase.Refresh(); Debug.Log(\"Bone Match Info has been saved to Assets/GPUSkinning/BoneMatchInfo.asset.\"); } } } 最后得到的BoneMatchInfo.asset和Hierarchy的关系如图所示，部分不参与实际蒙皮的骨骼，就不需要记录到BoneMatchInfo.asset中了：\nBoneGPUSkinning.cs 在BoneGPUSkinning.cs这个脚本中，要做的事情是：把骨骼的编号和权重写到UV中，只用执行一次；把骨骼矩阵和bindpose的乘积传到GPU中，每帧执行一次，我把这个操作放在了compute shader中进行计算。根据前面的描述，我们需要获取\\(M_{bone\\_localtoobject}\\)，这个值等价于\\(M_{object\\_worldtolocal} * M_{bone\\_localtoworld}\\)。但是在实际的操作中，获取一根骨骼的\\(M_{bone\\_localtoworld}\\)矩阵会导致额外的运算，使得GPU Skinning的效率受到了很大的限制。这里有可能是我不够熟悉Unity的API的原因，当然也有可能是Unity本身就没开放相关的API的原因。照理来说，Unity要把Animator的平移旋转缩放动画应用到每一个骨骼上时，已经计算过了每根骨骼的localToWorldMatrix，获取这个矩阵应该能做到没有任何消耗的。但是没有办法，我只能试图使用Unity Jobs和Unity Burst来加速获取localToWorldMatrix的过程，在我的测试中，相比于直接用for循环获取大概能有至少50%的速度提升（记不太清了），然而对于整个GPU Skinning的过程来说，消耗还是太高了。\n因为是比较久之前写的代码了，也懒得去再仔细地修正，[ExecuteInEditMode]在设置好各个引用之前会疯狂的报错，不过在设置好正确的引用之后重新启用脚本就不会有任何的问题了。似乎操作不当也会出现内存泄漏的问题，不过无伤大雅。\nusing System.Collections.Generic; using UnityEngine; using System; using Unity.Collections; using Unity.Jobs; using UnityEngine.Jobs; using Unity.Burst; namespace GPUSkinning { [ExecuteInEditMode] public class BoneGPUSkinning : MonoBehaviour { public const int BONE_WEIGHT_DECODE_VALUE = 2; public const float BONE_WEIGHT_INVERSE_DECODE_VALUE = 0.5f; public ComputeShader computeShader; public Transform rootBone; public BoneMatchInfo boneMatchInfo; public List meshRenderers; [SerializeField] private int boneSize; private Transform[] minBoneTrans; private TransformAccessArray transformAccessArray; #region ComputeShader  int kernel; private Matrix4x4[] bindPosesArray; private Matrix4x4[] LTWMatrixArray; readonly int bindPoseID = Shader.PropertyToID(\"_BoneBindPoseBuffer\"); readonly int LTWMatrixID = Shader.PropertyToID(\"_BoneLTWMatrixBuffer\"); readonly int outputBufferID = Shader.PropertyToID(\"_BoneOutputBuffer\"); private ComputeBuffer outputBuffer; private ComputeBuffer bindPoseBuffer; private ComputeBuffer ltwMatrixBuffer; #endregion  #region InitializeFunction  void OnEnable() { Initialize(); } ///   /// 全部的初始化  ///   public void Initialize() { InitializeBoneTrans(); InitializeBoneUV(1); InitializeComputeShader(); } ///   /// 整合所有mesh绑定的骨骼，从rootBone的子物件中找出minBoneTrans  ///   private void InitializeBoneTrans() { //标记每个mesh对应的骨骼  Transform[] allTrans = rootBone.GetComponentsInChildren(); Dictionarystring, Transform allTransDict = new Dictionarystring, Transform(); foreach (Transform tran in allTrans) { allTransDict.Add(tran.name, tran); } boneSize = boneMatchInfo.boneMatchNodes.Length; minBoneTrans = new Transform[boneSize]; for (int i = 0; i new TransformAccessArray(minBoneTrans); } ///   /// 把骨骼的编号和权重写入到targetUVIndex对应的UV中  ///   ///   public void InitializeBoneUV(int targetUVIndex) { Dictionarystring, BindList bindListDict = new Dictionarystring, BindList(); for (int i = 0; i for (int i = 0; i bool hasBindList = bindListDict.TryGetValue(meshRenderers[i].name, out tempBindList); if(!hasBindList) { throw new ArgumentException(String.Format(\"SkinnedMeshName:{0}在BoneMatchInfo中找不到！\", boneMatchInfo.bindLists[i].skinnedMeshName)); } Mesh mesh = meshRenderers[i].GetComponent().sharedMesh; BoneWeight[] boneWeights = mesh.boneWeights; List boneAndWeights = new List(); int[] bindIndexes = tempBindList.bindIndexs; foreach (BoneWeight weight in boneWeights) { Vector4 boneAndWeight = new Vector4(0, 0, 0, 0); //Shader中个BoneUV都会查找全局的骨骼编号  boneAndWeight.x = bindIndexes[weight.boneIndex0] + weight.weight0 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeight.y = bindIndexes[weight.boneIndex1] + weight.weight1 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeight.z = bindIndexes[weight.boneIndex2] + weight.weight2 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeight.w = bindIndexes[weight.boneIndex3] + weight.weight3 * BONE_WEIGHT_INVERSE_DECODE_VALUE; boneAndWeights.Add(boneAndWeight); } mesh.SetUVs(targetUVIndex, boneAndWeights.ToArray()); } } private void EnsureComputeBuffer(ref ComputeBuffer buffer, int count, int stride) { if (buffer != null) { buffer.Release(); } buffer = new ComputeBuffer(count, stride); } ///   /// 初始化ComputeShader，用于计算每根骨骼的矩阵和bindpos的乘积  ///   private void InitializeComputeShader() { bindPosesArray = new Matrix4x4[boneSize]; LTWMatrixArray = new Matrix4x4[boneSize]; Debug.Log(LTWMatrixArray.Length); for (int i = 0; i \"MatCompute\"); EnsureComputeBuffer(ref outputBuffer, boneSize, sizeof(float) * 16); EnsureComputeBuffer(ref bindPoseBuffer, boneSize, sizeof(float) * 16); EnsureComputeBuffer(ref ltwMatrixBuffer, boneSize, sizeof(float) * 16); bindPoseBuffer.SetData(bindPosesArray); computeShader.SetBuffer(kernel, bindPoseID, bindPoseBuffer); computeShader.SetBuffer(kernel, outputBufferID, outputBuffer); } #endregion  #region Update Function  void Update() { InvokeComputeShader(); PassMeshRendererMatrix(); } [BurstCompile(CompileSynchronously = true)] struct GetLocalToWorldMatrixStructJob : IJobParallelForTransform { public NativeArray matArray; public void Execute(int i, TransformAccess transform) { matArray[i] = transform.localToWorldMatrix; } } private void InvokeComputeShader() { if(computeShader) { #if true  //NativeList jobHandleList = new NativeList(Allocator.Temp);  NativeArray matArray = new NativeArray(boneSize, Allocator.Persistent); GetLocalToWorldMatrixStructJob job = new GetLocalToWorldMatrixStructJob { matArray = matArray }; JobHandle jobHandle = IJobParallelForTransformExtensions.Schedule(job, transformAccessArray);// job.Schedule(transformAccessArray);  jobHandle.Complete(); ltwMatrixBuffer.SetData(matArray); matArray.Dispose(); #else  for (int i = 0; i #endif  computeShader.SetBuffer(kernel, LTWMatrixID, ltwMatrixBuffer); int dispatchCount = Mathf.CeilToInt(boneSize / 64f); computeShader.Dispatch(kernel, dispatchCount, 1, 1); Shader.SetGlobalBuffer(\"_BoneMatArray\", outputBuffer); } } private void PassMeshRendererMatrix() { for (int i = 0; i foreach (Material mat in meshRenderers[i].sharedMaterials) { mat.SetMatrix(\"_BoneTransformMatrix\", meshRenderers[i].transform.worldToLocalMatrix); } } } #endregion  private void OnDisable() { outputBuffer.Release(); outputBuffer = null; transformAccessArray.Dispose(); } } } BoneComputeShader.compute 这个compute shader仅仅做了矩阵的运算，甚至都不见得比在CPU中运算要快，不过这边还是使用了compute shader来做这个运算，稍微还能优化的是float4x4可以改成float3x4，不过这样CPU的代码写起来稍乱一些。\n#pragma kernel MatCompute\rStructuredBuffer _BoneBindPoseBuffer;\rStructuredBuffer _BoneLTWMatrixBuffer;\rRWStructuredBuffer _BoneOutputBuffer;\r[numthreads(64, 1, 1)]\rvoid MatCompute(uint3 id : SV_DispatchThreadID)\r{\r_BoneOutputBuffer[id.x] = mul(_BoneLTWMatrixBuffer[id.x], _BoneBindPoseBuffer[id.x]);\r}\rBoneGPUSkinning.hlsl 操作流程是这样的，对每一个顶点定义一个结构体VertexInputStructure，读取MeshRenderer的原始数据中的位置、法线、切线和我们传入的骨骼编号和权重。使用编号去寻找_BoneMatArray中对应的\\(M_{bone\\_localtoworld}\\)，再左乘_BoneTransformMatrix也就是之前说过\\(M_{object\\_worldtolocal}\\)，使用这两个矩阵的乘积就能分别计算蒙皮后的顶点位置、切线和法线了，要注意的是法线需要做一次逆矩阵的转置。最后对四对顶点位置、切线和法线进行加权计算，获得最终的顶点位置、切线和法线。\n#ifndef BONE_GPU_SKINNING\r#define BONE_GPU_SKINNING\r#define BONE_WEIGHT_DECODE_VALUE 2\rStructuredBuffer _BoneMatArray;\rfloat4x4 _BoneTransformMatrix;\rstruct VertexInputStructure\r{\rfloat3 positionOS;\rfloat3 normalOS;\rfloat4 tangentOS;\rfloat4 boneUV;\r};\rstruct VertexOutputStructure\r{\rfloat3 positionOS;\rfloat3 normalOS;\rfloat4 tangentOS;\r};\rinline float3x3 InverseTranspose(float3x3 mat)\r{\rfloat determinant = mat._m00 * (mat._m11 * mat._m22 - mat._m12 * mat._m21)\r- mat._m01 * (mat._m10 * mat._m22 - mat._m12 * mat._m20)\r+ mat._m02 * (mat._m10 * mat._m21 - mat._m11 * mat._m20);\rfloat3 vec0 = float3(mat._m11 * mat._m22 - mat._m12 * mat._m21,\rmat._m12 * mat._m20 - mat._m10 * mat._m22,\rmat._m10 * mat._m21 - mat._m11 * mat._m20);\rfloat3 vec1 = float3(mat._m02 * mat._m21 - mat._m01 * mat._m22,\rmat._m00 * mat._m22 - mat._m02 * mat._m20,\rmat._m01 * mat._m20 - mat._m00 * mat._m21);\rfloat3 vec2 = float3(mat._m01 * mat._m12 - mat._m02 * mat._m11,\rmat._m02 * mat._m10 - mat._m00 * mat._m12,\rmat._m00 * mat._m11 - mat._m01 * mat._m10);\rfloat3x3 returnMat;\rreturnMat._m00_m01_m02 = vec0;\rreturnMat._m10_m11_m12 = vec1;\rreturnMat._m20_m21_m22 = vec2;\rreturn returnMat / determinant;\r}\rinline float3x3 InverseTransposeVec(float3 vec0, float3 vec1, float3 vec2)\r{\rfloat3x3 mat;\rmat._m00_m01_m02 = vec0;\rmat._m10_m11_m12 = vec1;\rmat._m20_m21_m22 = vec2;\rreturn InverseTranspose(mat);\r}\rinline float4x4 ReadBoneInfos(uint boneIndex)\r{\rreturn mul(_BoneTransformMatrix, _BoneMatArray[boneIndex]);\r}\rinline VertexOutputStructure BlendBonesPosNormalTangent(VertexInputStructure input)\r{\rfloat4 positionOS = float4(input.positionOS, 1);\rfloat3 normalOS = input.normalOS;\rfloat4 tangentOS = input.tangentOS;\rfloat4 boneUV = input.boneUV;\ruint boneIndexOne = floor(boneUV.x);\rfloat boneWeightOne = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.x);\ruint boneIndexTwo = floor(boneUV.y);\rfloat boneWeightTwo = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.y);\ruint boneIndexThree = floor(boneUV.z);\rfloat boneWeightThree = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.z);\ruint boneIndexFour = floor(boneUV.w);\rfloat boneWeightFour = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.w);\rfloat4x4 matOne = ReadBoneInfos(boneIndexOne);\rfloat4x4 matTwo = ReadBoneInfos(boneIndexTwo);\rfloat4x4 matThree = ReadBoneInfos(boneIndexThree);\rfloat4x4 matFour = ReadBoneInfos(boneIndexFour);\r//blend position\rfloat3 posOne = mul(matOne, positionOS).xyz;\rfloat3 posTwo = mul(matTwo, positionOS).xyz;\rfloat3 posThree = mul(matThree, positionOS).xyz;\rfloat3 posFour = mul(matFour, positionOS).xyz;\rfloat3 returnPos = posOne * boneWeightOne\r+ posTwo * boneWeightTwo\r+ posThree * boneWeightThree\r+ posFour * boneWeightFour;\r//blend normal\rfloat3x3 newMatOne = InverseTransposeVec(matOne._m00_m01_m02, matOne._m10_m11_m12, matOne._m20_m21_m22);\rfloat3x3 newMatTwo = InverseTransposeVec(matTwo._m00_m01_m02, matTwo._m10_m11_m12, matTwo._m20_m21_m22);\rfloat3x3 newMatThree = InverseTransposeVec(matThree._m00_m01_m02, matThree._m10_m11_m12, matThree._m20_m21_m22);\rfloat3x3 newMatFour = InverseTransposeVec(matFour._m00_m01_m02, matFour._m10_m11_m12, matFour._m20_m21_m22);\rfloat3 normalOne = mul(newMatOne, normalOS).xyz;\rfloat3 normalTwo = mul(newMatTwo, normalOS).xyz;\rfloat3 normalThree = mul(newMatThree, normalOS).xyz;\rfloat3 normalFour = mul(newMatFour, normalOS).xyz;\rfloat3 returnNormal = normalOne * boneWeightOne\r+ normalTwo * boneWeightTwo\r+ normalThree * boneWeightThree\r+ normalFour * boneWeightFour;\rreturnNormal = normalize(returnNormal);\r//blend tangent\rfloat3 tangentOne = mul((float3x3)matOne, tangentOS.xyz);\rfloat3 tangentTwo = mul((float3x3)matTwo, tangentOS.xyz);\rfloat3 tangentThree = mul((float3x3)matThree, tangentOS.xyz);\rfloat3 tangentFour = mul((float3x3)matFour, tangentOS.xyz);\rfloat3 tempTangent = tangentOne * boneWeightOne\r+ tangentTwo * boneWeightTwo\r+ tangentThree * boneWeightThree\r+ tangentFour * boneWeightFour;\rtempTangent = normalize(tempTangent);\rfloat4 returnTangent = float4(tempTangent, tangentOS.w);\rVertexOutputStructure output;\routput.positionOS = returnPos;\routput.normalOS = returnNormal;\routput.tangentOS = returnTangent;\rreturn output;\r}\r#endif\rBoneGPUSkinningShader.shader 用于渲染的shader中，要在顶点着色器中调用BoneGPUSkinning.hlsl中的方法获取蒙皮后的顶点位置、切线和法线。我这里使用了一个比较简单的渲染，给模型一点基础的光影。要注意的是，如果需要正确的阴影的话，在ShadowCaster这个pass中还需要计算一遍顶点位置，这里就暂且忽略了。\nShader \"zznewclear13/BoneGPUSkinningShader\"\r{\rProperties\r{\r_Color (\"Color\", Color) = (1,1,1,1)\r_MainTex (\"Albedo (RGB)\", 2D) = \"white\" {}\r}\rSubShader\r{\rTags { \"RenderType\" = \"Opaque\" \"RenderPipeline\" = \"UniversalPipeline\" \"IgnoreProjector\" = \"True\" }\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Assets/GPUSkinning/BoneGPUSkinning.hlsl\"\rsampler2D _MainTex;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _Color;\rCBUFFER_END\rstruct a2v\r{\rfloat4 vertex : POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 boneUV : TEXCOORD1;\rfloat3 normal : NORMAL;\rfloat4 tangent : TANGENT;\r};\rstruct v2f\r{\rfloat4 pos : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 tempColor : TEXCOORD1;\rfloat3 normalWS : TEXCOORD2;\rfloat4 tangentWS : TEXCOORD3;\rfloat3 eyeVec : TEXCOORD4;\r};\rv2f animVert(a2v v)\r{\rv2f o;\rVertexInputStructure inputStructure;\rinputStructure.positionOS = v.vertex;\rinputStructure.normalOS = v.normal;\rinputStructure.tangentOS = v.tangent;\rinputStructure.boneUV = v.boneUV;\rVertexOutputStructure outputStructure = BlendBonesPosNormalTangent(inputStructure);\rfloat3 vertexPos = outputStructure.positionOS;\rfloat3 vertexNormal = outputStructure.normalOS;\rfloat3 vertexTangent = outputStructure.tangentOS;\ro.pos = TransformObjectToHClip(vertexPos);\ro.normalWS = TransformObjectToWorldNormal(vertexNormal);\ro.tangentWS = float4(TransformObjectToWorldDir(vertexTangent), v.tangent.w);\ro.uv = v.uv;\ro.tempColor = float4(1, 1, 1, 1);\rfloat3 worldPos = TransformObjectToWorld(float4(vertexPos, 1));\ro.eyeVec = GetCameraPositionWS() - worldPos;\rreturn o;\r}\rfloat4 animFrag(v2f i) : SV_TARGET\r{\rfloat3 viewDir = normalize(i.eyeVec);\rfloat3 lightDir = normalize(float3(1, 1, 1));\rfloat3 halfVec = normalize(lightDir + viewDir);\rfloat3 normalWS = normalize(i.normalWS);\rfloat NdotL = dot(normalWS, lightDir) * 0.6 + 0.4;\rfloat NdotH = saturate(dot(normalWS, halfVec));\rfloat3 diffuseColor = _Color.xyz * NdotL;\rfloat3 specularColor = pow(NdotH, 30);\rreturn float4(diffuseColor + specularColor, 1);\r}\rENDHLSL\rpass\r{\rTags{ \"LightMode\" = \"UniversalForward\" }\rHLSLPROGRAM\r#pragma vertex animVert\r#pragma fragment animFrag\rENDHLSL\r}\r}\r}\r最后的思考 总的来说，上面的操作已经基本完成了GPU Skinning的需求，而且能够正确的与Animator组件相结合。当然仍有优化的空间，比如说把所有要做GPU Skinning的mesh使用同一个Update的方法来更新，等等。但是美中不足的是之前提到的获取localToWorldMatrix的问题，直接导致了使用这个方法不如Unity自带的GPU Skinning效率高，自带的GPU蒙皮应该是用到了Unity底层的一些优化吧，但是核心的操作应该和我这里做的差不多。\n","wordCount":"1728","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/posts/images/GPUSkinning.jpg","datePublished":"2021-07-11T19:00:00+08:00","dateModified":"2021-07-11T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/memos/ title=备忘录><span>备忘录</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>支持Animator Controller的实时GPU蒙皮</h1><div class=post-description>虽然不是特别完善，但好歹记录一下做过的事情.</div><div class=post-meta>July 11, 2021&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-gpu-skinning-with-animator-controller.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/GPUSkinning.jpg alt="GPU Skinning Cover"><p>GPU Skinning example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>支持Animator Controller的实时GPU蒙皮</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8gpu%e6%9d%a5%e8%bf%9b%e8%a1%8c%e8%92%99%e7%9a%ae aria-label=为什么要用GPU来进行蒙皮>为什么要用GPU来进行蒙皮</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e4%b8%80%e4%ba%9b%e6%83%b3%e6%b3%95 aria-label=GPU蒙皮的一些想法>GPU蒙皮的一些想法</a></li><li><a href=#gpu%e8%92%99%e7%9a%ae%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=GPU蒙皮的操作>GPU蒙皮的操作</a><ul><li><a href=#bonematchinfocs aria-label=BoneMatchInfo.cs>BoneMatchInfo.cs</a></li><li><a href=#bonegpuskinningcs aria-label=BoneGPUSkinning.cs>BoneGPUSkinning.cs</a></li><li><a href=#bonecomputeshadercompute aria-label=BoneComputeShader.compute>BoneComputeShader.compute</a></li><li><a href=#bonegpuskinninghlsl aria-label=BoneGPUSkinning.hlsl>BoneGPUSkinning.hlsl</a></li><li><a href=#bonegpuskinningshadershader aria-label=BoneGPUSkinningShader.shader>BoneGPUSkinningShader.shader</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e7%9a%84%e6%80%9d%e8%80%83 aria-label=最后的思考>最后的思考</a></li></ul></div></details></div><div class=post-content><h2 id=为什么要用gpu来进行蒙皮>为什么要用GPU来进行蒙皮<a hidden class=anchor aria-hidden=true href=#为什么要用gpu来进行蒙皮>#</a></h2><p>对于一个SkinnedMeshRenderer，在做蒙皮的时候，对于每一个顶点，会先计算出这个顶点对应的四根骨骼的从骨骼空间到物体空间的矩阵\(M_{bone\_localtoobject}\)，然后使用\(M_{bone\_localtoobject} * M_{bone\_bindpose} * Vertex_{objectspace}\)得到经过骨骼平移旋转缩放后的四个带权重的顶点数据位置和切线，对于法线则是使用上面矩阵的逆矩阵的转置。然后对获得的位置、法线和切线，用权重计算得到经过骨骼平移旋转缩放后的实际的顶点信息。在通常的渲染过程中，上述操作是在CPU中进行的，最后把顶点数据传递给GPU中进行渲染。在顶点数较多且主要是矩阵运算的情况下，CPU进行蒙皮的效率就不如高并行的GPU了，因此会考虑到在GPU中进行蒙皮处理。</p><h2 id=gpu蒙皮的一些想法>GPU蒙皮的一些想法<a hidden class=anchor aria-hidden=true href=#gpu蒙皮的一些想法>#</a></h2><p>从上面可以看到，要从CPU中传给GPU的数据有以下几种：一是\(M_{bone\_localtoobject} * M_{bone\_bindpose}\)这样骨骼数个float4x4的矩阵，但是由于其最后一行是(0, 0, 0, 1)，在传递时可以简化成骨骼数个float3x4矩阵，这些矩阵每一帧都要传递一次；二是每个顶点对应的骨骼编号和骨骼的权重，骨骼编号用来查询骨骼矩阵中对应的矩阵，是一个整型的数据，骨骼权重是一个[0, 1]的小数，可以用\(BoneIndex + BoneWeight * 0.5\)的方式，把编号和权重结合成一个float的数据，这样每个顶点的骨骼编号和权重数据是一个float4的数据，可以保存在UV中，也可以用数组的方式传递给GPU，这些顶点数个float4的数据，只需要传递一次就可以了；再有就是模型本身的顶点位置、法线和切线，这些引擎会自动为我们传递给GPU。</p><p>在实际操作中，网上通常找到的方案是把动画保存在一张贴图或者是一个自定义的数据结构中，这里可以直接保存顶点数据，甚至不需要在GPU中做蒙皮的操作，但是随着顶点数增加会占用大量的空间；或者是保存骨骼的变换矩阵，在GPU中进行蒙皮，相对来说储存空间会小很多。然而我认为这两种都不是很好的做GPU skinning的方法，将动画信息保存到贴图或者数据结构中，会很大程度上失去Animator Controller的功能，如两个动作之间的插值、触发事件等，对于动画来说甚至是得不偿失的一种效果。因此，我希望能够保留Animator Controller的特性，实时的把骨骼数据传送给GPU，在GPU中进行蒙皮操作。</p><h2 id=gpu蒙皮的操作>GPU蒙皮的操作<a hidden class=anchor aria-hidden=true href=#gpu蒙皮的操作>#</a></h2><p>我的想法是，先离线从SkinnedMeshRenderer中获得骨骼的ID和权重，然后实时的从Animator Controller对应的骨骼中获取每根骨骼的骨骼矩阵，再统一传给一个普通的MeshRenderer，在GPU中进行蒙皮的操作。这中间有一个小坑，Unity同一个模型的SkinnedMeshRenderer和MeshRenderer，他们虽然都能获取到boneweight和bindpose，但是SkinnedMeshRenderer和MeshRnederer的骨骼的顺序有时候会有一些差异，因此最好的办法是，抛弃这两者的骨骼顺序，用Hierarchy中的骨骼顺序来确定我们传给GPU的boneindex，boneweight和bonematrix是一致的。</p><p>这里使用的模型及动作是<a href=https://www.mixamo.com/>mixamo</a>的hip hop dancing资源。</p><h3 id=bonematchinfocs>BoneMatchInfo.cs<a hidden class=anchor aria-hidden=true href=#bonematchinfocs>#</a></h3><p>这个脚本的作用是，在离线时把一个GameObjectRoot下的所有SkinnedMeshRenderer和Hierarchy中的骨骼的信息结合起来，保存成一个Asset，用于实时的GPU Skinning。这个Asset包含两部分的信息，一个是BoneMatchNode用于记录Hierarchy骨骼列表中骨骼的名称和其bindpose，另一个是BindIndex用于记录所有SkinnedMeshRenderer的骨骼在Hierarchy骨骼列表中的顺序。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections;
<span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> UnityEditor;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.IO;

<span style=color:#66d9ef>namespace</span> GPUSkinning
{
<span style=color:#a6e22e>    [System.Serializable]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchNode</span>
    {
        <span style=color:#75715e>//[HideInInspector]
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> boneName;
        <span style=color:#75715e>//在查找位于所有Transfom的位置时，设置并使用boneIndex
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> boneIndex = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>public</span> Matrix4x4 bindPose;

        <span style=color:#66d9ef>public</span> BoneMatchNode(<span style=color:#66d9ef>string</span> <span style=color:#ae81ff>_</span>boneName)
        {
            boneName = <span style=color:#ae81ff>_</span>boneName;
            bindPose = Matrix4x4.identity;
        }
    }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [System.Serializable]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BindList</span>
    {
        <span style=color:#75715e>//[HideInInspector]
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> skinnedMeshName;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span>[] bindIndexs;

        <span style=color:#66d9ef>public</span> BindList(<span style=color:#66d9ef>string</span> <span style=color:#ae81ff>_</span>skinnedMeshName)
        {
            skinnedMeshName = <span style=color:#ae81ff>_</span>skinnedMeshName;
        }
    }


    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneMatchInfo</span> : ScriptableObject
    {   
        <span style=color:#66d9ef>public</span> BoneMatchNode[] boneMatchNodes;
        <span style=color:#66d9ef>public</span> BindList[] bindLists;
    }


    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GenerateBoneMatchInfo</span> : EditorWindow
    {
        <span style=color:#66d9ef>public</span> Transform rootBone;
        <span style=color:#66d9ef>public</span> Transform skinnedParent;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> skinnedMeshCount = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>public</span> SkinnedMeshRenderer[] smrArray;
        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;

        <span style=color:#66d9ef>private</span> Rect topToolBarRect
        {
            <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>, position.width - <span style=color:#ae81ff>40</span>, position.height - <span style=color:#ae81ff>20</span>); }
        }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [MenuItem(&#34;zznewclear13/Generate Bone Match Info&#34;)]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> GenerateBoneMatchInfo GetWindow()
        {
            GenerateBoneMatchInfo window = GetWindow&lt;GenerateBoneMatchInfo&gt;();
            window.titleContent = <span style=color:#66d9ef>new</span> GUIContent(<span style=color:#e6db74>&#34;Generate Bone Match Info&#34;</span>);
            window.Focus();
            window.Repaint();
            <span style=color:#66d9ef>return</span> window;
        }

        <span style=color:#66d9ef>void</span> OnGUI()
        {
            TopToolBar(topToolBarRect);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TopToolBar(Rect rect)
        {
            GUILayout.BeginArea(rect);
            rootBone = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Root Bone Transform&#34;</span>, rootBone, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);
            skinnedParent = (Transform)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Parent Transform&#34;</span>, skinnedParent, <span style=color:#66d9ef>typeof</span>(Transform), <span style=color:#66d9ef>true</span>);

            <span style=color:#66d9ef>if</span>(skinnedParent!=<span style=color:#66d9ef>null</span>)
            {
                smrArray = skinnedParent.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;();
                <span style=color:#66d9ef>if</span>(smrArray != <span style=color:#66d9ef>null</span>)
                {
                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(<span style=color:#66d9ef>true</span>))
                    {
                        EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Skinned Mesh Renderers&#34;</span>, smrArray[<span style=color:#ae81ff>0</span>], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
                        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>1</span>; i &lt; smrArray.Length; i++)
                        {
                            EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34; &#34;</span>, smrArray[i], <span style=color:#66d9ef>typeof</span>(SkinnedMeshRenderer), <span style=color:#66d9ef>false</span>);
                        }
                    }

                    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(smrArray.Length &lt;= <span style=color:#ae81ff>0</span>))
                    {
                        <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Generate Animator Map&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30f</span>) }))
                        {                           
                            boneMatchInfo = CompareBones();
                            <span style=color:#75715e>//LogBindPoses();
</span><span style=color:#75715e></span>                            Save();
                        }
                    }
                }
            }

            GUILayout.EndArea();
        }

        <span style=color:#66d9ef>private</span> BoneMatchInfo CompareBones()
        {
            BoneMatchInfo tempInfo = <span style=color:#66d9ef>new</span> BoneMatchInfo();

            Transform[] boneTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
            List&lt;BoneMatchNode&gt; boneMatchNodeList = <span style=color:#66d9ef>new</span> List&lt;BoneMatchNode&gt;();
            List&lt;BindList&gt; bindLists = <span style=color:#66d9ef>new</span> List&lt;BindList&gt;();
            List&lt;<span style=color:#66d9ef>int</span>[]&gt; tempIntLists = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>[]&gt;();

            List&lt;Transform[]&gt; smrBoneTransList = <span style=color:#66d9ef>new</span> List&lt;Transform[]&gt;();
            List&lt;Matrix4x4[]&gt; smrBindPoseList = <span style=color:#66d9ef>new</span> List&lt;Matrix4x4[]&gt;();
            <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
            {
                Transform[] smrBoneTrans = smr.bones;
                Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
                smrBoneTransList.Add(smrBoneTrans);
                smrBindPoseList.Add(smrBindPos);
                tempIntLists.Add(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[smr.bones.Length]);
            }

            <span style=color:#66d9ef>int</span> boneTranIndex = <span style=color:#ae81ff>0</span>;
            <span style=color:#66d9ef>foreach</span> (Transform boneTran <span style=color:#66d9ef>in</span> boneTrans)
            {
                BoneMatchNode bmn = <span style=color:#66d9ef>new</span> BoneMatchNode(boneTran.name);
                <span style=color:#66d9ef>bool</span> isInSMRBones = <span style=color:#66d9ef>false</span>;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrBoneTransList.Count; i++)
                {
                    <span style=color:#66d9ef>int</span> index = Array.IndexOf(smrBoneTransList[i], boneTran);
                    <span style=color:#66d9ef>if</span> (index &gt;= <span style=color:#ae81ff>0</span>)
                    {
                        isInSMRBones = <span style=color:#66d9ef>true</span>;
                        bmn.bindPose = smrBindPoseList[i][index];
                        tempIntLists[i][index] = boneTranIndex;
                    }
                }

                <span style=color:#66d9ef>if</span> (isInSMRBones)
                {
                    bmn.boneIndex = boneTranIndex;
                    boneMatchNodeList.Add(bmn);
                    boneTranIndex++;
                }
            }

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; smrArray.Length; i++)
            {
                bindLists.Add(<span style=color:#66d9ef>new</span> BindList(smrArray[i].name));
                bindLists[i].bindIndexs = tempIntLists[i];
            }

            tempInfo.boneMatchNodes = boneMatchNodeList.ToArray();
            tempInfo.bindLists = bindLists.ToArray();
            <span style=color:#66d9ef>return</span> tempInfo;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> LogBindPoses()
        {
            using(StreamWriter sw = <span style=color:#66d9ef>new</span> StreamWriter(<span style=color:#e6db74>&#34;Assets/GPUSkinning/BindPoses.txt&#34;</span>))
            {
                <span style=color:#66d9ef>foreach</span> (SkinnedMeshRenderer smr <span style=color:#66d9ef>in</span> smrArray)
                {
                    Transform[] smrBoneTrans = smr.bones;
                    Matrix4x4[] smrBindPos = smr.sharedMesh.bindposes;
                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; smrBoneTrans.Length; j++)
                    {
                        sw.WriteLine(smr.name + <span style=color:#e6db74>&#34;\t&#34;</span> + smrBoneTrans[j].name + <span style=color:#e6db74>&#34;\r\n&#34;</span> + smrBindPos[j].ToString());
                    }
                }
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Save()
        {
            AssetDatabase.CreateAsset(boneMatchInfo, <span style=color:#e6db74>&#34;Assets/GPUSkinning/BoneMatchInfo.asset&#34;</span>);
            AssetDatabase.Refresh();
            Debug.Log(<span style=color:#e6db74>&#34;&lt;color=blue&gt;Bone Match Info has been saved to Assets/GPUSkinning/BoneMatchInfo.asset.&lt;/color&gt;&#34;</span>);
        }
    }
}
</code></pre></div><p>最后得到的<code>BoneMatchInfo.asset</code>和Hierarchy的关系如图所示，部分不参与实际蒙皮的骨骼，就不需要记录到<code>BoneMatchInfo.asset</code>中了：</p><p><img loading=lazy src=../images/BoneMatchInfo.jpg#center alt=BoneMatchInfo></p><h3 id=bonegpuskinningcs>BoneGPUSkinning.cs<a hidden class=anchor aria-hidden=true href=#bonegpuskinningcs>#</a></h3><p>在<code>BoneGPUSkinning.cs</code>这个脚本中，要做的事情是：把骨骼的编号和权重写到UV中，只用执行一次；把骨骼矩阵和bindpose的乘积传到GPU中，每帧执行一次，我把这个操作放在了compute shader中进行计算。根据前面的描述，我们需要获取\(M_{bone\_localtoobject}\)，这个值等价于\(M_{object\_worldtolocal} * M_{bone\_localtoworld}\)。但是在实际的操作中，获取一根骨骼的\(M_{bone\_localtoworld}\)矩阵会导致额外的运算，使得GPU Skinning的效率受到了很大的限制。这里有可能是我不够熟悉Unity的API的原因，当然也有可能是Unity本身就没开放相关的API的原因。照理来说，Unity要把Animator的平移旋转缩放动画应用到每一个骨骼上时，已经计算过了每根骨骼的localToWorldMatrix，获取这个矩阵应该能做到没有任何消耗的。但是没有办法，我只能试图使用<code>Unity Jobs</code>和<code>Unity Burst</code>来加速获取localToWorldMatrix的过程，在我的测试中，相比于直接用for循环获取大概能有至少50%的速度提升（记不太清了），然而对于整个GPU Skinning的过程来说，消耗还是太高了。</p><p>因为是比较久之前写的代码了，也懒得去再仔细地修正，<code>[ExecuteInEditMode]</code>在设置好各个引用之前会疯狂的报错，不过在设置好正确的引用之后重新启用脚本就不会有任何的问题了。似乎操作不当也会出现内存泄漏的问题，不过无伤大雅。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> Unity.Collections;
<span style=color:#66d9ef>using</span> Unity.Jobs;
<span style=color:#66d9ef>using</span> UnityEngine.Jobs;
<span style=color:#66d9ef>using</span> Unity.Burst;


<span style=color:#66d9ef>namespace</span> GPUSkinning
{
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [ExecuteInEditMode]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoneGPUSkinning</span> : MonoBehaviour
    {
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> BONE_WEIGHT_DECODE_VALUE = <span style=color:#ae81ff>2</span>;
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> BONE_WEIGHT_INVERSE_DECODE_VALUE = <span style=color:#ae81ff>0.5f</span>;

        <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        <span style=color:#66d9ef>public</span> Transform rootBone;
        <span style=color:#66d9ef>public</span> BoneMatchInfo boneMatchInfo;
        <span style=color:#66d9ef>public</span> List&lt;MeshRenderer&gt; meshRenderers;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [SerializeField]</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> boneSize;
        <span style=color:#66d9ef>private</span> Transform[] minBoneTrans;

        <span style=color:#66d9ef>private</span> TransformAccessArray transformAccessArray;

        <span style=color:#75715e>#region ComputeShader
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> kernel;

        <span style=color:#66d9ef>private</span> Matrix4x4[] bindPosesArray;
        <span style=color:#66d9ef>private</span> Matrix4x4[] LTWMatrixArray;

        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> bindPoseID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneBindPoseBuffer&#34;</span>);
        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> LTWMatrixID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneLTWMatrixBuffer&#34;</span>);
        <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> outputBufferID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BoneOutputBuffer&#34;</span>);
        <span style=color:#66d9ef>private</span> ComputeBuffer outputBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer bindPoseBuffer;
        <span style=color:#66d9ef>private</span> ComputeBuffer ltwMatrixBuffer;
        <span style=color:#75715e>#endregion
</span><span style=color:#75715e></span>
        <span style=color:#75715e>#region InitializeFunction
</span><span style=color:#75715e></span>
        <span style=color:#66d9ef>void</span> OnEnable()
        {
            Initialize();
        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// 全部的初始化
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
        {

            InitializeBoneTrans();

            InitializeBoneUV(<span style=color:#ae81ff>1</span>);

            InitializeComputeShader();

        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// 整合所有mesh绑定的骨骼，从rootBone的子物件中找出minBoneTrans
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeBoneTrans()
        {
            <span style=color:#75715e>//标记每个mesh对应的骨骼
</span><span style=color:#75715e></span>            Transform[] allTrans = rootBone.GetComponentsInChildren&lt;Transform&gt;();
            Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt; allTransDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, Transform&gt;();
            <span style=color:#66d9ef>foreach</span> (Transform tran <span style=color:#66d9ef>in</span> allTrans)
            {
                allTransDict.Add(tran.name, tran);
            }
            boneSize = boneMatchInfo.boneMatchNodes.Length;
            minBoneTrans = <span style=color:#66d9ef>new</span> Transform[boneSize];

            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
            {
                Transform tempTran = allTransDict[boneMatchInfo.boneMatchNodes[i].boneName];
                boneMatchInfo.boneMatchNodes[i].boneIndex = i;
                minBoneTrans[i] = tempTran;
            }

            transformAccessArray = <span style=color:#66d9ef>new</span> TransformAccessArray(minBoneTrans);
        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// 把骨骼的编号和权重写入到targetUVIndex对应的UV中
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;param name=&#34;targetUVIndex&#34;&gt;&lt;/param&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> InitializeBoneUV(<span style=color:#66d9ef>int</span> targetUVIndex)
        {
            Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt; bindListDict = <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, BindList&gt;();
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneMatchInfo.bindLists.Length; i++)
            {
                bindListDict.Add(boneMatchInfo.bindLists[i].skinnedMeshName, boneMatchInfo.bindLists[i]);
            }
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
            {
                BindList tempBindList;
                <span style=color:#66d9ef>bool</span> hasBindList = bindListDict.TryGetValue(meshRenderers[i].name, <span style=color:#66d9ef>out</span> tempBindList);
                <span style=color:#66d9ef>if</span>(!hasBindList)
                {
                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentException(String.Format(<span style=color:#e6db74>&#34;SkinnedMeshName:{0}在BoneMatchInfo中找不到！&#34;</span>,
                                                boneMatchInfo.bindLists[i].skinnedMeshName));
                }

                Mesh mesh = meshRenderers[i].GetComponent&lt;MeshFilter&gt;().sharedMesh;
                BoneWeight[] boneWeights = mesh.boneWeights;

                List&lt;Vector4&gt; boneAndWeights = <span style=color:#66d9ef>new</span> List&lt;Vector4&gt;();
                <span style=color:#66d9ef>int</span>[] bindIndexes = tempBindList.bindIndexs;
                <span style=color:#66d9ef>foreach</span> (BoneWeight weight <span style=color:#66d9ef>in</span> boneWeights)
                {
                    Vector4 boneAndWeight = <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);

                    <span style=color:#75715e>//Shader中个BoneUV都会查找全局的骨骼编号
</span><span style=color:#75715e></span>                    boneAndWeight.x = bindIndexes[weight.boneIndex0] + weight.weight0 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeight.y = bindIndexes[weight.boneIndex1] + weight.weight1 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeight.z = bindIndexes[weight.boneIndex2] + weight.weight2 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeight.w = bindIndexes[weight.boneIndex3] + weight.weight3 * BONE_WEIGHT_INVERSE_DECODE_VALUE;
                    boneAndWeights.Add(boneAndWeight);
                }
                mesh.SetUVs(targetUVIndex, boneAndWeights.ToArray());
            }
        }


        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ComputeBuffer buffer, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
        {
            <span style=color:#66d9ef>if</span> (buffer != <span style=color:#66d9ef>null</span>)
            {
                buffer.Release();
            }

            buffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride);
        }

        <span style=color:#75715e>/// &lt;summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// 初始化ComputeShader，用于计算每根骨骼的矩阵和bindpos的乘积
</span><span style=color:#75715e></span>        <span style=color:#75715e>/// &lt;/summary&gt;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InitializeComputeShader()
        {
            bindPosesArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
            LTWMatrixArray = <span style=color:#66d9ef>new</span> Matrix4x4[boneSize];
            Debug.Log(LTWMatrixArray.Length);
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
            {
                bindPosesArray[i] = boneMatchInfo.boneMatchNodes[i].bindPose;
            }

            kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;MatCompute&#34;</span>);

            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> outputBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> bindPoseBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);
            EnsureComputeBuffer(<span style=color:#66d9ef>ref</span> ltwMatrixBuffer, boneSize, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>) * <span style=color:#ae81ff>16</span>);

            bindPoseBuffer.SetData(bindPosesArray);
            computeShader.SetBuffer(kernel, bindPoseID, bindPoseBuffer);

            computeShader.SetBuffer(kernel, outputBufferID, outputBuffer);
        }

        <span style=color:#75715e>#endregion
</span><span style=color:#75715e></span>
        <span style=color:#75715e>#region Update Function
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> Update()
        {
            InvokeComputeShader();
            PassMeshRendererMatrix();
        }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [BurstCompile(CompileSynchronously = true)]</span>
        <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GetLocalToWorldMatrixStructJob</span> : IJobParallelForTransform
        {
            <span style=color:#66d9ef>public</span> NativeArray&lt;Matrix4x4&gt; matArray;

            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i, TransformAccess transform)
            {
                matArray[i] = transform.localToWorldMatrix;
            }
        }


        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> InvokeComputeShader()
        {
            <span style=color:#66d9ef>if</span>(computeShader)
            {
<span style=color:#75715e>#if true
</span><span style=color:#75715e></span>                <span style=color:#75715e>//NativeList&lt;JobHandle&gt; jobHandleList = new NativeList&lt;JobHandle&gt;(Allocator.Temp);
</span><span style=color:#75715e></span>                NativeArray&lt;Matrix4x4&gt; matArray = <span style=color:#66d9ef>new</span> NativeArray&lt;Matrix4x4&gt;(boneSize, Allocator.Persistent);

                GetLocalToWorldMatrixStructJob job = <span style=color:#66d9ef>new</span> GetLocalToWorldMatrixStructJob
                {
                    matArray = matArray
                };
                JobHandle jobHandle = IJobParallelForTransformExtensions.Schedule(job, transformAccessArray);<span style=color:#75715e>// job.Schedule(transformAccessArray);
</span><span style=color:#75715e></span>                jobHandle.Complete();

                ltwMatrixBuffer.SetData(matArray);
                matArray.Dispose();
<span style=color:#75715e>#else
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; boneSize; i++)
                {
                    LTWMatrixArray[i] = minBoneTrans[i].localToWorldMatrix;
                }
                ltwMatrixBuffer.SetData(LTWMatrixArray);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
                computeShader.SetBuffer(kernel, LTWMatrixID, ltwMatrixBuffer);
                <span style=color:#66d9ef>int</span> dispatchCount = Mathf.CeilToInt(boneSize / <span style=color:#ae81ff>64f</span>);
                computeShader.Dispatch(kernel, dispatchCount, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
                Shader.SetGlobalBuffer(<span style=color:#e6db74>&#34;_BoneMatArray&#34;</span>, outputBuffer);
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PassMeshRendererMatrix()
        {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; meshRenderers.Count; i++)
            {
                <span style=color:#66d9ef>foreach</span> (Material mat <span style=color:#66d9ef>in</span> meshRenderers[i].sharedMaterials)
                {
                    mat.SetMatrix(<span style=color:#e6db74>&#34;_BoneTransformMatrix&#34;</span>, meshRenderers[i].transform.worldToLocalMatrix);
                }
            }

        }

<span style=color:#75715e>#endregion
</span><span style=color:#75715e></span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
        {
            outputBuffer.Release();
            outputBuffer = <span style=color:#66d9ef>null</span>;
            transformAccessArray.Dispose();
        }
    }

}
</code></pre></div><h3 id=bonecomputeshadercompute>BoneComputeShader.compute<a hidden class=anchor aria-hidden=true href=#bonecomputeshadercompute>#</a></h3><p>这个compute shader仅仅做了矩阵的运算，甚至都不见得比在CPU中运算要快，不过这边还是使用了compute shader来做这个运算，稍微还能优化的是float4x4可以改成float3x4，不过这样CPU的代码写起来稍乱一些。</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel MatCompute

StructuredBuffer&lt;float4x4&gt; _BoneBindPoseBuffer;
StructuredBuffer&lt;float4x4&gt; _BoneLTWMatrixBuffer;

RWStructuredBuffer&lt;float4x4&gt; _BoneOutputBuffer;

[numthreads(64, 1, 1)]
void MatCompute(uint3 id : SV_DispatchThreadID)
{
    _BoneOutputBuffer[id.x] = mul(_BoneLTWMatrixBuffer[id.x], _BoneBindPoseBuffer[id.x]);
}
</code></pre><h3 id=bonegpuskinninghlsl>BoneGPUSkinning.hlsl<a hidden class=anchor aria-hidden=true href=#bonegpuskinninghlsl>#</a></h3><p>操作流程是这样的，对每一个顶点定义一个结构体<code>VertexInputStructure</code>，读取MeshRenderer的原始数据中的位置、法线、切线和我们传入的骨骼编号和权重。使用编号去寻找<code>_BoneMatArray</code>中对应的\(M_{bone\_localtoworld}\)，再左乘<code>_BoneTransformMatrix</code>也就是之前说过\(M_{object\_worldtolocal}\)，使用这两个矩阵的乘积就能分别计算蒙皮后的顶点位置、切线和法线了，要注意的是法线需要做一次逆矩阵的转置。最后对四对顶点位置、切线和法线进行加权计算，获得最终的顶点位置、切线和法线。</p><pre><code class=language-HLSL data-lang=HLSL>#ifndef BONE_GPU_SKINNING
#define BONE_GPU_SKINNING

#define BONE_WEIGHT_DECODE_VALUE 2

StructuredBuffer&lt;float4x4&gt; _BoneMatArray;
float4x4 _BoneTransformMatrix;

struct VertexInputStructure
{
    float3 positionOS;
    float3 normalOS;
    float4 tangentOS;
    float4 boneUV;
};

struct VertexOutputStructure
{
    float3 positionOS;
    float3 normalOS;
    float4 tangentOS;
};

inline float3x3 InverseTranspose(float3x3 mat)
{

    float determinant = mat._m00 * (mat._m11 * mat._m22 - mat._m12 * mat._m21)
                        - mat._m01 * (mat._m10 * mat._m22 - mat._m12 * mat._m20)
                        + mat._m02 * (mat._m10 * mat._m21 - mat._m11 * mat._m20);
    float3 vec0 = float3(mat._m11 * mat._m22 - mat._m12 * mat._m21,
                        mat._m12 * mat._m20 - mat._m10 * mat._m22,
                        mat._m10 * mat._m21 - mat._m11 * mat._m20);
    float3 vec1 = float3(mat._m02 * mat._m21 - mat._m01 * mat._m22,
                        mat._m00 * mat._m22 - mat._m02 * mat._m20,
                        mat._m01 * mat._m20 - mat._m00 * mat._m21);
    float3 vec2 = float3(mat._m01 * mat._m12 - mat._m02 * mat._m11,
                        mat._m02 * mat._m10 - mat._m00 * mat._m12,
                        mat._m00 * mat._m11 - mat._m01 * mat._m10);
    float3x3 returnMat;
    returnMat._m00_m01_m02 = vec0;
    returnMat._m10_m11_m12 = vec1;
    returnMat._m20_m21_m22 = vec2;
    return returnMat / determinant;
}

inline float3x3 InverseTransposeVec(float3 vec0, float3 vec1, float3 vec2)
{
    float3x3 mat;
    mat._m00_m01_m02 = vec0;
    mat._m10_m11_m12 = vec1;
    mat._m20_m21_m22 = vec2;
    return InverseTranspose(mat);
}

inline float4x4 ReadBoneInfos(uint boneIndex)
{
    return mul(_BoneTransformMatrix, _BoneMatArray[boneIndex]);
}

inline VertexOutputStructure BlendBonesPosNormalTangent(VertexInputStructure input)
{
    float4 positionOS = float4(input.positionOS, 1);
    float3 normalOS = input.normalOS;
    float4 tangentOS = input.tangentOS;
    float4 boneUV = input.boneUV;

    uint boneIndexOne = floor(boneUV.x);
    float boneWeightOne = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.x);

    uint boneIndexTwo = floor(boneUV.y);
    float boneWeightTwo = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.y);

    uint boneIndexThree = floor(boneUV.z);
    float boneWeightThree = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.z);

    uint boneIndexFour = floor(boneUV.w);
    float boneWeightFour = BONE_WEIGHT_DECODE_VALUE * frac(boneUV.w);

    float4x4 matOne = ReadBoneInfos(boneIndexOne);
    float4x4 matTwo = ReadBoneInfos(boneIndexTwo);
    float4x4 matThree = ReadBoneInfos(boneIndexThree);
    float4x4 matFour = ReadBoneInfos(boneIndexFour);

    //blend position
    float3 posOne = mul(matOne, positionOS).xyz;
    float3 posTwo = mul(matTwo, positionOS).xyz;
    float3 posThree = mul(matThree, positionOS).xyz;
    float3 posFour = mul(matFour, positionOS).xyz;

    float3 returnPos = posOne * boneWeightOne
        + posTwo * boneWeightTwo
        + posThree * boneWeightThree
        + posFour * boneWeightFour;

    //blend normal
    float3x3 newMatOne = InverseTransposeVec(matOne._m00_m01_m02, matOne._m10_m11_m12, matOne._m20_m21_m22);
    float3x3 newMatTwo = InverseTransposeVec(matTwo._m00_m01_m02, matTwo._m10_m11_m12, matTwo._m20_m21_m22);
    float3x3 newMatThree = InverseTransposeVec(matThree._m00_m01_m02, matThree._m10_m11_m12, matThree._m20_m21_m22);
    float3x3 newMatFour = InverseTransposeVec(matFour._m00_m01_m02, matFour._m10_m11_m12, matFour._m20_m21_m22);

    float3 normalOne = mul(newMatOne, normalOS).xyz;
    float3 normalTwo = mul(newMatTwo, normalOS).xyz;
    float3 normalThree = mul(newMatThree, normalOS).xyz;
    float3 normalFour = mul(newMatFour, normalOS).xyz;

    float3 returnNormal = normalOne * boneWeightOne
        + normalTwo * boneWeightTwo
        + normalThree * boneWeightThree
        + normalFour * boneWeightFour;

    returnNormal = normalize(returnNormal);

    //blend tangent
    float3 tangentOne = mul((float3x3)matOne, tangentOS.xyz);
    float3 tangentTwo = mul((float3x3)matTwo, tangentOS.xyz);
    float3 tangentThree = mul((float3x3)matThree, tangentOS.xyz);
    float3 tangentFour = mul((float3x3)matFour, tangentOS.xyz);

    float3 tempTangent = tangentOne * boneWeightOne
                        + tangentTwo * boneWeightTwo
                        + tangentThree * boneWeightThree
                        + tangentFour * boneWeightFour;
    tempTangent = normalize(tempTangent);
    float4 returnTangent = float4(tempTangent, tangentOS.w);

    VertexOutputStructure output;
    output.positionOS = returnPos;
    output.normalOS = returnNormal;
    output.tangentOS = returnTangent;
    return output;
}
#endif
</code></pre><h3 id=bonegpuskinningshadershader>BoneGPUSkinningShader.shader<a hidden class=anchor aria-hidden=true href=#bonegpuskinningshadershader>#</a></h3><p>用于渲染的shader中，要在顶点着色器中调用<code>BoneGPUSkinning.hlsl</code>中的方法获取蒙皮后的顶点位置、切线和法线。我这里使用了一个比较简单的渲染，给模型一点基础的光影。要注意的是，如果需要正确的阴影的话，在<code>ShadowCaster</code>这个pass中还需要计算一遍顶点位置，这里就暂且忽略了。</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/BoneGPUSkinningShader&quot;
{
    Properties
    {
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; &quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; }

        HLSLINCLUDE

#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
#include &quot;Assets/GPUSkinning/BoneGPUSkinning.hlsl&quot;

        sampler2D _MainTex;
        CBUFFER_START(UnityPerMaterial)
        float4 _Color;
        CBUFFER_END

        struct a2v
        {
            float4 vertex   : POSITION;
            float2 uv       : TEXCOORD0;
            float4 boneUV   : TEXCOORD1;
            float3 normal   : NORMAL;
            float4 tangent  : TANGENT;
        };

        struct v2f
        {
            float4 pos          : SV_POSITION;
            float2 uv           : TEXCOORD0;
            float4 tempColor    : TEXCOORD1;
            float3 normalWS     : TEXCOORD2;
            float4 tangentWS    : TEXCOORD3;
            float3 eyeVec       : TEXCOORD4;
        };

        v2f animVert(a2v v)
        {
            v2f o;
            VertexInputStructure inputStructure;
            inputStructure.positionOS = v.vertex;
            inputStructure.normalOS = v.normal;
            inputStructure.tangentOS = v.tangent;
            inputStructure.boneUV = v.boneUV;

            VertexOutputStructure outputStructure = BlendBonesPosNormalTangent(inputStructure);
            float3 vertexPos = outputStructure.positionOS;
            float3 vertexNormal = outputStructure.normalOS;
            float3 vertexTangent = outputStructure.tangentOS;

            o.pos = TransformObjectToHClip(vertexPos);
            o.normalWS = TransformObjectToWorldNormal(vertexNormal);
            o.tangentWS = float4(TransformObjectToWorldDir(vertexTangent), v.tangent.w);

            o.uv = v.uv;
            o.tempColor = float4(1, 1, 1, 1);
            float3 worldPos = TransformObjectToWorld(float4(vertexPos, 1));
            o.eyeVec = GetCameraPositionWS() - worldPos;

            return o;
        }

        float4 animFrag(v2f i) : SV_TARGET
        {
            float3 viewDir = normalize(i.eyeVec);
            float3 lightDir = normalize(float3(1, 1, 1));
            float3 halfVec = normalize(lightDir + viewDir);

            float3 normalWS = normalize(i.normalWS);
            float NdotL = dot(normalWS, lightDir) * 0.6 + 0.4;
            float NdotH = saturate(dot(normalWS, halfVec));

            float3 diffuseColor = _Color.xyz * NdotL;
            float3 specularColor = pow(NdotH, 30);
            return float4(diffuseColor + specularColor, 1);
        }

        ENDHLSL
        pass
        {
            Tags{ &quot;LightMode&quot; = &quot;UniversalForward&quot; }

            HLSLPROGRAM
            #pragma vertex animVert
            #pragma fragment animFrag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=最后的思考>最后的思考<a hidden class=anchor aria-hidden=true href=#最后的思考>#</a></h2><p>总的来说，上面的操作已经基本完成了GPU Skinning的需求，而且能够正确的与Animator组件相结合。当然仍有优化的空间，比如说把所有要做GPU Skinning的mesh使用同一个Update的方法来更新，等等。但是美中不足的是之前提到的获取localToWorldMatrix的问题，直接导致了使用这个方法不如Unity自带的GPU Skinning效率高，自带的GPU蒙皮应该是用到了Unity底层的一些优化吧，但是核心的操作应该和我这里做的差不多。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/gpu-skinning/>GPU Skinning</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><span class=title>« Prev Page</span><br><span>在Unity SRP中实现TAA效果</span></a>
<a class=next href=https://zznewclear13.github.io/posts/get-world-space-position-from-depth-texture/><span class=title>Next Page »</span><br><span>从深度图中获取世界空间的坐标</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>