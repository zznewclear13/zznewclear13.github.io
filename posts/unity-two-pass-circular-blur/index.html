<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š | ZZNEWCLEAR13</title><meta name=keywords content="Circular Blur,Group Shared Memory,Compute Shader,Bokeh,Post-Process"><meta name=description content="åœ¨Unityé‡Œå®ç°EAçš„åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Š."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š"><meta property="og:description" content="åœ¨Unityé‡Œå®ç°EAçš„åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Š."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/posts/images/CircularBlur.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-09T12:00:00+08:00"><meta property="article:modified_time" content="2023-04-09T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/posts/images/CircularBlur.png"><meta name=twitter:title content="Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š"><meta name=twitter:description content="åœ¨Unityé‡Œå®ç°EAçš„åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Š."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š","item":"https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š","name":"Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š","description":"åœ¨Unityé‡Œå®ç°EAçš„åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Š.","keywords":["Circular Blur","Group Shared Memory","Compute Shader","Bokeh","Post-Process"],"articleBody":"åœ†å½¢æ¨¡ç³Š åœ†å½¢æ¨¡ç³Šï¼Œåœ¨Photoshopé‡Œåˆç§°é•œå¤´æ¨¡ç³Š(Lens Blur)ï¼Œå’Œæ™¯æ·±ç»“åˆåœ¨ä¸€èµ·çš„æ—¶å€™è¢«ç§°ä½œæ•£æ™¯(Bokeh)ï¼Œæ˜¯æŒ‡åœ¨æ‘„å½±æ—¶å¤±ç„¦çš„åŒºåŸŸäº§ç”Ÿçš„å’Œå…‰åœˆçš„å½¢çŠ¶ä¸€è‡´çš„æ¨¡ç³Šæ•ˆæœï¼Œäº”è¾¹å½¢å…«è¾¹å½¢æˆ–æ˜¯åœ†å½¢éƒ½æœ‰å¯èƒ½ã€‚\nåœ¨è®¡ç®—æœºå›¾å½¢å­¦ä¸­å®ç°æ™¯æ·±æ•ˆæœåŸºæœ¬ä¸Šæœ‰ä¸¤ç§æ–¹æ³•ï¼šç¬¬ä¸€ç§ä¹Ÿæ˜¯æœ€å¸¸ç”¨çš„ï¼Œé€šè¿‡é»„é‡‘ç‡ç”Ÿæˆä¸€ç³»åˆ—çš„é‡‡æ ·ç‚¹ï¼Œä½¿å¾—å…¶å½¢çŠ¶æ¥è¿‘æƒ³è¦æ¨¡ç³Šçš„å½¢çŠ¶ï¼Œè¿™ç§æ–¹æ³•éœ€è¦å¾ˆå¤šå¾ˆå¤šçš„é‡‡æ ·ç‚¹ï¼ŒåŸºæœ¬ä¸Šæ‰¾åˆ°çš„éƒ½æ˜¯60æ¬¡ä»¥ä¸Šçš„é‡‡æ ·æ¬¡æ•°ï¼Œç”±äºé‡‡æ ·ç‚¹çš„åˆ†å¸ƒä¸ä¸€å®šæ­£å¥½åœ¨åƒç´ ç‚¹ä¸­å¿ƒï¼Œä¹Ÿä¸èƒ½è½»æ˜“åœ°ä½¿ç”¨Group Shared Memoryè¿›è¡Œä¼˜åŒ–ï¼Œäº‹å®ä¸Šå¤§çš„æ¨¡ç³ŠåŠå¾„å¾ˆå¯èƒ½å¯¼è‡´Group Shared Memoryçš„å¤§å°ä¸å¤Ÿï¼›å¦ä¸€ç§æ˜¯é’ˆå¯¹äºç‰¹æ®Šçš„æ¨¡ç³Šå½¢çŠ¶ï¼Œæ¯”å¦‚æ­£å…­è¾¹å½¢ï¼Œå¯ä»¥ä½¿ç”¨ä¸‰æ¬¡ï¼ˆMRTçš„è¯å¯ä»¥è®¤ä¸ºæ˜¯ä¸¤æ¬¡ï¼‰1Dçš„æ¨¡ç³Šæ¥ç»„åˆè€Œæˆï¼Œå¯ä»¥åœ¨Colin BarrÃ©-Briseboisçš„åšå®¢Hexagonal Bokeh Blur Revisitedä¸­çœ‹åˆ°è¯¦ç»†çš„è¯´æ˜ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ä»–æ­¤å‰ä¹Ÿåœ¨EAå·¥ä½œè¿‡ï¼ˆçœ‹æ¥EAæ˜¯çœŸçš„å¾ˆå–œæ¬¢æ•£æ™¯å•Šï¼‰ã€‚\nEAçš„æ¸²æŸ“å·¥ç¨‹å¸ˆKleber Garciaåœ¨2018å¹´çš„GDCæ¼”è®²Circular Separable Convolution Depth of Fieldä¸­æåˆ°äº†é€šè¿‡å¤æ•°çš„è¿ç®—æ¥å®ç°åœ†å½¢æ¨¡ç³Šçš„ç®—æ³•ï¼Œå…¶èƒŒåçš„æ•°å­¦æˆ‘è¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ï¼Œæ„Ÿå…´è¶£çš„è¯å¯ä»¥å‚è€ƒCircularly symmetric convolution and lens bluè¿™ç¯‡æ–‡ç« ã€‚åœ†å½¢æ¨¡ç³Šçš„å‚æ•°çš„ç”Ÿæˆçš„ä»£ç å¯ä»¥åœ¨Kleber Garciaçš„å…¬å¼€ä»“åº“é‡Œæ‰¾åˆ°ã€‚Kleber Garciaæœ¬äººä¹Ÿåœ¨Shadertoyä¸Šå†™äº†å…·ä½“çš„åœ†å½¢æ¨¡ç³Šçš„ä»£ç ã€‚\n\rCircular Dof\n\rç”±äºæ™¯æ·±æ•ˆæœç›¸å¯¹æ¥è¯´æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œå°±åªè€ƒè™‘å¯¹æ•´ä¸ªå±å¹•æ–½åŠ ç›¸åŒç¨‹åº¦çš„åœ†å½¢æ¨¡ç³Šæ•ˆæœã€‚\nå…·ä½“çš„å®ç°æ–¹æ³• å…¶å®å¤§éƒ¨åˆ†å’Œä¹‹å‰çš„é«˜æ–¯æ¨¡ç³Šæ²¡æœ‰ä»€ä¹ˆå·®åˆ«ã€‚åœ¨åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Šçš„ç®—æ³•ä¸­ï¼Œåœ†å½¢çš„æ•ˆæœæ˜¯é€šè¿‡å¤šä¸ªFilterå åŠ è€Œæˆçš„ï¼Œæ¯ä¸ªFilterå¯¹åº”å®éƒ¨å’Œè™šéƒ¨ä¸¤ä¸ªå‚æ•°ã€‚ä»¥æœ¬æ–‡ä¸ºä¾‹ï¼Œæœ¬æ–‡ä½¿ç”¨äº†ä¸¤ä¸ªFilterï¼Œå¯¹äºä¸€ä¸ªFilterçš„ä¸€ä¸ªé¢œè‰²åˆ†é‡ï¼Œéœ€è¦å‚¨å­˜å®éƒ¨è™šéƒ¨ä¸¤ä¸ªæ•°æ®ï¼Œæ€»ä½“å°±éœ€è¦2x3x2=12ä¸ªé€šé“ï¼Œä½¿ç”¨ä¸‰å¼ R16G16B16A16_SFloatå°±èƒ½å‚¨å­˜æ‰€æœ‰çš„æ•°æ®ã€‚åœ¨Kleber Garciaçš„æ¼”è®²ä¸­ä»–è¿˜æåˆ°äº†ï¼Œå¯ä»¥ä½¿ç”¨bracketçš„æ–¹æ³•ï¼Œå°†é¢œè‰²çš„å·ç§¯æ•°æ®å‚¨å­˜åˆ°å¦ä¸€å¼ å›¾ä¸­ï¼Œè¿™æ ·ä¸­é—´çš„Filterçš„ç»“æœå°±ä¼šè½åœ¨[0, 1]çš„èŒƒå›´å†…ï¼Œå°±èƒ½ä½¿ç”¨R8G8A8B8æ¥å‚¨å­˜äº†ï¼Œå¯ä»¥èŠ‚çœä¸€åŠçš„å¸¦å®½ï¼ˆä½†æ˜¯é¢œè‰²çš„å·ç§¯æ•°æ®ä¸ä¹Ÿè¦ä¸€å¼ 32ä½çš„å›¾å—ï¼Œè¿™é‡Œæˆ‘æ²¡å¤ªæ‡‚ï¼Œæ„Ÿè§‰ä¼˜åŒ–äº†ä½†åˆæ²¡é‚£ä¹ˆä¼˜åŒ–ï¼Œç´¢æ€§å°±æ²¡é‚£ä¹ˆåšï¼‰ã€‚\næ•´ä½“çš„æ“ä½œæ˜¯ï¼š1. é‡‡æ ·æºå›¾ç‰‡ï¼Œå¯¹æ¯ä¸ªFilterå’Œæ¯ä¸ªé¢œè‰²åˆ†é‡è®¡ç®—å®éƒ¨å’Œè™šéƒ¨çš„å€¼ï¼Œæ°´å¹³ç´¯åŠ åå‚¨å­˜åˆ°ä¸­é—´è´´å›¾ä¸­ï¼›2. é‡‡æ ·ä¸­é—´è´´å›¾ï¼Œå¯¹æ¯ä¸ªFilterå’Œæ¯ä¸ªé¢œè‰²åˆ†é‡è®¡ç®—å®éƒ¨å’Œè™šéƒ¨çš„å€¼ï¼Œç«–ç›´ç´¯åŠ åä¹˜ä¸Šå„è‡ªçš„æƒé‡å°±å¾—åˆ°æœ€ç»ˆçš„é¢œè‰²äº†ã€‚ç”±äºæˆ‘æ²¡æœ‰ä½¿ç”¨bracketçš„æ–¹æ³•ï¼ŒFilterä¸­ä¼šæœ‰è´Ÿå€¼å­˜åœ¨ï¼Œåœ¨ä»…ä½¿ç”¨ä¸¤ä¸ªFilterä¸”åŠå¾„è¾ƒå¤§ä¸”åƒç´ é¢œè‰²è¿‡äº®çš„æ—¶å€™ï¼Œç”±äºbandingçš„å­˜åœ¨ä¼šä½¿æœ€ç»ˆçš„é¢œè‰²å‡ºç°è´Ÿå€¼ï¼Œè§£å†³æ–¹æ³•æ˜¯åœ¨è¯»å–é¢œè‰²çš„æ—¶å€™åšä¸€æ¬¡Clampæˆ–è€…æ˜¯ToneMappingåˆ°åˆç†èŒƒå›´ã€‚\nCircularBlurFilterGenerator.cs æ”¹å†™è‡ªKleber Garciaçš„å…¬å¼€ä»“åº“ã€‚\n/* Copyright 2023 zznewclear13 (zznewclear@gmail.com) Copyright 2016 Kleber A Garcia (kecho_garcia@hotmail.com) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\u001d */ using UnityEngine; public static class CircularBlurFilterGenerator { public struct Filter { public Vector2 kernelWeight; public Vector2[] circularKernels; } public struct KernelData { public Filter[] filters; } private static Vector4 KernelFunction(float x, Vector4 C) { float real = Mathf.Cos(x * x * C.x) * Mathf.Exp(x * x * C.y); float imaginary = Mathf.Sin(x * x * C.x) * Mathf.Exp(x * x * C.y); float realWeight = C.z; float imaginaryWeight = C.w; return new Vector4(real, imaginary, realWeight, imaginaryWeight); } // 1  // best: 0.2f  public static KernelData GenerateFilter(float radius, int components = 2, float transition = 0.2f, bool logKernel = false) { int sampleRadius = Mathf.CeilToInt(radius); int kernelSize = 2 * sampleRadius + 1; KernelData kernelData = new KernelData(); if (transition 1.0f) { Debug.Log(\"Invalid transition bandwidth. Must be greater than -1 and preferably positive.\"); return kernelData; } Vector4[] P; switch (components) { case 1: P = new Vector4[] { new Vector4( 1.624835f, -0.862325f, 0.767583f, 1.862321f ) }; break; case 2: P = new Vector4[] { new Vector4( 5.268909f, -0.886528f, 0.411259f, -0.548794f ), new Vector4(1.558213f, -1.960518f, 0.513282f, 4.561110f ) }; break; case 3: P = new Vector4[] { new Vector4( 5.043495f, -2.176490f, 1.621035f, -2.105439f ), new Vector4( 9.027613f, -1.019306f, -0.280860f, -0.162882f ), new Vector4( 1.597273f, -2.815110f, -0.366471f, 10.300301f ) }; break; case 4: P = new Vector4[] { new Vector4( 1.553635f, -4.338459f, -5.767909f, 46.164397f ), new Vector4( 4.693183f, -3.839993f, 9.795391f, 15.227561f ), new Vector4( 8.178137f, -2.791880f, -3.048324f, 0.302959f ), new Vector4( 12.328289f, -1.342190f, 0.010001f, 0.244650f ) }; break; case 5: P = new Vector4[] { new Vector4( 1.685979f, -4.892608f, -22.356787f, 85.912460f ), new Vector4( 4.998496f, -4.711870f, 35.918936f , -28.875618f ), new Vector4( 8.244168f, -4.052795f, -13.212253f, -1.578428f ), new Vector4( 11.900859f, -2.929212f, 0.507991f, 1.816328f ), new Vector4( 16.116382f, -1.512961f, 0.138051f, -0.010000f ) }; break; default: Debug.Log(\"Invalid component count. Must be [1-5].\"); return kernelData; } Vector4[,] kernels = new Vector4[components, kernelSize]; float totalBandWidth = 1.0f + transition; for (int i = 0; i for (int j = -sampleRadius; j 1; j++) { kernels[i, j + sampleRadius] = KernelFunction(totalBandWidth * j / radius, C); } } // normalize kernels  float accum = 0.0f; for (int i = 0; i for (int j = 0; j for (int k = 0; k float normConstant = 1.0f / Mathf.Sqrt(accum); Vector4[,] kernelsNormalized = new Vector4[components, kernelSize]; for (int i = 0; i for (int j = 0; j new Vector4(normConstant * v.x, normConstant * v.y, 0.0f, 0.0f); kernelsNormalized[i, j] = vn; } } // bracket the kernel so we maximize precision. This means figureout a Offset and a Scale  Vector2[] scales = new Vector2[components]; Vector2[] offsets = new Vector2[components]; for (int i = 0; i new Vector2(kernelsNormalized[i, 0].x, kernelsNormalized[i, 0].y); for (int j = 1; j new Vector2(Mathf.Min(minVector.x, kernelsNormalized[i, j].x), Mathf.Min(minVector.y, kernels[i, j].y)); } offsets[i] = minVector; } for (int i = 0; i new Vector2(0f, 0f); for (int j = 0; j float realScale = v.x - offset.x; float immScale = v.y - offset.y; scale += new Vector2(realScale, immScale); } scales[i] = scale; } Vector4[,] finalKernels = new Vector4[components, kernelSize]; for (int i = 0; i for (int j = 0; j float realScale = v.x - offset.x; float immScale = v.y - offset.y; finalKernels[i, j] = new Vector4(v.x, v.y, realScale / scale.x, immScale / scale.y); } } Vector2[] componentWeights = new Vector2[components]; for (int i = 0; i new Vector2(comp.z, comp.w); } Filter[] filters = new Filter[components]; for (int i = 0; i new Vector2[kernelSize]; for (int j = 0; j new Vector2(v.x, v.y); } Vector2 kernelWeight = componentWeights[i]; filters[i] = new Filter { kernelWeight = kernelWeight, circularKernels = circularKernels }; } kernelData.filters = filters; if(logKernel) { Debug.Log(Log(radius, finalKernels, componentWeights, offsets, scales)); } return kernelData; } private static readonly string[] syntax = new string[] { \"uint\", \"float\", \"static const\", \"{\", \"};\" }; private static string Log(float radius, Vector4[,] finalKernels, Vector2[] componentWeights, Vector2[] offsets, Vector2[] scales) { string logStr = \"\"; logStr += string.Format(\"{0} {1} KERNEL_RADIUS = {2};\\n\", syntax[2], syntax[0], radius); int kernelSize = Mathf.CeilToInt(radius) * 2 + 1; logStr += string.Format(\"{0} {1} KERNEL_COUNT = {2};\\n\", syntax[2], syntax[0], kernelSize); int component = componentWeights.Length; for (int i = 0; i string.Format(\"{0} {1}4 Kernel{2}BracketsRealXY_ImZW = {1}4({3},{4},{5},{6});\\n\", syntax[2], syntax[1], i, o.x, s.x, o.y, s.y); logStr += string.Format(\"{0} {1}2 Kernel{2}Weights_RealX_ImY = {1}2({3},{4});\\n\", syntax[2], syntax[1], i, comp.x, comp.y); logStr += string.Format(\"{0} {1}4 Kernel{2}_RealX_ImY_RealZ_ImW[] = {3}\\n\", syntax[2], syntax[1], i, syntax[3]); for (int j = 0; j string.Format(\"\\t{0}4(/*XY: Non Bracketed*/{1},{2},/*Bracketed WZ:*/{3},{4}){5}\\n\", syntax[1], val.x, val.y, val.z, val.w, (j 1) ? \",\" : \"\"); } logStr += string.Format(\"{0}\\n\", syntax[4]); } return logStr; } } CircularBlurComputeShader.compute æˆ‘åªä½¿ç”¨äº†ä¸¤ä¸ªFilterï¼Œä¸”å°†å…¶æƒé‡å’Œå‚æ•°åˆå¹¶åˆ°äº†ä¸€ä¸ªStructuredBufferä¸­ï¼Œæ¯ä¸€ä¸ªFilterå°±éœ€è¦æ ¹æ®ä¸€å®šçš„åç§»é‡å»è·å–åˆ°æƒé‡å’Œå‚æ•°çš„æ•°æ®ã€‚åŒæ—¶åˆå› ä¸ºåªä½¿ç”¨äº†ä¸¤ä¸ªFilterï¼Œä¸€ä¸ªé¢œè‰²åˆ†é‡ä¼šæœ‰ä¸¤ç»„å®éƒ¨å’Œè™šéƒ¨ï¼Œåˆšå¥½æ„æˆä¸€ä¸ªå››é€šé“çš„æ•°æ®ï¼Œå¯¹åº”åˆ°ä¸€å¼ è´´å›¾ä¸Šã€‚è¿™ä¸ªCompute Shaderå¾ˆå¤§ç¨‹åº¦åœ°å‚è€ƒäº†Kleber Garciaçš„Circular Dofã€‚\n#pragma kernel CircularH\r#pragma kernel CircularV\rTexture2D _ColorTexture;\rTexture2D _RTexture;\rTexture2D _GTexture;\rTexture2D _BTexture;\rRWTexture2D _RW_RTexture;\rRWTexture2D _RW_GTexture;\rRWTexture2D _RW_BTexture;\rRWTexture2D _RW_CompositeTexture;\rfloat4 _TextureSize;\rint _SampleRadius;\rStructuredBuffer _CircularKernels;\r#define COLOR_THRESHOLD 5.0f\r#define CIRCULAR_BLUR_MAX_RADIUS 128\r#define THREAD_GROUP_SIZE 256\rconst static int CACHED_COLOR_SIZE = THREAD_GROUP_SIZE + CIRCULAR_BLUR_MAX_RADIUS * 2;\rgroupshared half3 cachedColor[CACHED_COLOR_SIZE];\rvoid SetCachedColor(half3 color, int index) { cachedColor[index] = color; }\rhalf3 GetCachedColor(int threadPos) { return cachedColor[threadPos + CIRCULAR_BLUR_MAX_RADIUS]; }\rvoid CacheColor(int2 groupCacheStartPos, int cacheIndex)\r{\rint2 texturePos = groupCacheStartPos + int2(cacheIndex, 0);\rtexturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f);\rhalf3 color = _ColorTexture.Load(uint3(texturePos, 0)).rgb;\rcolor = clamp(color, 0.0f, COLOR_THRESHOLD);\rSetCachedColor(color, cacheIndex);\r}\rstruct RGBComp\r{\rhalf4 rComp;\rhalf4 gComp;\rhalf4 bComp;\r};\rgroupshared RGBComp cachedComp[CACHED_COLOR_SIZE];\rvoid SetCachedComp(RGBComp comp, int index) { cachedComp[index] = comp; }\rRGBComp GetCachedComp(int threadPos) { return cachedComp[threadPos + CIRCULAR_BLUR_MAX_RADIUS]; }\rvoid CacheComp(int2 groupCacheStartPos, int cacheIndex)\r{\rint2 texturePos = groupCacheStartPos + int2(0, cacheIndex);\rtexturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f);\rhalf4 rComp = _RTexture.Load(uint3(texturePos, 0));\rhalf4 gComp = _GTexture.Load(uint3(texturePos, 0));\rhalf4 bComp = _BTexture.Load(uint3(texturePos, 0));\rRGBComp rgbComp = (RGBComp)0;\rrgbComp.rComp = rComp;\rrgbComp.gComp = gComp;\rrgbComp.bComp = bComp;\rSetCachedComp(rgbComp, cacheIndex);\r}\r//(Pr+Pi)*(Qr+Qi) = (Pr*Qr+Pr*Qi+Pi*Qr-Pi*Qi)\rfloat2 multComplex(float2 p, float2 q)\r{\rreturn float2(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);\r}\r[numthreads(THREAD_GROUP_SIZE,1,1)]\rvoid CircularH(uint3 groupID : SV_GroupID,\ruint3 groupThreadID : SV_GroupThreadID,\ruint groupIndex : SV_GroupIndex,\ruint3 dispatchThreadID : SV_DispatchThreadID)\r{\rint2 threadGroupSize = int2(THREAD_GROUP_SIZE, 1);\rint2 groupCacheStartPos = groupID.xy * threadGroupSize - int2(CIRCULAR_BLUR_MAX_RADIUS, 0);\rint cacheIndex = groupIndex * 2;\rif (cacheIndex CircularBlur.cs è¿™é‡Œéœ€è¦ä¿è¯radiusçš„æœ€å¤§å€¼ä¸å¤§äºCompute Shaderé‡Œçš„CIRCULAR_BLUR_MAX_RADIUSã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Circular Blur\", typeof(UniversalRenderPipeline))] public class CircularBlur : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter radius = new ClampedFloatParameter(0.0f, 0.0f, 128.0f); public bool IsActive() { return isEnabled.value \u0026\u0026 radius.value  0.0f; } public bool IsTileCompatible() { return false; } } } CircularBlurRenderPass.cs å’Œé«˜æ–¯æ¨¡ç³Šçš„Render Passå¤§åŒå°å¼‚ã€‚\nusing System.Collections.Generic; namespace UnityEngine.Rendering.Universal { public class CircularBlurRenderPass : ScriptableRenderPass { static readonly string passName = \"Circular Blur Render Pass\"; private CircularBlurRendererFeature.CircularBlurSettings settings; private CircularBlur circularBlur; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); RenderTargetIdentifier cameraColorIden; static readonly string circularBlurTextureRName = \"_CircularBlurTextureR\"; static readonly int circularBlurTextureRID = Shader.PropertyToID(circularBlurTextureRName); RenderTargetIdentifier circularBlurTextureRIden; static readonly string circularBlurTextureGName = \"_CircularBlurTextureG\"; static readonly int circularBlurTextureGID = Shader.PropertyToID(circularBlurTextureGName); RenderTargetIdentifier circularBlurTextureGIden; static readonly string circularBlurTextureBName = \"_CircularBlurTextureB\"; static readonly int circularBlurTextureBID = Shader.PropertyToID(circularBlurTextureBName); RenderTargetIdentifier circularBlurTextureBIden; static readonly string compositeTextureName = \"_CompositeTexture\"; static readonly int compositeTextureID = Shader.PropertyToID(compositeTextureName); RenderTargetIdentifier compositeTextureIden; CircularBlurFilterGenerator.KernelData kernelData; private ComputeBuffer computeBuffer; private Vector2Int textureSize; private float lastRadius = 0.0f; static readonly string HorizontalKernelName = \"CircularH\"; static readonly string VerticalKernelName = \"CircularV\"; static readonly int _ColorTexture = Shader.PropertyToID(\"_ColorTexture\"); static readonly int _RTexture = Shader.PropertyToID(\"_RTexture\"); static readonly int _GTexture = Shader.PropertyToID(\"_GTexture\"); static readonly int _BTexture = Shader.PropertyToID(\"_BTexture\"); static readonly int _RW_RTexture = Shader.PropertyToID(\"_RW_RTexture\"); static readonly int _RW_GTexture = Shader.PropertyToID(\"_RW_GTexture\"); static readonly int _RW_BTexture = Shader.PropertyToID(\"_RW_BTexture\"); static readonly int _RW_CompositeTexture = Shader.PropertyToID(\"_RW_CompositeTexture\"); static readonly int _TextureSize = Shader.PropertyToID(\"_TextureSize\"); static readonly int _SampleRadius = Shader.PropertyToID(\"_SampleRadius\"); static readonly int _CircularKernels = Shader.PropertyToID(\"_CircularKernels\"); public CircularBlurRenderPass(CircularBlurRendererFeature.CircularBlurSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); circularBlurTextureRIden = new RenderTargetIdentifier(circularBlurTextureRID); circularBlurTextureGIden = new RenderTargetIdentifier(circularBlurTextureGID); circularBlurTextureBIden = new RenderTargetIdentifier(circularBlurTextureBID); compositeTextureIden = new RenderTargetIdentifier(compositeTextureID); } public void Setup(CircularBlur circularBlur) { this.circularBlur = circularBlur; } private void EnsureComputeBuffer(int count, int stride) { if (computeBuffer == null || computeBuffer.count != count || computeBuffer.stride != stride) { if (computeBuffer != null) { computeBuffer.Release(); } computeBuffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData) { if(lastRadius != circularBlur.radius.value) { kernelData = CircularBlurFilterGenerator.GenerateFilter(circularBlur.radius.value, 2, 0.2f, false); int count = kernelData.filters.Length * (1 + kernelData.filters[0].circularKernels.Length); EnsureComputeBuffer(count, 2 * sizeof(float)); List data = new List(); foreach (var filter in kernelData.filters) { data.Add(filter.kernelWeight); data.AddRange(filter.circularKernels); } computeBuffer.SetData(data); lastRadius = circularBlur.radius.value; } } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat; cmd.GetTemporaryRT(circularBlurTextureRID, desc); cmd.GetTemporaryRT(circularBlurTextureGID, desc); cmd.GetTemporaryRT(circularBlurTextureBID, desc); cmd.GetTemporaryRT(compositeTextureID, desc); } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoCircularBlur(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier rid, RenderTargetIdentifier gid, RenderTargetIdentifier bid, RenderTargetIdentifier compositeid, ComputeShader computeShader) { if (!computeShader) return; { int kernelID = computeShader.FindKernel(HorizontalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _ColorTexture, colorid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_RTexture, rid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_GTexture, gid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_BTexture, bid); cmd.SetComputeBufferParam(computeShader, kernelID, _CircularKernels, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.SetComputeIntParam(computeShader, _SampleRadius, Mathf.CeilToInt(circularBlur.radius.value)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } { int kernelID = computeShader.FindKernel(VerticalKernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, _RTexture, rid); cmd.SetComputeTextureParam(computeShader, kernelID, _GTexture, gid); cmd.SetComputeTextureParam(computeShader, kernelID, _BTexture, bid); cmd.SetComputeTextureParam(computeShader, kernelID, _RW_CompositeTexture, compositeid); cmd.SetComputeBufferParam(computeShader, kernelID, _CircularKernels, computeBuffer); cmd.SetComputeVectorParam(computeShader, _TextureSize, GetTextureSizeParams(textureSize)); cmd.SetComputeIntParam(computeShader, _SampleRadius, Mathf.CeilToInt(circularBlur.radius.value)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } cmd.Blit(compositeid, cameraColorIden); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { DoCircularBlur(cmd, cameraColorIden, circularBlurTextureRIden, circularBlurTextureGIden, circularBlurTextureBIden, compositeTextureIden, computeShader); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(circularBlurTextureRID); cmd.ReleaseTemporaryRT(circularBlurTextureGID); cmd.ReleaseTemporaryRT(circularBlurTextureBID); cmd.ReleaseTemporaryRT(compositeTextureID); } public void Dispose() { if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } } } } CircularBlurRendererFeature.cs å’Œé«˜æ–¯æ¨¡ç³Šçš„Renderer Featureå¦‚å‡ºä¸€è¾™ã€‚\nnamespace UnityEngine.Rendering.Universal { public class CircularBlurRendererFeature : ScriptableRendererFeature { [System.Serializable] public class CircularBlurSettings { public RenderPassEvent renderPassEvent; public ComputeShader computeShader; } public CircularBlurSettings settings = new CircularBlurSettings(); private CircularBlurRenderPass circularBlurRenderPass; public override void Create() { circularBlurRenderPass = new CircularBlurRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { CircularBlur circularBlur = VolumeManager.instance.stack.GetComponent(); if (circularBlur != null \u0026\u0026 circularBlur.IsActive()) { circularBlurRenderPass.Setup(circularBlur); renderer.EnqueuePass(circularBlurRenderPass); } } protected override void Dispose(bool disposing) { circularBlurRenderPass.Dispose(); base.Dispose(disposing); } } } åè®° å¤ªæ£’äº†å¤ªæ£’äº†ï¼Œè¿…é€Ÿåœ°å†™å®Œäº†EAçš„Circular Blurï¼æœ¬æ¥æƒ³é…ä¸€å¼ å¤•é˜³ä¸‹çš„æ¤°æ ‘å‰ªå½±å’Œæµ·é¢æ³¢å…‰ç²¼ç²¼åå…‰çš„åœºæ™¯ï¼Œå¯¹å…¶è¿›è¡Œåœ†å½¢æ¨¡ç³Šçš„ï¼Œå‘ç°æ°´çš„Shaderè¿˜è¦è‡ªå·±å†™ï¼ŒUnityçš„é»˜è®¤æè´¨çƒçš„Smoothnessè¿˜è¦ä½¿ç”¨Albedoæˆ–è€…Metallicå›¾çš„Alphaé€šé“ï¼Œå¯¼è‡´MegaScansçš„ç´ æè¿˜ä¸èƒ½ç›´æ¥ç”¨ï¼Œå°±æš‚æ—¶æ”¾å¼ƒäº†ã€‚ç­‰å†™å®Œæ™¯æ·±ä¹‹åå†æ•´è¿™äº›å§ï¼Œé¡ºä¾¿ä¸€æä¸ºäº†è®©å°é¢å›¾èƒ½æœ‰é‚£ä¸ªå°å°çš„æ•£æ™¯çš„åœ†å½¢ï¼Œæˆ‘å·å·åœ°å¦å¤–æ‰“äº†ä¸€ç›ç¯ã€‚ä¸‹ä¸€æ­¥ï¼Œæ™¯æ·±ï¼ï¼ï¼\n","wordCount":"2393","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/posts/images/CircularBlur.png","datePublished":"2023-04-09T12:00:00+08:00","dateModified":"2023-04-09T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-two-pass-circular-blur/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š</h1><div class=post-description>åœ¨Unityé‡Œå®ç°EAçš„åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Š.</div><div class=post-meta><span title="2023-04-09 12:00:00 +0800 CST">April 9, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-two-pass-circular-blur.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/CircularBlur.png alt="Circular Blur Cover"><p>Circular Blur Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Unityä¸¤ä¸ªPassçš„åœ†å½¢æ¨¡ç³Š</div></summary><div class=inner><ul><li><a href=#%e5%9c%86%e5%bd%a2%e6%a8%a1%e7%b3%8a aria-label=åœ†å½¢æ¨¡ç³Š>åœ†å½¢æ¨¡ç³Š</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•</a><ul><li><a href=#circularblurfiltergeneratorcs aria-label=CircularBlurFilterGenerator.cs>CircularBlurFilterGenerator.cs</a></li><li><a href=#circularblurcomputeshadercompute aria-label=CircularBlurComputeShader.compute>CircularBlurComputeShader.compute</a></li><li><a href=#circularblurcs aria-label=CircularBlur.cs>CircularBlur.cs</a></li><li><a href=#circularblurrenderpasscs aria-label=CircularBlurRenderPass.cs>CircularBlurRenderPass.cs</a></li><li><a href=#circularblurrendererfeaturecs aria-label=CircularBlurRendererFeature.cs>CircularBlurRendererFeature.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=åœ†å½¢æ¨¡ç³Š>åœ†å½¢æ¨¡ç³Š<a hidden class=anchor aria-hidden=true href=#åœ†å½¢æ¨¡ç³Š>#</a></h2><p>åœ†å½¢æ¨¡ç³Šï¼Œåœ¨Photoshopé‡Œåˆç§°é•œå¤´æ¨¡ç³Š(Lens Blur)ï¼Œå’Œæ™¯æ·±ç»“åˆåœ¨ä¸€èµ·çš„æ—¶å€™è¢«ç§°ä½œæ•£æ™¯(Bokeh)ï¼Œæ˜¯æŒ‡åœ¨æ‘„å½±æ—¶å¤±ç„¦çš„åŒºåŸŸäº§ç”Ÿçš„å’Œå…‰åœˆçš„å½¢çŠ¶ä¸€è‡´çš„æ¨¡ç³Šæ•ˆæœï¼Œäº”è¾¹å½¢å…«è¾¹å½¢æˆ–æ˜¯åœ†å½¢éƒ½æœ‰å¯èƒ½ã€‚</p><p>åœ¨è®¡ç®—æœºå›¾å½¢å­¦ä¸­å®ç°æ™¯æ·±æ•ˆæœåŸºæœ¬ä¸Šæœ‰ä¸¤ç§æ–¹æ³•ï¼šç¬¬ä¸€ç§ä¹Ÿæ˜¯æœ€å¸¸ç”¨çš„ï¼Œé€šè¿‡é»„é‡‘ç‡ç”Ÿæˆä¸€ç³»åˆ—çš„é‡‡æ ·ç‚¹ï¼Œä½¿å¾—å…¶å½¢çŠ¶æ¥è¿‘æƒ³è¦æ¨¡ç³Šçš„å½¢çŠ¶ï¼Œè¿™ç§æ–¹æ³•éœ€è¦å¾ˆå¤šå¾ˆå¤šçš„é‡‡æ ·ç‚¹ï¼ŒåŸºæœ¬ä¸Šæ‰¾åˆ°çš„éƒ½æ˜¯60æ¬¡ä»¥ä¸Šçš„é‡‡æ ·æ¬¡æ•°ï¼Œç”±äºé‡‡æ ·ç‚¹çš„åˆ†å¸ƒä¸ä¸€å®šæ­£å¥½åœ¨åƒç´ ç‚¹ä¸­å¿ƒï¼Œä¹Ÿä¸èƒ½è½»æ˜“åœ°ä½¿ç”¨Group Shared Memoryè¿›è¡Œä¼˜åŒ–ï¼Œäº‹å®ä¸Šå¤§çš„æ¨¡ç³ŠåŠå¾„å¾ˆå¯èƒ½å¯¼è‡´Group Shared Memoryçš„å¤§å°ä¸å¤Ÿï¼›å¦ä¸€ç§æ˜¯é’ˆå¯¹äºç‰¹æ®Šçš„æ¨¡ç³Šå½¢çŠ¶ï¼Œæ¯”å¦‚æ­£å…­è¾¹å½¢ï¼Œå¯ä»¥ä½¿ç”¨ä¸‰æ¬¡ï¼ˆMRTçš„è¯å¯ä»¥è®¤ä¸ºæ˜¯ä¸¤æ¬¡ï¼‰1Dçš„æ¨¡ç³Šæ¥ç»„åˆè€Œæˆï¼Œå¯ä»¥åœ¨Colin BarrÃ©-Briseboisçš„åšå®¢<a href=https://colinbarrebrisebois.com/2017/04/18/hexagonal-bokeh-blur-revisited/>Hexagonal Bokeh Blur Revisited</a>ä¸­çœ‹åˆ°è¯¦ç»†çš„è¯´æ˜ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ä»–æ­¤å‰ä¹Ÿåœ¨EAå·¥ä½œè¿‡ï¼ˆçœ‹æ¥EAæ˜¯çœŸçš„å¾ˆå–œæ¬¢æ•£æ™¯å•Šï¼‰ã€‚</p><p>EAçš„æ¸²æŸ“å·¥ç¨‹å¸ˆKleber Garciaåœ¨2018å¹´çš„GDCæ¼”è®²<a href=https://www.ea.com/frostbite/news/circular-separable-convolution-depth-of-field>Circular Separable Convolution Depth of Field</a>ä¸­æåˆ°äº†é€šè¿‡å¤æ•°çš„è¿ç®—æ¥å®ç°åœ†å½¢æ¨¡ç³Šçš„ç®—æ³•ï¼Œå…¶èƒŒåçš„æ•°å­¦æˆ‘è¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ï¼Œæ„Ÿå…´è¶£çš„è¯å¯ä»¥å‚è€ƒ<a href="http://yehar.com/blog/?p=1495">Circularly symmetric convolution and lens blu</a>è¿™ç¯‡æ–‡ç« ã€‚åœ†å½¢æ¨¡ç³Šçš„å‚æ•°çš„ç”Ÿæˆçš„ä»£ç å¯ä»¥åœ¨Kleber Garciaçš„<a href=https://github.com/kecho/CircularDofFilterGenerator>å…¬å¼€ä»“åº“</a>é‡Œæ‰¾åˆ°ã€‚Kleber Garciaæœ¬äººä¹Ÿåœ¨Shadertoyä¸Šå†™äº†å…·ä½“çš„<a href=https://www.shadertoy.com/view/Xd2BWc>åœ†å½¢æ¨¡ç³Šçš„ä»£ç </a>ã€‚</p><figure class=entry-cover><iframe width=640 height=360 frameborder=0 src="https://www.shadertoy.com/embed/Xd2BWc?gui=true&t=10&paused=false&muted=true" allowfullscreen></iframe><p>Circular Dof</p></figure><p>ç”±äºæ™¯æ·±æ•ˆæœç›¸å¯¹æ¥è¯´æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œå°±åªè€ƒè™‘å¯¹æ•´ä¸ªå±å¹•æ–½åŠ ç›¸åŒç¨‹åº¦çš„åœ†å½¢æ¨¡ç³Šæ•ˆæœã€‚</p><h2 id=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æ–¹æ³•>#</a></h2><p>å…¶å®å¤§éƒ¨åˆ†å’Œä¹‹å‰çš„<a href=/posts/gaussian-blur-revisited/>é«˜æ–¯æ¨¡ç³Š</a>æ²¡æœ‰ä»€ä¹ˆå·®åˆ«ã€‚åœ¨åˆ†ç¦»å·ç§¯åœ†å½¢æ¨¡ç³Šçš„ç®—æ³•ä¸­ï¼Œåœ†å½¢çš„æ•ˆæœæ˜¯é€šè¿‡å¤šä¸ª<code>Filter</code>å åŠ è€Œæˆçš„ï¼Œæ¯ä¸ª<code>Filter</code>å¯¹åº”å®éƒ¨å’Œè™šéƒ¨ä¸¤ä¸ªå‚æ•°ã€‚ä»¥æœ¬æ–‡ä¸ºä¾‹ï¼Œæœ¬æ–‡ä½¿ç”¨äº†ä¸¤ä¸ª<code>Filter</code>ï¼Œå¯¹äºä¸€ä¸ª<code>Filter</code>çš„ä¸€ä¸ªé¢œè‰²åˆ†é‡ï¼Œéœ€è¦å‚¨å­˜å®éƒ¨è™šéƒ¨ä¸¤ä¸ªæ•°æ®ï¼Œæ€»ä½“å°±éœ€è¦2x3x2=12ä¸ªé€šé“ï¼Œä½¿ç”¨ä¸‰å¼ <code>R16G16B16A16_SFloat</code>å°±èƒ½å‚¨å­˜æ‰€æœ‰çš„æ•°æ®ã€‚åœ¨Kleber Garciaçš„æ¼”è®²ä¸­ä»–è¿˜æåˆ°äº†ï¼Œå¯ä»¥ä½¿ç”¨<code>bracket</code>çš„æ–¹æ³•ï¼Œå°†é¢œè‰²çš„å·ç§¯æ•°æ®å‚¨å­˜åˆ°å¦ä¸€å¼ å›¾ä¸­ï¼Œè¿™æ ·ä¸­é—´çš„<code>Filter</code>çš„ç»“æœå°±ä¼šè½åœ¨[0, 1]çš„èŒƒå›´å†…ï¼Œå°±èƒ½ä½¿ç”¨<code>R8G8A8B8</code>æ¥å‚¨å­˜äº†ï¼Œå¯ä»¥èŠ‚çœä¸€åŠçš„å¸¦å®½ï¼ˆä½†æ˜¯é¢œè‰²çš„å·ç§¯æ•°æ®ä¸ä¹Ÿè¦ä¸€å¼ 32ä½çš„å›¾å—ï¼Œè¿™é‡Œæˆ‘æ²¡å¤ªæ‡‚ï¼Œæ„Ÿè§‰ä¼˜åŒ–äº†ä½†åˆæ²¡é‚£ä¹ˆä¼˜åŒ–ï¼Œç´¢æ€§å°±æ²¡é‚£ä¹ˆåšï¼‰ã€‚</p><p>æ•´ä½“çš„æ“ä½œæ˜¯ï¼š1. é‡‡æ ·æºå›¾ç‰‡ï¼Œå¯¹æ¯ä¸ª<code>Filter</code>å’Œæ¯ä¸ªé¢œè‰²åˆ†é‡è®¡ç®—å®éƒ¨å’Œè™šéƒ¨çš„å€¼ï¼Œæ°´å¹³ç´¯åŠ åå‚¨å­˜åˆ°ä¸­é—´è´´å›¾ä¸­ï¼›2. é‡‡æ ·ä¸­é—´è´´å›¾ï¼Œå¯¹æ¯ä¸ª<code>Filter</code>å’Œæ¯ä¸ªé¢œè‰²åˆ†é‡è®¡ç®—å®éƒ¨å’Œè™šéƒ¨çš„å€¼ï¼Œç«–ç›´ç´¯åŠ åä¹˜ä¸Šå„è‡ªçš„æƒé‡å°±å¾—åˆ°æœ€ç»ˆçš„é¢œè‰²äº†ã€‚ç”±äºæˆ‘æ²¡æœ‰ä½¿ç”¨<code>bracket</code>çš„æ–¹æ³•ï¼Œ<code>Filter</code>ä¸­ä¼šæœ‰è´Ÿå€¼å­˜åœ¨ï¼Œåœ¨ä»…ä½¿ç”¨ä¸¤ä¸ª<code>Filter</code>ä¸”åŠå¾„è¾ƒå¤§ä¸”åƒç´ é¢œè‰²è¿‡äº®çš„æ—¶å€™ï¼Œç”±äºbandingçš„å­˜åœ¨ä¼šä½¿æœ€ç»ˆçš„é¢œè‰²å‡ºç°è´Ÿå€¼ï¼Œè§£å†³æ–¹æ³•æ˜¯åœ¨è¯»å–é¢œè‰²çš„æ—¶å€™åšä¸€æ¬¡Clampæˆ–è€…æ˜¯ToneMappingåˆ°åˆç†èŒƒå›´ã€‚</p><h3 id=circularblurfiltergeneratorcs>CircularBlurFilterGenerator.cs<a hidden class=anchor aria-hidden=true href=#circularblurfiltergeneratorcs>#</a></h3><p>æ”¹å†™è‡ªKleber Garciaçš„<a href=https://github.com/kecho/CircularDofFilterGenerator>å…¬å¼€ä»“åº“</a>ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#75715e>/*
</span><span style=color:#75715e>Copyright 2023  zznewclear13 (zznewclear@gmail.com)
</span><span style=color:#75715e>Copyright 2016  Kleber A Garcia (kecho_garcia@hotmail.com)
</span><span style=color:#75715e>
</span><span style=color:#75715e>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
</span><span style=color:#75715e>
</span><span style=color:#75715e>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
</span><span style=color:#75715e>
</span><span style=color:#75715e>THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</span><span style=color:#75715e>*/</span>

<span style=color:#66d9ef>using</span> UnityEngine;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CircularBlurFilterGenerator</span>
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Filter</span>
    {
        <span style=color:#66d9ef>public</span> Vector2 kernelWeight;
        <span style=color:#66d9ef>public</span> Vector2[] circularKernels;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>KernelData</span>
    {
        <span style=color:#66d9ef>public</span> Filter[] filters;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Vector4 KernelFunction(<span style=color:#66d9ef>float</span> x, Vector4 C)
    {
        <span style=color:#66d9ef>float</span> real = Mathf.Cos(x * x * C.x) * Mathf.Exp(x * x * C.y);
        <span style=color:#66d9ef>float</span> imaginary = Mathf.Sin(x * x * C.x) * Mathf.Exp(x * x * C.y);
        <span style=color:#66d9ef>float</span> realWeight = C.z;
        <span style=color:#66d9ef>float</span> imaginaryWeight = C.w;
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(real, imaginary, realWeight, imaginaryWeight);
    }

    <span style=color:#75715e>// 1 &lt;= components &lt;= 5
</span><span style=color:#75715e></span>    <span style=color:#75715e>// best: 0.2f &lt;= transition &lt;= 0.4f
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> KernelData GenerateFilter(<span style=color:#66d9ef>float</span> radius, <span style=color:#66d9ef>int</span> components = <span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>float</span> transition = <span style=color:#ae81ff>0.2f</span>, <span style=color:#66d9ef>bool</span> logKernel = <span style=color:#66d9ef>false</span>)
    {
        <span style=color:#66d9ef>int</span> sampleRadius = Mathf.CeilToInt(radius);
        <span style=color:#66d9ef>int</span> kernelSize = <span style=color:#ae81ff>2</span> * sampleRadius + <span style=color:#ae81ff>1</span>;
        KernelData kernelData = <span style=color:#66d9ef>new</span> KernelData();
        <span style=color:#66d9ef>if</span> (transition &lt;= -<span style=color:#ae81ff>1.0f</span>)
        {
            Debug.Log(<span style=color:#e6db74>&#34;Invalid transition bandwidth. Must be greater than -1 and preferably positive.&#34;</span>);
            <span style=color:#66d9ef>return</span> kernelData;
        }

        Vector4[] P;
        <span style=color:#66d9ef>switch</span> (components)
        {
            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
                P = <span style=color:#66d9ef>new</span> Vector4[]
                    {
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>1.624835f</span>, -<span style=color:#ae81ff>0.862325f</span>, <span style=color:#ae81ff>0.767583f</span>, <span style=color:#ae81ff>1.862321f</span> )
                    };
                <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>:
                P = <span style=color:#66d9ef>new</span> Vector4[]
                   {
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>5.268909f</span>, -<span style=color:#ae81ff>0.886528f</span>, <span style=color:#ae81ff>0.411259f</span>, -<span style=color:#ae81ff>0.548794f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4(<span style=color:#ae81ff>1.558213f</span>, -<span style=color:#ae81ff>1.960518f</span>, <span style=color:#ae81ff>0.513282f</span>, <span style=color:#ae81ff>4.561110f</span> )
                   };
                <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span>:
                P = <span style=color:#66d9ef>new</span> Vector4[]
                   {
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>5.043495f</span>, -<span style=color:#ae81ff>2.176490f</span>, <span style=color:#ae81ff>1.621035f</span>, -<span style=color:#ae81ff>2.105439f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>9.027613f</span>, -<span style=color:#ae81ff>1.019306f</span>, -<span style=color:#ae81ff>0.280860f</span>, -<span style=color:#ae81ff>0.162882f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>1.597273f</span>, -<span style=color:#ae81ff>2.815110f</span>, -<span style=color:#ae81ff>0.366471f</span>, <span style=color:#ae81ff>10.300301f</span> )
                   };
                <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>4</span>:
                P = <span style=color:#66d9ef>new</span> Vector4[]
                   {
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>1.553635f</span>, -<span style=color:#ae81ff>4.338459f</span>, -<span style=color:#ae81ff>5.767909f</span>, <span style=color:#ae81ff>46.164397f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>4.693183f</span>, -<span style=color:#ae81ff>3.839993f</span>, <span style=color:#ae81ff>9.795391f</span>, <span style=color:#ae81ff>15.227561f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>8.178137f</span>, -<span style=color:#ae81ff>2.791880f</span>, -<span style=color:#ae81ff>3.048324f</span>, <span style=color:#ae81ff>0.302959f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>12.328289f</span>, -<span style=color:#ae81ff>1.342190f</span>, <span style=color:#ae81ff>0.010001f</span>, <span style=color:#ae81ff>0.244650f</span> )
                   };
                <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>5</span>:
                P = <span style=color:#66d9ef>new</span> Vector4[]
                   {
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>1.685979f</span>, -<span style=color:#ae81ff>4.892608f</span>, -<span style=color:#ae81ff>22.356787f</span>, <span style=color:#ae81ff>85.912460f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>4.998496f</span>, -<span style=color:#ae81ff>4.711870f</span>, <span style=color:#ae81ff>35.918936f</span> , -<span style=color:#ae81ff>28.875618f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>8.244168f</span>, -<span style=color:#ae81ff>4.052795f</span>, -<span style=color:#ae81ff>13.212253f</span>, -<span style=color:#ae81ff>1.578428f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>11.900859f</span>, -<span style=color:#ae81ff>2.929212f</span>, <span style=color:#ae81ff>0.507991f</span>, <span style=color:#ae81ff>1.816328f</span> ),
                        <span style=color:#66d9ef>new</span> Vector4( <span style=color:#ae81ff>16.116382f</span>, -<span style=color:#ae81ff>1.512961f</span>, <span style=color:#ae81ff>0.138051f</span>, -<span style=color:#ae81ff>0.010000f</span> )
                   };
                <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>default</span>:
                Debug.Log(<span style=color:#e6db74>&#34;Invalid component count. Must be [1-5].&#34;</span>);
                <span style=color:#66d9ef>return</span> kernelData;
        }

        Vector4[,] kernels = <span style=color:#66d9ef>new</span> Vector4[components, kernelSize];
        <span style=color:#66d9ef>float</span> totalBandWidth = <span style=color:#ae81ff>1.0f</span> + transition;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            Vector4 C = P[i];
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = -sampleRadius; j &lt; sampleRadius + <span style=color:#ae81ff>1</span>; j++)
            {
                kernels[i, j + sampleRadius] = KernelFunction(totalBandWidth * j / radius, C);
            }
        }

        <span style=color:#75715e>// normalize kernels
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>float</span> accum = <span style=color:#ae81ff>0.0f</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; kernelSize; j++)
            {
                Vector4 v = kernels[i, j];
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k = <span style=color:#ae81ff>0</span>; k &lt; kernelSize; k++)
                {
                    Vector4 w = kernels[i, k];
                    accum += v.z * (v.x * w.x - v.y * w.y) + v.w * (v.x * w.y + v.y * w.x);
                }
            }
        }

        <span style=color:#66d9ef>float</span> normConstant = <span style=color:#ae81ff>1.0f</span> / Mathf.Sqrt(accum);
        Vector4[,] kernelsNormalized = <span style=color:#66d9ef>new</span> Vector4[components, kernelSize];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; kernelSize; j++)
            {
                Vector4 v = kernels[i, j];
                Vector4 vn = <span style=color:#66d9ef>new</span> Vector4(normConstant * v.x, normConstant * v.y, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>);
                kernelsNormalized[i, j] = vn;
            }
        }

        <span style=color:#75715e>// bracket the kernel so we maximize precision. This means figureout a Offset and a Scale
</span><span style=color:#75715e></span>        Vector2[] scales = <span style=color:#66d9ef>new</span> Vector2[components];
        Vector2[] offsets = <span style=color:#66d9ef>new</span> Vector2[components];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            Vector2 minVector = <span style=color:#66d9ef>new</span> Vector2(kernelsNormalized[i, <span style=color:#ae81ff>0</span>].x, kernelsNormalized[i, <span style=color:#ae81ff>0</span>].y);
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>1</span>; j &lt; kernelSize; j++)
            {
                minVector = <span style=color:#66d9ef>new</span> Vector2(Mathf.Min(minVector.x, kernelsNormalized[i, j].x), Mathf.Min(minVector.y, kernels[i, j].y));
            }
            offsets[i] = minVector;
        }

        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            Vector2 offset = offsets[i];
            Vector2 scale = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>0f</span>);
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; kernelSize; j++)
            {
                Vector4 v = kernelsNormalized[i, j];
                <span style=color:#66d9ef>float</span> realScale = v.x - offset.x;
                <span style=color:#66d9ef>float</span> immScale = v.y - offset.y;
                scale += <span style=color:#66d9ef>new</span> Vector2(realScale, immScale);
            }
            scales[i] = scale;
        }

        Vector4[,] finalKernels = <span style=color:#66d9ef>new</span> Vector4[components, kernelSize];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            Vector2 offset = offsets[i];
            Vector2 scale = scales[i];
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; kernelSize; j++)
            {
                Vector4 v = kernelsNormalized[i, j];
                <span style=color:#66d9ef>float</span> realScale = v.x - offset.x;
                <span style=color:#66d9ef>float</span> immScale = v.y - offset.y;
                finalKernels[i, j] = <span style=color:#66d9ef>new</span> Vector4(v.x, v.y, realScale / scale.x, immScale / scale.y);
            }
        }

        Vector2[] componentWeights = <span style=color:#66d9ef>new</span> Vector2[components];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            Vector4 comp = P[i];
            componentWeights[i] = <span style=color:#66d9ef>new</span> Vector2(comp.z, comp.w);
        }

        Filter[] filters = <span style=color:#66d9ef>new</span> Filter[components];
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; components; i++)
        {
            Vector2[] circularKernels = <span style=color:#66d9ef>new</span> Vector2[kernelSize];
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; kernelSize; j++)
            {
                Vector4 v = finalKernels[i, j];
                circularKernels[j] = <span style=color:#66d9ef>new</span> Vector2(v.x, v.y);
            }
            Vector2 kernelWeight = componentWeights[i];
            filters[i] = <span style=color:#66d9ef>new</span> Filter
            {
                kernelWeight = kernelWeight,
                circularKernels = circularKernels
            };
        }
        kernelData.filters = filters;

        <span style=color:#66d9ef>if</span>(logKernel)
        {
            Debug.Log(Log(radius, finalKernels, componentWeights, offsets, scales));
        }
        <span style=color:#66d9ef>return</span> kernelData;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span>[] syntax = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[] { <span style=color:#e6db74>&#34;uint&#34;</span>, <span style=color:#e6db74>&#34;float&#34;</span>, <span style=color:#e6db74>&#34;static const&#34;</span>, <span style=color:#e6db74>&#34;{&#34;</span>, <span style=color:#e6db74>&#34;};&#34;</span> };
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span> Log(<span style=color:#66d9ef>float</span> radius, Vector4[,] finalKernels, Vector2[] componentWeights, Vector2[] offsets, Vector2[] scales)
    {
        <span style=color:#66d9ef>string</span> logStr = <span style=color:#e6db74>&#34;&#34;</span>;
        logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;{0} {1} KERNEL_RADIUS = {2};\n&#34;</span>, syntax[<span style=color:#ae81ff>2</span>], syntax[<span style=color:#ae81ff>0</span>], radius);
        <span style=color:#66d9ef>int</span> kernelSize = Mathf.CeilToInt(radius) * <span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>;
        logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;{0} {1} KERNEL_COUNT = {2};\n&#34;</span>, syntax[<span style=color:#ae81ff>2</span>], syntax[<span style=color:#ae81ff>0</span>], kernelSize);
        <span style=color:#66d9ef>int</span> component = componentWeights.Length;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; component; i++)
        {
            Vector2 o = offsets[i];
            Vector2 s = scales[i];
            Vector2 comp = componentWeights[i];
            logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;{0} {1}4 Kernel{2}BracketsRealXY_ImZW = {1}4({3},{4},{5},{6});\n&#34;</span>,
                                    syntax[<span style=color:#ae81ff>2</span>], syntax[<span style=color:#ae81ff>1</span>], i, o.x, s.x, o.y, s.y);
            logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;{0} {1}2 Kernel{2}Weights_RealX_ImY = {1}2({3},{4});\n&#34;</span>,
                                    syntax[<span style=color:#ae81ff>2</span>], syntax[<span style=color:#ae81ff>1</span>], i, comp.x, comp.y);
            logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;{0} {1}4 Kernel{2}_RealX_ImY_RealZ_ImW[] = {3}\n&#34;</span>,
                                    syntax[<span style=color:#ae81ff>2</span>], syntax[<span style=color:#ae81ff>1</span>], i, syntax[<span style=color:#ae81ff>3</span>]);
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; kernelSize; j++)
            {
                Vector4 val = finalKernels[i, j];
                logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;\t{0}4(/*XY: Non Bracketed*/{1},{2},/*Bracketed WZ:*/{3},{4}){5}\n&#34;</span>,
                                        syntax[<span style=color:#ae81ff>1</span>], val.x, val.y, val.z, val.w,
                                        (j &lt; kernelSize - <span style=color:#ae81ff>1</span>) ? <span style=color:#e6db74>&#34;,&#34;</span> : <span style=color:#e6db74>&#34;&#34;</span>);
            }
            logStr += <span style=color:#66d9ef>string</span>.Format(<span style=color:#e6db74>&#34;{0}\n&#34;</span>, syntax[<span style=color:#ae81ff>4</span>]);
        }
        <span style=color:#66d9ef>return</span> logStr;
    }
}
</code></pre></div><h3 id=circularblurcomputeshadercompute>CircularBlurComputeShader.compute<a hidden class=anchor aria-hidden=true href=#circularblurcomputeshadercompute>#</a></h3><p>æˆ‘åªä½¿ç”¨äº†ä¸¤ä¸ª<code>Filter</code>ï¼Œä¸”å°†å…¶æƒé‡å’Œå‚æ•°åˆå¹¶åˆ°äº†ä¸€ä¸ª<code>StructuredBuffer&lt;float2></code>ä¸­ï¼Œæ¯ä¸€ä¸ª<code>Filter</code>å°±éœ€è¦æ ¹æ®ä¸€å®šçš„åç§»é‡å»è·å–åˆ°æƒé‡å’Œå‚æ•°çš„æ•°æ®ã€‚åŒæ—¶åˆå› ä¸ºåªä½¿ç”¨äº†ä¸¤ä¸ª<code>Filter</code>ï¼Œä¸€ä¸ªé¢œè‰²åˆ†é‡ä¼šæœ‰ä¸¤ç»„å®éƒ¨å’Œè™šéƒ¨ï¼Œåˆšå¥½æ„æˆä¸€ä¸ªå››é€šé“çš„æ•°æ®ï¼Œå¯¹åº”åˆ°ä¸€å¼ è´´å›¾ä¸Šã€‚è¿™ä¸ªCompute Shaderå¾ˆå¤§ç¨‹åº¦åœ°å‚è€ƒäº†Kleber Garciaçš„<a href=https://www.shadertoy.com/view/Xd2BWc>Circular Dof</a>ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel CircularH
#pragma kernel CircularV

Texture2D&lt;float4&gt; _ColorTexture;
Texture2D&lt;float4&gt; _RTexture;
Texture2D&lt;float4&gt; _GTexture;
Texture2D&lt;float4&gt; _BTexture;

RWTexture2D&lt;float4&gt; _RW_RTexture;
RWTexture2D&lt;float4&gt; _RW_GTexture;
RWTexture2D&lt;float4&gt; _RW_BTexture;
RWTexture2D&lt;float4&gt; _RW_CompositeTexture;

float4 _TextureSize;
int _SampleRadius;
StructuredBuffer&lt;float2&gt; _CircularKernels;
#define COLOR_THRESHOLD 5.0f

#define CIRCULAR_BLUR_MAX_RADIUS 128
#define THREAD_GROUP_SIZE 256
const static int CACHED_COLOR_SIZE = THREAD_GROUP_SIZE + CIRCULAR_BLUR_MAX_RADIUS * 2;
groupshared half3 cachedColor[CACHED_COLOR_SIZE];
void SetCachedColor(half3 color, int index) { cachedColor[index] = color; }
half3 GetCachedColor(int threadPos) { return cachedColor[threadPos + CIRCULAR_BLUR_MAX_RADIUS]; }
void CacheColor(int2 groupCacheStartPos, int cacheIndex)
{
    int2 texturePos = groupCacheStartPos + int2(cacheIndex, 0);
    texturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f);
    half3 color = _ColorTexture.Load(uint3(texturePos, 0)).rgb;
    color = clamp(color, 0.0f, COLOR_THRESHOLD);
    SetCachedColor(color, cacheIndex);
}

struct RGBComp
{
    half4 rComp;
    half4 gComp;
    half4 bComp;
};
groupshared RGBComp cachedComp[CACHED_COLOR_SIZE];
void SetCachedComp(RGBComp comp, int index) { cachedComp[index] = comp; }
RGBComp GetCachedComp(int threadPos) { return cachedComp[threadPos + CIRCULAR_BLUR_MAX_RADIUS]; }
void CacheComp(int2 groupCacheStartPos, int cacheIndex)
{
    int2 texturePos = groupCacheStartPos + int2(0, cacheIndex);
    texturePos = clamp(texturePos, 0, _TextureSize.xy - 1.0f);
    half4 rComp = _RTexture.Load(uint3(texturePos, 0));
    half4 gComp = _GTexture.Load(uint3(texturePos, 0));
    half4 bComp = _BTexture.Load(uint3(texturePos, 0));
    RGBComp rgbComp = (RGBComp)0;
    rgbComp.rComp = rComp;
    rgbComp.gComp = gComp;
    rgbComp.bComp = bComp;
    SetCachedComp(rgbComp, cacheIndex);
}

//(Pr+Pi)*(Qr+Qi) = (Pr*Qr+Pr*Qi+Pi*Qr-Pi*Qi)
float2 multComplex(float2 p, float2 q)
{
    return float2(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);
}

[numthreads(THREAD_GROUP_SIZE,1,1)]
void CircularH(uint3 groupID : SV_GroupID,
                uint3 groupThreadID : SV_GroupThreadID,
                uint groupIndex : SV_GroupIndex,
                uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 threadGroupSize = int2(THREAD_GROUP_SIZE, 1);
    int2 groupCacheStartPos = groupID.xy * threadGroupSize - int2(CIRCULAR_BLUR_MAX_RADIUS, 0);
    int cacheIndex = groupIndex * 2;
    if (cacheIndex &lt; CACHED_COLOR_SIZE - 1)
    {
        CacheColor(groupCacheStartPos, cacheIndex);
        CacheColor(groupCacheStartPos, cacheIndex + 1);
    }
    GroupMemoryBarrierWithGroupSync();

    int sampleRadius = _SampleRadius;
    int threadPos = groupIndex;
    
    half4 redSum = 0.0f;
    half4 greenSum = 0.0f;
    half4 blueSum = 0.0f;
    for (int i = -sampleRadius; i &lt;=sampleRadius; ++i)
    {
        half3 color = GetCachedColor(threadPos + i);
        float2 kernel0 = _CircularKernels[1 + i + sampleRadius];
        float2 kernel1 = _CircularKernels[1 + 2 * sampleRadius + 1 + 1 + i + sampleRadius];
        redSum += color.r * float4(kernel0, kernel1);
        greenSum += color.g * float4(kernel0, kernel1);
        blueSum += color.b * float4(kernel0, kernel1);
    }

    _RW_RTexture[dispatchThreadID.xy] = redSum;
    _RW_GTexture[dispatchThreadID.xy] = greenSum;
    _RW_BTexture[dispatchThreadID.xy] = blueSum;
}

[numthreads(1,THREAD_GROUP_SIZE,1)]
void CircularV(uint3 groupID : SV_GroupID,
                uint3 groupThreadID : SV_GroupThreadID,
                uint groupIndex : SV_GroupIndex,
                uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 threadGroupSize = int2(1, THREAD_GROUP_SIZE);
    int2 groupCacheStartPos = groupID.xy * threadGroupSize - int2(0, CIRCULAR_BLUR_MAX_RADIUS);
    int cacheIndex = groupIndex * 2;
    if (cacheIndex &lt; CACHED_COLOR_SIZE - 1)
    {
        CacheComp(groupCacheStartPos, cacheIndex);
        CacheComp(groupCacheStartPos, cacheIndex + 1);
    }
    GroupMemoryBarrierWithGroupSync();


    int sampleRadius = _SampleRadius;
    int threadPos = groupIndex;

    half4 redSum = 0.0f;
    half4 greenSum = 0.0f;
    half4 blueSum = 0.0f;
    for (int i = -sampleRadius; i &lt;= sampleRadius; ++i)
    {
        RGBComp comp = GetCachedComp(threadPos + i);
        float2 kernel0 = _CircularKernels[1 + i + sampleRadius];
        float2 kernel1 = _CircularKernels[1 + 2 * sampleRadius + 1 + 1 + i + sampleRadius];

        redSum.xy += multComplex(comp.rComp.xy, kernel0);
        redSum.zw += multComplex(comp.rComp.zw, kernel1);
        greenSum.xy += multComplex(comp.gComp.xy, kernel0);
        greenSum.zw += multComplex(comp.gComp.zw, kernel1);
        blueSum.xy += multComplex(comp.bComp.xy, kernel0);
        blueSum.zw += multComplex(comp.bComp.zw, kernel1);
    }
    float2 weight0 = _CircularKernels[0];
    float2 weight1 = _CircularKernels[1 + 2 * sampleRadius + 1];

    half r = dot(redSum.xy, weight0) + dot(redSum.zw, weight1);
    half g = dot(greenSum.xy, weight0) + dot(greenSum.zw, weight1);
    half b = dot(blueSum.xy, weight0) + dot(blueSum.zw, weight1);

    _RW_CompositeTexture[dispatchThreadID.xy] = half4(r, g, b, 1.0f);
}
</code></pre><h3 id=circularblurcs>CircularBlur.cs<a hidden class=anchor aria-hidden=true href=#circularblurcs>#</a></h3><p>è¿™é‡Œéœ€è¦ä¿è¯<code>radius</code>çš„æœ€å¤§å€¼ä¸å¤§äºCompute Shaderé‡Œçš„<code>CIRCULAR_BLUR_MAX_RADIUS</code>ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Circular Blur&#34;, typeof(UniversalRenderPipeline))]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CircularBlur</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter radius = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>128.0f</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; radius.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }
    }
}
</code></pre></div><h3 id=circularblurrenderpasscs>CircularBlurRenderPass.cs<a hidden class=anchor aria-hidden=true href=#circularblurrenderpasscs>#</a></h3><p>å’Œé«˜æ–¯æ¨¡ç³Šçš„Render Passå¤§åŒå°å¼‚ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CircularBlurRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Circular Blur Render Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> CircularBlurRendererFeature.CircularBlurSettings settings;
        <span style=color:#66d9ef>private</span> CircularBlur circularBlur;
        <span style=color:#66d9ef>private</span> ComputeShader computeShader;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
        RenderTargetIdentifier cameraColorIden;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> circularBlurTextureRName = <span style=color:#e6db74>&#34;_CircularBlurTextureR&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> circularBlurTextureRID = Shader.PropertyToID(circularBlurTextureRName);
        RenderTargetIdentifier circularBlurTextureRIden;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> circularBlurTextureGName = <span style=color:#e6db74>&#34;_CircularBlurTextureG&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> circularBlurTextureGID = Shader.PropertyToID(circularBlurTextureGName);
        RenderTargetIdentifier circularBlurTextureGIden;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> circularBlurTextureBName = <span style=color:#e6db74>&#34;_CircularBlurTextureB&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> circularBlurTextureBID = Shader.PropertyToID(circularBlurTextureBName);
        RenderTargetIdentifier circularBlurTextureBIden;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> compositeTextureName = <span style=color:#e6db74>&#34;_CompositeTexture&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> compositeTextureID = Shader.PropertyToID(compositeTextureName);
        RenderTargetIdentifier compositeTextureIden;

        CircularBlurFilterGenerator.KernelData kernelData;
        <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> lastRadius = <span style=color:#ae81ff>0.0f</span>;
        
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> HorizontalKernelName = <span style=color:#e6db74>&#34;CircularH&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> VerticalKernelName = <span style=color:#e6db74>&#34;CircularV&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>ColorTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_ColorTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>RTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>GTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_GTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>BTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_BTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>RW_RTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_RTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>RW_GTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_GTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>RW_BTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_BTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>RW_CompositeTexture = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_CompositeTexture&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>TextureSize = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>SampleRadius = Shader.PropertyToID(<span style=color:#e6db74>&#34;_SampleRadius&#34;</span>);
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> <span style=color:#ae81ff>_</span>CircularKernels = Shader.PropertyToID(<span style=color:#e6db74>&#34;_CircularKernels&#34;</span>);

        <span style=color:#66d9ef>public</span> CircularBlurRenderPass(CircularBlurRendererFeature.CircularBlurSettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);

            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            computeShader = settings.computeShader;

            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
            circularBlurTextureRIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(circularBlurTextureRID);
            circularBlurTextureGIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(circularBlurTextureGID);
            circularBlurTextureBIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(circularBlurTextureBID);
            compositeTextureIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(compositeTextureID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(CircularBlur circularBlur)
        {
            <span style=color:#66d9ef>this</span>.circularBlur = circularBlur;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
        {
            <span style=color:#66d9ef>if</span> (computeBuffer == <span style=color:#66d9ef>null</span> || computeBuffer.count != count || computeBuffer.stride != stride)
            {
                <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
                {
                    computeBuffer.Release();
                }
                computeBuffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnCameraSetup(CommandBuffer cmd, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            <span style=color:#66d9ef>if</span>(lastRadius != circularBlur.radius.<span style=color:#66d9ef>value</span>)
            {
                kernelData = CircularBlurFilterGenerator.GenerateFilter(circularBlur.radius.<span style=color:#66d9ef>value</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0.2f</span>, <span style=color:#66d9ef>false</span>);
                <span style=color:#66d9ef>int</span> count = kernelData.filters.Length * (<span style=color:#ae81ff>1</span> + kernelData.filters[<span style=color:#ae81ff>0</span>].circularKernels.Length);
                EnsureComputeBuffer(count, <span style=color:#ae81ff>2</span> * <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>float</span>));
                List&lt;Vector2&gt; data = <span style=color:#66d9ef>new</span> List&lt;Vector2&gt;();
                <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> filter <span style=color:#66d9ef>in</span> kernelData.filters)
                {
                    data.Add(filter.kernelWeight);
                    data.AddRange(filter.circularKernels);
                }
                computeBuffer.SetData(data);

                lastRadius = circularBlur.radius.<span style=color:#66d9ef>value</span>;
            }            
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
            RenderTextureDescriptor desc = cameraTextureDescriptor;
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;

            desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat;
            cmd.GetTemporaryRT(circularBlurTextureRID, desc);
            cmd.GetTemporaryRT(circularBlurTextureGID, desc);
            cmd.GetTemporaryRT(circularBlurTextureBID, desc);
            cmd.GetTemporaryRT(compositeTextureID, desc);
        }

        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoCircularBlur(CommandBuffer cmd, RenderTargetIdentifier colorid,
            RenderTargetIdentifier rid, RenderTargetIdentifier gid, RenderTargetIdentifier bid,
            RenderTargetIdentifier compositeid, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;

            {
                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(HorizontalKernelName);
                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>ColorTexture, colorid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RW_RTexture, rid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RW_GTexture, gid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RW_BTexture, bid);
                cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>CircularKernels, computeBuffer);
                cmd.SetComputeVectorParam(computeShader, <span style=color:#ae81ff>_</span>TextureSize, GetTextureSizeParams(textureSize));
                cmd.SetComputeIntParam(computeShader, <span style=color:#ae81ff>_</span>SampleRadius, Mathf.CeilToInt(circularBlur.radius.<span style=color:#66d9ef>value</span>));
                cmd.DispatchCompute(computeShader, kernelID,
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
                    <span style=color:#ae81ff>1</span>);
            }

            {
                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(VerticalKernelName);
                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RTexture, rid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>GTexture, gid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>BTexture, bid);
                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>RW_CompositeTexture, compositeid);
                cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#ae81ff>_</span>CircularKernels, computeBuffer);
                cmd.SetComputeVectorParam(computeShader, <span style=color:#ae81ff>_</span>TextureSize, GetTextureSizeParams(textureSize));
                cmd.SetComputeIntParam(computeShader, <span style=color:#ae81ff>_</span>SampleRadius, Mathf.CeilToInt(circularBlur.radius.<span style=color:#66d9ef>value</span>));
                cmd.DispatchCompute(computeShader, kernelID,
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
                    <span style=color:#ae81ff>1</span>);
            }
            cmd.Blit(compositeid, cameraColorIden);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get();
            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                DoCircularBlur(cmd, cameraColorIden,
                    circularBlurTextureRIden, circularBlurTextureGIden, circularBlurTextureBIden,
                    compositeTextureIden, computeShader);
            }
            context.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
        {
            cmd.ReleaseTemporaryRT(circularBlurTextureRID);
            cmd.ReleaseTemporaryRT(circularBlurTextureGID);
            cmd.ReleaseTemporaryRT(circularBlurTextureBID);
            cmd.ReleaseTemporaryRT(compositeTextureID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
        {
            <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
            {
                computeBuffer.Release();
                computeBuffer = <span style=color:#66d9ef>null</span>;
            }
        }
    }
}
</code></pre></div><h3 id=circularblurrendererfeaturecs>CircularBlurRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#circularblurrendererfeaturecs>#</a></h3><p>å’Œé«˜æ–¯æ¨¡ç³Šçš„Renderer Featureå¦‚å‡ºä¸€è¾™ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CircularBlurRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CircularBlurSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent;
            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        }

        <span style=color:#66d9ef>public</span> CircularBlurSettings settings = <span style=color:#66d9ef>new</span> CircularBlurSettings();
        <span style=color:#66d9ef>private</span> CircularBlurRenderPass circularBlurRenderPass;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            circularBlurRenderPass = <span style=color:#66d9ef>new</span> CircularBlurRenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CircularBlur circularBlur = VolumeManager.instance.stack.GetComponent&lt;CircularBlur&gt;();
            <span style=color:#66d9ef>if</span> (circularBlur != <span style=color:#66d9ef>null</span> &amp;&amp; circularBlur.IsActive())
            {
                circularBlurRenderPass.Setup(circularBlur);
                renderer.EnqueuePass(circularBlurRenderPass);
            }
        }

        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
        {
            circularBlurRenderPass.Dispose();
            <span style=color:#66d9ef>base</span>.Dispose(disposing);
        }
    }
}
</code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>å¤ªæ£’äº†å¤ªæ£’äº†ï¼Œè¿…é€Ÿåœ°å†™å®Œäº†EAçš„Circular Blurï¼æœ¬æ¥æƒ³é…ä¸€å¼ å¤•é˜³ä¸‹çš„æ¤°æ ‘å‰ªå½±å’Œæµ·é¢æ³¢å…‰ç²¼ç²¼åå…‰çš„åœºæ™¯ï¼Œå¯¹å…¶è¿›è¡Œåœ†å½¢æ¨¡ç³Šçš„ï¼Œå‘ç°æ°´çš„Shaderè¿˜è¦è‡ªå·±å†™ï¼ŒUnityçš„é»˜è®¤æè´¨çƒçš„Smoothnessè¿˜è¦ä½¿ç”¨Albedoæˆ–è€…Metallicå›¾çš„Alphaé€šé“ï¼Œå¯¼è‡´MegaScansçš„ç´ æè¿˜ä¸èƒ½ç›´æ¥ç”¨ï¼Œå°±æš‚æ—¶æ”¾å¼ƒäº†ã€‚ç­‰å†™å®Œæ™¯æ·±ä¹‹åå†æ•´è¿™äº›å§ï¼Œé¡ºä¾¿ä¸€æä¸ºäº†è®©å°é¢å›¾èƒ½æœ‰é‚£ä¸ªå°å°çš„æ•£æ™¯çš„åœ†å½¢ï¼Œæˆ‘å·å·åœ°å¦å¤–æ‰“äº†ä¸€ç›ç¯ã€‚ä¸‹ä¸€æ­¥ï¼Œæ™¯æ·±ï¼ï¼ï¼</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/circular-blur/>Circular Blur</a></li><li><a href=https://zznewclear13.github.io/tags/group-shared-memory/>Group Shared Memory</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li><li><a href=https://zznewclear13.github.io/tags/bokeh/>Bokeh</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><span class=title>Â« Prev</span><br><span>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</span></a>
<a class=next href=https://zznewclear13.github.io/posts/gaussian-blur-revisited/><span class=title>Next Â»</span><br><span>å†è®®é«˜æ–¯æ¨¡ç³Š</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>