<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å¾„å‘åˆ†æ´¾Compute Shader | ZZNEWCLEAR13</title>
<meta name=keywords content="Compute Shader"><meta name=description content="è®©åŒä¸€ä¸ªgroupå¯¹åº”çš„åƒç´ å½¢æˆæ”¾å°„çŠ¶å›¾æ¡ˆ."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="å¾„å‘åˆ†æ´¾Compute Shader"><meta property="og:description" content="è®©åŒä¸€ä¸ªgroupå¯¹åº”çš„åƒç´ å½¢æˆæ”¾å°„çŠ¶å›¾æ¡ˆ."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/"><meta property="og:image" content="https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/posts/images/RadiallyDispatchedComputeShader.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-30T12:00:00+08:00"><meta property="article:modified_time" content="2024-03-30T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/posts/images/RadiallyDispatchedComputeShader.png"><meta name=twitter:title content="å¾„å‘åˆ†æ´¾Compute Shader"><meta name=twitter:description content="è®©åŒä¸€ä¸ªgroupå¯¹åº”çš„åƒç´ å½¢æˆæ”¾å°„çŠ¶å›¾æ¡ˆ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"å¾„å‘åˆ†æ´¾Compute Shader","item":"https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å¾„å‘åˆ†æ´¾Compute Shader","name":"å¾„å‘åˆ†æ´¾Compute Shader","description":"è®©åŒä¸€ä¸ªgroupå¯¹åº”çš„åƒç´ å½¢æˆæ”¾å°„çŠ¶å›¾æ¡ˆ.","keywords":["Compute Shader"],"articleBody":"åŠ¨æœº æœ€ç›´æ¥çš„åŠ¨æœºæ˜¯æˆ‘æœ€è¿‘éœ€è¦å®ç°è§¦é˜´å½±äº†ã€‚ç´¢å°¼çš„Bend Studioçš„Graham Aldridgeåœ¨Sigraph 2023çš„ç´¢å°¼åˆ›ä½œè€…å¤§ä¼šä¸Šï¼Œä»‹ç»äº†å¾€æ—¥ä¸å†ï¼ˆDays Goneï¼‰ä¸­è®¡ç®—è§¦é˜´å½±çš„æ–¹å¼ï¼Œè¿™é‡Œå¯ä»¥æ‰¾åˆ°æ¼”ç¤ºæ–‡ç¨¿å’Œå‚è€ƒä»£ç ã€‚æ¼”ç¤ºæ–‡ç¨¿çš„ç¬¬24-27é¡µï¼Œå±•ç¤ºäº†ä¸€ç§æ–°é¢–çš„åˆ†æ´¾Compute Shaderçš„æ–¹æ³•ï¼Œä¼ ç»Ÿçš„åˆ†æ´¾Compute Shaderå¾€å¾€æ˜¯å°†ç”»é¢æ°´å¹³å’Œç«–ç›´åˆ‡åˆ†æˆåƒç´ æ•°é‡ä¸º64å€æ•°çš„å°å—ï¼Œå°†åˆ†æ´¾çš„Compute Shaderå¯¹åº”åˆ°è¿™äº›å°å—ä¸Šï¼Œè€ŒDays Goneä¸­åˆ™æ˜¯å°†åˆ†æ´¾çš„Compute Shaderå¯¹åº”åˆ°å‘ˆæ”¾å°„çŠ¶çš„åƒç´ å°å—ä¸Šã€‚å¤§è‡´çš„æ„æ€å¯ä»¥çœ‹ä¸‹å›¾ï¼Œä¸‹å›¾ä¸­ç›¸åŒé¢œè‰²çš„ç›¸é‚»åƒç´ å±äºåŒä¸€ä¸ªthread groupï¼Œå·¦è¾¹æ˜¯ä¼ ç»Ÿçš„åˆ†æ´¾æ–¹å¼ï¼Œå³è¾¹åˆ™æ˜¯å¾„å‘çš„åˆ†æ´¾æ–¹å¼ã€‚\nå½“è¿›è¡Œå¾„å‘æ¨¡ç³Šæˆ–æ˜¯è®¡ç®—æ¥è§¦é˜´å½±æ—¶ï¼Œå¾€å¾€éœ€è¦æ²¿ç€æŸä¸ªæ–¹å‘è¿ç»­é‡‡æ ·çº¹ç†ã€‚å¯¹äºå¤šæ¬¡é‡‡æ ·ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¼šæƒ³åˆ°ä½¿ç”¨Compute Shaderä¸­çš„Group Shared Memoryè¿›è¡Œç¼“å­˜ä»è€Œå‡å°‘é‡‡æ ·æ¬¡æ•°ã€‚ä½†æ˜¯å¯¹ç‰¹å®šæ–¹å‘è¿›è¡Œç¼“å­˜çš„è¯ï¼Œä¼šè¦ç¼“å­˜O((N+C)^2)ä¸ªé¢œè‰²ï¼Œå¦‚æœåˆ†æ´¾çš„Thread Group Sizeæˆ–æ˜¯æ­¥è¿›çš„æ¬¡æ•°æ¯”è¾ƒå¤§ï¼Œå¾ˆå®¹æ˜“å°±è¶…å‡ºäº†Group Shared Memoryçš„æœ€å¤§é™åˆ¶ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨å¾„å‘åˆ†æ´¾çš„æ–¹å¼ï¼Œå°†æ¯ä¸€ä¸ªThread Groupå¯¹åº”çš„åƒç´ æ²¿ç€é‡‡æ ·çš„æ–¹å‘æ’åˆ—ï¼Œç®—ä¸Šçº¿æ€§æ’å€¼ä¹Ÿåªéœ€è¦ç¼“å­˜(N+C)*2ä¸ªé¢œè‰²ï¼Œè¿™æ ·å°±èƒ½å¾ˆæ–¹ä¾¿åœ°è¿›è¡Œè¾ƒè¿œçš„æ­¥è¿›äº†ã€‚\nç›¸è¾ƒäºç´¢å°¼çš„æ¼”ç¤ºï¼Œæœ¬æ–‡è§£å†³äº†Thread Groupå¯¹åº”çš„åƒç´ é‡å çš„é—®é¢˜ï¼Œä¹Ÿå°½é‡åœ°ä»‹ç»äº†è®¾ç½®åˆ†æ´¾å‚æ•°æ—¶çš„å„ç§æ¡ä»¶åˆ¤æ–­ã€‚æœ¬æ–‡ä½¿ç”¨çš„æ˜¯Unity 2022.3.21f1ï¼ŒURPç‰ˆæœ¬æ˜¯14.0.10ã€‚\nå¦‚ä½•è¿›è¡Œå¾„å‘åˆ†æ´¾ åˆ†æ´¾æ–¹å¼å’ŒåŸå›  é¦–å…ˆæˆ‘ä»¬æ³¨æ„åˆ°å¯¹äºå±å¹•ä¸­æ‰€æœ‰æŒ‡å‘ä¸­å¿ƒçš„å°„çº¿ï¼Œå¯ä»¥å°†å…¶åˆ†ä¸ºå·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸‹ã€å³ä¸Šå››ç§ï¼Œè¿™å››ç§å°„çº¿æœ€æ˜æ˜¾çš„æ˜¯ç¬¦å·ç›¸åï¼Œå› æ­¤åœ¨æˆ‘ä»¬åˆ†æ´¾çš„æ—¶å€™å¯ä»¥åˆ†æˆå››ç»„æ•°æ®ï¼Œæ¯ä¸€ç»„æ•°æ®ä½¿ç”¨åŒæ ·çš„æ–¹å¼æ‰¾åˆ°å¯¹åº”çš„åç§»å€¼ï¼Œå†ä¹˜ä¸Šç¬¦å·å’Œä¸­å¿ƒçš„åæ ‡ç›¸åŠ ï¼Œå°±èƒ½å¾—åˆ°å¯¹åº”çš„åƒç´ åæ ‡ã€‚\nå› æ­¤æˆ‘ä»¬åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µï¼Œæˆ‘ä»¬ä»¥å³ä¸Šè§’ä¸ºä¾‹ã€‚ä¸‹å›¾æ˜¯ä¸€ä¸ªå¾„å‘åˆ†æ´¾çš„ç¤ºæ„å›¾ï¼Œç»¿è‰²æ˜¯æˆ‘ä»¬çš„ä¸­å¿ƒç‚¹ï¼Œæ‰€æœ‰çš„Thread Groupéƒ½ä¼šä»¥ç»¿ç‚¹ä¸ºä¸­å¿ƒæ”¾å°„çŠ¶æ’å¸ƒï¼Œé»‘æ¡†å°±æ˜¯å±å¹•ä¸Šä¸­å¿ƒç‚¹å³ä¸Šè§’å¯¹åº”çš„åŒºåŸŸï¼ˆä¸ºäº†ç®€ä¾¿è¿™é‡Œé€‰å–äº†æ¯”è¾ƒå°çš„18x10åƒç´ ï¼‰ï¼Œè¿™é‡Œæ¯å››ä¸ªç›¸é‚»ç™½è‰²æ–¹æ¡†åŒå±äºä¸€ä¸ªThread Groupï¼ˆæ›´å¤šçš„Thread Groupæˆ‘æ²¡æœ‰ç”»å‡ºæ¥ï¼‰ï¼Œè“è‰²çš„åŒºåŸŸæ˜¯æ¯ä¸€ä¸ªThread Groupçš„èµ·ç‚¹ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°æ·±è“å’Œæµ…è“ä¸¤ç§é¢œè‰²ï¼Œå®ƒä»¬å¯¹åº”äº†ä¸¤ç§åˆ†æ´¾çš„è§„å¾‹ï¼Œä¸€ç§æ˜¯å‘ˆæ­£æ–¹å½¢çš„ï¼Œå¦ä¸€ç§åˆ™æ˜¯å‘ˆçŸ©å½¢çš„ï¼Œç°è‰²çš„åŒºåŸŸæ˜¯æ‰€æœ‰è®¡ç®—è€Œå¾—çš„æ¯ä¸€ä¸ªThreadå¯¹åº”çš„åƒç´ ï¼Œä¸ºäº†è®©ç°è‰²çš„åŒºåŸŸè¦†ç›–æ•´ä¸ªé»‘æ¡†çš„åŒºåŸŸï¼Œæˆ‘ä»¬éœ€è¦åšæ¯”å½“å‰åƒç´ æ›´å¤šçš„åˆ†æ´¾ã€‚\nç›´æ¥è®¡ç®—æ¯ä¸€ä¸ªThreadå¯¹åº”çš„åƒç´ ä¼¼ä¹æœ‰ç‚¹å›°éš¾ï¼Œæˆ‘ä»¬å¯ä»¥å°†åˆ†æ´¾åˆ†æˆä¸¤ä¸ªç»´åº¦ï¼Œç”¨ç¬¬ä¸€ä¸ªç»´åº¦è®¡ç®—Thread Groupçš„èµ·ç‚¹ï¼Œå³ä¸Šå›¾çš„è“è‰²åŒºåŸŸï¼Œç”¨ç¬¬äºŒä¸ªç»´åº¦å’ŒThread Groupçš„èµ·ç‚¹ï¼Œè®¡ç®—å¯¹åº”çš„åƒç´ çš„ä½ç½®ã€‚å› æ­¤æˆ‘ä»¬åˆ†æ´¾çš„æ•°æ®ä¹Ÿå°±å˜æˆäº†ä¸€ä¸ªGroupIDå’ŒGroupIndexäº†ã€‚æ³¨æ„åˆ°æµ…è“è‰²çš„åŒºåŸŸçš„ä½ç½®å†³å®šäºé»‘æ¡†çš„é•¿å®½æ¯”ï¼Œå½“é»‘æ¡†çš„é«˜å¤§äºé•¿æ—¶ï¼Œæµ…è“è‰²çš„åŒºåŸŸä¼šåœ¨æ·±è“è‰²çš„ä¸Šæ–¹ä¸”æ¨ªå‘æ’å¸ƒã€‚æˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªxMajorçš„åˆ¤æ–­ï¼Œå¦‚æœä¸æ˜¯xMajorï¼Œæˆ‘ä»¬å°±è°ƒæ¢xyåˆ†é‡ï¼Œå…¨éƒ¨è®¡ç®—å®Œæ¯•ä¹‹åå†æ¢å›æ¥ã€‚\næ ¹æ®å›¾ä¸Šçš„æ·±è“è‰²å’Œæµ…è“è‰²åŒºåŸŸï¼Œæˆ‘ä»¬ä¼šå°†ä¸¤ä¸ªåŒºåŸŸåˆ†å¼€æ¥è®¡ç®—GroupIDã€‚æ¯”è¾ƒç®€å•çš„æ˜¯æµ…è“è‰²çš„åŒºåŸŸï¼Œä»æ•°å­¦ä¸Šæˆ‘ä»¬éœ€è¦ä¼ å…¥æ¯ä¸€åˆ—çš„åˆ—é«˜ï¼Œè®¡ç®—å‡ºGroupIDçš„åˆ—åºå·å’Œåœ¨ä¸€åˆ—ä¸­çš„åºå·ï¼Œå°±èƒ½å¾—åˆ°èµ·ç‚¹çš„åæ ‡äº†ã€‚æ·±è“è‰²çš„åŒºåŸŸï¼Œå¦‚æœå•çº¯å¯¹æ¯ä¸€åœˆæ±‚å’Œçš„è¯ï¼Œè¿™æ˜¯ä¸€ä¸ªäºŒæ¬¡æ–¹ç¨‹ï¼Œè™½ç„¶ä¹Ÿèƒ½è®¡ç®—ä½†æ•ˆç‡è‚¯å®šä¸ä¼šå¾ˆé«˜ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘é«˜æ–¯æ±‚å’Œçš„æ–¹æ³•ï¼Œå°†ç¬¬ä¸€åœˆçš„ç«–å‘çš„åƒç´ å’Œæœ€åä¸€åœˆçš„æ¨ªå‘åƒç´ åˆå¹¶æˆä¸€åˆ—ï¼ˆä¹Ÿå°±æ˜¯å›¾ä¸Šæ·±è“è‰²æ–¹æ¡†å·¦ä¸Šè§’å›¾æ¡ˆç›¸åŒçš„ä¸ºåŒä¸€åˆ—ï¼‰ï¼Œè¿™æ ·å¾—åˆ°çš„æ¯ä¸€åˆ—çš„åˆ—é«˜éƒ½æ˜¯ç›¸åŒçš„ï¼Œå°±èƒ½ä½¿ç”¨æµ…è“è‰²åŒºåŸŸçš„æ–¹å¼è®¡ç®—åºå·äº†ï¼Œä¹‹åæˆ‘ä»¬å†å¯¹æ¯”è¾ƒåºå·çš„å¤§å°æ¥å†³å®šæ˜¯ç«–å‘çš„åƒç´ è¿˜æ˜¯æ¨ªå‘çš„åƒç´ ã€‚\nå¾—åˆ°äº†Thread Groupçš„èµ·ç‚¹åæ ‡ä¹‹åï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨èµ·ç‚¹åæ ‡åˆ°ä¸­å¿ƒçš„å‘é‡ï¼Œå¯¹Xæ–¹å‘æˆ–Yæ–¹å‘ä»¥1ä¸ºå•ä½æ­¥è¿›ï¼Œå†å¯¹å¦ä¸€ä¸ªæ–¹å‘å–æœ€è¿‘çš„æ•´æ•°ï¼Œå°±èƒ½å¾—åˆ°å½“å‰Threadå¯¹åº”çš„åƒç´ ç›¸å¯¹äºæ•´ä¸ªThread Groupèµ·ç‚¹åæ ‡çš„åç§»ï¼Œä¸¤è€…ç›¸åŠ å°±èƒ½å¾—åˆ°æœ€ç»ˆçš„åƒç´ åæ ‡äº†ã€‚\näº‹å®ä¸Šï¼Œæˆ‘ä»¬çš„ä¸­å¿ƒç‚¹æœ‰å¯èƒ½ä¼šåœ¨å±å¹•å¤–éƒ¨ï¼Œè¿™ä¸ªæ—¶å€™ä¸Šå›¾å°±ä¼šå˜æˆè¿™æ ·ï¼Œæˆ‘ä»¬åœ¨è®¡ç®—åˆ—é«˜çš„æ—¶å€™éœ€è¦é¢å¤–çš„è€ƒè™‘ä¸­å¿ƒç‚¹çš„åç§»ï¼Œæ·±è“è‰²çš„åŒºåŸŸä¹Ÿä¸ä¼šè€ƒè™‘å®Œå…¨åœ¨å±å¹•å¤–çš„åœˆã€‚\nå¾„å‘åˆ†æ´¾çš„é¢å¤–å‚æ•° ä¸ºäº†åœ¨Compute Shaderä¸­è®¡ç®—æ¯ä¸ªThreadå¯¹åº”çš„åƒç´ ï¼Œæˆ‘ä»¬éœ€è¦ä»CPUé¢å¤–ä¼ é€’ä¸€äº›å‚æ•°ã€‚åœ¨å¾„å‘åˆ†æ´¾ä¸­ï¼Œæˆ‘ä»¬ä»SV_DispatchThreadIDä¸­è·å–åˆ°çš„å…¶å®æ˜¯GroupIDå’ŒGroupIndexä¸¤ä¸ªå‚æ•°ã€‚ç”±ä¸Šé¢çš„è®¨è®ºï¼Œæˆ‘ä»¬å°†æ‰€æœ‰æƒ…å†µåˆ†ä¸º4 * 2ç§ï¼Œå³å·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸‹ã€å³ä¸Šã€æ·±è“ã€æµ…è“çš„ç»„åˆï¼Œå¯¹äºæ¯ä¸€ç§ç»„åˆæˆ‘ä»¬éœ€è¦çŸ¥é“æ€»çš„æ•°é‡ï¼Œæ‰èƒ½è®¡ç®—åœ¨æ¯ä¸€ç§ç»„åˆä¸­çš„GroupIDã€‚æ ¹æ®æˆ‘ä»¬ä¸Šè¿°çš„è®¡ç®—æ–¹å¼ï¼Œæˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“æ¯ä¸€ç§ç»„åˆå¯¹åº”çš„åˆ—é«˜å’ŒxMajorçš„ä¿¡æ¯ã€‚ä¸ºäº†å…¼å®¹ä¸­å¿ƒç‚¹åœ¨å±å¹•å¤–çš„æƒ…å†µï¼Œæˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“ä¸­å¿ƒç‚¹çš„åç§»å€¼ã€‚è¿™æ ·æˆ‘ä»¬çš„å‚æ•°å°±æ˜¯8ç»„5ä¸ªintå€¼ï¼Œåˆ†åˆ«å¯¹åº”åç§»å€¼Xï¼Œåç§»å€¼Yï¼Œå½“å‰æ€»Thread Groupæ•°ï¼Œåˆ—é«˜å’ŒxMajorï¼Œå…¶ä¸­xMajorå…¶å®æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼å¯ä»¥å°è£…åˆ°åˆ—é«˜çš„ç¬¬ä¸€ä½ï¼Œè¿™æ ·å°±åˆšå¥½æ˜¯å››ä¸ªintå€¼äº†ï¼Œæˆ‘ä»¬è¿™é‡Œä¸ºäº†æ–¹ä¾¿æ¼”ç¤ºå°±ä¸åšè¿™æ ·çš„ä¼˜åŒ–äº†ã€‚\nprivate struct DispatchParams { public int2 offset; public int count; public int stride; public int xMajor; public DispatchParams(int2 offset, int count, int stride, int xMajor) { this.offset = offset; this.count = count; this.stride = stride; this.xMajor = xMajor; } } è§£å†³å¤šä¸ªThreadå¯¹åº”åŒä¸€ä¸ªåƒç´ å¸¦æ¥çš„é—ªçƒ ç”±äºæˆ‘ä»¬æ˜¯ä»å¤–éƒ¨å‘å†…éƒ¨æ­¥è¿›ï¼Œè¿™å¿…ç„¶ä¼šå¯¼è‡´è¶Šé è¿‘ä¸­å¿ƒï¼Œè¶Šå¤šçš„Threadä¼šåœ¨åŒä¸€ä¸ªåƒç´ å‘ç”Ÿç¢°æ’ï¼Œåœ¨ç¤ºæ„å›¾ä¸­æˆ‘ä»¬ä¹Ÿèƒ½çœ‹åˆ°è¶Šé è¿‘ä¸­å¿ƒé”¯é½¿æ„Ÿè¶Šå¼ºçƒˆã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä»ä¸­å¿ƒå‘å½“å‰Threadå¯¹åº”çš„åƒç´ å‘å°„å°„çº¿ï¼Œè®¡ç®—å’Œè¿™ä¸ªå°„çº¿æœ€æ¥è¿‘çš„Thread Groupçš„èµ·å§‹åƒç´ ã€‚å¦‚æœè¿™ä¸ªèµ·å§‹åƒç´ å’Œå½“å‰Thread Groupçš„èµ·å§‹åƒç´ ç›¸åŒï¼Œæˆ‘ä»¬è®¤ä¸ºå½“å‰åƒç´ å±äºå½“å‰çš„Thread Groupï¼Œä¿ç•™è¿™ä¸ªåƒç´ ï¼Œå¦åˆ™ï¼Œå½“å‰åƒç´ å±äºåˆ«çš„Thread Groupï¼Œæˆ‘ä»¬è·³è¿‡åç»­çš„å¡«è‰²ã€‚è¿™æ ·æˆ‘ä»¬å°±èƒ½ç¡®ä¿ä¸€ä¸ªåƒç´ æœ€å¤šåªä¼šè¢«ä¸€ä¸ªThread Groupå†™å…¥ã€‚\nç”±äºæ­¤æ—¶æˆ‘ä»¬å±å¹•ä¸Šçš„åƒç´ å¹¶ä¸ä¸€å®šæ€»ä¼šè¢«å†™å…¥ï¼ˆå°¤å…¶æ˜¯æˆ‘ä»¬å†™äº†ä»€ä¹ˆbugçš„æ—¶å€™ï¼‰ï¼Œå»ºè®®åœ¨Debugæ—¶å…ˆå¯¹RenderTextureè¿›è¡Œä¸€æ¬¡åˆå§‹åŒ–ä¸º0çš„æ“ä½œï¼Œæœ¬æ–‡ä¹Ÿå°†ClearMainä¿ç•™åœ¨Compute Shaderä¸­ã€‚\nå…·ä½“çš„ä»£ç  æŒ‡å¯¼æ€æƒ³å°±æ˜¯ä¸Šé¢æ‰€æè¿°çš„äº†ï¼Œä½†æ˜¯å®é™…å®ç°çš„æ—¶å€™ä¼šè¢«å„ç§å–æ¨¡ã€å–ä½™ã€åŠ ä¸€ã€å‡ä¸€æå¾—æ™•å¤´è½¬å‘ã€‚ã€‚ã€‚è¿™è¾¹è¿˜ç¨åšäº†ä¼˜åŒ–ï¼Œæ¯”è¾ƒ{ä»ä¸­å¿ƒåˆ°å½“å‰Thread Groupçš„å°„çº¿çš„æ–œç‡å’Œå½“å‰åƒç´ æ°´å¹³åç§»å€¼çš„ä¹˜ç§¯}å’Œ{ä»ä¸­å¿ƒåˆ°å½“å‰åƒç´ çš„å°„çº¿çš„æ–œç‡å’Œå½“å‰åƒç´ æ°´å¹³åç§»å€¼çš„ä¹˜ç§¯}ï¼Œä»è€Œå¿«é€Ÿåœ°åˆ¤æ–­å½“å‰åƒç´ æ˜¯å¦å±äºå½“å‰Thread Groupã€‚RadialDispatchå³ä¸ºå¾„å‘åˆ†æ´¾çš„ä¸»å‡½æ•°ï¼ŒNormalDispatchä¸ºæ™®é€šåˆ†æ´¾çš„ä¸»å‡½æ•°ï¼Œé€šè¿‡å¯¹GroupIDåšå“ˆå¸Œæ¥å¯è§†åŒ–ã€‚\nRadialDispatchComputeShader.compute #pragma kernel RadialDispatch #pragma kernel NormalDispatch #pragma kernel ClearMain // #pragma warning(disable: 3556) #define THREAD_COUNT 128 Texture2D\u003cfloat4\u003e _ColorTex; RWTexture2D\u003cfloat4\u003e _RW_TargetTex; float2 _CenterPosSS; float4 _TextureSize; struct DispatchParams { int2 offset; int count; int stride; int xMajor; }; StructuredBuffer\u003cDispatchParams\u003e _DispatchData; int GetDispatchType(int index, out int dispatchIndex, out DispatchParams dispatchParams) { for (int i=0; i\u003c8; ++i) { dispatchParams = _DispatchData[i]; dispatchIndex = dispatchParams.count - 1 - index; if (dispatchIndex \u003e= 0) return i; } return 0; } int2 GetDispatchDirection(int dispatchType, out int2 iLightPosOffset) { dispatchType /= 2; int xDir = dispatchType / 2; int yDir = dispatchType % 2; int2 dir = int2(xDir, yDir); iLightPosOffset = dir - 1; return dir * 2 - 1; } int2 GetDispatchOffset(int dispatchType, int dispatchIndex, DispatchParams dispatchParams, out int groupIndex) { groupIndex = 0; int2 dispatchOffset = int2(0, 0); int offsetType = dispatchType % 2; int colIndexOffset = max(dispatchParams.offset.x,dispatchParams.offset.y)/THREAD_COUNT; int2 indexOffset = dispatchParams.xMajor==1?dispatchParams.offset:dispatchParams.offset.yx; int stride = dispatchParams.stride; int colIndex = dispatchIndex / stride; int rowIndex = dispatchIndex - colIndex * stride; if (offsetType == 0) { int offsetedColIndex = colIndex + colIndexOffset; int tempIndex = rowIndex + indexOffset.y - (offsetedColIndex + 1) * THREAD_COUNT; if (tempIndex \u003e= 0) { dispatchOffset = int2(tempIndex + indexOffset.x, dispatchParams.stride - (colIndex + colIndexOffset + 1) * THREAD_COUNT + indexOffset.x + indexOffset.y); groupIndex = tempIndex; } else { dispatchOffset = int2((offsetedColIndex + 1) * THREAD_COUNT - 1, rowIndex + indexOffset.y); groupIndex = rowIndex; } } else { int minOffsetX = max(dispatchParams.stride + indexOffset.y, (colIndexOffset + 1) * THREAD_COUNT); dispatchOffset = int2(minOffsetX + colIndex * THREAD_COUNT - 1, rowIndex + indexOffset.y); groupIndex = rowIndex; } if (dispatchParams.xMajor == 0) dispatchOffset.xy = dispatchOffset.yx; return dispatchOffset; } // https://www.shadertoy.com/view/4djSRW // 1 out, 1 in... float hash11(float p) { p = frac(p * .1031); p *= p + 33.33; p *= p + p; return frac(p); } // https://www.shadertoy.com/view/MsS3Wc // Smooth HSV to RGB conversion float3 hsv2rgb_smooth(float3 c) { float3 rgb = clamp(abs(fmod(c.x*6.0+float3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0); rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\treturn c.z * lerp(float3(1.0, 1.0f, 1.0f), rgb, c.y); } [numthreads(1, THREAD_COUNT, 1)] void RadialDispatch(uint3 id : SV_DISPATCHTHREADID) { float2 centerPosSS = _CenterPosSS; int2 iCenterPosSS = int2(floor(centerPosSS + 0.5f)); int dispatchIndex; DispatchParams dispatchParams; int dispatchType = GetDispatchType(id.x, dispatchIndex, dispatchParams); int2 iCenterPosOffset; int2 dispatchDirection = GetDispatchDirection(dispatchType, iCenterPosOffset); int groupIndex; int2 dispatchOffset = GetDispatchOffset(dispatchType, dispatchIndex, dispatchParams, groupIndex); int2 iGroupStartSS = iCenterPosSS + iCenterPosOffset + dispatchDirection * dispatchOffset; float2 toCenter = centerPosSS - (float2(iGroupStartSS) + 0.5f); float2 absDir = abs(toCenter); int2 signDir = sign(toCenter); bool xMajor = absDir.x \u003e= absDir.y; float2 absNDir = normalize(absDir); float absToCenterStepRatio = xMajor ? absDir.y / absDir.x : absDir.x / absDir.y; int baseOffsetY = int(float(id.y) * absToCenterStepRatio + 0.5f); int2 iOffset = xMajor ? int2(id.y, baseOffsetY) : int2(baseOffsetY, id.y); int2 iPosSS = iGroupStartSS + iOffset * signDir; if (any(iPosSS \u003c int2(0, 0)) || any(iPosSS \u003e= int2(_TextureSize.xy))) return; float2 posSS = float2(iPosSS) + 0.5f; float2 toPosSS = posSS - centerPosSS; float2 absToPos = abs(toPosSS); float absToPosStepRatio = xMajor ? absToPos.y / absToPos.x : absToPos.x / absToPos.y; int yIntersect = int(float(id.y) * absToPosStepRatio + 0.5f); int yVal = baseOffsetY; if (yIntersect != yVal) return; float rv1 = hash11(id.x); float3 color = hsv2rgb_smooth(float3(rv1, 0.8f, 1.0f)); _RW_TargetTex[iPosSS] = float4(color, 1.0f); } [numthreads(1, THREAD_COUNT, 1)] void NormalDispatch(uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { float rv1 = hash11(THREAD_COUNT * groupID.x + groupID.y + THREAD_COUNT * groupID.z); float3 color = hsv2rgb_smooth(float3(rv1, 0.8f, 1.0f)); _RW_TargetTex[dispatchThreadID.xy] = float4(color, 1.0f); } [numthreads(16, 16, 1)] void ClearMain(uint3 id : SV_DISPATCHTHREADID) { _RW_TargetTex[id.xy] = 0.0f; } RadialDispatchRenderPass.cs å¾ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è®¡ç®—ä¸­å¿ƒç‚¹æœ€è¿‘çš„æ•´æ•°æ—¶ï¼Œä¸èƒ½ç®€å•åœ°ä½¿ç”¨int2 iCenterPosSS = new int2(centerPosSS + 0.5f);æ¥è®¡ç®—ï¼Œå› ä¸ºcenterPosSSçš„åˆ†é‡å¾ˆå¯èƒ½ä¼šå°äº0ï¼Œè½¬æ¢ä¸ºintæ—¶ä¼šå˜æˆæœ€æ¥è¿‘é›¶çš„æ•´æ•°ã€‚\nusing Unity.Mathematics; namespace UnityEngine.Rendering.Universal { public class RadialDispatchRenderPass : ScriptableRenderPass { public static Transform centerTrans; private static readonly string passName = \"Radial Dispatch Render Pass\"; private ScriptableRenderer renderer; private RadialDispatchRendererFeature.RadialDispatchSettings settings; private RadialDispatch radialDispatch; private ComputeShader computeShader; private Vector2Int textureSize; private static readonly string radialDispatchTextureName = \"_RadialDispatchTexture\"; private static readonly int radialDispatchTextureID = Shader.PropertyToID(radialDispatchTextureName); private RTHandle radialDispatchTextureHandle; private ComputeBuffer computeBuffer; private static readonly int THREAD_COUNT = 128; private static readonly int DISPATCH_DATA_COUNT = 8; private static readonly int DISPATCH_DATA_STRIDE = 5; private static readonly int DISPATCH_DATA_SIZE = DISPATCH_DATA_COUNT * DISPATCH_DATA_STRIDE; private int[] dispatchData = new int[DISPATCH_DATA_SIZE]; public RadialDispatchRenderPass(RadialDispatchRendererFeature.RadialDispatchSettings settings) { this.settings = settings; computeShader = settings.computeShader; renderPassEvent = settings.renderPassEvent; profilingSampler = new ProfilingSampler(passName); } public void Setup(ScriptableRenderer renderer, RadialDispatch RadialDispatch) { this.renderer = renderer; this.radialDispatch = RadialDispatch; } private void EnsureComputeBuffer(int count, int stride) { if (computeBuffer == null || computeBuffer.count != count || computeBuffer.stride != stride) { if (computeBuffer != null) { computeBuffer.Release(); } computeBuffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData) { EnsureComputeBuffer(DISPATCH_DATA_COUNT, DISPATCH_DATA_STRIDE * 4); RenderTextureDescriptor desc = renderingData.cameraData.cameraTargetDescriptor; textureSize = new Vector2Int(desc.width, desc.height); desc.enableRandomWrite = true; desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat; desc.depthBufferBits = 0; desc.msaaSamples = 1; desc.useMipMap = false; RenderingUtils.ReAllocateIfNeeded(ref radialDispatchTextureHandle, desc, FilterMode.Point, TextureWrapMode.Clamp, false, 1, 0, radialDispatchTextureName); ; } private Vector4 GetTextureSizeParameter(Vector2Int textureSize) { return new Vector4(textureSize.x, textureSize.y, 1.0f / textureSize.x, 1.0f / textureSize.y); } private struct DispatchParams { public int2 offset; public int count; public int stride; public int xMajor; public DispatchParams(int2 offset, int count, int stride, int xMajor) { this.offset = offset; this.count = count; this.stride = stride; this.xMajor = xMajor; } } private void GetDispatchParams(int2 coord, int2 offset, out DispatchParams dp1, out DispatchParams dp2) { int colIndexOffset = math.max(offset.x, offset.y) / THREAD_COUNT; int yIndexOffset; int minVal, maxVal, xMajor; if (coord.x \u003e= coord.y) { minVal = coord.y; maxVal = coord.x; yIndexOffset = offset.y; xMajor = 1; } else { minVal = coord.x; maxVal = coord.y; yIndexOffset = offset.x; xMajor = 0; } int stride1 = math.max(0, (minVal + colIndexOffset + 1) * THREAD_COUNT - 1 - offset.x - offset.y); int count1 = stride1 * math.max(0, minVal - colIndexOffset); int stride2 = math.max(0, (minVal + 1) * THREAD_COUNT - yIndexOffset); int count2 = stride2 * math.max(0, maxVal - math.max(minVal, colIndexOffset)); dp1 = new DispatchParams(offset, count1, stride1, xMajor); dp2 = new DispatchParams(offset, count2, stride2, xMajor); } private void GetDispatchList(int2 iCenterPosSS, int2 textureSize, out DispatchParams[] dispatchList) { int2 offsetLB = math.max(0, iCenterPosSS - textureSize); int2 offsetRT = math.max(0, new int2(0, 0) - iCenterPosSS); int2 coordLB = (iCenterPosSS + THREAD_COUNT - 1) / THREAD_COUNT; int2 coordRT = (textureSize - iCenterPosSS + THREAD_COUNT - 1) / THREAD_COUNT; int2 coordRB = new int2(coordRT.x, coordLB.y); int2 coordLT = new int2(coordLB.x, coordRT.y); int2 offsetRB = new int2(offsetRT.x, offsetLB.y); int2 offsetLT = new int2(offsetLB.x, offsetRT.y); GetDispatchParams(coordLB, offsetLB, out DispatchParams dpLB1, out DispatchParams dpLB2); GetDispatchParams(coordLT, offsetLT, out DispatchParams dpLT1, out DispatchParams dpLT2); GetDispatchParams(coordRB, offsetRB, out DispatchParams dpRB1, out DispatchParams dpRB2); GetDispatchParams(coordRT, offsetRT, out DispatchParams dpRT1, out DispatchParams dpRT2); dispatchList = new DispatchParams[] { dpLB1, dpLB2, dpLT1, dpLT2, dpRB1, dpRB2, dpRT1, dpRT2 }; } private int SetDispatchData(DispatchParams[] dispatchList) { if (dispatchList.Length != 8) return 0; int totalCount = 0; for (int i = 0; i \u003c 8; ++i) { var param = dispatchList[i]; totalCount += param.count; dispatchData[5 * i + 0] = param.offset.x; dispatchData[5 * i + 1] = param.offset.y; dispatchData[5 * i + 2] = totalCount; dispatchData[5 * i + 3] = param.stride; dispatchData[5 * i + 4] = param.xMajor; } computeBuffer.SetData(dispatchData); return totalCount; } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = renderingData.commandBuffer; UniversalRenderer universalRenderer = renderer as UniversalRenderer; if (universalRenderer == null || computeShader == null || centerTrans == null) return; using (new ProfilingScope(cmd, profilingSampler)) { float4 centerPosWS = new float4(centerTrans.position, 1.0f); float4x4 viewMat = renderingData.cameraData.GetViewMatrix(); float4x4 projMat = renderingData.cameraData.GetGPUProjectionMatrix(); float4x4 vpMat = math.mul(projMat, viewMat); float4 centerPosCS = math.mul(vpMat, centerPosWS); centerPosCS.xyz /= math.abs(centerPosCS.w); centerPosCS.y = -centerPosCS.y; float2 centerPosSS = (centerPosCS.xy * 0.5f + 0.5f) * new float2(textureSize.x, textureSize.y); int2 iCenterPosSS = new int2(math.floor(centerPosSS + 0.5f)); int2 ts = new int2(textureSize.x, textureSize.y); GetDispatchList(iCenterPosSS, ts, out DispatchParams[] dispatchList); int totalDispatchCount = SetDispatchData(dispatchList); var backBuffer = universalRenderer.m_ColorBufferSystem.GetBackBuffer(cmd); int clearID = computeShader.FindKernel(\"ClearMain\"); cmd.SetComputeTextureParam(computeShader, clearID, \"_RW_TargetTex\", radialDispatchTextureHandle); computeShader.GetKernelThreadGroupSizes(clearID, out uint x1, out uint y1, out uint z1); cmd.DispatchCompute(computeShader, clearID, Mathf.CeilToInt((float)textureSize.x / x1), Mathf.CeilToInt((float)textureSize.y / y1), 1); if (radialDispatch.radialDispatch.value) { int kernelID = computeShader.FindKernel(\"RadialDispatch\"); cmd.SetComputeTextureParam(computeShader, kernelID, \"_ColorTex\", backBuffer); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTex\", radialDispatchTextureHandle); cmd.SetComputeVectorParam(computeShader, \"_CenterPosSS\", new float4(centerPosSS, 0.0f, 0.0f)); cmd.SetComputeVectorParam(computeShader, \"_TextureSize\", GetTextureSizeParameter(textureSize)); cmd.SetComputeBufferParam(computeShader, kernelID, \"_DispatchData\", computeBuffer); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)totalDispatchCount / x), 1, 1); } else { int kernelID = computeShader.FindKernel(\"NormalDispatch\"); cmd.SetComputeTextureParam(computeShader, kernelID, \"_ColorTex\", backBuffer); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTex\", radialDispatchTextureHandle); cmd.SetComputeVectorParam(computeShader, \"_CenterPosSS\", new float4(centerPosSS, 0.0f, 0.0f)); cmd.SetComputeVectorParam(computeShader, \"_TextureSize\", GetTextureSizeParameter(textureSize)); cmd.SetComputeBufferParam(computeShader, kernelID, \"_DispatchData\", computeBuffer); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)textureSize.x / x), Mathf.CeilToInt((float)textureSize.y / y), 1); } cmd.Blit(radialDispatchTextureHandle, backBuffer); } } public void Dispose() { radialDispatchTextureHandle?.Release(); if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } } } } RadialDispatchRendererFeature.cs using System; namespace UnityEngine.Rendering.Universal { public class RadialDispatchRendererFeature : ScriptableRendererFeature { [Serializable] public class RadialDispatchSettings { public ComputeShader computeShader; public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; } public RadialDispatchSettings settings = new RadialDispatchSettings(); private RadialDispatchRenderPass radialDispatchRenderPass; public override void Create() { radialDispatchRenderPass = new RadialDispatchRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { RadialDispatch rd = VolumeManager.instance.stack.GetComponent(); if (rd.IsActive()) { radialDispatchRenderPass.Setup(renderer, rd); renderer.EnqueuePass(radialDispatchRenderPass); } } protected override void Dispose(bool disposing) { radialDispatchRenderPass?.Dispose(); base.Dispose(disposing); } } } RadialDispatch.cs using System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Radial Dispatch\", typeof(UniversalRenderPipeline))] public sealed class RadialDispatch : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public BoolParameter radialDispatch = new BoolParameter(true); public bool IsActive() { return isEnabled.value; } public bool IsTileCompatible() =\u003e false; } } RadialDispatchCenter.cs using UnityEngine; [ExecuteAlways] public class RadialDispatchCenter : MonoBehaviour { public static RadialDispatchCenter Instance { get; private set; } private void OnEnable() { if (Instance == null) { Instance = this; UnityEngine.Rendering.Universal.RadialDispatchRenderPass.centerTrans = this.transform; } else { Debug.LogError(\"Only one instance of RadialDispatchCenter is allowed to exist at the same time.\"); enabled = false; } } private void OnDisable() { if (Instance == this) { Instance = null; UnityEngine.Rendering.Universal.RadialDispatchRenderPass.centerTrans = null; } } private void OnDestroy() { if (Instance == this) { Instance = null; UnityEngine.Rendering.Universal.RadialDispatchRenderPass.centerTrans = null; } } } åè®° åˆæ˜¯å¤´æ™•ç›®çœ©çš„å–æ¨¡ã€å–ä½™ã€åŠ ä¸€ã€å‡ä¸€ï¼Œè€Œä¸”æ˜¯æéš¾debugçš„ä¸è§„åˆ™Thread Groupå’Œåƒç´ å¯¹åº”çš„æ–¹å¼ï¼Œå¥½å‡ æ¬¡å¯¹ç€å±å¹•ä¸Šé»‘è‰²çš„åŒºåŸŸå‘å‘†ï¼Œä½†æœ€ç»ˆè¿˜æ˜¯è‰°éš¾çš„åšäº†å‡ºæ¥ã€‚ä½†æ˜¯æœ€ç»ˆçš„ä»£ç å†™çš„å¾ˆæŠ½è±¡ï¼Œå°±åƒæˆ‘æ²¡æœ‰æ€ä¹ˆçœ‹Bend Studioæä¾›çš„å‚è€ƒä»£ç ä¸€æ ·ï¼Œè¯»è€…ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ä¹Ÿä¸ä¼šæ€ä¹ˆçœ‹æˆ‘å†™çš„ä»£ç å§ã€‚ã€‚ã€‚\néå¸¸æ„Ÿè°¢Unityçš„Mathematicsè¿™ä¸ªåŒ…ï¼Œè¿™ä¸ªåŒ…æå¤§åœ°å‡å°‘äº†æˆ‘å°†åŒæ ·çš„ä»£ç å¤åˆ¶åˆ°C#ä¸­debugçš„å·¥ä½œé‡ã€‚ä½†æ„¿æ²¡æœ‰ä»€ä¹ˆæ²¡æŸ¥å‡ºæ¥çš„bugï¼Œæ˜å¤©åº”è¯¥èƒ½å†™ä¸€ä¸ªå¾„å‘æ¨¡ç³Šçš„æ–‡ç« äº†ï¼Œä¹‹åå°±æ˜¯æ¥è§¦é˜´å½±äº†ï¼Œåœ¨ä¹‹åå¤§æ¦‚å°±èƒ½åˆ°è‰åœºçš„æ¸²æŸ“äº†ã€‚\n","wordCount":"1726","inLanguage":"en","image":"https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/posts/images/RadiallyDispatchedComputeShader.png","datePublished":"2024-03-30T12:00:00+08:00","dateModified":"2024-03-30T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/dispatch-compute-shader-in-a-radial-way/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">å¾„å‘åˆ†æ´¾Compute Shader</h1><div class=post-description>è®©åŒä¸€ä¸ªgroupå¯¹åº”çš„åƒç´ å½¢æˆæ”¾å°„çŠ¶å›¾æ¡ˆ.</div><div class=post-meta><span title='2024-03-30 12:00:00 +0800 CST'>March 30, 2024</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/dispatch-compute-shader-in-a-radial-way.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/RadiallyDispatchedComputeShader.png alt="Radially Dispatched Cover"><p>Radially Dispatched Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>å¾„å‘åˆ†æ´¾Compute Shader</div></summary><div class=inner><ul><li><a href=#%e5%8a%a8%e6%9c%ba aria-label=åŠ¨æœº>åŠ¨æœº</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e5%be%84%e5%90%91%e5%88%86%e6%b4%be aria-label=å¦‚ä½•è¿›è¡Œå¾„å‘åˆ†æ´¾>å¦‚ä½•è¿›è¡Œå¾„å‘åˆ†æ´¾</a><ul><li><a href=#%e5%88%86%e6%b4%be%e6%96%b9%e5%bc%8f%e5%92%8c%e5%8e%9f%e5%9b%a0 aria-label=åˆ†æ´¾æ–¹å¼å’ŒåŸå› >åˆ†æ´¾æ–¹å¼å’ŒåŸå› </a></li><li><a href=#%e5%be%84%e5%90%91%e5%88%86%e6%b4%be%e7%9a%84%e9%a2%9d%e5%a4%96%e5%8f%82%e6%95%b0 aria-label=å¾„å‘åˆ†æ´¾çš„é¢å¤–å‚æ•°>å¾„å‘åˆ†æ´¾çš„é¢å¤–å‚æ•°</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e5%a4%9a%e4%b8%aathread%e5%af%b9%e5%ba%94%e5%90%8c%e4%b8%80%e4%b8%aa%e5%83%8f%e7%b4%a0%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%97%aa%e7%83%81 aria-label=è§£å†³å¤šä¸ªThreadå¯¹åº”åŒä¸€ä¸ªåƒç´ å¸¦æ¥çš„é—ªçƒ>è§£å†³å¤šä¸ªThreadå¯¹åº”åŒä¸€ä¸ªåƒç´ å¸¦æ¥çš„é—ªçƒ</a></li></ul></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç </a><ul><li><a href=#radialdispatchcomputeshadercompute aria-label=RadialDispatchComputeShader.compute>RadialDispatchComputeShader.compute</a></li><li><a href=#radialdispatchrenderpasscs aria-label=RadialDispatchRenderPass.cs>RadialDispatchRenderPass.cs</a></li><li><a href=#radialdispatchrendererfeaturecs aria-label=RadialDispatchRendererFeature.cs>RadialDispatchRendererFeature.cs</a></li><li><a href=#radialdispatchcs aria-label=RadialDispatch.cs>RadialDispatch.cs</a></li><li><a href=#radialdispatchcentercs aria-label=RadialDispatchCenter.cs>RadialDispatchCenter.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=åŠ¨æœº>åŠ¨æœº<a hidden class=anchor aria-hidden=true href=#åŠ¨æœº>#</a></h2><p>æœ€ç›´æ¥çš„åŠ¨æœºæ˜¯æˆ‘æœ€è¿‘éœ€è¦å®ç°è§¦é˜´å½±äº†ã€‚ç´¢å°¼çš„Bend Studioçš„Graham Aldridgeåœ¨Sigraph 2023çš„ç´¢å°¼åˆ›ä½œè€…å¤§ä¼šä¸Šï¼Œä»‹ç»äº†å¾€æ—¥ä¸å†ï¼ˆDays Goneï¼‰ä¸­è®¡ç®—è§¦é˜´å½±çš„æ–¹å¼ï¼Œ<a href=https://www.bendstudio.com/blog/inside-bend-screen-space-shadows/>è¿™é‡Œ</a>å¯ä»¥æ‰¾åˆ°æ¼”ç¤ºæ–‡ç¨¿å’Œå‚è€ƒä»£ç ã€‚æ¼”ç¤ºæ–‡ç¨¿çš„ç¬¬24-27é¡µï¼Œå±•ç¤ºäº†ä¸€ç§æ–°é¢–çš„åˆ†æ´¾Compute Shaderçš„æ–¹æ³•ï¼Œä¼ ç»Ÿçš„åˆ†æ´¾Compute Shaderå¾€å¾€æ˜¯å°†ç”»é¢æ°´å¹³å’Œç«–ç›´åˆ‡åˆ†æˆåƒç´ æ•°é‡ä¸º64å€æ•°çš„å°å—ï¼Œå°†åˆ†æ´¾çš„Compute Shaderå¯¹åº”åˆ°è¿™äº›å°å—ä¸Šï¼Œè€ŒDays Goneä¸­åˆ™æ˜¯å°†åˆ†æ´¾çš„Compute Shaderå¯¹åº”åˆ°å‘ˆæ”¾å°„çŠ¶çš„åƒç´ å°å—ä¸Šã€‚å¤§è‡´çš„æ„æ€å¯ä»¥çœ‹ä¸‹å›¾ï¼Œä¸‹å›¾ä¸­ç›¸åŒé¢œè‰²çš„ç›¸é‚»åƒç´ å±äºåŒä¸€ä¸ªthread groupï¼Œå·¦è¾¹æ˜¯ä¼ ç»Ÿçš„åˆ†æ´¾æ–¹å¼ï¼Œå³è¾¹åˆ™æ˜¯å¾„å‘çš„åˆ†æ´¾æ–¹å¼ã€‚</p><p><img loading=lazy src=../images/RadiallyDispatchedComputeShader.png#center alt=RadiallyDispatchedComputeShader.png></p><p>å½“è¿›è¡Œå¾„å‘æ¨¡ç³Šæˆ–æ˜¯è®¡ç®—æ¥è§¦é˜´å½±æ—¶ï¼Œå¾€å¾€éœ€è¦æ²¿ç€æŸä¸ªæ–¹å‘è¿ç»­é‡‡æ ·çº¹ç†ã€‚å¯¹äºå¤šæ¬¡é‡‡æ ·ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¼šæƒ³åˆ°ä½¿ç”¨Compute Shaderä¸­çš„Group Shared Memoryè¿›è¡Œç¼“å­˜ä»è€Œå‡å°‘é‡‡æ ·æ¬¡æ•°ã€‚ä½†æ˜¯å¯¹ç‰¹å®šæ–¹å‘è¿›è¡Œç¼“å­˜çš„è¯ï¼Œä¼šè¦ç¼“å­˜O((N+C)^2)ä¸ªé¢œè‰²ï¼Œå¦‚æœåˆ†æ´¾çš„Thread Group Sizeæˆ–æ˜¯æ­¥è¿›çš„æ¬¡æ•°æ¯”è¾ƒå¤§ï¼Œå¾ˆå®¹æ˜“å°±è¶…å‡ºäº†Group Shared Memoryçš„æœ€å¤§é™åˆ¶ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨å¾„å‘åˆ†æ´¾çš„æ–¹å¼ï¼Œå°†æ¯ä¸€ä¸ªThread Groupå¯¹åº”çš„åƒç´ æ²¿ç€é‡‡æ ·çš„æ–¹å‘æ’åˆ—ï¼Œç®—ä¸Šçº¿æ€§æ’å€¼ä¹Ÿåªéœ€è¦ç¼“å­˜(N+C)*2ä¸ªé¢œè‰²ï¼Œè¿™æ ·å°±èƒ½å¾ˆæ–¹ä¾¿åœ°è¿›è¡Œè¾ƒè¿œçš„æ­¥è¿›äº†ã€‚</p><p>ç›¸è¾ƒäºç´¢å°¼çš„æ¼”ç¤ºï¼Œæœ¬æ–‡è§£å†³äº†Thread Groupå¯¹åº”çš„åƒç´ é‡å çš„é—®é¢˜ï¼Œä¹Ÿå°½é‡åœ°ä»‹ç»äº†è®¾ç½®åˆ†æ´¾å‚æ•°æ—¶çš„å„ç§æ¡ä»¶åˆ¤æ–­ã€‚æœ¬æ–‡ä½¿ç”¨çš„æ˜¯Unity 2022.3.21f1ï¼ŒURPç‰ˆæœ¬æ˜¯14.0.10ã€‚</p><h2 id=å¦‚ä½•è¿›è¡Œå¾„å‘åˆ†æ´¾>å¦‚ä½•è¿›è¡Œå¾„å‘åˆ†æ´¾<a hidden class=anchor aria-hidden=true href=#å¦‚ä½•è¿›è¡Œå¾„å‘åˆ†æ´¾>#</a></h2><h3 id=åˆ†æ´¾æ–¹å¼å’ŒåŸå› >åˆ†æ´¾æ–¹å¼å’ŒåŸå› <a hidden class=anchor aria-hidden=true href=#åˆ†æ´¾æ–¹å¼å’ŒåŸå› >#</a></h3><p>é¦–å…ˆæˆ‘ä»¬æ³¨æ„åˆ°å¯¹äºå±å¹•ä¸­æ‰€æœ‰æŒ‡å‘ä¸­å¿ƒçš„å°„çº¿ï¼Œå¯ä»¥å°†å…¶åˆ†ä¸ºå·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸‹ã€å³ä¸Šå››ç§ï¼Œè¿™å››ç§å°„çº¿æœ€æ˜æ˜¾çš„æ˜¯ç¬¦å·ç›¸åï¼Œå› æ­¤åœ¨æˆ‘ä»¬åˆ†æ´¾çš„æ—¶å€™å¯ä»¥åˆ†æˆå››ç»„æ•°æ®ï¼Œæ¯ä¸€ç»„æ•°æ®ä½¿ç”¨åŒæ ·çš„æ–¹å¼æ‰¾åˆ°å¯¹åº”çš„åç§»å€¼ï¼Œå†ä¹˜ä¸Šç¬¦å·å’Œä¸­å¿ƒçš„åæ ‡ç›¸åŠ ï¼Œå°±èƒ½å¾—åˆ°å¯¹åº”çš„åƒç´ åæ ‡ã€‚</p><p>å› æ­¤æˆ‘ä»¬åªéœ€è¦è€ƒè™‘ä¸€ç§æƒ…å†µï¼Œæˆ‘ä»¬ä»¥å³ä¸Šè§’ä¸ºä¾‹ã€‚ä¸‹å›¾æ˜¯ä¸€ä¸ªå¾„å‘åˆ†æ´¾çš„ç¤ºæ„å›¾ï¼Œç»¿è‰²æ˜¯æˆ‘ä»¬çš„ä¸­å¿ƒç‚¹ï¼Œæ‰€æœ‰çš„Thread Groupéƒ½ä¼šä»¥ç»¿ç‚¹ä¸ºä¸­å¿ƒæ”¾å°„çŠ¶æ’å¸ƒï¼Œé»‘æ¡†å°±æ˜¯å±å¹•ä¸Šä¸­å¿ƒç‚¹å³ä¸Šè§’å¯¹åº”çš„åŒºåŸŸï¼ˆä¸ºäº†ç®€ä¾¿è¿™é‡Œé€‰å–äº†æ¯”è¾ƒå°çš„18x10åƒç´ ï¼‰ï¼Œè¿™é‡Œæ¯å››ä¸ªç›¸é‚»ç™½è‰²æ–¹æ¡†åŒå±äºä¸€ä¸ªThread Groupï¼ˆæ›´å¤šçš„Thread Groupæˆ‘æ²¡æœ‰ç”»å‡ºæ¥ï¼‰ï¼Œè“è‰²çš„åŒºåŸŸæ˜¯æ¯ä¸€ä¸ªThread Groupçš„èµ·ç‚¹ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°æ·±è“å’Œæµ…è“ä¸¤ç§é¢œè‰²ï¼Œå®ƒä»¬å¯¹åº”äº†ä¸¤ç§åˆ†æ´¾çš„è§„å¾‹ï¼Œä¸€ç§æ˜¯å‘ˆæ­£æ–¹å½¢çš„ï¼Œå¦ä¸€ç§åˆ™æ˜¯å‘ˆçŸ©å½¢çš„ï¼Œç°è‰²çš„åŒºåŸŸæ˜¯æ‰€æœ‰è®¡ç®—è€Œå¾—çš„æ¯ä¸€ä¸ªThreadå¯¹åº”çš„åƒç´ ï¼Œä¸ºäº†è®©ç°è‰²çš„åŒºåŸŸè¦†ç›–æ•´ä¸ªé»‘æ¡†çš„åŒºåŸŸï¼Œæˆ‘ä»¬éœ€è¦åšæ¯”å½“å‰åƒç´ æ›´å¤šçš„åˆ†æ´¾ã€‚</p><p><img loading=lazy src=../images/RadialDispatchDiagram.png#center alt=RadialDispatchDiagram.png></p><p>ç›´æ¥è®¡ç®—æ¯ä¸€ä¸ªThreadå¯¹åº”çš„åƒç´ ä¼¼ä¹æœ‰ç‚¹å›°éš¾ï¼Œæˆ‘ä»¬å¯ä»¥å°†åˆ†æ´¾åˆ†æˆä¸¤ä¸ªç»´åº¦ï¼Œç”¨ç¬¬ä¸€ä¸ªç»´åº¦è®¡ç®—Thread Groupçš„èµ·ç‚¹ï¼Œå³ä¸Šå›¾çš„è“è‰²åŒºåŸŸï¼Œç”¨ç¬¬äºŒä¸ªç»´åº¦å’ŒThread Groupçš„èµ·ç‚¹ï¼Œè®¡ç®—å¯¹åº”çš„åƒç´ çš„ä½ç½®ã€‚å› æ­¤æˆ‘ä»¬åˆ†æ´¾çš„æ•°æ®ä¹Ÿå°±å˜æˆäº†ä¸€ä¸ªGroupIDå’ŒGroupIndexäº†ã€‚æ³¨æ„åˆ°æµ…è“è‰²çš„åŒºåŸŸçš„ä½ç½®å†³å®šäºé»‘æ¡†çš„é•¿å®½æ¯”ï¼Œå½“é»‘æ¡†çš„é«˜å¤§äºé•¿æ—¶ï¼Œæµ…è“è‰²çš„åŒºåŸŸä¼šåœ¨æ·±è“è‰²çš„ä¸Šæ–¹ä¸”æ¨ªå‘æ’å¸ƒã€‚æˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªxMajorçš„åˆ¤æ–­ï¼Œå¦‚æœä¸æ˜¯xMajorï¼Œæˆ‘ä»¬å°±è°ƒæ¢xyåˆ†é‡ï¼Œå…¨éƒ¨è®¡ç®—å®Œæ¯•ä¹‹åå†æ¢å›æ¥ã€‚</p><p>æ ¹æ®å›¾ä¸Šçš„æ·±è“è‰²å’Œæµ…è“è‰²åŒºåŸŸï¼Œæˆ‘ä»¬ä¼šå°†ä¸¤ä¸ªåŒºåŸŸåˆ†å¼€æ¥è®¡ç®—GroupIDã€‚æ¯”è¾ƒç®€å•çš„æ˜¯æµ…è“è‰²çš„åŒºåŸŸï¼Œä»æ•°å­¦ä¸Šæˆ‘ä»¬éœ€è¦ä¼ å…¥æ¯ä¸€åˆ—çš„åˆ—é«˜ï¼Œè®¡ç®—å‡ºGroupIDçš„åˆ—åºå·å’Œåœ¨ä¸€åˆ—ä¸­çš„åºå·ï¼Œå°±èƒ½å¾—åˆ°èµ·ç‚¹çš„åæ ‡äº†ã€‚æ·±è“è‰²çš„åŒºåŸŸï¼Œå¦‚æœå•çº¯å¯¹æ¯ä¸€åœˆæ±‚å’Œçš„è¯ï¼Œè¿™æ˜¯ä¸€ä¸ªäºŒæ¬¡æ–¹ç¨‹ï¼Œè™½ç„¶ä¹Ÿèƒ½è®¡ç®—ä½†æ•ˆç‡è‚¯å®šä¸ä¼šå¾ˆé«˜ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘é«˜æ–¯æ±‚å’Œçš„æ–¹æ³•ï¼Œå°†ç¬¬ä¸€åœˆçš„ç«–å‘çš„åƒç´ å’Œæœ€åä¸€åœˆçš„æ¨ªå‘åƒç´ åˆå¹¶æˆä¸€åˆ—ï¼ˆä¹Ÿå°±æ˜¯å›¾ä¸Šæ·±è“è‰²æ–¹æ¡†å·¦ä¸Šè§’å›¾æ¡ˆç›¸åŒçš„ä¸ºåŒä¸€åˆ—ï¼‰ï¼Œè¿™æ ·å¾—åˆ°çš„æ¯ä¸€åˆ—çš„åˆ—é«˜éƒ½æ˜¯ç›¸åŒçš„ï¼Œå°±èƒ½ä½¿ç”¨æµ…è“è‰²åŒºåŸŸçš„æ–¹å¼è®¡ç®—åºå·äº†ï¼Œä¹‹åæˆ‘ä»¬å†å¯¹æ¯”è¾ƒåºå·çš„å¤§å°æ¥å†³å®šæ˜¯ç«–å‘çš„åƒç´ è¿˜æ˜¯æ¨ªå‘çš„åƒç´ ã€‚</p><p>å¾—åˆ°äº†Thread Groupçš„èµ·ç‚¹åæ ‡ä¹‹åï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨èµ·ç‚¹åæ ‡åˆ°ä¸­å¿ƒçš„å‘é‡ï¼Œå¯¹Xæ–¹å‘æˆ–Yæ–¹å‘ä»¥1ä¸ºå•ä½æ­¥è¿›ï¼Œå†å¯¹å¦ä¸€ä¸ªæ–¹å‘å–æœ€è¿‘çš„æ•´æ•°ï¼Œå°±èƒ½å¾—åˆ°å½“å‰Threadå¯¹åº”çš„åƒç´ ç›¸å¯¹äºæ•´ä¸ªThread Groupèµ·ç‚¹åæ ‡çš„åç§»ï¼Œä¸¤è€…ç›¸åŠ å°±èƒ½å¾—åˆ°æœ€ç»ˆçš„åƒç´ åæ ‡äº†ã€‚</p><p>äº‹å®ä¸Šï¼Œæˆ‘ä»¬çš„ä¸­å¿ƒç‚¹æœ‰å¯èƒ½ä¼šåœ¨å±å¹•å¤–éƒ¨ï¼Œè¿™ä¸ªæ—¶å€™ä¸Šå›¾å°±ä¼šå˜æˆè¿™æ ·ï¼Œæˆ‘ä»¬åœ¨è®¡ç®—åˆ—é«˜çš„æ—¶å€™éœ€è¦é¢å¤–çš„è€ƒè™‘ä¸­å¿ƒç‚¹çš„åç§»ï¼Œæ·±è“è‰²çš„åŒºåŸŸä¹Ÿä¸ä¼šè€ƒè™‘å®Œå…¨åœ¨å±å¹•å¤–çš„åœˆã€‚</p><p><img loading=lazy src=../images/RadialDispatchDiagram2.png#center alt=RadialDispatchDiagram2.png></p><h3 id=å¾„å‘åˆ†æ´¾çš„é¢å¤–å‚æ•°>å¾„å‘åˆ†æ´¾çš„é¢å¤–å‚æ•°<a hidden class=anchor aria-hidden=true href=#å¾„å‘åˆ†æ´¾çš„é¢å¤–å‚æ•°>#</a></h3><p>ä¸ºäº†åœ¨Compute Shaderä¸­è®¡ç®—æ¯ä¸ªThreadå¯¹åº”çš„åƒç´ ï¼Œæˆ‘ä»¬éœ€è¦ä»CPUé¢å¤–ä¼ é€’ä¸€äº›å‚æ•°ã€‚åœ¨å¾„å‘åˆ†æ´¾ä¸­ï¼Œæˆ‘ä»¬ä»SV_DispatchThreadIDä¸­è·å–åˆ°çš„å…¶å®æ˜¯GroupIDå’ŒGroupIndexä¸¤ä¸ªå‚æ•°ã€‚ç”±ä¸Šé¢çš„è®¨è®ºï¼Œæˆ‘ä»¬å°†æ‰€æœ‰æƒ…å†µåˆ†ä¸º4 * 2ç§ï¼Œå³å·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸‹ã€å³ä¸Šã€æ·±è“ã€æµ…è“çš„ç»„åˆï¼Œå¯¹äºæ¯ä¸€ç§ç»„åˆæˆ‘ä»¬éœ€è¦çŸ¥é“æ€»çš„æ•°é‡ï¼Œæ‰èƒ½è®¡ç®—åœ¨æ¯ä¸€ç§ç»„åˆä¸­çš„GroupIDã€‚æ ¹æ®æˆ‘ä»¬ä¸Šè¿°çš„è®¡ç®—æ–¹å¼ï¼Œæˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“æ¯ä¸€ç§ç»„åˆå¯¹åº”çš„åˆ—é«˜å’ŒxMajorçš„ä¿¡æ¯ã€‚ä¸ºäº†å…¼å®¹ä¸­å¿ƒç‚¹åœ¨å±å¹•å¤–çš„æƒ…å†µï¼Œæˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“ä¸­å¿ƒç‚¹çš„åç§»å€¼ã€‚è¿™æ ·æˆ‘ä»¬çš„å‚æ•°å°±æ˜¯8ç»„5ä¸ªintå€¼ï¼Œåˆ†åˆ«å¯¹åº”åç§»å€¼Xï¼Œåç§»å€¼Yï¼Œå½“å‰æ€»Thread Groupæ•°ï¼Œåˆ—é«˜å’ŒxMajorï¼Œå…¶ä¸­xMajorå…¶å®æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼å¯ä»¥å°è£…åˆ°åˆ—é«˜çš„ç¬¬ä¸€ä½ï¼Œè¿™æ ·å°±åˆšå¥½æ˜¯å››ä¸ªintå€¼äº†ï¼Œæˆ‘ä»¬è¿™é‡Œä¸ºäº†æ–¹ä¾¿æ¼”ç¤ºå°±ä¸åšè¿™æ ·çš„ä¼˜åŒ–äº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DispatchParams</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> int2 offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> xMajor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DispatchParams(int2 offset, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride, <span style=color:#66d9ef>int</span> xMajor)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.offset = offset; <span style=color:#66d9ef>this</span>.count = count; <span style=color:#66d9ef>this</span>.stride = stride; <span style=color:#66d9ef>this</span>.xMajor = xMajor;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=è§£å†³å¤šä¸ªthreadå¯¹åº”åŒä¸€ä¸ªåƒç´ å¸¦æ¥çš„é—ªçƒ>è§£å†³å¤šä¸ªThreadå¯¹åº”åŒä¸€ä¸ªåƒç´ å¸¦æ¥çš„é—ªçƒ<a hidden class=anchor aria-hidden=true href=#è§£å†³å¤šä¸ªthreadå¯¹åº”åŒä¸€ä¸ªåƒç´ å¸¦æ¥çš„é—ªçƒ>#</a></h3><p>ç”±äºæˆ‘ä»¬æ˜¯ä»å¤–éƒ¨å‘å†…éƒ¨æ­¥è¿›ï¼Œè¿™å¿…ç„¶ä¼šå¯¼è‡´è¶Šé è¿‘ä¸­å¿ƒï¼Œè¶Šå¤šçš„Threadä¼šåœ¨åŒä¸€ä¸ªåƒç´ å‘ç”Ÿç¢°æ’ï¼Œåœ¨ç¤ºæ„å›¾ä¸­æˆ‘ä»¬ä¹Ÿèƒ½çœ‹åˆ°è¶Šé è¿‘ä¸­å¿ƒé”¯é½¿æ„Ÿè¶Šå¼ºçƒˆã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä»ä¸­å¿ƒå‘å½“å‰Threadå¯¹åº”çš„åƒç´ å‘å°„å°„çº¿ï¼Œè®¡ç®—å’Œè¿™ä¸ªå°„çº¿æœ€æ¥è¿‘çš„Thread Groupçš„èµ·å§‹åƒç´ ã€‚å¦‚æœè¿™ä¸ªèµ·å§‹åƒç´ å’Œå½“å‰Thread Groupçš„èµ·å§‹åƒç´ ç›¸åŒï¼Œæˆ‘ä»¬è®¤ä¸ºå½“å‰åƒç´ å±äºå½“å‰çš„Thread Groupï¼Œä¿ç•™è¿™ä¸ªåƒç´ ï¼Œå¦åˆ™ï¼Œå½“å‰åƒç´ å±äºåˆ«çš„Thread Groupï¼Œæˆ‘ä»¬è·³è¿‡åç»­çš„å¡«è‰²ã€‚è¿™æ ·æˆ‘ä»¬å°±èƒ½ç¡®ä¿ä¸€ä¸ªåƒç´ æœ€å¤šåªä¼šè¢«ä¸€ä¸ªThread Groupå†™å…¥ã€‚</p><p>ç”±äºæ­¤æ—¶æˆ‘ä»¬å±å¹•ä¸Šçš„åƒç´ å¹¶ä¸ä¸€å®šæ€»ä¼šè¢«å†™å…¥ï¼ˆå°¤å…¶æ˜¯æˆ‘ä»¬å†™äº†ä»€ä¹ˆbugçš„æ—¶å€™ï¼‰ï¼Œå»ºè®®åœ¨Debugæ—¶å…ˆå¯¹RenderTextureè¿›è¡Œä¸€æ¬¡åˆå§‹åŒ–ä¸º0çš„æ“ä½œï¼Œæœ¬æ–‡ä¹Ÿå°†ClearMainä¿ç•™åœ¨Compute Shaderä¸­ã€‚</p><h2 id=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç <a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„ä»£ç >#</a></h2><p>æŒ‡å¯¼æ€æƒ³å°±æ˜¯ä¸Šé¢æ‰€æè¿°çš„äº†ï¼Œä½†æ˜¯å®é™…å®ç°çš„æ—¶å€™ä¼šè¢«å„ç§å–æ¨¡ã€å–ä½™ã€åŠ ä¸€ã€å‡ä¸€æå¾—æ™•å¤´è½¬å‘ã€‚ã€‚ã€‚è¿™è¾¹è¿˜ç¨åšäº†ä¼˜åŒ–ï¼Œæ¯”è¾ƒ{ä»ä¸­å¿ƒåˆ°å½“å‰Thread Groupçš„å°„çº¿çš„æ–œç‡å’Œå½“å‰åƒç´ æ°´å¹³åç§»å€¼çš„ä¹˜ç§¯}å’Œ{ä»ä¸­å¿ƒåˆ°å½“å‰åƒç´ çš„å°„çº¿çš„æ–œç‡å’Œå½“å‰åƒç´ æ°´å¹³åç§»å€¼çš„ä¹˜ç§¯}ï¼Œä»è€Œå¿«é€Ÿåœ°åˆ¤æ–­å½“å‰åƒç´ æ˜¯å¦å±äºå½“å‰Thread Groupã€‚<code>RadialDispatch</code>å³ä¸ºå¾„å‘åˆ†æ´¾çš„ä¸»å‡½æ•°ï¼Œ<code>NormalDispatch</code>ä¸ºæ™®é€šåˆ†æ´¾çš„ä¸»å‡½æ•°ï¼Œé€šè¿‡å¯¹GroupIDåšå“ˆå¸Œæ¥å¯è§†åŒ–ã€‚</p><h3 id=radialdispatchcomputeshadercompute>RadialDispatchComputeShader.compute<a hidden class=anchor aria-hidden=true href=#radialdispatchcomputeshadercompute>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel RadialDispatch</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel NormalDispatch</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel ClearMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// #pragma warning(disable: 3556)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define THREAD_COUNT 128</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ColorTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_TargetTex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> _CenterPosSS;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> DispatchParams
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> xMajor;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span>DispatchParams<span style=color:#f92672>&gt;</span> _DispatchData;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> GetDispatchType(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> dispatchIndex, <span style=color:#66d9ef>out</span> DispatchParams dispatchParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        dispatchParams <span style=color:#f92672>=</span> _DispatchData[i];
</span></span><span style=display:flex><span>        dispatchIndex <span style=color:#f92672>=</span> dispatchParams.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> index;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dispatchIndex <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int2</span> GetDispatchDirection(<span style=color:#66d9ef>int</span> dispatchType, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> iLightPosOffset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    dispatchType <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> xDir <span style=color:#f92672>=</span> dispatchType <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yDir <span style=color:#f92672>=</span> dispatchType <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dir <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(xDir, yDir);
</span></span><span style=display:flex><span>    iLightPosOffset <span style=color:#f92672>=</span> dir <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dir <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int2</span> GetDispatchOffset(<span style=color:#66d9ef>int</span> dispatchType, <span style=color:#66d9ef>int</span> dispatchIndex, DispatchParams dispatchParams, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> groupIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    groupIndex <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> offsetType <span style=color:#f92672>=</span> dispatchType <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> colIndexOffset <span style=color:#f92672>=</span> max(dispatchParams.offset.x,dispatchParams.offset.y)<span style=color:#f92672>/</span>THREAD_COUNT;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> indexOffset <span style=color:#f92672>=</span> dispatchParams.xMajor<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span><span style=color:#f92672>?</span>dispatchParams.offset<span style=color:#f92672>:</span>dispatchParams.offset.yx;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stride <span style=color:#f92672>=</span> dispatchParams.stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> colIndex <span style=color:#f92672>=</span> dispatchIndex <span style=color:#f92672>/</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> rowIndex <span style=color:#f92672>=</span> dispatchIndex <span style=color:#f92672>-</span> colIndex <span style=color:#f92672>*</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offsetType <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {         
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> offsetedColIndex <span style=color:#f92672>=</span> colIndex <span style=color:#f92672>+</span> colIndexOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> tempIndex <span style=color:#f92672>=</span> rowIndex <span style=color:#f92672>+</span> indexOffset.y <span style=color:#f92672>-</span> (offsetedColIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tempIndex <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(tempIndex <span style=color:#f92672>+</span> indexOffset.x, dispatchParams.stride <span style=color:#f92672>-</span> (colIndex <span style=color:#f92672>+</span> colIndexOffset <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT <span style=color:#f92672>+</span> indexOffset.x <span style=color:#f92672>+</span> indexOffset.y);
</span></span><span style=display:flex><span>            groupIndex <span style=color:#f92672>=</span> tempIndex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>((offsetedColIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, rowIndex <span style=color:#f92672>+</span> indexOffset.y);
</span></span><span style=display:flex><span>            groupIndex <span style=color:#f92672>=</span> rowIndex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> minOffsetX <span style=color:#f92672>=</span> max(dispatchParams.stride <span style=color:#f92672>+</span> indexOffset.y, (colIndexOffset <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT);
</span></span><span style=display:flex><span>        dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(minOffsetX <span style=color:#f92672>+</span> colIndex <span style=color:#f92672>*</span> THREAD_COUNT <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, rowIndex <span style=color:#f92672>+</span> indexOffset.y);
</span></span><span style=display:flex><span>        groupIndex <span style=color:#f92672>=</span> rowIndex;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dispatchParams.xMajor <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) dispatchOffset.xy <span style=color:#f92672>=</span> dispatchOffset.yx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dispatchOffset;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://www.shadertoy.com/view/4djSRW</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  1 out, 1 in...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> hash11(<span style=color:#66d9ef>float</span> p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> frac(p <span style=color:#f92672>*</span> .<span style=color:#ae81ff>1031</span>);
</span></span><span style=display:flex><span>    p <span style=color:#f92672>*=</span> p <span style=color:#f92672>+</span> <span style=color:#ae81ff>33.33</span>;
</span></span><span style=display:flex><span>    p <span style=color:#f92672>*=</span> p <span style=color:#f92672>+</span> p;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> frac(p);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// https://www.shadertoy.com/view/MsS3Wc</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Smooth HSV to RGB conversion </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> hsv2rgb_smooth(<span style=color:#66d9ef>float3</span> c)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> rgb <span style=color:#f92672>=</span> clamp(abs(fmod(c.x<span style=color:#f92672>*</span><span style=color:#ae81ff>6.0</span><span style=color:#f92672>+</span><span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>0.0</span>,<span style=color:#ae81ff>4.0</span>,<span style=color:#ae81ff>2.0</span>),<span style=color:#ae81ff>6.0</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>3.0</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>	rgb <span style=color:#f92672>=</span> rgb<span style=color:#f92672>*</span>rgb<span style=color:#f92672>*</span>(<span style=color:#ae81ff>3.0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span><span style=color:#f92672>*</span>rgb); <span style=color:#75715e>// cubic smoothing	</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> c.z <span style=color:#f92672>*</span> lerp(<span style=color:#66d9ef>float3</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1.0f</span>), rgb, c.y);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>1</span>, THREAD_COUNT, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> RadialDispatch(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> SV_DISPATCHTHREADID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> centerPosSS <span style=color:#f92672>=</span> _CenterPosSS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iCenterPosSS <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(floor(centerPosSS <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dispatchIndex;
</span></span><span style=display:flex><span>    DispatchParams dispatchParams;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dispatchType <span style=color:#f92672>=</span> GetDispatchType(id.x, dispatchIndex, dispatchParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iCenterPosOffset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dispatchDirection <span style=color:#f92672>=</span> GetDispatchDirection(dispatchType, iCenterPosOffset);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dispatchOffset <span style=color:#f92672>=</span> GetDispatchOffset(dispatchType, dispatchIndex, dispatchParams, groupIndex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iGroupStartSS <span style=color:#f92672>=</span> iCenterPosSS <span style=color:#f92672>+</span> iCenterPosOffset <span style=color:#f92672>+</span> dispatchDirection <span style=color:#f92672>*</span> dispatchOffset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> toCenter <span style=color:#f92672>=</span> centerPosSS <span style=color:#f92672>-</span> (<span style=color:#66d9ef>float2</span>(iGroupStartSS) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absDir <span style=color:#f92672>=</span> abs(toCenter);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> signDir <span style=color:#f92672>=</span> sign(toCenter);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> xMajor <span style=color:#f92672>=</span> absDir.x <span style=color:#f92672>&gt;=</span> absDir.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absNDir <span style=color:#f92672>=</span> normalize(absDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> absToCenterStepRatio <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span>  absDir.y <span style=color:#f92672>/</span> absDir.x <span style=color:#f92672>:</span>  absDir.x <span style=color:#f92672>/</span> absDir.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> baseOffsetY <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#66d9ef>float</span>(id.y) <span style=color:#f92672>*</span> absToCenterStepRatio <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iOffset <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span> <span style=color:#66d9ef>int2</span>(id.y, baseOffsetY) <span style=color:#f92672>:</span> <span style=color:#66d9ef>int2</span>(baseOffsetY, id.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iPosSS <span style=color:#f92672>=</span> iGroupStartSS <span style=color:#f92672>+</span> iOffset <span style=color:#f92672>*</span> signDir;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (any(iPosSS <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>||</span> any(iPosSS <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>int2</span>(_TextureSize.xy))) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> posSS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(iPosSS) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> toPosSS <span style=color:#f92672>=</span> posSS <span style=color:#f92672>-</span> centerPosSS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absToPos <span style=color:#f92672>=</span> abs(toPosSS);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> absToPosStepRatio <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span> absToPos.y <span style=color:#f92672>/</span> absToPos.x <span style=color:#f92672>:</span>  absToPos.x <span style=color:#f92672>/</span> absToPos.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yIntersect <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#66d9ef>float</span>(id.y) <span style=color:#f92672>*</span> absToPosStepRatio <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yVal <span style=color:#f92672>=</span> baseOffsetY;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (yIntersect <span style=color:#f92672>!=</span> yVal) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rv1 <span style=color:#f92672>=</span> hash11(id.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> hsv2rgb_smooth(<span style=color:#66d9ef>float3</span>(rv1, <span style=color:#ae81ff>0.8f</span>, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_TargetTex[iPosSS] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>1</span>, THREAD_COUNT, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> NormalDispatch(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rv1 <span style=color:#f92672>=</span> hash11(THREAD_COUNT <span style=color:#f92672>*</span> groupID.x <span style=color:#f92672>+</span> groupID.y <span style=color:#f92672>+</span> THREAD_COUNT <span style=color:#f92672>*</span> groupID.z);   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> hsv2rgb_smooth(<span style=color:#66d9ef>float3</span>(rv1, <span style=color:#ae81ff>0.8f</span>, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_TargetTex[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ClearMain(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> SV_DISPATCHTHREADID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _RW_TargetTex[id.xy] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=radialdispatchrenderpasscs>RadialDispatchRenderPass.cs<a hidden class=anchor aria-hidden=true href=#radialdispatchrenderpasscs>#</a></h3><p>å¾ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è®¡ç®—ä¸­å¿ƒç‚¹æœ€è¿‘çš„æ•´æ•°æ—¶ï¼Œä¸èƒ½ç®€å•åœ°ä½¿ç”¨<code>int2 iCenterPosSS = new int2(centerPosSS + 0.5f);</code>æ¥è®¡ç®—ï¼Œå› ä¸º<code>centerPosSS</code>çš„åˆ†é‡å¾ˆå¯èƒ½ä¼šå°äº0ï¼Œè½¬æ¢ä¸ºintæ—¶ä¼šå˜æˆæœ€æ¥è¿‘é›¶çš„æ•´æ•°ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Mathematics;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RadialDispatchRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Transform centerTrans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Radial Dispatch Render Pass&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ScriptableRenderer renderer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RadialDispatchRendererFeature.RadialDispatchSettings settings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RadialDispatch radialDispatch;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> radialDispatchTextureName = <span style=color:#e6db74>&#34;_RadialDispatchTexture&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> radialDispatchTextureID = Shader.PropertyToID(radialDispatchTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RTHandle radialDispatchTextureHandle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> THREAD_COUNT = <span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> DISPATCH_DATA_COUNT = <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> DISPATCH_DATA_STRIDE = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> DISPATCH_DATA_SIZE = DISPATCH_DATA_COUNT * DISPATCH_DATA_STRIDE;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] dispatchData = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[DISPATCH_DATA_SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> RadialDispatchRenderPass(RadialDispatchRendererFeature.RadialDispatchSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            computeShader = settings.computeShader;
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(ScriptableRenderer renderer, RadialDispatch RadialDispatch)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.renderer = renderer;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.radialDispatch = RadialDispatch;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (computeBuffer == <span style=color:#66d9ef>null</span> || computeBuffer.count != count || computeBuffer.stride != stride)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    computeBuffer.Release();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnCameraSetup(CommandBuffer cmd, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            EnsureComputeBuffer(DISPATCH_DATA_COUNT, DISPATCH_DATA_STRIDE * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = renderingData.cameraData.cameraTargetDescriptor;
</span></span><span style=display:flex><span>            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(desc.width, desc.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            desc.useMipMap = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            RenderingUtils.ReAllocateIfNeeded(<span style=color:#66d9ef>ref</span> radialDispatchTextureHandle, desc, FilterMode.Point, TextureWrapMode.Clamp, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, radialDispatchTextureName); ;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParameter(Vector2Int textureSize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(textureSize.x, textureSize.y, <span style=color:#ae81ff>1.0f</span> / textureSize.x, <span style=color:#ae81ff>1.0f</span> / textureSize.y);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DispatchParams</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> int2 offset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> stride;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> xMajor;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> DispatchParams(int2 offset, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride, <span style=color:#66d9ef>int</span> xMajor)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.offset = offset; <span style=color:#66d9ef>this</span>.count = count; <span style=color:#66d9ef>this</span>.stride = stride; <span style=color:#66d9ef>this</span>.xMajor = xMajor;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GetDispatchParams(int2 coord, int2 offset, <span style=color:#66d9ef>out</span> DispatchParams dp1, <span style=color:#66d9ef>out</span> DispatchParams dp2)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> colIndexOffset = math.max(offset.x, offset.y) / THREAD_COUNT;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> yIndexOffset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> minVal, maxVal, xMajor;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (coord.x &gt;= coord.y)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                minVal = coord.y;
</span></span><span style=display:flex><span>                maxVal = coord.x;
</span></span><span style=display:flex><span>                yIndexOffset = offset.y;
</span></span><span style=display:flex><span>                xMajor = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                minVal = coord.x;
</span></span><span style=display:flex><span>                maxVal = coord.y;
</span></span><span style=display:flex><span>                yIndexOffset = offset.x;
</span></span><span style=display:flex><span>                xMajor = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> stride1 = math.max(<span style=color:#ae81ff>0</span>, (minVal + colIndexOffset + <span style=color:#ae81ff>1</span>) * THREAD_COUNT - <span style=color:#ae81ff>1</span> - offset.x - offset.y);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count1 = stride1 * math.max(<span style=color:#ae81ff>0</span>, minVal - colIndexOffset);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> stride2 = math.max(<span style=color:#ae81ff>0</span>, (minVal + <span style=color:#ae81ff>1</span>) * THREAD_COUNT - yIndexOffset);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count2 = stride2 * math.max(<span style=color:#ae81ff>0</span>, maxVal - math.max(minVal, colIndexOffset));
</span></span><span style=display:flex><span>            dp1 = <span style=color:#66d9ef>new</span> DispatchParams(offset, count1, stride1, xMajor);
</span></span><span style=display:flex><span>            dp2 = <span style=color:#66d9ef>new</span> DispatchParams(offset, count2, stride2, xMajor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GetDispatchList(int2 iCenterPosSS, int2 textureSize, <span style=color:#66d9ef>out</span> DispatchParams[] dispatchList)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            int2 offsetLB = math.max(<span style=color:#ae81ff>0</span>, iCenterPosSS - textureSize);
</span></span><span style=display:flex><span>            int2 offsetRT = math.max(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>new</span> int2(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) - iCenterPosSS);
</span></span><span style=display:flex><span>            int2 coordLB = (iCenterPosSS + THREAD_COUNT - <span style=color:#ae81ff>1</span>) / THREAD_COUNT;
</span></span><span style=display:flex><span>            int2 coordRT = (textureSize - iCenterPosSS + THREAD_COUNT - <span style=color:#ae81ff>1</span>) / THREAD_COUNT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            int2 coordRB = <span style=color:#66d9ef>new</span> int2(coordRT.x, coordLB.y);
</span></span><span style=display:flex><span>            int2 coordLT = <span style=color:#66d9ef>new</span> int2(coordLB.x, coordRT.y);
</span></span><span style=display:flex><span>            int2 offsetRB = <span style=color:#66d9ef>new</span> int2(offsetRT.x, offsetLB.y);
</span></span><span style=display:flex><span>            int2 offsetLT = <span style=color:#66d9ef>new</span> int2(offsetLB.x, offsetRT.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            GetDispatchParams(coordLB, offsetLB, <span style=color:#66d9ef>out</span> DispatchParams dpLB1, <span style=color:#66d9ef>out</span> DispatchParams dpLB2);
</span></span><span style=display:flex><span>            GetDispatchParams(coordLT, offsetLT, <span style=color:#66d9ef>out</span> DispatchParams dpLT1, <span style=color:#66d9ef>out</span> DispatchParams dpLT2);
</span></span><span style=display:flex><span>            GetDispatchParams(coordRB, offsetRB, <span style=color:#66d9ef>out</span> DispatchParams dpRB1, <span style=color:#66d9ef>out</span> DispatchParams dpRB2);
</span></span><span style=display:flex><span>            GetDispatchParams(coordRT, offsetRT, <span style=color:#66d9ef>out</span> DispatchParams dpRT1, <span style=color:#66d9ef>out</span> DispatchParams dpRT2);
</span></span><span style=display:flex><span>            dispatchList = <span style=color:#66d9ef>new</span> DispatchParams[] { dpLB1, dpLB2, dpLT1, dpLT2, dpRB1, dpRB2, dpRT1, dpRT2 };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> SetDispatchData(DispatchParams[] dispatchList)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (dispatchList.Length != <span style=color:#ae81ff>8</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> totalCount = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>8</span>; ++i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> param = dispatchList[i];
</span></span><span style=display:flex><span>                totalCount += param.count;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>0</span>] = param.offset.x;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>1</span>] = param.offset.y;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>2</span>] = totalCount;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>3</span>] = param.stride;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>4</span>] = param.xMajor;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            computeBuffer.SetData(dispatchData);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> totalCount;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = renderingData.commandBuffer;
</span></span><span style=display:flex><span>            UniversalRenderer universalRenderer = renderer <span style=color:#66d9ef>as</span> UniversalRenderer;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (universalRenderer == <span style=color:#66d9ef>null</span> || computeShader == <span style=color:#66d9ef>null</span> || centerTrans == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                float4 centerPosWS = <span style=color:#66d9ef>new</span> float4(centerTrans.position, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>                float4x4 viewMat = renderingData.cameraData.GetViewMatrix();
</span></span><span style=display:flex><span>                float4x4 projMat = renderingData.cameraData.GetGPUProjectionMatrix();
</span></span><span style=display:flex><span>                float4x4 vpMat = math.mul(projMat, viewMat);
</span></span><span style=display:flex><span>                float4 centerPosCS = math.mul(vpMat, centerPosWS);
</span></span><span style=display:flex><span>                centerPosCS.xyz /= math.abs(centerPosCS.w);
</span></span><span style=display:flex><span>                centerPosCS.y = -centerPosCS.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                float2 centerPosSS = (centerPosCS.xy * <span style=color:#ae81ff>0.5f</span> + <span style=color:#ae81ff>0.5f</span>) * <span style=color:#66d9ef>new</span> float2(textureSize.x, textureSize.y);
</span></span><span style=display:flex><span>                int2 iCenterPosSS = <span style=color:#66d9ef>new</span> int2(math.floor(centerPosSS + <span style=color:#ae81ff>0.5f</span>));
</span></span><span style=display:flex><span>                int2 ts = <span style=color:#66d9ef>new</span> int2(textureSize.x, textureSize.y);
</span></span><span style=display:flex><span>                GetDispatchList(iCenterPosSS, ts, <span style=color:#66d9ef>out</span> DispatchParams[] dispatchList);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> totalDispatchCount = SetDispatchData(dispatchList);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> backBuffer = universalRenderer.m_ColorBufferSystem.GetBackBuffer(cmd);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> clearID = computeShader.FindKernel(<span style=color:#e6db74>&#34;ClearMain&#34;</span>);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, clearID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, radialDispatchTextureHandle);
</span></span><span style=display:flex><span>                computeShader.GetKernelThreadGroupSizes(clearID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z1);
</span></span><span style=display:flex><span>                cmd.DispatchCompute(computeShader, clearID,
</span></span><span style=display:flex><span>                                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x1),
</span></span><span style=display:flex><span>                                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y1),
</span></span><span style=display:flex><span>                                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (radialDispatch.radialDispatch.<span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RadialDispatch&#34;</span>);
</span></span><span style=display:flex><span>                    cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_ColorTex&#34;</span>, backBuffer);
</span></span><span style=display:flex><span>                    cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, radialDispatchTextureHandle);
</span></span><span style=display:flex><span>                    cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_CenterPosSS&#34;</span>, <span style=color:#66d9ef>new</span> float4(centerPosSS, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>                    cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSizeParameter(textureSize));
</span></span><span style=display:flex><span>                    cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_DispatchData&#34;</span>, computeBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                    cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                                         Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)totalDispatchCount / x),
</span></span><span style=display:flex><span>                                         <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                                         <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;NormalDispatch&#34;</span>);
</span></span><span style=display:flex><span>                    cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_ColorTex&#34;</span>, backBuffer);
</span></span><span style=display:flex><span>                    cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, radialDispatchTextureHandle);
</span></span><span style=display:flex><span>                    cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_CenterPosSS&#34;</span>, <span style=color:#66d9ef>new</span> float4(centerPosSS, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>                    cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSizeParameter(textureSize));
</span></span><span style=display:flex><span>                    cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_DispatchData&#34;</span>, computeBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                    cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                                         Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.x / x),
</span></span><span style=display:flex><span>                                         Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)textureSize.y / y),
</span></span><span style=display:flex><span>                                         <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                cmd.Blit(radialDispatchTextureHandle, backBuffer);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            radialDispatchTextureHandle?.Release();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                computeBuffer.Release();
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=radialdispatchrendererfeaturecs>RadialDispatchRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#radialdispatchrendererfeaturecs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RadialDispatchRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RadialDispatchSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> RadialDispatchSettings settings = <span style=color:#66d9ef>new</span> RadialDispatchSettings();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RadialDispatchRenderPass radialDispatchRenderPass;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            radialDispatchRenderPass = <span style=color:#66d9ef>new</span> RadialDispatchRenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RadialDispatch rd = VolumeManager.instance.stack.GetComponent&lt;RadialDispatch&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rd.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                radialDispatchRenderPass.Setup(renderer, rd);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(radialDispatchRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            radialDispatchRenderPass?.Dispose();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>base</span>.Dispose(disposing);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=radialdispatchcs>RadialDispatch.cs<a hidden class=anchor aria-hidden=true href=#radialdispatchcs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Radial Dispatch&#34;, typeof(UniversalRenderPipeline))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RadialDispatch</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter radialDispatch = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible() =&gt; <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=radialdispatchcentercs>RadialDispatchCenter.cs<a hidden class=anchor aria-hidden=true href=#radialdispatchcentercs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[ExecuteAlways]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RadialDispatchCenter</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> RadialDispatchCenter Instance { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Instance = <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>            UnityEngine.Rendering.Universal.RadialDispatchRenderPass.centerTrans = <span style=color:#66d9ef>this</span>.transform;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.LogError(<span style=color:#e6db74>&#34;Only one instance of RadialDispatchCenter is allowed to exist at the same time.&#34;</span>);
</span></span><span style=display:flex><span>            enabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance == <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Instance = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            UnityEngine.Rendering.Universal.RadialDispatchRenderPass.centerTrans = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance == <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Instance = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            UnityEngine.Rendering.Universal.RadialDispatchRenderPass.centerTrans = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>åˆæ˜¯å¤´æ™•ç›®çœ©çš„å–æ¨¡ã€å–ä½™ã€åŠ ä¸€ã€å‡ä¸€ï¼Œè€Œä¸”æ˜¯æéš¾debugçš„ä¸è§„åˆ™Thread Groupå’Œåƒç´ å¯¹åº”çš„æ–¹å¼ï¼Œå¥½å‡ æ¬¡å¯¹ç€å±å¹•ä¸Šé»‘è‰²çš„åŒºåŸŸå‘å‘†ï¼Œä½†æœ€ç»ˆè¿˜æ˜¯è‰°éš¾çš„åšäº†å‡ºæ¥ã€‚ä½†æ˜¯æœ€ç»ˆçš„ä»£ç å†™çš„å¾ˆæŠ½è±¡ï¼Œå°±åƒæˆ‘æ²¡æœ‰æ€ä¹ˆçœ‹Bend Studioæä¾›çš„å‚è€ƒä»£ç ä¸€æ ·ï¼Œè¯»è€…ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ä¹Ÿä¸ä¼šæ€ä¹ˆçœ‹æˆ‘å†™çš„ä»£ç å§ã€‚ã€‚ã€‚</p><p>éå¸¸æ„Ÿè°¢Unityçš„Mathematicsè¿™ä¸ªåŒ…ï¼Œè¿™ä¸ªåŒ…æå¤§åœ°å‡å°‘äº†æˆ‘å°†åŒæ ·çš„ä»£ç å¤åˆ¶åˆ°C#ä¸­debugçš„å·¥ä½œé‡ã€‚ä½†æ„¿æ²¡æœ‰ä»€ä¹ˆæ²¡æŸ¥å‡ºæ¥çš„bugï¼Œæ˜å¤©åº”è¯¥èƒ½å†™ä¸€ä¸ªå¾„å‘æ¨¡ç³Šçš„æ–‡ç« äº†ï¼Œä¹‹åå°±æ˜¯æ¥è§¦é˜´å½±äº†ï¼Œåœ¨ä¹‹åå¤§æ¦‚å°±èƒ½åˆ°è‰åœºçš„æ¸²æŸ“äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=next href=https://zznewclear13.github.io/posts/use-hex-tiling-for-terrain-texture-blending/><span class=title>Next Â»</span><br><span>åœ¨åœ°å½¢è´´å›¾æ··åˆæ—¶ä½¿ç”¨å…­è¾¹å½¢å¹³é“º</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>