<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº | ZZNEWCLEAR13</title>
<meta name=keywords content="Compute Shader,Signed Distance Field,Jump Flooding Algorithm"><meta name=description content="ä½¿ç”¨Jump Flooding Algorithmæ¥å¯¹ä¸€å¼ å›¾ç‰‡è®¡ç®—æœ‰å‘è·ç¦»åœº."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº"><meta property="og:description" content="ä½¿ç”¨Jump Flooding Algorithmæ¥å¯¹ä¸€å¼ å›¾ç‰‡è®¡ç®—æœ‰å‘è·ç¦»åœº."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/"><meta property="og:image" content="https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/posts/images/SignedDistanceField.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-21T19:00:00+08:00"><meta property="article:modified_time" content="2021-06-21T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/posts/images/SignedDistanceField.jpg"><meta name=twitter:title content="ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº"><meta name=twitter:description content="ä½¿ç”¨Jump Flooding Algorithmæ¥å¯¹ä¸€å¼ å›¾ç‰‡è®¡ç®—æœ‰å‘è·ç¦»åœº."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº","item":"https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº","name":"ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº","description":"ä½¿ç”¨Jump Flooding Algorithmæ¥å¯¹ä¸€å¼ å›¾ç‰‡è®¡ç®—æœ‰å‘è·ç¦»åœº.","keywords":["Compute Shader","Signed Distance Field","Jump Flooding Algorithm"],"articleBody":"ä»€ä¹ˆæ˜¯æœ‰å‘è·ç¦»åœºä»¥åŠå®ƒèƒ½ç”¨æ¥å¹²ä»€ä¹ˆ æœ‰å‘è·ç¦»åœºè®°å½•çš„æ˜¯ä»ä¸€ä¸ªç‚¹åˆ°é›†åˆè¾¹ç•Œçš„çš„è·ç¦»å€¼ï¼Œå…¶å€¼çš„æ­£è´Ÿå¯¹åº”è¯¥ç‚¹åœ¨é›†åˆå¤–éƒ¨æˆ–å†…éƒ¨ã€‚æœ‰å‘è·ç¦»åœºæœ‰å¾ˆå¹¿çš„åº”ç”¨èŒƒå›´å¯ä»¥ç”¨æ¥ç®€å•çš„ç”ŸæˆVoronoiå›¾å½¢ï¼Œå¯ä»¥ç”¨æ¥åšå…¨å±€å…‰ç…§çš„è®¡ç®—ï¼Œå¯ä»¥ç”¨æ¥åšä¸¤ä¸ªå½¢çŠ¶çš„å¹³æ»‘çš„å˜å½¢ï¼Œå¯ä»¥ç”¨æ¥åšé«˜æ¸…æ™°åº¦çš„å­—ä½“ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥åšRay Marchï¼ˆè™½ç„¶æˆ‘è®¤ä¸ºä¸å¦‚ç›´æ¥å…‰çº¿è¿½è¸ªæ±‚äº¤æ¥çš„æ•ˆç‡é«˜ï¼‰ã€‚åƒåŸç¥å°±ä½¿ç”¨äº†SDFçš„æ–¹æ³•ï¼Œç”Ÿæˆäº†è§’è‰²è„¸éƒ¨çš„é˜´å½±å›¾ï¼Œä»è€Œè®©è§’è‰²è„¸éƒ¨çš„é˜´å½±èƒ½è‡ªç„¶çš„å˜åŒ–ã€‚\né‚£ä¹ˆä»€ä¹ˆåˆæ˜¯Jump Flooding Algorithmå‘¢ Jump Flooding Algorithmæ˜¯è£å›½æ ‹åœ¨ä»–çš„åšå£«è®ºæ–‡Jump Flooding Algorithm On Graphics Hardware And Its Applicationsæå‡ºçš„ä¸€ç§åœ¨GPUä¸Šè¿è¡Œçš„èƒ½å¤Ÿå¿«é€Ÿä¼ æ’­æŸä¸ªåƒç´ çš„ä¿¡æ¯åˆ°å…¶ä»–åƒç´ çš„ç®—æ³•ã€‚\næ™®é€šçš„Floodingç®—æ³•åœ¨ä¸€æ¬¡è¿è¡Œä¸­ï¼Œå›ºå®šå‘ç›¸é‚»çš„ä¸€ä¸ªåƒç´ çš„åƒç´ ä¼ æ’­ä¿¡æ¯ï¼Œè€ŒJump Floodingåˆ™æ˜¯æŒ‰ç…§2çš„å¹‚æ¬¡é€’å¢æˆ–æ˜¯é€’å‡æ¥ä¼ æ’­ä¿¡æ¯ã€‚è¿™å’Œä¹‹å‰æåˆ°çš„å¹¶è¡Œè®¡ç®—â€”â€”Reductionçš„æƒ³æ³•å·®ä¸å¤šã€‚ä¸‹å›¾æ¼”ç¤ºäº†æ™®é€šçš„Floodingå’ŒJump Floodingçš„è¿‡ç¨‹ï¼š ä½¿ç”¨JFAè®¡ç®—ä¸€å¼ 2Då›¾ç‰‡å¯¹åº”çš„SDFè´´å›¾ é¦–å…ˆåœ¨Unityä¸­åˆ›å»ºJumpFlooding.cs, JFAComputeShader.compute, å’ŒJFAVisualize.shaderï¼Œåˆ†åˆ«ç”¨æ¥æ‰§è¡ŒCompute Shaderï¼Œä½¿ç”¨JFAç®—æ³•è®¡ç®—SDFå’Œå¯è§†åŒ–JFAç®—æ³•çš„ç»“æœã€‚\nè¿™é‡Œä½¿ç”¨ä¸€å¼ RGBé€šé“ä¸ºç°è‰²ï¼ŒAlphaé€šé“å†™ç€â€œJFAâ€çš„è´´å›¾ä½œä¸ºæˆ‘ä»¬2Då›¾ç‰‡çš„è¾“å…¥ã€‚ æ•´ä½“æ€è·¯å’Œéœ€è¦æ³¨æ„çš„äº‹é¡¹ å…ˆä»ç®€å•å®ç°åŠŸèƒ½ä¸Šæ¥è€ƒè™‘ï¼Œæš‚æ—¶å¿½ç•¥æ‰æŠ—é”¯é½¿çš„éœ€æ±‚ï¼Œç›´æ¥å¯¹Alphaé€šé“çš„å€¼æŒ‰ç…§0.5æ¥åˆ’åˆ†å‡ºå›¾å½¢çš„å†…éƒ¨å’Œå¤–éƒ¨ï¼Œå¤§äºç­‰äº0.5ä¸ºå¤–éƒ¨ï¼Œå°äº0.5ä¸ºå†…éƒ¨ã€‚ SDFéœ€è¦è¦è®¡ç®—è·ç¦»ï¼Œè¿™é‡Œä½¿ç”¨åƒç´ ç‚¹ä¸­å¿ƒåˆ°å¦ä¸€ä¸ªåƒç´ ç‚¹ä¸­å¿ƒçš„è·ç¦»ï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨åƒç´ ç‚¹å·¦ä¸‹è§’åˆ°å¦ä¸€ä¸ªåƒç´ ç‚¹å·¦ä¸‹è§’çš„è·ç¦»ï¼Œä¸è¿‡ä¸ºäº†æ˜ç¡®èµ·è§ï¼Œè¿˜æ˜¯åŠ ä¸Šè¿™åŠä¸ªåƒç´ çš„åç§»æ¯”è¾ƒå¥½ï¼‰ã€‚è·ç¦»å¯ä»¥ç”¨uvçš„å¤§å°æ¥è¡¨ç¤ºï¼Œä¹Ÿå¯ä»¥ç”¨åƒç´ æ•°é‡æ¥è¡¨ç¤ºï¼Œé’ˆå¯¹å›¾åƒé•¿å®½ä¸åŒçš„æƒ…å†µï¼Œè¿™é‡Œä»¥ä¸€ä¸ªåƒç´ å®½åº¦ä¸º1æ¥è¡¨ç¤ºä¸¤ä¸ªåƒç´ ç‚¹çš„è·ç¦»ã€‚åœ¨æœ€åé‡‡æ ·JFAçš„Render Textureçš„æ—¶å€™ï¼Œä¹Ÿè¦æ³¨æ„ä½¿ç”¨sampler_PointClampæ¥è¿›è¡Œé‡‡æ ·ï¼Œè®¡ç®—è·ç¦»æ—¶ä¹Ÿä¸èƒ½ä»…ä»…ä½¿ç”¨uvæ¥è®¡ç®—ï¼Œè€Œæ˜¯è¦ä½¿ç”¨åƒç´ ä¸­é—´çš„ç‚¹çš„ä½ç½®æ¥è¿›è¡Œè®¡ç®—ã€‚ æ™®é€šçš„JFAç®—æ³•ä¼šä½¿ç”¨åˆ°Render Textureçš„ä¸¤ä¸ªé€šé“ï¼Œæ¥æ ‡è®°åƒç´ å¯¹åº”çš„æœ€è¿‘è¾¹ç•Œåƒç´ çš„UVï¼Œç”±äºè®°å½•çš„æ˜¯UVçš„æ•°å€¼è€Œä¸æ˜¯é¢œè‰²ä¿¡æ¯ï¼ŒRender Textureè¦å‚¨å­˜åœ¨çº¿æ€§ç©ºé—´ä¸­ã€‚ç”±äºè¦åŒæ—¶è®¡ç®—å†…éƒ¨å’Œå¤–éƒ¨çš„ç‚¹åˆ°è¾¹ç•Œçš„æœ‰å‘è·ç¦»ï¼ŒJFAç®—æ³•ä¼šä½¿ç”¨åˆ°Render Textureå…¨éƒ¨çš„å››ä¸ªé€šé“ï¼Œè¿™é‡Œä½¿ç”¨å‰ä¸¤ä½è®°å½•ä½äºå†…éƒ¨çš„åƒç´ å¯¹åº”çš„è¾¹ç•Œåƒç´ çš„åæ ‡ï¼Œç”¨åä¸¤ä½è®°å½•ä½äºå¤–éƒ¨çš„åƒç´ å¯¹åº”çš„è¾¹ç•Œåƒç´ çš„åæ ‡ï¼Œå³å¯¹äºå†…éƒ¨çš„åƒç´ (nearestUV.x, nearestUV.y, Z, W)ï¼Œå¯¹äºå¤–éƒ¨çš„åƒç´ (X, Y, nearestUV.x, nearestUV.y)ï¼ŒXYZWåˆ™å¯ä»¥ç”¨æ¥è¡¨ç¤ºè¯¥ç‚¹ä¸ºæœ€åˆå§‹çš„å†…å¤–éƒ¨çš„ç‚¹ã€åŒ…å«JFAä¼ é€’çš„ä¿¡æ¯çš„ç‚¹ã€‚ä¸åŒ…å«JFAä¼ é€’çš„ä¿¡æ¯çš„ç‚¹ã€‚ åœ¨JFAè®¡ç®—ä¹‹å‰ï¼Œéœ€è¦å…ˆè®©è´´å›¾å¯¹åº”çš„ç‚¹åŒ…å«JFAä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºå†…éƒ¨çš„ç‚¹åˆå§‹åŒ–ä¸º(UV.x, UV.y, -1, -1)ï¼Œå¯¹äºå¤–éƒ¨çš„ç‚¹åˆå§‹åŒ–ä¸º(-1, -1, UV.x, UV.y)ã€‚è¿™è¦æ±‚æˆ‘ä»¬ä½¿ç”¨çš„Render Textureæ ¼å¼ä¸ºè‡³å°‘R16G16B16A16 SFloatã€‚ åœ¨JFAçš„è®¡ç®—ä¸­ï¼Œä»¥å¤–éƒ¨çš„åƒç´ ç‚¹ä¸ºä¾‹ï¼Œæ‰€è¿›è¡Œçš„æ“ä½œæ˜¯ï¼šé‡‡æ ·ä¸Šæ¬¡ç»è¿‡JFAæ“ä½œçš„Render Textureï¼›æ ¹æ®XYé€šé“åˆ¤æ–­è¯¥ç‚¹åœ¨è¾¹ç•Œçš„å†…éƒ¨è¿˜æ˜¯å¤–éƒ¨ï¼Œå†…éƒ¨å°±è·³è¿‡ï¼›å¯¹å¤–éƒ¨çš„åƒç´ ç‚¹ï¼Œé€šè¿‡XYé€šé“åˆ¤æ–­æ˜¯å¦å·²åŒ…å«JFAçš„ä¿¡æ¯ï¼Œå¦‚æœåŒ…å«ï¼Œæ ¹æ®ZWé€šé“è®¡ç®—å‡ºå½“å‰ç‚¹åˆ°å…¶åŒ…å«çš„æœ€è¿‘åƒç´ çš„è·ç¦»ï¼Œå¦‚æœä¸åŒ…å«ï¼Œå°†è¿™ä¸ªè·ç¦»è®¾ç½®ä¸ºä¸€ä¸ªæå¤§çš„å¸¸æ•°ï¼›åˆ†åˆ«é‡‡æ ·è·ç¦»åƒç´ ç‚¹2çš„å¹‚æ¬¡çš„è·ç¦»çš„å…«ä¸ªåƒç´ ï¼Œåˆ¤æ–­è¿™äº›åƒç´ æ˜¯å¦å·²åŒ…å«JFAçš„ä¿¡æ¯ï¼Œå¦‚æœä¸åŒ…å«ï¼Œé‡‡æ ·ä¸‹ä¸€ä¸ªç‚¹ï¼Œå¦‚æœåŒ…å«ï¼Œæ ¹æ®è¿™äº›åƒç´ çš„ZWé€šé“è®¡ç®—å‡ºå½“å‰ç‚¹åˆ°è¿™äº›åƒç´ åŒ…å«çš„æœ€è¿‘åƒç´ çš„è·ç¦»ï¼Œå¹¶å’Œä¸Šä¸€æ­¥ç®—å‡ºçš„è·ç¦»è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå°äºä¸Šä¸€æ­¥ç®—å‡ºçš„è·ç¦»ï¼Œåˆ™è¯æ˜è¯¥åƒç´ å¯¹åº”çš„æœ€è¿‘åƒç´ ä¸ºå‘¨å›´ç‚¹åŒ…å«çš„åƒç´ ï¼Œæ›´æ–°è¯¥åƒç´ çš„ZWé€šé“ï¼Œå¹¶ä¸”å°†XYé€šé“æ ‡è®°æˆå·²åŒ…å«JFAçš„ä¿¡æ¯ã€‚ é‡‡æ ·å‘¨è¾¹åƒç´ çš„æ­¥é•¿ä»2Dè´´å›¾çš„é•¿å®½çš„ä¸€åŠå‘ä¸Šå–æ•´å¼€å§‹ï¼Œæ¯æ¬¡JFAéƒ½å–ä¸Šä¸€æ­¥æ­¥é•¿çš„ä¸€åŠå‘ä¸Šå–æ•´ä½œä¸ºæ–°çš„æ­¥é•¿ï¼Œä¸€ç›´è¿›è¡Œåˆ°æ­¥é•¿ä¸º(1, 1)ï¼Œè¿›è¡Œæœ€åä¸€æ¬¡JFAè®¡ç®—ã€‚ ç»è¿‡JFAè®¡ç®—ä¹‹åï¼Œè¿˜éœ€è¦å°†åˆ†åˆ«è¡¨ç¤ºå†…éƒ¨çš„ç‚¹å¯¹åº”çš„æœ€è¿‘åƒç´ çš„UVå’Œå¤–éƒ¨çš„ç‚¹å¯¹åº”çš„æœ€è¿‘åƒç´ çš„UVç»“åˆèµ·æ¥ï¼Œå‚¨å­˜ä¸ºä¸€å¼ è´´å›¾ï¼Œå¯ä»¥æ˜¯(nearestUV.x, nearestUV.y, 0, inside?1:0)ï¼Œä¹Ÿå¯ä»¥æ˜¯(distance * inside?-1:1, 1)ã€‚ åº”è¯¥æ˜¯è·Ÿå½“å‰å¹³å°æœ‰å…³ï¼Œæœ‰æ—¶å€™ä¼šå‡ºç°è´´å›¾ä¸Šä¸‹é¢ å€’çš„æƒ…å†µï¼Œå¯ä»¥ç”¨UNITY_UV_STARTS_AT_TOPæ¥ååŠ©è§£å†³ï¼Œä¸è¿‡compute shaderå¯èƒ½éœ€è¦è‡ªå·±å¯ç”¨è¿™ä¸ªå®ï¼Œè¿™é‡Œå°±ç›´æ¥ç¡¬å†™åœ¨shaderé‡Œï¼Œä¸åšå¹³å°åˆ¤æ–­äº†ã€‚ JFAComputeShader.compute æ ¹æ®ä¸Šé¢çš„æ•´ä½“æ€è·¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸‰ä¸ªkernelï¼Œä¸€ä¸ªç”¨æ¥åˆå§‹åŒ–ï¼Œä¸€ä¸ªåšJFAè®¡ç®—ï¼Œæœ€åä¸€ä¸ªç”¨æ¥åˆæˆæœ€åçš„è´´å›¾ã€‚Compute Shaderçš„å…³é”®å­—éœ€è¦Unity 2020ä»¥ä¸Šï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“å…·ä½“å“ªä¸ªç‰ˆæœ¬ï¼‰æ‰èƒ½æœ‰ï¼Œè¿™é‡Œå°±æš‚æ—¶ç”¨UNITY_2020_2_OR_NEWERè¿™ä¸ªå®æ¥å±è”½äº†ã€‚\n#pragma kernel CopyUVMain #define PIXEL_OFFSET 0.5 Texture2D\u003cfloat4\u003e _InputTexture; RWTexture2D\u003cfloat4\u003e _OutputTexture; float4 _TextureSize; float _Channel; [numthreads(8, 8, 1)] void CopyUVMain(uint3 id : SV_DispatchThreadID) { float2 samplePosition = id.xy + PIXEL_OFFSET; if (any(samplePosition \u003e= _TextureSize.xy)) return; float4 inputTexture = _InputTexture.Load(float3(id.xy, 0)); float determin = 0; switch ((uint)_Channel) { case 0: determin = inputTexture.r; break; case 1: determin = inputTexture.g; break; case 2: determin = inputTexture.b; break; case 3: determin = inputTexture.a; break; default: break; } if (determin \u003e= 0.5) { _OutputTexture[id.xy] = float4(-1, -1, samplePosition.x * _TextureSize.z, samplePosition.y * _TextureSize.w); } else { _OutputTexture[id.xy] = float4(samplePosition.x * _TextureSize.z, samplePosition.y * _TextureSize.w, -1, -1); } } #pragma kernel JFAMain float2 _Step; static int2 directions[] = { int2(-1, -1), int2(-1, 0), int2(-1, 1), int2(0, -1), int2(0, 1), int2(1, -1), int2(1, 0), int2(1, 1) }; float4 JFAOutside(float4 inputTex, float2 idxy) { float4 outputTex = inputTex; //cull inside if (inputTex.x != -1) { float2 nearestUV = inputTex.zw; float minDistance = 1e16; //if had min distance in previous flooding if (inputTex.z != -1) { minDistance = length(idxy + PIXEL_OFFSET - nearestUV * _TextureSize.xy); } bool hasMin = false; for (uint i = 0; i \u003c 8; i++) { uint2 sampleOffset = idxy + directions[i] * _Step; sampleOffset = clamp(sampleOffset, 0, _TextureSize.xy - 1); float4 offsetTexture = _InputTexture.Load(float3(sampleOffset, 0)); //if had min distance in previous flooding if (offsetTexture.z != -1) { float2 tempUV = offsetTexture.zw; float tempDistance = length(idxy + PIXEL_OFFSET - tempUV * _TextureSize.xy); if (tempDistance \u003c minDistance) { hasMin = true; minDistance = tempDistance; nearestUV = tempUV; } } } if (hasMin) { outputTex = float4(inputTex.xy, nearestUV); } } return outputTex; } float4 JFAInside(float4 inputTex, float2 idxy) { float4 outputTex = inputTex; //cull outside if (inputTex.z != -1) { float2 nearestUV = inputTex.xy; float minDistance = 1e16; //if had min distance in previous flooding if (inputTex.x != -1) { minDistance = length(idxy + PIXEL_OFFSET - nearestUV * _TextureSize.xy); } bool hasMin = false; for (uint i = 0; i \u003c 8; i++) { uint2 sampleOffset = idxy + directions[i] * _Step; sampleOffset = clamp(sampleOffset, 0, _TextureSize.xy - 1); float4 offsetTexture = _InputTexture.Load(float3(sampleOffset, 0)); //if had min distance in previous flooding if (offsetTexture.x != -1) { float2 tempUV = offsetTexture.xy; float tempDistance = length(idxy + PIXEL_OFFSET - tempUV * _TextureSize.xy); if (tempDistance \u003c minDistance) { hasMin = true; minDistance = tempDistance; nearestUV = tempUV; } } } if (hasMin) { outputTex = float4(nearestUV, inputTex.zw); } } return outputTex; } [numthreads(8,8,1)] void JFAMain(uint3 id : SV_DispatchThreadID) { float2 samplePosition = id.xy + PIXEL_OFFSET; if (any(samplePosition \u003e= _TextureSize.xy)) return; float4 inputTexture = _InputTexture.Load(float3(id.xy, 0)); float4 outSide = JFAOutside(inputTexture, id.xy); _OutputTexture[id.xy] = JFAInside(outSide, id.xy); } #pragma kernel ComposeMain Texture2D\u003cfloat4\u003e _OriginalTexture; #if UNITY_2020_2_OR_NEWER #pragma multi_compile _USE_GRAYSCALE #else #define _USE_GRAYSCALE 0 #endif [numthreads(8, 8, 1)] void ComposeMain(uint3 id : SV_DispatchThreadID) { uint2 reverseY = id.xy; reverseY = uint2(id.x, _TextureSize.y - 1 - id.y); float4 inputTexture = _InputTexture.Load(float3(reverseY, 0)); float4 originalTexture = _OriginalTexture.Load(float3(reverseY, 0)); float determin = 0; switch ((uint)_Channel) { case 0: determin = originalTexture.r; break; case 1: determin = originalTexture.g; break; case 2: determin = originalTexture.b; break; case 3: determin = originalTexture.a; break; default: break; } #if _USE_GRAYSCALE float distance = 0; if (determin \u003e= 0.5) { distance = -length(reverseY + PIXEL_OFFSET - inputTexture.xy * _TextureSize.xy); _OutputTexture[id.xy] = float4(distance, distance, distance, 1); } else { distance = length(reverseY + PIXEL_OFFSET - inputTexture.zw * _TextureSize.xy); _OutputTexture[id.xy] = float4(distance, distance, distance, 0); } #else if (determin \u003e= 0.5) { _OutputTexture[id.xy] = float4(inputTexture.xy, 0, 1); } else { _OutputTexture[id.xy] = float4(inputTexture.zw, 0, 0); } #endif } JumpFlooding.cs C#è„šæœ¬æ²¡ä»€ä¹ˆç‰¹æ®Šçš„åœ°æ–¹äº†ï¼Œåªè¦å‡†å¤‡å¥½Render Textureå’Œå„ç±»å‚æ•°ï¼Œä¼ é€’ç»™Compute Shaderå°±å¥½äº†ã€‚ä¸ºäº†æ–¹ä¾¿å¯è§†åŒ–ï¼Œè¿™é‡Œä½¿ç”¨äº†MonoBehaviourçš„Coroutineï¼Œéœ€è¦ç‚¹å‡»playä¹‹ååœ¨ç‚¹å‡»è„šæœ¬é‡Œçš„\"Calculate SDF\"ã€‚è¿™é‡Œä¿å­˜çš„æ˜¯è®°å½•äº†å¯¹åº”çš„åƒç´ ç‚¹çš„UVçš„è´´å›¾ï¼Œè¿™æ ·å¯ä»¥ç”¨jpgæˆ–è€…pngæ¥ä¿å­˜ï¼Œå¦‚æœè¦ä¿å­˜è®°å½•äº†æœ‰å‘è·ç¦»çš„ç°åº¦è´´å›¾ï¼Œå°±éœ€è¦ä¿å­˜ä¸ºfloatç±»å‹çš„exræ ¼å¼äº†ã€‚\nusing System.Collections; using UnityEngine; using UnityEditor; public class JumpFlooding : MonoBehaviour { enum Channels { R, G, B, A } public Texture inputTexture; public ComputeShader computeShader; public float updateTime; public MeshRenderer meshRenderer; public bool useGrayScale = false; private RenderTexture[] renderTextures; private static void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } private static void EnsureRenderTexture(ref RenderTexture rt, RenderTextureDescriptor descriptor, string RTName) { if (rt != null \u0026\u0026 (rt.width != descriptor.width || rt.height != descriptor.height)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { RenderTextureDescriptor desc = descriptor; desc.depthBufferBits = 0; desc.msaaSamples = 1; rt = RenderTexture.GetTemporary(desc); rt.name = RTName; if (!rt.IsCreated()) rt.Create(); } } public static void EnsureRT(ref RenderTexture[] rts, RenderTextureDescriptor descriptor) { EnsureArray(ref rts, 2); EnsureRenderTexture(ref rts[0], descriptor, \"Froxel Tex One\"); EnsureRenderTexture(ref rts[1], descriptor, \"Froxel Tex Two\"); } public void Calculate() { StartCoroutine(CalculateCoroutine()); } public void CopyUV(Texture texture, RenderTexture renderTexture, uint channel) { int kernel = computeShader.FindKernel(\"CopyUVMain\"); computeShader.GetKernelThreadGroupSizes(kernel, out uint x, out uint y, out uint z); Vector3Int dispatchCounts = new Vector3Int(Mathf.CeilToInt((float)inputTexture.width / x), Mathf.CeilToInt((float)inputTexture.height / y), 1); computeShader.SetTexture(kernel, \"_InputTexture\", texture); computeShader.SetTexture(kernel, \"_OutputTexture\", renderTexture); computeShader.SetVector(\"_TextureSize\", new Vector4(texture.width, texture.height, 1.0f / texture.width, 1.0f / texture.height)); computeShader.SetFloat(\"_Channel\", (float)channel); computeShader.Dispatch(kernel, dispatchCounts.x, dispatchCounts.y, dispatchCounts.z); } public void JFA(RenderTexture one, RenderTexture two, Vector2Int step, bool reverse) { int kernel = computeShader.FindKernel(\"JFAMain\"); computeShader.GetKernelThreadGroupSizes(kernel, out uint x, out uint y, out uint z); Vector3Int dispatchCounts = new Vector3Int(Mathf.CeilToInt((float)inputTexture.width / x), Mathf.CeilToInt((float)inputTexture.height / y), 1); if (reverse) { computeShader.SetTexture(kernel, \"_InputTexture\", two); computeShader.SetTexture(kernel, \"_OutputTexture\", one); } else { computeShader.SetTexture(kernel, \"_InputTexture\", one); computeShader.SetTexture(kernel, \"_OutputTexture\", two); } computeShader.SetVector(\"_TextureSize\", new Vector4(inputTexture.width, inputTexture.height, 1.0f / inputTexture.width, 1.0f / inputTexture.height)); computeShader.SetVector(\"_Step\", (Vector2)step); computeShader.Dispatch(kernel, dispatchCounts.x, dispatchCounts.y, dispatchCounts.z); } public void Compose(RenderTexture one, RenderTexture two, Texture texture, uint channel, bool reverse) { int kernel = computeShader.FindKernel(\"ComposeMain\"); computeShader.GetKernelThreadGroupSizes(kernel, out uint x, out uint y, out uint z); Vector3Int dispatchCounts = new Vector3Int(Mathf.CeilToInt((float)inputTexture.width / x), Mathf.CeilToInt((float)inputTexture.height / y), 1); if (reverse) { computeShader.SetTexture(kernel, \"_InputTexture\", two); computeShader.SetTexture(kernel, \"_OutputTexture\", one); } else { computeShader.SetTexture(kernel, \"_InputTexture\", one); computeShader.SetTexture(kernel, \"_OutputTexture\", two); } computeShader.SetTexture(kernel, \"_OriginalTexture\", texture); computeShader.SetFloat(\"_Channel\", (float)channel); #if UNITY_2020_2_OR_NEWER if(useGrayScale) { computeShader.EnableKeyword(\"_USE_GRAYSCALE\"); } else { computeShader.DisableKeyword(\"_USE_GRAYSCALE\"); } #endif computeShader.Dispatch(kernel, dispatchCounts.x, dispatchCounts.y, dispatchCounts.z); } public void Visualize(RenderTexture one, RenderTexture two, bool reverse) { MaterialPropertyBlock mpb = new MaterialPropertyBlock(); mpb.SetTexture(\"_MainTex\", reverse ? two : one); meshRenderer.SetPropertyBlock(mpb); } static public void SaveToTexture(string name, RenderTexture renderTexture, bool alphaIsTransparency) { RenderTexture currentRT = RenderTexture.active; RenderTexture.active = renderTexture; Texture2D texture2D = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGBAFloat, false); texture2D.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0); RenderTexture.active = currentRT; System.IO.Directory.CreateDirectory(\"Assets/JumpFlooding/\"); byte[] bytes = texture2D.EncodeToEXR(); string path = \"Assets/JumpFlooding/\" + name + \".exr\"; System.IO.File.WriteAllBytes(path, bytes); TextureImporter importer = (TextureImporter)AssetImporter.GetAtPath(path); if (importer != null) { importer.alphaIsTransparency = alphaIsTransparency; importer.sRGBTexture = false; importer.mipmapEnabled = false; AssetDatabase.ImportAsset(path); } Debug.Log(\"Saved to \" + path); AssetDatabase.Refresh(); } IEnumerator CalculateCoroutine() { RenderTextureDescriptor desc = new RenderTextureDescriptor { width = inputTexture.width, height = inputTexture.height, volumeDepth = 1, msaaSamples = 1, graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat, enableRandomWrite = true, dimension = UnityEngine.Rendering.TextureDimension.Tex2D, sRGB = false }; EnsureRT(ref renderTextures, desc); RenderTexture rtOne = renderTextures[0]; RenderTexture rtTwo = renderTextures[1]; CopyUV(inputTexture, rtOne, (uint)Channels.A); yield return new WaitForSeconds(updateTime); Shader.DisableKeyword(\"RENDERTEXTURE_UPSIDE_DOWN\"); Vector2Int step = new Vector2Int((inputTexture.width + 1) \u003e\u003e 1, (inputTexture.height + 1) \u003e\u003e 1); bool reverse = false; do { Debug.Log(step); JFA(rtOne, rtTwo, step, reverse); reverse = !reverse; Visualize(rtOne, rtTwo, reverse); step = new Vector2Int((step.x + 1) \u003e\u003e 1, (step.y + 1) \u003e\u003e 1); yield return new WaitForSeconds(updateTime); } while (step.x \u003e 1 || step.y \u003e 1); Debug.Log(new Vector2Int(1, 1)); JFA(rtOne, rtTwo, new Vector2Int(1, 1), reverse); reverse = !reverse; Visualize(rtOne, rtTwo, reverse); yield return new WaitForSeconds(updateTime); Debug.Log(new Vector2Int(1, 1)); JFA(rtOne, rtTwo, new Vector2Int(1, 1), reverse); reverse = !reverse; Visualize(rtOne, rtTwo, reverse); yield return new WaitForSeconds(updateTime); Compose(rtOne, rtTwo, inputTexture, (uint)Channels.A, reverse); reverse = !reverse; Shader.EnableKeyword(\"RENDERTEXTURE_UPSIDE_DOWN\"); Visualize(rtOne, rtTwo, reverse); SaveToTexture(\"WhatIsThis\", reverse ? rtTwo : rtOne, false); } } [CustomEditor(typeof(JumpFlooding))] public class JumpFloodingEditor : Editor { private JumpFlooding jumpFlooding; private void OnEnable() { jumpFlooding = (JumpFlooding)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); using (new EditorGUI.DisabledGroupScope(!Application.isPlaying)) { if (GUILayout.Button(\"Calculate SDF\", GUILayout.Height(30))) { jumpFlooding.Calculate(); } } } } JFAVisualize.shader è¿™ä¸ªshaderåº”è¯¥ç”¨åœ¨å®½é«˜æ¯”2:1çš„Meshä¸Šï¼Œè¿™æ ·å·¦åŠéƒ¨åˆ†æ˜¯è®°å½•äº†æœ€è¿‘åƒç´ çš„uvçš„è´´å›¾ï¼Œæœ‰ä¼´éƒ¨åˆ†æ˜¯è®°å½•äº†å¸¦æ–¹å‘çš„è·ç¦»çš„ç°åº¦è´´å›¾æˆ–è€…å…¶æè¾¹çš„å¯è§†åŒ–ã€‚éœ€è¦æ³¨æ„é‡‡æ ·çš„æ–¹å¼å’Œä½¿ç”¨åƒç´ ç‚¹ä¸­å¿ƒæ¥è®¡ç®—è·ç¦»ã€‚\nShader \"Unlit/JFAVisualize\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Distance (\"Distance\", float) = 10 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #pragma multi_compile _ RENDERTEXTURE_UPSIDE_DOWN Texture2D _MainTex; float4 _MainTex_TexelSize; SamplerState sampler_PointClamp; float _Distance; struct Attributes { float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; }; Varyings Vert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); output.positionCS = vertexInput.positionCS; output.uv = input.texcoord; return output; } float4 Frag(Varyings input) : SV_TARGET { float2 upsideDown = input.uv; #if RENDERTEXTURE_UPSIDE_DOWN upsideDown = float2(input.uv.x, 1 - input.uv.y); #endif float2 uvOne = float2(upsideDown.x * 2, upsideDown.y); float2 uvTwo = float2(upsideDown.x * 2 - 1, upsideDown.y); float4 returnColor = 0; if (input.uv.x \u003e= 0.5) { float4 texColor = _MainTex.SampleLevel(sampler_PointClamp, uvTwo, 0); #if RENDERTEXTURE_UPSIDE_DOWN float2 realTexcoord = float2(input.uv.x * 2 - 1, input.uv.y); realTexcoord = floor(realTexcoord* _MainTex_TexelSize.zw) + 0.5; float distance = length(texColor.xy * _MainTex_TexelSize.zw - realTexcoord); #else float2 realTexcoord = uvTwo; realTexcoord = floor(realTexcoord * _MainTex_TexelSize.zw) + 0.5; float distance = length(texColor.xy * _MainTex_TexelSize.zw - realTexcoord); #endif float grayScale = smoothstep(_Distance, 0, distance); returnColor = float4(grayScale, grayScale, grayScale, 1); } else { returnColor = _MainTex.SampleLevel(sampler_PointClamp, uvOne, 0); } return returnColor; } ENDHLSL SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { Name \"JFA Visualize Pass\" Tags{\"LightMode\" = \"UniversalForward\"} Cull Back ZTest LEqual ZWrite On HLSLPROGRAM #pragma vertex Vert #pragma fragment Frag ENDHLSL } } } ","wordCount":"1568","inLanguage":"en","image":"https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/posts/images/SignedDistanceField.jpg","datePublished":"2021-06-21T19:00:00+08:00","dateModified":"2021-06-21T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/calculate-signed-distance-field-using-compute-shader/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº</h1><div class=post-description>ä½¿ç”¨Jump Flooding Algorithmæ¥å¯¹ä¸€å¼ å›¾ç‰‡è®¡ç®—æœ‰å‘è·ç¦»åœº.</div><div class=post-meta><span title='2021-06-21 19:00:00 +0800 CST'>June 21, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/calculate-signed-distance-field-using-compute-shader.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/SignedDistanceField.jpg alt="Signed Distance Field Cover"><p>Signed Distance Field Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä½¿ç”¨Compute Shaderè®¡ç®—æœ‰å‘è·ç¦»åœº</div></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%9c%89%e5%90%91%e8%b7%9d%e7%a6%bb%e5%9c%ba%e4%bb%a5%e5%8f%8a%e5%ae%83%e8%83%bd%e7%94%a8%e6%9d%a5%e5%b9%b2%e4%bb%80%e4%b9%88 aria-label=ä»€ä¹ˆæ˜¯æœ‰å‘è·ç¦»åœºä»¥åŠå®ƒèƒ½ç”¨æ¥å¹²ä»€ä¹ˆ>ä»€ä¹ˆæ˜¯æœ‰å‘è·ç¦»åœºä»¥åŠå®ƒèƒ½ç”¨æ¥å¹²ä»€ä¹ˆ</a></li><li><a href=#%e9%82%a3%e4%b9%88%e4%bb%80%e4%b9%88%e5%8f%88%e6%98%afjump-flooding-algorithm%e5%91%a2 aria-label="é‚£ä¹ˆä»€ä¹ˆåˆæ˜¯Jump Flooding Algorithmå‘¢">é‚£ä¹ˆä»€ä¹ˆåˆæ˜¯Jump Flooding Algorithmå‘¢</a></li><li><a href=#%e4%bd%bf%e7%94%a8jfa%e8%ae%a1%e7%ae%97%e4%b8%80%e5%bc%a02d%e5%9b%be%e7%89%87%e5%af%b9%e5%ba%94%e7%9a%84sdf%e8%b4%b4%e5%9b%be aria-label=ä½¿ç”¨JFAè®¡ç®—ä¸€å¼ 2Då›¾ç‰‡å¯¹åº”çš„SDFè´´å›¾>ä½¿ç”¨JFAè®¡ç®—ä¸€å¼ 2Då›¾ç‰‡å¯¹åº”çš„SDFè´´å›¾</a><ul><li><a href=#%e6%95%b4%e4%bd%93%e6%80%9d%e8%b7%af%e5%92%8c%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e4%ba%8b%e9%a1%b9 aria-label=æ•´ä½“æ€è·¯å’Œéœ€è¦æ³¨æ„çš„äº‹é¡¹>æ•´ä½“æ€è·¯å’Œéœ€è¦æ³¨æ„çš„äº‹é¡¹</a></li><li><a href=#jfacomputeshadercompute aria-label=JFAComputeShader.compute>JFAComputeShader.compute</a></li><li><a href=#jumpfloodingcs aria-label=JumpFlooding.cs>JumpFlooding.cs</a></li><li><a href=#jfavisualizeshader aria-label=JFAVisualize.shader>JFAVisualize.shader</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=ä»€ä¹ˆæ˜¯æœ‰å‘è·ç¦»åœºä»¥åŠå®ƒèƒ½ç”¨æ¥å¹²ä»€ä¹ˆ>ä»€ä¹ˆæ˜¯æœ‰å‘è·ç¦»åœºä»¥åŠå®ƒèƒ½ç”¨æ¥å¹²ä»€ä¹ˆ<a hidden class=anchor aria-hidden=true href=#ä»€ä¹ˆæ˜¯æœ‰å‘è·ç¦»åœºä»¥åŠå®ƒèƒ½ç”¨æ¥å¹²ä»€ä¹ˆ>#</a></h2><p>æœ‰å‘è·ç¦»åœºè®°å½•çš„æ˜¯ä»ä¸€ä¸ªç‚¹åˆ°é›†åˆè¾¹ç•Œçš„çš„è·ç¦»å€¼ï¼Œå…¶å€¼çš„æ­£è´Ÿå¯¹åº”è¯¥ç‚¹åœ¨é›†åˆå¤–éƒ¨æˆ–å†…éƒ¨ã€‚æœ‰å‘è·ç¦»åœºæœ‰å¾ˆå¹¿çš„åº”ç”¨èŒƒå›´å¯ä»¥ç”¨æ¥ç®€å•çš„ç”ŸæˆVoronoiå›¾å½¢ï¼Œå¯ä»¥ç”¨æ¥åšå…¨å±€å…‰ç…§çš„è®¡ç®—ï¼Œå¯ä»¥ç”¨æ¥åšä¸¤ä¸ªå½¢çŠ¶çš„å¹³æ»‘çš„å˜å½¢ï¼Œå¯ä»¥ç”¨æ¥åšé«˜æ¸…æ™°åº¦çš„å­—ä½“ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥åšRay Marchï¼ˆè™½ç„¶æˆ‘è®¤ä¸ºä¸å¦‚ç›´æ¥å…‰çº¿è¿½è¸ªæ±‚äº¤æ¥çš„æ•ˆç‡é«˜ï¼‰ã€‚åƒåŸç¥å°±ä½¿ç”¨äº†SDFçš„æ–¹æ³•ï¼Œç”Ÿæˆäº†è§’è‰²è„¸éƒ¨çš„é˜´å½±å›¾ï¼Œä»è€Œè®©è§’è‰²è„¸éƒ¨çš„é˜´å½±èƒ½è‡ªç„¶çš„å˜åŒ–ã€‚</p><h2 id=é‚£ä¹ˆä»€ä¹ˆåˆæ˜¯jump-flooding-algorithmå‘¢>é‚£ä¹ˆä»€ä¹ˆåˆæ˜¯Jump Flooding Algorithmå‘¢<a hidden class=anchor aria-hidden=true href=#é‚£ä¹ˆä»€ä¹ˆåˆæ˜¯jump-flooding-algorithmå‘¢>#</a></h2><p>Jump Flooding Algorithmæ˜¯è£å›½æ ‹åœ¨ä»–çš„åšå£«è®ºæ–‡<a href=https://www.comp.nus.edu.sg/~tants/jfa/rong-guodong-phd-thesis.pdf>Jump Flooding Algorithm On Graphics Hardware And Its Applications</a>æå‡ºçš„ä¸€ç§åœ¨GPUä¸Šè¿è¡Œçš„èƒ½å¤Ÿå¿«é€Ÿä¼ æ’­æŸä¸ªåƒç´ çš„ä¿¡æ¯åˆ°å…¶ä»–åƒç´ çš„ç®—æ³•ã€‚</p><p>æ™®é€šçš„Floodingç®—æ³•åœ¨ä¸€æ¬¡è¿è¡Œä¸­ï¼Œå›ºå®šå‘ç›¸é‚»çš„ä¸€ä¸ªåƒç´ çš„åƒç´ ä¼ æ’­ä¿¡æ¯ï¼Œè€ŒJump Floodingåˆ™æ˜¯æŒ‰ç…§2çš„å¹‚æ¬¡é€’å¢æˆ–æ˜¯é€’å‡æ¥ä¼ æ’­ä¿¡æ¯ã€‚è¿™å’Œä¹‹å‰æåˆ°çš„å¹¶è¡Œè®¡ç®—â€”â€”Reductionçš„æƒ³æ³•å·®ä¸å¤šã€‚ä¸‹å›¾æ¼”ç¤ºäº†æ™®é€šçš„Floodingå’ŒJump Floodingçš„è¿‡ç¨‹ï¼š
<img loading=lazy src=../images/NormalFlooding.jpg#center alt="Normal Flooding">
<img loading=lazy src=../images/JumpFlooding.jpg#center alt="Jump Flooding"></p><h2 id=ä½¿ç”¨jfaè®¡ç®—ä¸€å¼ 2då›¾ç‰‡å¯¹åº”çš„sdfè´´å›¾>ä½¿ç”¨JFAè®¡ç®—ä¸€å¼ 2Då›¾ç‰‡å¯¹åº”çš„SDFè´´å›¾<a hidden class=anchor aria-hidden=true href=#ä½¿ç”¨jfaè®¡ç®—ä¸€å¼ 2då›¾ç‰‡å¯¹åº”çš„sdfè´´å›¾>#</a></h2><p>é¦–å…ˆåœ¨Unityä¸­åˆ›å»º<code>JumpFlooding.cs</code>, <code>JFAComputeShader.compute</code>, å’Œ<code>JFAVisualize.shader</code>ï¼Œåˆ†åˆ«ç”¨æ¥æ‰§è¡ŒCompute Shaderï¼Œä½¿ç”¨JFAç®—æ³•è®¡ç®—SDFå’Œå¯è§†åŒ–JFAç®—æ³•çš„ç»“æœã€‚</p><p>è¿™é‡Œä½¿ç”¨ä¸€å¼ RGBé€šé“ä¸ºç°è‰²ï¼ŒAlphaé€šé“å†™ç€â€œJFAâ€çš„è´´å›¾ä½œä¸ºæˆ‘ä»¬2Då›¾ç‰‡çš„è¾“å…¥ã€‚<figure><img loading=lazy src=../images/JFAImage.png#center width=200px></figure></p><h3 id=æ•´ä½“æ€è·¯å’Œéœ€è¦æ³¨æ„çš„äº‹é¡¹>æ•´ä½“æ€è·¯å’Œéœ€è¦æ³¨æ„çš„äº‹é¡¹<a hidden class=anchor aria-hidden=true href=#æ•´ä½“æ€è·¯å’Œéœ€è¦æ³¨æ„çš„äº‹é¡¹>#</a></h3><ol><li>å…ˆä»ç®€å•å®ç°åŠŸèƒ½ä¸Šæ¥è€ƒè™‘ï¼Œæš‚æ—¶å¿½ç•¥æ‰æŠ—é”¯é½¿çš„éœ€æ±‚ï¼Œç›´æ¥å¯¹Alphaé€šé“çš„å€¼æŒ‰ç…§0.5æ¥åˆ’åˆ†å‡ºå›¾å½¢çš„å†…éƒ¨å’Œå¤–éƒ¨ï¼Œå¤§äºç­‰äº0.5ä¸ºå¤–éƒ¨ï¼Œå°äº0.5ä¸ºå†…éƒ¨ã€‚</li><li>SDFéœ€è¦è¦è®¡ç®—è·ç¦»ï¼Œè¿™é‡Œä½¿ç”¨åƒç´ ç‚¹ä¸­å¿ƒåˆ°å¦ä¸€ä¸ªåƒç´ ç‚¹ä¸­å¿ƒçš„è·ç¦»ï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨åƒç´ ç‚¹å·¦ä¸‹è§’åˆ°å¦ä¸€ä¸ªåƒç´ ç‚¹å·¦ä¸‹è§’çš„è·ç¦»ï¼Œä¸è¿‡ä¸ºäº†æ˜ç¡®èµ·è§ï¼Œè¿˜æ˜¯åŠ ä¸Šè¿™åŠä¸ªåƒç´ çš„åç§»æ¯”è¾ƒå¥½ï¼‰ã€‚è·ç¦»å¯ä»¥ç”¨uvçš„å¤§å°æ¥è¡¨ç¤ºï¼Œä¹Ÿå¯ä»¥ç”¨åƒç´ æ•°é‡æ¥è¡¨ç¤ºï¼Œé’ˆå¯¹å›¾åƒé•¿å®½ä¸åŒçš„æƒ…å†µï¼Œè¿™é‡Œä»¥ä¸€ä¸ªåƒç´ å®½åº¦ä¸º1æ¥è¡¨ç¤ºä¸¤ä¸ªåƒç´ ç‚¹çš„è·ç¦»ã€‚åœ¨æœ€åé‡‡æ ·JFAçš„Render Textureçš„æ—¶å€™ï¼Œä¹Ÿè¦æ³¨æ„ä½¿ç”¨sampler_PointClampæ¥è¿›è¡Œé‡‡æ ·ï¼Œè®¡ç®—è·ç¦»æ—¶ä¹Ÿä¸èƒ½ä»…ä»…ä½¿ç”¨uvæ¥è®¡ç®—ï¼Œè€Œæ˜¯è¦ä½¿ç”¨åƒç´ ä¸­é—´çš„ç‚¹çš„ä½ç½®æ¥è¿›è¡Œè®¡ç®—ã€‚</li><li>æ™®é€šçš„JFAç®—æ³•ä¼šä½¿ç”¨åˆ°Render Textureçš„ä¸¤ä¸ªé€šé“ï¼Œæ¥æ ‡è®°åƒç´ å¯¹åº”çš„æœ€è¿‘è¾¹ç•Œåƒç´ çš„UVï¼Œç”±äºè®°å½•çš„æ˜¯UVçš„æ•°å€¼è€Œä¸æ˜¯é¢œè‰²ä¿¡æ¯ï¼ŒRender Textureè¦å‚¨å­˜åœ¨çº¿æ€§ç©ºé—´ä¸­ã€‚ç”±äºè¦åŒæ—¶è®¡ç®—å†…éƒ¨å’Œå¤–éƒ¨çš„ç‚¹åˆ°è¾¹ç•Œçš„æœ‰å‘è·ç¦»ï¼ŒJFAç®—æ³•ä¼šä½¿ç”¨åˆ°Render Textureå…¨éƒ¨çš„å››ä¸ªé€šé“ï¼Œè¿™é‡Œä½¿ç”¨å‰ä¸¤ä½è®°å½•ä½äºå†…éƒ¨çš„åƒç´ å¯¹åº”çš„è¾¹ç•Œåƒç´ çš„åæ ‡ï¼Œç”¨åä¸¤ä½è®°å½•ä½äºå¤–éƒ¨çš„åƒç´ å¯¹åº”çš„è¾¹ç•Œåƒç´ çš„åæ ‡ï¼Œå³å¯¹äºå†…éƒ¨çš„åƒç´ (nearestUV.x, nearestUV.y, Z, W)ï¼Œå¯¹äºå¤–éƒ¨çš„åƒç´ (X, Y, nearestUV.x, nearestUV.y)ï¼ŒXYZWåˆ™å¯ä»¥ç”¨æ¥è¡¨ç¤ºè¯¥ç‚¹ä¸ºæœ€åˆå§‹çš„å†…å¤–éƒ¨çš„ç‚¹ã€åŒ…å«JFAä¼ é€’çš„ä¿¡æ¯çš„ç‚¹ã€‚ä¸åŒ…å«JFAä¼ é€’çš„ä¿¡æ¯çš„ç‚¹ã€‚</li><li>åœ¨JFAè®¡ç®—ä¹‹å‰ï¼Œéœ€è¦å…ˆè®©è´´å›¾å¯¹åº”çš„ç‚¹åŒ…å«JFAä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºå†…éƒ¨çš„ç‚¹åˆå§‹åŒ–ä¸º(UV.x, UV.y, -1, -1)ï¼Œå¯¹äºå¤–éƒ¨çš„ç‚¹åˆå§‹åŒ–ä¸º(-1, -1, UV.x, UV.y)ã€‚è¿™è¦æ±‚æˆ‘ä»¬ä½¿ç”¨çš„Render Textureæ ¼å¼ä¸ºè‡³å°‘R16G16B16A16 SFloatã€‚</li><li>åœ¨JFAçš„è®¡ç®—ä¸­ï¼Œä»¥å¤–éƒ¨çš„åƒç´ ç‚¹ä¸ºä¾‹ï¼Œæ‰€è¿›è¡Œçš„æ“ä½œæ˜¯ï¼šé‡‡æ ·ä¸Šæ¬¡ç»è¿‡JFAæ“ä½œçš„Render Textureï¼›æ ¹æ®XYé€šé“åˆ¤æ–­è¯¥ç‚¹åœ¨è¾¹ç•Œçš„å†…éƒ¨è¿˜æ˜¯å¤–éƒ¨ï¼Œå†…éƒ¨å°±è·³è¿‡ï¼›å¯¹å¤–éƒ¨çš„åƒç´ ç‚¹ï¼Œé€šè¿‡XYé€šé“åˆ¤æ–­æ˜¯å¦å·²åŒ…å«JFAçš„ä¿¡æ¯ï¼Œå¦‚æœåŒ…å«ï¼Œæ ¹æ®ZWé€šé“è®¡ç®—å‡ºå½“å‰ç‚¹åˆ°å…¶åŒ…å«çš„æœ€è¿‘åƒç´ çš„è·ç¦»ï¼Œå¦‚æœä¸åŒ…å«ï¼Œå°†è¿™ä¸ªè·ç¦»è®¾ç½®ä¸ºä¸€ä¸ªæå¤§çš„å¸¸æ•°ï¼›åˆ†åˆ«é‡‡æ ·è·ç¦»åƒç´ ç‚¹2çš„å¹‚æ¬¡çš„è·ç¦»çš„å…«ä¸ªåƒç´ ï¼Œåˆ¤æ–­è¿™äº›åƒç´ æ˜¯å¦å·²åŒ…å«JFAçš„ä¿¡æ¯ï¼Œå¦‚æœä¸åŒ…å«ï¼Œé‡‡æ ·ä¸‹ä¸€ä¸ªç‚¹ï¼Œå¦‚æœåŒ…å«ï¼Œæ ¹æ®è¿™äº›åƒç´ çš„ZWé€šé“è®¡ç®—å‡ºå½“å‰ç‚¹åˆ°è¿™äº›åƒç´ åŒ…å«çš„æœ€è¿‘åƒç´ çš„è·ç¦»ï¼Œå¹¶å’Œä¸Šä¸€æ­¥ç®—å‡ºçš„è·ç¦»è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå°äºä¸Šä¸€æ­¥ç®—å‡ºçš„è·ç¦»ï¼Œåˆ™è¯æ˜è¯¥åƒç´ å¯¹åº”çš„æœ€è¿‘åƒç´ ä¸ºå‘¨å›´ç‚¹åŒ…å«çš„åƒç´ ï¼Œæ›´æ–°è¯¥åƒç´ çš„ZWé€šé“ï¼Œå¹¶ä¸”å°†XYé€šé“æ ‡è®°æˆå·²åŒ…å«JFAçš„ä¿¡æ¯ã€‚</li><li>é‡‡æ ·å‘¨è¾¹åƒç´ çš„æ­¥é•¿ä»2Dè´´å›¾çš„é•¿å®½çš„ä¸€åŠå‘ä¸Šå–æ•´å¼€å§‹ï¼Œæ¯æ¬¡JFAéƒ½å–ä¸Šä¸€æ­¥æ­¥é•¿çš„ä¸€åŠå‘ä¸Šå–æ•´ä½œä¸ºæ–°çš„æ­¥é•¿ï¼Œä¸€ç›´è¿›è¡Œåˆ°æ­¥é•¿ä¸º(1, 1)ï¼Œè¿›è¡Œæœ€åä¸€æ¬¡JFAè®¡ç®—ã€‚</li><li>ç»è¿‡JFAè®¡ç®—ä¹‹åï¼Œè¿˜éœ€è¦å°†åˆ†åˆ«è¡¨ç¤ºå†…éƒ¨çš„ç‚¹å¯¹åº”çš„æœ€è¿‘åƒç´ çš„UVå’Œå¤–éƒ¨çš„ç‚¹å¯¹åº”çš„æœ€è¿‘åƒç´ çš„UVç»“åˆèµ·æ¥ï¼Œå‚¨å­˜ä¸ºä¸€å¼ è´´å›¾ï¼Œå¯ä»¥æ˜¯(nearestUV.x, nearestUV.y, 0, inside?1:0)ï¼Œä¹Ÿå¯ä»¥æ˜¯(distance * inside?-1:1, 1)ã€‚</li><li>åº”è¯¥æ˜¯è·Ÿå½“å‰å¹³å°æœ‰å…³ï¼Œæœ‰æ—¶å€™ä¼šå‡ºç°è´´å›¾ä¸Šä¸‹é¢ å€’çš„æƒ…å†µï¼Œå¯ä»¥ç”¨UNITY_UV_STARTS_AT_TOPæ¥ååŠ©è§£å†³ï¼Œä¸è¿‡compute shaderå¯èƒ½éœ€è¦è‡ªå·±å¯ç”¨è¿™ä¸ªå®ï¼Œè¿™é‡Œå°±ç›´æ¥ç¡¬å†™åœ¨shaderé‡Œï¼Œä¸åšå¹³å°åˆ¤æ–­äº†ã€‚</li></ol><h3 id=jfacomputeshadercompute>JFAComputeShader.compute<a hidden class=anchor aria-hidden=true href=#jfacomputeshadercompute>#</a></h3><p>æ ¹æ®ä¸Šé¢çš„æ•´ä½“æ€è·¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸‰ä¸ªkernelï¼Œä¸€ä¸ªç”¨æ¥åˆå§‹åŒ–ï¼Œä¸€ä¸ªåšJFAè®¡ç®—ï¼Œæœ€åä¸€ä¸ªç”¨æ¥åˆæˆæœ€åçš„è´´å›¾ã€‚Compute Shaderçš„å…³é”®å­—éœ€è¦Unity 2020ä»¥ä¸Šï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“å…·ä½“å“ªä¸ªç‰ˆæœ¬ï¼‰æ‰èƒ½æœ‰ï¼Œè¿™é‡Œå°±æš‚æ—¶ç”¨<code>UNITY_2020_2_OR_NEWER</code>è¿™ä¸ªå®æ¥å±è”½äº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel CopyUVMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PIXEL_OFFSET 0.5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _InputTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _OutputTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _Channel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CopyUVMain(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float2</span> samplePosition <span style=color:#f92672>=</span> id.xy <span style=color:#f92672>+</span> PIXEL_OFFSET;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (any(samplePosition <span style=color:#f92672>&gt;=</span> _TextureSize.xy))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> inputTexture <span style=color:#f92672>=</span> _InputTexture.Load(<span style=color:#66d9ef>float3</span>(id.xy, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> determin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> ((<span style=color:#66d9ef>uint</span>)_Channel)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			determin <span style=color:#f92672>=</span> inputTexture.r;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			determin <span style=color:#f92672>=</span> inputTexture.g;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			determin <span style=color:#f92672>=</span> inputTexture.b;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			determin <span style=color:#f92672>=</span> inputTexture.a;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (determin <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_OutputTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, samplePosition.x <span style=color:#f92672>*</span> _TextureSize.z, samplePosition.y <span style=color:#f92672>*</span> _TextureSize.w);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_OutputTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(samplePosition.x <span style=color:#f92672>*</span> _TextureSize.z, samplePosition.y <span style=color:#f92672>*</span> _TextureSize.w, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}   
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel JFAMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> _Step;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int2</span> directions[] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> JFAOutside(<span style=color:#66d9ef>float4</span> inputTex, <span style=color:#66d9ef>float2</span> idxy)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> outputTex <span style=color:#f92672>=</span> inputTex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//cull inside</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (inputTex.x <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float2</span> nearestUV <span style=color:#f92672>=</span> inputTex.zw;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> minDistance <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>e16;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//if had min distance in previous flooding</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (inputTex.z <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			minDistance <span style=color:#f92672>=</span> length(idxy <span style=color:#f92672>+</span> PIXEL_OFFSET <span style=color:#f92672>-</span> nearestUV <span style=color:#f92672>*</span> _TextureSize.xy);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>bool</span> hasMin <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>8</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>uint2</span> sampleOffset <span style=color:#f92672>=</span> idxy <span style=color:#f92672>+</span> directions[i] <span style=color:#f92672>*</span> _Step;
</span></span><span style=display:flex><span>			sampleOffset <span style=color:#f92672>=</span> clamp(sampleOffset, <span style=color:#ae81ff>0</span>, _TextureSize.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>float4</span> offsetTexture <span style=color:#f92672>=</span> _InputTexture.Load(<span style=color:#66d9ef>float3</span>(sampleOffset, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>			<span style=color:#75715e>//if had min distance in previous flooding</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (offsetTexture.z <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>float2</span> tempUV <span style=color:#f92672>=</span> offsetTexture.zw;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>float</span> tempDistance <span style=color:#f92672>=</span> length(idxy <span style=color:#f92672>+</span> PIXEL_OFFSET <span style=color:#f92672>-</span> tempUV <span style=color:#f92672>*</span> _TextureSize.xy);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (tempDistance <span style=color:#f92672>&lt;</span> minDistance)
</span></span><span style=display:flex><span>				{
</span></span><span style=display:flex><span>					hasMin <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>					minDistance <span style=color:#f92672>=</span> tempDistance;
</span></span><span style=display:flex><span>					nearestUV <span style=color:#f92672>=</span> tempUV;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (hasMin)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			outputTex <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(inputTex.xy, nearestUV);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> outputTex;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> JFAInside(<span style=color:#66d9ef>float4</span> inputTex, <span style=color:#66d9ef>float2</span> idxy)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> outputTex <span style=color:#f92672>=</span> inputTex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//cull outside</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (inputTex.z <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float2</span> nearestUV <span style=color:#f92672>=</span> inputTex.xy;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>float</span> minDistance <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>e16;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//if had min distance in previous flooding</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (inputTex.x <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			minDistance <span style=color:#f92672>=</span> length(idxy <span style=color:#f92672>+</span> PIXEL_OFFSET <span style=color:#f92672>-</span> nearestUV <span style=color:#f92672>*</span> _TextureSize.xy);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>bool</span> hasMin <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>8</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>uint2</span> sampleOffset <span style=color:#f92672>=</span> idxy <span style=color:#f92672>+</span> directions[i] <span style=color:#f92672>*</span> _Step;
</span></span><span style=display:flex><span>			sampleOffset <span style=color:#f92672>=</span> clamp(sampleOffset, <span style=color:#ae81ff>0</span>, _TextureSize.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>float4</span> offsetTexture <span style=color:#f92672>=</span> _InputTexture.Load(<span style=color:#66d9ef>float3</span>(sampleOffset, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>			<span style=color:#75715e>//if had min distance in previous flooding</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (offsetTexture.x <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>float2</span> tempUV <span style=color:#f92672>=</span> offsetTexture.xy;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>float</span> tempDistance <span style=color:#f92672>=</span> length(idxy <span style=color:#f92672>+</span> PIXEL_OFFSET <span style=color:#f92672>-</span> tempUV <span style=color:#f92672>*</span> _TextureSize.xy);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (tempDistance <span style=color:#f92672>&lt;</span> minDistance)
</span></span><span style=display:flex><span>				{
</span></span><span style=display:flex><span>					hasMin <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>					minDistance <span style=color:#f92672>=</span> tempDistance;
</span></span><span style=display:flex><span>					nearestUV <span style=color:#f92672>=</span> tempUV;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (hasMin)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			outputTex <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(nearestUV, inputTex.zw);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> outputTex;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> JFAMain(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float2</span> samplePosition <span style=color:#f92672>=</span> id.xy <span style=color:#f92672>+</span> PIXEL_OFFSET;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (any(samplePosition <span style=color:#f92672>&gt;=</span> _TextureSize.xy))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> inputTexture <span style=color:#f92672>=</span> _InputTexture.Load(<span style=color:#66d9ef>float3</span>(id.xy, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> outSide <span style=color:#f92672>=</span> JFAOutside(inputTexture, id.xy);
</span></span><span style=display:flex><span>	_OutputTexture[id.xy] <span style=color:#f92672>=</span> JFAInside(outSide, id.xy);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel ComposeMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _OriginalTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if UNITY_2020_2_OR_NEWER</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma multi_compile _USE_GRAYSCALE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _USE_GRAYSCALE 0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ComposeMain(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>uint2</span> reverseY <span style=color:#f92672>=</span> id.xy;
</span></span><span style=display:flex><span>	reverseY <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint2</span>(id.x, _TextureSize.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> id.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> inputTexture <span style=color:#f92672>=</span> _InputTexture.Load(<span style=color:#66d9ef>float3</span>(reverseY, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float4</span> originalTexture <span style=color:#f92672>=</span> _OriginalTexture.Load(<span style=color:#66d9ef>float3</span>(reverseY, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> determin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> ((<span style=color:#66d9ef>uint</span>)_Channel)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		determin <span style=color:#f92672>=</span> originalTexture.r;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		determin <span style=color:#f92672>=</span> originalTexture.g;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		determin <span style=color:#f92672>=</span> originalTexture.b;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		determin <span style=color:#f92672>=</span> originalTexture.a;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if _USE_GRAYSCALE</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> distance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (determin <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		distance <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>length(reverseY <span style=color:#f92672>+</span> PIXEL_OFFSET <span style=color:#f92672>-</span> inputTexture.xy <span style=color:#f92672>*</span> _TextureSize.xy);
</span></span><span style=display:flex><span>		_OutputTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(distance, distance, distance, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		distance <span style=color:#f92672>=</span> length(reverseY <span style=color:#f92672>+</span> PIXEL_OFFSET <span style=color:#f92672>-</span> inputTexture.zw <span style=color:#f92672>*</span> _TextureSize.xy);
</span></span><span style=display:flex><span>		_OutputTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(distance, distance, distance, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (determin <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_OutputTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(inputTexture.xy, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_OutputTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(inputTexture.zw, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=jumpfloodingcs>JumpFlooding.cs<a hidden class=anchor aria-hidden=true href=#jumpfloodingcs>#</a></h3><p>C#è„šæœ¬æ²¡ä»€ä¹ˆç‰¹æ®Šçš„åœ°æ–¹äº†ï¼Œåªè¦å‡†å¤‡å¥½Render Textureå’Œå„ç±»å‚æ•°ï¼Œä¼ é€’ç»™Compute Shaderå°±å¥½äº†ã€‚ä¸ºäº†æ–¹ä¾¿å¯è§†åŒ–ï¼Œè¿™é‡Œä½¿ç”¨äº†MonoBehaviourçš„Coroutineï¼Œéœ€è¦ç‚¹å‡»playä¹‹ååœ¨ç‚¹å‡»è„šæœ¬é‡Œçš„"Calculate SDF"ã€‚è¿™é‡Œä¿å­˜çš„æ˜¯è®°å½•äº†å¯¹åº”çš„åƒç´ ç‚¹çš„UVçš„è´´å›¾ï¼Œè¿™æ ·å¯ä»¥ç”¨jpgæˆ–è€…pngæ¥ä¿å­˜ï¼Œå¦‚æœè¦ä¿å­˜è®°å½•äº†æœ‰å‘è·ç¦»çš„ç°åº¦è´´å›¾ï¼Œå°±éœ€è¦ä¿å­˜ä¸ºfloatç±»å‹çš„exræ ¼å¼äº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JumpFlooding</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> Channels
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        R, G, B, A
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Texture inputTexture;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> updateTime;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> MeshRenderer meshRenderer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> useGrayScale = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RenderTexture[] renderTextures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            array = <span style=color:#66d9ef>new</span> T[size];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
</span></span><span style=display:flex><span>                array[i] = initialValue;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRenderTexture(<span style=color:#66d9ef>ref</span> RenderTexture rt, RenderTextureDescriptor descriptor, <span style=color:#66d9ef>string</span> RTName)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != descriptor.width || rt.height != descriptor.height))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTexture.ReleaseTemporary(rt);
</span></span><span style=display:flex><span>            rt = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = descriptor;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            rt = RenderTexture.GetTemporary(desc);
</span></span><span style=display:flex><span>            rt.name = RTName;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture[] rts, RenderTextureDescriptor descriptor)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EnsureArray(<span style=color:#66d9ef>ref</span> rts, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        EnsureRenderTexture(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>0</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex One&#34;</span>);
</span></span><span style=display:flex><span>        EnsureRenderTexture(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>1</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex Two&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Calculate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        StartCoroutine(CalculateCoroutine());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> CopyUV(Texture texture, RenderTexture renderTexture, <span style=color:#66d9ef>uint</span> channel)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;CopyUVMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        Vector3Int dispatchCounts = <span style=color:#66d9ef>new</span> Vector3Int(Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)inputTexture.width / x),
</span></span><span style=display:flex><span>                                                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)inputTexture.height / y),
</span></span><span style=display:flex><span>                                                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_InputTexture&#34;</span>, texture);
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_OutputTexture&#34;</span>, renderTexture);
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(texture.width, texture.height, <span style=color:#ae81ff>1.0f</span> / texture.width, <span style=color:#ae81ff>1.0f</span> / texture.height));
</span></span><span style=display:flex><span>        computeShader.SetFloat(<span style=color:#e6db74>&#34;_Channel&#34;</span>, (<span style=color:#66d9ef>float</span>)channel);
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernel, dispatchCounts.x, dispatchCounts.y, dispatchCounts.z);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> JFA(RenderTexture one, RenderTexture two, Vector2Int step, <span style=color:#66d9ef>bool</span> reverse)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;JFAMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        Vector3Int dispatchCounts = <span style=color:#66d9ef>new</span> Vector3Int(Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)inputTexture.width / x),
</span></span><span style=display:flex><span>                                                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)inputTexture.height / y),
</span></span><span style=display:flex><span>                                                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (reverse)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_InputTexture&#34;</span>, two);
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_OutputTexture&#34;</span>, one);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_InputTexture&#34;</span>, one);
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_OutputTexture&#34;</span>, two);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(inputTexture.width, inputTexture.height, <span style=color:#ae81ff>1.0f</span> / inputTexture.width, <span style=color:#ae81ff>1.0f</span> / inputTexture.height));
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_Step&#34;</span>, (Vector2)step);
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernel, dispatchCounts.x, dispatchCounts.y, dispatchCounts.z);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Compose(RenderTexture one, RenderTexture two, Texture texture, <span style=color:#66d9ef>uint</span> channel, <span style=color:#66d9ef>bool</span> reverse)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;ComposeMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        Vector3Int dispatchCounts = <span style=color:#66d9ef>new</span> Vector3Int(Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)inputTexture.width / x),
</span></span><span style=display:flex><span>                                                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)inputTexture.height / y),
</span></span><span style=display:flex><span>                                                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (reverse)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_InputTexture&#34;</span>, two);
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_OutputTexture&#34;</span>, one);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_InputTexture&#34;</span>, one);
</span></span><span style=display:flex><span>            computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_OutputTexture&#34;</span>, two);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernel, <span style=color:#e6db74>&#34;_OriginalTexture&#34;</span>, texture);
</span></span><span style=display:flex><span>        computeShader.SetFloat(<span style=color:#e6db74>&#34;_Channel&#34;</span>, (<span style=color:#66d9ef>float</span>)channel);
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> UNITY_2020_2_OR_NEWER
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(useGrayScale)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader.EnableKeyword(<span style=color:#e6db74>&#34;_USE_GRAYSCALE&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader.DisableKeyword(<span style=color:#e6db74>&#34;_USE_GRAYSCALE&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernel, dispatchCounts.x, dispatchCounts.y, dispatchCounts.z);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Visualize(RenderTexture one, RenderTexture two, <span style=color:#66d9ef>bool</span> reverse)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MaterialPropertyBlock mpb = <span style=color:#66d9ef>new</span> MaterialPropertyBlock();
</span></span><span style=display:flex><span>        mpb.SetTexture(<span style=color:#e6db74>&#34;_MainTex&#34;</span>, reverse ? two : one);
</span></span><span style=display:flex><span>        meshRenderer.SetPropertyBlock(mpb);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SaveToTexture(<span style=color:#66d9ef>string</span> name, RenderTexture renderTexture, <span style=color:#66d9ef>bool</span> alphaIsTransparency)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        RenderTexture currentRT = RenderTexture.active;
</span></span><span style=display:flex><span>        RenderTexture.active = renderTexture;
</span></span><span style=display:flex><span>        Texture2D texture2D = <span style=color:#66d9ef>new</span> Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGBAFloat, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        texture2D.ReadPixels(<span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, renderTexture.width, renderTexture.height), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        RenderTexture.active = currentRT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.IO.Directory.CreateDirectory(<span style=color:#e6db74>&#34;Assets/JumpFlooding/&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>[] bytes = texture2D.EncodeToEXR();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> path = <span style=color:#e6db74>&#34;Assets/JumpFlooding/&#34;</span> + name + <span style=color:#e6db74>&#34;.exr&#34;</span>;
</span></span><span style=display:flex><span>        System.IO.File.WriteAllBytes(path, bytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TextureImporter importer = (TextureImporter)AssetImporter.GetAtPath(path);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (importer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            importer.alphaIsTransparency = alphaIsTransparency;
</span></span><span style=display:flex><span>            importer.sRGBTexture = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            importer.mipmapEnabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            AssetDatabase.ImportAsset(path);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#e6db74>&#34;Saved to &#34;</span> + path);
</span></span><span style=display:flex><span>        AssetDatabase.Refresh();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IEnumerator CalculateCoroutine()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            width = inputTexture.width,
</span></span><span style=display:flex><span>            height = inputTexture.height,
</span></span><span style=display:flex><span>            volumeDepth = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            msaaSamples = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat,
</span></span><span style=display:flex><span>            enableRandomWrite = <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>            dimension = UnityEngine.Rendering.TextureDimension.Tex2D,
</span></span><span style=display:flex><span>            sRGB = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        EnsureRT(<span style=color:#66d9ef>ref</span> renderTextures, desc);
</span></span><span style=display:flex><span>        RenderTexture rtOne = renderTextures[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        RenderTexture rtTwo = renderTextures[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        CopyUV(inputTexture, rtOne, (<span style=color:#66d9ef>uint</span>)Channels.A);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(updateTime);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Shader.DisableKeyword(<span style=color:#e6db74>&#34;RENDERTEXTURE_UPSIDE_DOWN&#34;</span>);
</span></span><span style=display:flex><span>        Vector2Int step = <span style=color:#66d9ef>new</span> Vector2Int((inputTexture.width + <span style=color:#ae81ff>1</span>) &gt;&gt; <span style=color:#ae81ff>1</span>, (inputTexture.height + <span style=color:#ae81ff>1</span>) &gt;&gt; <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> reverse = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(step);
</span></span><span style=display:flex><span>            JFA(rtOne, rtTwo, step, reverse);
</span></span><span style=display:flex><span>            reverse = !reverse;
</span></span><span style=display:flex><span>            Visualize(rtOne, rtTwo, reverse);
</span></span><span style=display:flex><span>            step = <span style=color:#66d9ef>new</span> Vector2Int((step.x + <span style=color:#ae81ff>1</span>) &gt;&gt; <span style=color:#ae81ff>1</span>, (step.y + <span style=color:#ae81ff>1</span>) &gt;&gt; <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(updateTime);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (step.x &gt; <span style=color:#ae81ff>1</span> || step.y &gt; <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#66d9ef>new</span> Vector2Int(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        JFA(rtOne, rtTwo, <span style=color:#66d9ef>new</span> Vector2Int(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>), reverse);
</span></span><span style=display:flex><span>        reverse = !reverse;
</span></span><span style=display:flex><span>        Visualize(rtOne, rtTwo, reverse);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(updateTime);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Debug.Log(<span style=color:#66d9ef>new</span> Vector2Int(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        JFA(rtOne, rtTwo, <span style=color:#66d9ef>new</span> Vector2Int(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>), reverse);
</span></span><span style=display:flex><span>        reverse = !reverse;
</span></span><span style=display:flex><span>        Visualize(rtOne, rtTwo, reverse);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(updateTime);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Compose(rtOne, rtTwo, inputTexture, (<span style=color:#66d9ef>uint</span>)Channels.A, reverse);
</span></span><span style=display:flex><span>        reverse = !reverse;
</span></span><span style=display:flex><span>        Shader.EnableKeyword(<span style=color:#e6db74>&#34;RENDERTEXTURE_UPSIDE_DOWN&#34;</span>);
</span></span><span style=display:flex><span>        Visualize(rtOne, rtTwo, reverse);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SaveToTexture(<span style=color:#e6db74>&#34;WhatIsThis&#34;</span>, reverse ? rtTwo : rtOne, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[CustomEditor(typeof(JumpFlooding))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JumpFloodingEditor</span> : Editor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> JumpFlooding jumpFlooding;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        jumpFlooding = (JumpFlooding)target;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInspectorGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>base</span>.OnInspectorGUI();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!Application.isPlaying))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (GUILayout.Button(<span style=color:#e6db74>&#34;Calculate SDF&#34;</span>, GUILayout.Height(<span style=color:#ae81ff>30</span>)))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                jumpFlooding.Calculate();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=jfavisualizeshader>JFAVisualize.shader<a hidden class=anchor aria-hidden=true href=#jfavisualizeshader>#</a></h3><p>è¿™ä¸ªshaderåº”è¯¥ç”¨åœ¨å®½é«˜æ¯”2:1çš„Meshä¸Šï¼Œè¿™æ ·å·¦åŠéƒ¨åˆ†æ˜¯è®°å½•äº†æœ€è¿‘åƒç´ çš„uvçš„è´´å›¾ï¼Œæœ‰ä¼´éƒ¨åˆ†æ˜¯è®°å½•äº†å¸¦æ–¹å‘çš„è·ç¦»çš„ç°åº¦è´´å›¾æˆ–è€…å…¶æè¾¹çš„å¯è§†åŒ–ã€‚éœ€è¦æ³¨æ„é‡‡æ ·çš„æ–¹å¼å’Œä½¿ç”¨åƒç´ ç‚¹ä¸­å¿ƒæ¥è®¡ç®—è·ç¦»ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;Unlit/JFAVisualize&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _Distance (<span style=color:#e6db74>&#34;Distance&#34;</span>, <span style=color:#66d9ef>float</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma multi_compile _ RENDERTEXTURE_UPSIDE_DOWN</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Texture2D</span> _MainTex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _MainTex_TexelSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SamplerState</span> sampler_PointClamp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _Distance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings Vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vertexInput <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vertexInput.positionCS;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> Frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> upsideDown <span style=color:#f92672>=</span> input.uv;
</span></span><span style=display:flex><span><span style=color:#75715e>#if RENDERTEXTURE_UPSIDE_DOWN</span>
</span></span><span style=display:flex><span>        upsideDown <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(input.uv.x, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> input.uv.y);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvOne <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(upsideDown.x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, upsideDown.y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uvTwo <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(upsideDown.x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, upsideDown.y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> returnColor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (input.uv.x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float4</span> texColor <span style=color:#f92672>=</span> _MainTex.SampleLevel(sampler_PointClamp, uvTwo, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#if RENDERTEXTURE_UPSIDE_DOWN</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> realTexcoord <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(input.uv.x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, input.uv.y);
</span></span><span style=display:flex><span>            realTexcoord <span style=color:#f92672>=</span> floor(realTexcoord<span style=color:#f92672>*</span> _MainTex_TexelSize.zw) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> distance <span style=color:#f92672>=</span> length(texColor.xy <span style=color:#f92672>*</span> _MainTex_TexelSize.zw <span style=color:#f92672>-</span> realTexcoord);
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> realTexcoord <span style=color:#f92672>=</span> uvTwo;
</span></span><span style=display:flex><span>            realTexcoord <span style=color:#f92672>=</span> floor(realTexcoord <span style=color:#f92672>*</span> _MainTex_TexelSize.zw) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> distance <span style=color:#f92672>=</span> length(texColor.xy <span style=color:#f92672>*</span> _MainTex_TexelSize.zw <span style=color:#f92672>-</span> realTexcoord);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> grayScale <span style=color:#f92672>=</span> smoothstep(_Distance, <span style=color:#ae81ff>0</span>, distance);
</span></span><span style=display:flex><span>            returnColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(grayScale, grayScale, grayScale, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            returnColor <span style=color:#f92672>=</span> _MainTex.SampleLevel(sampler_PointClamp, uvOne, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> returnColor;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Opaque&#34;</span> }
</span></span><span style=display:flex><span>        LOD <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Name <span style=color:#e6db74>&#34;JFA Visualize Pass&#34;</span>
</span></span><span style=display:flex><span>            Tags{<span style=color:#e6db74>&#34;LightMode&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UniversalForward&#34;</span>}
</span></span><span style=display:flex><span>            Cull Back
</span></span><span style=display:flex><span>            ZTest LEqual
</span></span><span style=display:flex><span>            ZWrite On
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex Vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment Frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li><li><a href=https://zznewclear13.github.io/tags/signed-distance-field/>Signed Distance Field</a></li><li><a href=https://zznewclear13.github.io/tags/jump-flooding-algorithm/>Jump Flooding Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-space-transformation-overview/><span class=title>Â« Prev</span><br><span>Unityç©ºé—´å˜æ¢æ€»è§ˆ</span>
</a><a class=next href=https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/><span class=title>Next Â»</span><br><span>ä½¿ç”¨Compute Shaderè®¡ç®—çƒè°å…¨å±€å…‰ç…§</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>