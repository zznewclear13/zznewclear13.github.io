<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping | ZZNEWCLEAR13</title><meta name=keywords content="Relaxed Cone Step Mapping,Parallax Occlusion Mapping,Compute Shader"><meta name=description content="å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.a6fe470bfe70eb4fad7ee3efc590e817f121cf0f6d66fa91de327cf6bfbad62d.css integrity="sha256-pv5HC/5w60+tfuPvxZDoF/Ehzw9tZvqR3jJ89r+61i0=" rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping"><meta property="og:description" content="å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-01T19:00:00+08:00"><meta property="article:modified_time" content="2023-07-01T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png"><meta name=twitter:title content="åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping"><meta name=twitter:description content="å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping","item":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping","name":"åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping","description":"å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•.","keywords":["Relaxed Cone Step Mapping","Parallax Occlusion Mapping","Compute Shader"],"articleBody":"é˜…è¯»å‰æç¤º ç”±äºæœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å‡ä¸ºLearnOpenGLç½‘ç«™ä¸Šçš„è´´å›¾ï¼Œå…¶æ³•çº¿è´´å›¾å’Œä¸€èˆ¬Unityæˆ–Unrealå¼•æ“ä¸­çš„æ³•çº¿è´´å›¾çš„Yåˆ†é‡æ˜¯ç›¸åçš„ï¼Œå› æ­¤åœ¨è®¡ç®—ä¸–ç•Œåæ ‡çš„bitangentçš„æ—¶å€™ä¼šé¢å¤–å†ä¹˜ä¸Šä¸€ä¸ªsignï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹æ˜¯ä¸éœ€è¦çš„ã€‚\nè§†å·®æ•ˆæœ åœ¨ä¸‰è§’å½¢é¢æ•°æ¯”è¾ƒå—é™çš„æƒ…å†µä¸‹ï¼Œå¾€å¾€ä¼šè€ƒè™‘ä½¿ç”¨ä¸€å¼ é«˜åº¦å›¾ï¼Œé€šè¿‡è§†å·®çš„è®¡ç®—å»æ¸²æŸ“å‡ºä¸€ç§3Dçš„æ•ˆæœï¼ˆè™½ç„¶ç°åœ¨ç›´æ¥ç”¨æ›²é¢ç»†åˆ†Tessellationä¼¼ä¹æ˜¯ä¸€ç§æ›´æ™®éçš„ä¸”æ›´æœ‰æ•ˆçš„æ–¹æ³•ï¼‰ã€‚æœ‰ä¸¤ç§è®¡ç®—è§†å·®çš„æ–¹æ³•ï¼Œä¸€ç§å«åšParallax Occlusion Mappingï¼Œå…ˆå‡å®šé«˜åº¦çš„å±‚æ•°ï¼Œç„¶åå¯¹æ¯ä¸€å±‚è®¡ç®—å‡ºåˆé€‚çš„ä½ç½®å’Œé¢œè‰²ï¼Œä»è€Œè¾¾åˆ°3Dæ•ˆæœï¼›å¦ä¸€ç§å«åšCone Step Mappingï¼Œæ˜¯æ ¹æ®é«˜åº¦å›¾é¢„å…ˆè®¡ç®—å‡ºæ¯ä¸ªç‚¹å¯¹äºå…¶ä»–æ‰€æœ‰åƒç´ çš„æœ€å¤§çš„åœ†é”¥å¼ è§’ï¼ˆæœ‰ç‚¹åƒAOï¼‰ï¼Œæ ¹æ®åœ†é”¥å¼ è§’å¿«é€Ÿæ­¥è¿›ï¼Œæœ€åä½¿ç”¨äºŒåˆ†æ³•è®¡ç®—å‡ºæœ€ç»ˆçš„äº¤ç‚¹çš„é¢œè‰²ã€‚ç¬¬ä¸€ç§æ–¹æ³•æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„ç¼ºç‚¹ï¼Œå°±æ˜¯åœ¨è§†è§’æ¯”è¾ƒæ¥è¿‘å¹³é¢çš„æ—¶å€™ï¼Œå¦‚æœé‡‡æ ·æ¬¡æ•°ä¸æ˜¯å¾ˆé«˜ï¼Œå°±ä¼šçœ‹åˆ°ä¸€å±‚ä¸€å±‚çš„æ•ˆæœï¼Œå¯ä»¥é€šè¿‡å¯¹æœ€åä¸€æ¬¡è®¡ç®—æ·±åº¦è¿›è¡Œçº¿æ€§æ’å€¼åœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡è½»ä¸€å±‚ä¸€å±‚çš„é—®é¢˜ï¼›ç¬¬äºŒç§æ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼Œå½“é‡‡æ ·æ¬¡æ•°è¾ƒå°æ—¶ï¼Œäº§ç”Ÿçš„å›¾åƒä¼šæœ‰ä¸€å®šç¨‹åº¦çš„æ‰­æ›²ï¼Œä½†ä¸ä¼šæœ‰ä¸€å±‚ä¸€å±‚çš„æ„Ÿè§‰ï¼Œæ­¤å¤–ç›¸è¾ƒäºç¬¬ä¸€ç§ä¼šæœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œè¾ƒç»†ç‰©ä½“ä¸ä¼šè¢«è·³è¿‡ã€‚åœ¨GPU Gems 3ä¸­æåˆ°äº†ä¸€ç§Cone Step Mappingçš„ä¼˜åŒ–ï¼Œå«åšRelaxed Cone Step Mappingï¼Œç›¸è¾ƒäºä¹‹å‰è®¡ç®—æœ€å¤§å¼ è§’çš„æ–¹å¼ï¼Œè¿™ç§ä¼˜åŒ–é€šè¿‡ç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œå‡å°‘äº†ä¸€å¼€å§‹åœ†é”¥æ­¥è¿›çš„æ¬¡æ•°ã€‚æœ¬æ–‡å°±ä¸»è¦ä½¿ç”¨è¿™ç§æ–¹æ³•è¿›è¡Œè®¡ç®—ï¼Œä¹Ÿè®¸å°†åœ†é”¥çš„é¡¶éƒ¨æ”¾åœ¨æ¯”å½“å‰é«˜åº¦å›¾æ›´æ·±çš„ä½ç½®èƒ½å¤Ÿæ›´åŠ å‡å°‘æ­¥è¿›çš„æ¬¡æ•°ï¼Œä¸è¿‡æˆ‘ç¨å¾®å°è¯•äº†ä¸€ä¸‹å¥½åƒæ•ˆæœå¹¶ä¸æ˜¯ç‰¹åˆ«ç†æƒ³ã€‚\nParallax Occlusion Mappingå¯ä»¥åœ¨Learn OpenGLé‡Œæ‰¾åˆ°ä»‹ç»å’Œä¼˜åŒ–æ–¹æ¡ˆï¼ŒShadertoyä¸Šä¹Ÿæœ‰å¼€æºçš„ä»£ç å¯ä»¥å‚è€ƒã€‚UE5ä¸­æœ‰ä¸€ä¸ªå«Get Relief!çš„æ’ä»¶ï¼Œå¯ä»¥ç”¨æ¥å¿«é€Ÿç”ŸæˆRelaxed Cone Step Mappingçš„é¢„è®¡ç®—çš„è´´å›¾ï¼Œä¹Ÿæä¾›äº†æ¸²æŸ“çš„Shaderã€‚è¿™ä¸ªæ’ä»¶çš„ä½œè€…Daniel Elliottä¹Ÿåœ¨GDC2023ä¸Šåˆ†äº«äº†åˆ¶ä½œçš„æ€è·¯ï¼Œå¦‚æœé“¾æ¥æ‰“ä¸å¼€çš„è¯è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªGDC Vaultçš„é“¾æ¥ã€‚\næœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å¯ä»¥åœ¨Learn OpenGLä¸­ç»™å‡ºçš„ä¸‹è½½é“¾æ¥ä¸­æ‰¾åˆ°ã€‚ä¸ºäº†çœ‹ä¸Šå»èˆ’æœä¸€äº›ï¼Œè¿™é‡Œå¯¹displacementè´´å›¾çš„é¢œè‰²è¿›è¡Œäº†åå‘ã€‚\nä¸‹å›¾æ˜¯ä¸¤ç§è§†å·®åšæ³•çš„æ¯”è¾ƒï¼Œå·¦è¾¹æ˜¯Parallax Occlusion Mappingï¼Œå³è¾¹æ˜¯Relaxed Cone Step Mappingï¼Œä¸¤è€…çš„é‡‡æ ·æ¬¡æ•°æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥çœ‹åˆ°POMåœ¨è¾ƒæé™çš„æƒ…å†µä¸‹ä¼šæœ‰åˆ†å±‚æ„Ÿè€ŒRCSMä¼šæœ‰æ‰­æ›²ã€‚RCSMä½¿ç”¨çš„è´´å›¾ä¹Ÿæ”¾åœ¨ä¸‹é¢äº†ï¼ŒRé€šé“æ˜¯é«˜åº¦å›¾ï¼ŒGé€šé“æ˜¯åœ†é”¥çš„å¼ è§’ã€‚æœ¬æ–‡ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ã€‚\nç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾ å’ŒParallax Occlusion Mappingç›´æ¥ä½¿ç”¨æ·±åº¦å›¾ä¸åŒçš„æ˜¯ï¼ŒCone Step Mappingéœ€è¦é¢„å…ˆè®¡ç®—å‡ºä¸€å¼ åœ†é”¥å¼ è§’çš„å›¾ï¼Œåœ†é”¥çš„å¼ è§’å¯ä»¥ä½¿ç”¨åœ†é”¥åº•çš„åŠå¾„é™¤ä»¥åœ†é”¥çš„é«˜æ¥è¡¨ç¤ºï¼Œè®°ä¸ºconeRatioã€‚æœ¬æ–‡ä¸­ä½¿ç”¨çš„æ˜¯é«˜åº¦å›¾ï¼Œä½†å®é™…è®¡ç®—ä¸­ä¼šä½¿ç”¨1å‡å»é«˜åº¦å€¼ï¼Œå¯¹åº”çš„æ˜¯ä»æ¨¡å‹è¡¨é¢åˆ°å®é™…é«˜åº¦çš„æ·±åº¦å€¼ã€‚ç”±äºæ·±åº¦å€¼åªä¼šåœ¨01ä¹‹é—´ï¼Œuvä¹Ÿåªä¼šåœ¨01ä¹‹é—´ï¼Œå› æ­¤å¯¹äºæœ€æ·±çš„ç‚¹ï¼Œå…¶æœ€å¤§çš„åœ†é”¥å¼ è§’ä¸ä¼šå¤§äº1ã€‚\nâ€œç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹â€ï¼Œå¯¹äºåœ†é”¥é¡¶éƒ¨çš„currentPoså’Œåœ†é”¥åº•éƒ¨çš„rayStartPosï¼ˆè¿™ä¸ªåœ†é”¥æ˜¯ä¸€ä¸ªå€’ç«‹çš„åœ†é”¥ï¼Œå…¶åº•éƒ¨å’Œæ¨¡å‹è¡¨é¢ç›¸å¹³ï¼‰ï¼Œå¯ä»¥é‡‡æ ·ä¸€ä¸ªç›®æ ‡ç‚¹cachedPosï¼Œå½“cachedPosçš„æ·±åº¦å°äºcurrentPosçš„æ·±åº¦æ—¶ï¼Œæ²¿ç€cachedPos - rayStartPosçš„æ–¹å‘ç§»åŠ¨cachedPosçš„ä½ç½®å¹¶ä¸€ç›´é‡‡æ ·æ‰€æœ‰åƒç´ samplePosï¼Œç›´åˆ°samplePosçš„æ·±åº¦å€¼å°äºcachedPosï¼ˆå³å°„çº¿ç©¿è¿‡é«˜åº¦å›¾å¹¶ç©¿å‡ºï¼‰ï¼Œæ ¹æ®samplePoså’ŒcurrentPoså°±èƒ½è®¡ç®—å‡ºä¸€ä¸ªåœ†é”¥çš„å¼ è§’coneRatioã€‚å¾ªç¯æ‰€æœ‰çš„åƒç´ å°±èƒ½å¾—åˆ°æœ€å°çš„åœ†é”¥å¼ è§’äº†ã€‚\nä¸ºäº†å‡å°‘å•æ¬¡è®¡ç®—çš„æ¶ˆè€—ï¼Œæœ¬æ–‡ä¼šå…ˆå°†æ•´å¼ å›¾ç‰‡åˆ†æˆNxNå¤§å°çš„åŒºåŸŸï¼Œåœ¨ä¸€æ¬¡å¾ªç¯ä¸­ä¼šè®¡ç®—æ‰€æœ‰åƒç´ å¯¹äºè¿™NxNå¤§å°çš„åŒºåŸŸçš„åœ†é”¥å¼ è§’ï¼Œå¾ªç¯æ‰€æœ‰çš„åŒºåŸŸå°±èƒ½å¾—åˆ°æœ€åçš„åœ†é”¥å¼ è§’äº†ã€‚åŒæ—¶åªéœ€è¦è®©Nç­‰äºTHREAD_GROUP_SIZEï¼Œå°±èƒ½ä½¿ç”¨group shared memoryä»…é€šè¿‡ä¸€æ¬¡é‡‡æ ·ç¼“å­˜è¿™äº›åŒºåŸŸçš„æ·±åº¦å€¼ã€‚å†æœ‰å°±æ˜¯Early Exitçš„ä¼˜åŒ–ï¼Œå½“cachedPosåœ¨è´´å›¾å¤–éƒ¨ï¼Œå½“cachedPosçš„æ·±åº¦å¤§äºcurrentPosçš„æ·±åº¦ï¼Œå½“cachedPosçš„åœ†é”¥å¼ è§’å¤§äºå½“å‰æœ€å°çš„åœ†é”¥å¼ è§’ï¼Œåœ¨è¿™äº›æƒ…å†µä¸‹å¯ä»¥ç›´æ¥ç»“æŸå‘å¤–æ­¥è¿›çš„å¾ªç¯ã€‚æ›´å¤šçš„ä¼˜åŒ–æ–¹æ³•ä¹Ÿéƒ½èƒ½åœ¨Get Relief!çš„åˆ†äº«ä¸­æ‰¾åˆ°ã€‚\nå…·ä½“çš„ä»£ç  RCSMComputeShader.compute ç”¨äºç”ŸæˆRelaxed Cone Step Mappingçš„è´´å›¾ã€‚PreProcessMainç”¨äºå¤„ç†æœ€ä¸€å¼€å§‹çš„æ·±åº¦å›¾ï¼Œé¢„å…ˆè®¾ç½®æœ€å¤§çš„coneRatioä¸º1ã€‚Early Exitæ˜¯å‡å°‘è¿ç®—æ—¶é—´çš„å…³é”®ã€‚\n#pragma kernel PreProcessMain\r#pragma kernel RCSMMain\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\rTexture2D _SourceTex;\rRWTexture2D _RW_TargetTex;\rSamplerState sampler_LinearClamp;\rfloat4 _TextureSize;\rfloat2 _CacheOffset;\r#define THREAD_GROUP_SIZE 16u\r[numthreads(8, 8, 1)]\rvoid PreProcessMain(uint3 id : SV_DispatchThreadID)\r{\ruint2 tempID = uint2(id.x, _TextureSize.y - 1.0f - id.y);\rfloat sourceTex = _SourceTex.Load(uint3(tempID, 0)).r;\r_RW_TargetTex[id.xy] = float4(sourceTex, 1.0f, 0.0f, 0.0f);\r}\rfloat3 LoadPos(uint2 coord)\r{\rreturn float3((coord + 0.5f) * _TextureSize.zw, 1.0f - _SourceTex.Load(uint3(coord, 0)).r);\r}\rfloat3 LoadPos(uint2 coord, out float coneRatio)\r{\rfloat2 sourceTex = _SourceTex.Load(uint3(coord, 0)).rg;\rconeRatio = sourceTex.y;\rreturn float3((coord + 0.5f) * _TextureSize.zw, 1.0f - sourceTex.x);\r}\rfloat3 SamplePos(float2 uv)\r{\rreturn float3(uv, 1.0f - _SourceTex.SampleLevel(sampler_LinearClamp, uv, 0.0f).r);\r}\rconst static uint CACHED_POS_SIZE = THREAD_GROUP_SIZE * THREAD_GROUP_SIZE;\rgroupshared float3 cachedPos[CACHED_POS_SIZE];\rvoid SetCachedPos(float3 pos, uint index) { cachedPos[index] = pos; }\rfloat3 GetCachedPos(uint index) { return cachedPos[index]; }\rvoid CachePos(uint2 cacheStartPos, uint cacheIndex)\r{\ruint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE);\ruint2 sampleCoord = cacheStartPos + offset;\rfloat3 pos = LoadPos(sampleCoord);\rSetCachedPos(pos, cacheIndex);\r}\r[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]\rvoid RCSMMain(uint3 groupID : SV_GroupID,\ruint3 groupThreadID : SV_GroupThreadID,\ruint groupIndex : SV_GroupIndex,\ruint3 dispatchThreadID : SV_DispatchThreadID)\r{\ruint2 cacheStartPos = uint2(_CacheOffset)*THREAD_GROUP_SIZE;\rCachePos(cacheStartPos, groupIndex);\rGroupMemoryBarrierWithGroupSync();\rfloat coneRatio;\rfloat3 currentPos = LoadPos(dispatchThreadID.xy, coneRatio);\rfloat3 rayStartPos = float3(currentPos.xy, 0.0f);\rconst int steps = 128;\rfor (uint cacheIndex = 0; cacheIndex = _TextureSize.xy)) continue;\rif (length((int2(sampleCoord.xy) - int2(dispatchThreadID.xy)) * _TextureSize.zw)  coneRatio * currentPos.z) continue;\rif (all(sampleCoord == dispatchThreadID.xy)) continue;\rfloat3 cachedPos = GetCachedPos(cacheIndex);\rfloat3 dir = cachedPos - rayStartPos;\rfloat dirXYLength = length(dir.xy);\rfloat3 normalizedDir = dir / dirXYLength;\rfloat stepLength = 1.414 * _TextureSize.z;\rfor (int j = 0; j = 1.0f) || any(cachedPos.xy currentPos.z) break;\rif (length(cachedPos.xy - currentPos.xy) / (currentPos.z - cachedPos.z)  coneRatio) break;\rfloat3 samplePos = SamplePos(cachedPos.xy);\rif (samplePos.z  currentPos.z) continue;\rfloat tempConeRatio = length(samplePos.xy - currentPos.xy) / (currentPos.z - samplePos.z);\rif (tempConeRatio RelaxedConeStepMappingGenerator.cs éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œä¿å­˜çš„æ ¼å¼æ˜¯tgaï¼Œå¦‚æœæ˜¯å­˜æˆjpgçš„è¯ä¼šæœ‰å‹ç¼©çš„é—®é¢˜ã€‚æ­¤å¤–è¿˜è¦æ³¨æ„æ·±åº¦å›¾å’Œé¢„è®¡ç®—çš„è´´å›¾å‚¨å­˜çš„ä¸æ˜¯é¢œè‰²å€¼ï¼Œå› æ­¤ä¸èƒ½å‹¾é€‰srgbï¼ŒconeRatioä¹Ÿä¸å¤ªé€‚åˆMipMapã€‚\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using Unity.EditorCoroutines.Editor; using System.IO; public class RelaxedConeStepMappingGenerator : EditorWindow { private ComputeShader computeShader; private Texture2D texture; private string savePath = \"Assets/ParallaxMapping/rcsm\"; private static readonly string suffix = \".tga\"; private Vector2Int textureSize; private RenderTexture[] rts = new RenderTexture[2]; private EditorCoroutine editorCoroutine; Rect rect { get { return new Rect(20.0f, 20.0f, position.width - 40.0f, position.height - 10.0f); } } private void EnsureRTs() { foreach (var rt in rts) { if (rt != null) rt.Release(); } rts = new RenderTexture[2]; } private void EnsureRT(ref RenderTexture rt, int width, int height) { if(rt == null || rt.width != width || rt.height != height) { if(rt != null) rt.Release(); RenderTextureDescriptor desc = new RenderTextureDescriptor { width = width, height = height, volumeDepth = 1, dimension = UnityEngine.Rendering.TextureDimension.Tex2D, depthBufferBits = 0, msaaSamples = 1, graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm, enableRandomWrite = true }; rt = new RenderTexture(desc); if (!rt.IsCreated()) rt.Create(); } } [MenuItem(\"zznewclear13/Relaxed Cone Step Mapping Generator\")] public static void Init() { RelaxedConeStepMappingGenerator window = GetWindow(\"Relaxed Cone Step Mapping Generator\"); window.Show(); window.Repaint(); window.Focus(); } private void OnGUI() { using (new GUILayout.AreaScope(rect)) { computeShader = (ComputeShader)EditorGUILayout.ObjectField(\"Compute Shader\", computeShader, typeof(ComputeShader), false); texture = (Texture2D)EditorGUILayout.ObjectField(\"Texture\", texture, typeof(Texture2D), false); savePath = EditorGUILayout.TextField(\"Save Path\", savePath); using (new EditorGUI.DisabledGroupScope(!computeShader || !texture)) { if(GUILayout.Button(\"Generate!\", new GUILayoutOption[] { GUILayout.Height(30.0f) })) { GenerateRCSM(); } } } } private static Vector4 GetTextureSize(Vector2Int textureSize) { return new Vector4(textureSize.x, textureSize.y, 1.0f / textureSize.x, 1.0f / textureSize.y); } private void PreProcess(RenderTexture target) { int kernelID = computeShader.FindKernel(\"PreProcessMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); computeShader.SetVector(\"_TextureSize\", GetTextureSize(textureSize)); computeShader.SetTexture(kernelID, \"_SourceTex\", texture); computeShader.SetTexture(kernelID, \"_RW_TargetTex\", target); computeShader.Dispatch(kernelID, Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y), 1); } private void ComputeRCSM(Vector2Int offset, RenderTexture source, RenderTexture target) { int kernelID = computeShader.FindKernel(\"RCSMMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); computeShader.SetVector(\"_TextureSize\", GetTextureSize(textureSize)); computeShader.SetVector(\"_CacheOffset\", new Vector2(offset.x, offset.y)); computeShader.SetTexture(kernelID, \"_SourceTex\", source); computeShader.SetTexture(kernelID, \"_RW_TargetTex\", target); computeShader.Dispatch(kernelID, Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y), 1); } private IEnumerator DispatchCompute() { PreProcess(rts[0]); yield return null; int kernelID = computeShader.FindKernel(\"RCSMMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); Vector2Int dispatchCount = new Vector2Int(Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y)); int fromID = 0; bool cancel = false; for (int i = 0; i for (int j = 0; j new Vector2Int(i, j), rts[fromID], rts[1 - fromID]); fromID = 1 - fromID; yield return null; } cancel = EditorUtility.DisplayCancelableProgressBar(\"In Progress...\", i + \"/\" + dispatchCount.x, (float)i / dispatchCount.x); if (cancel) break; } EditorUtility.ClearProgressBar(); if (!cancel) SaveRenderTextureToFile(rts[fromID]); } private void GenerateRCSM() { textureSize = new Vector2Int(texture.width, texture.height); EnsureRTs(); EnsureRT(ref rts[0], textureSize.x, textureSize.y); EnsureRT(ref rts[1], textureSize.x, textureSize.y); Stop(); editorCoroutine = EditorCoroutineUtility.StartCoroutine(DispatchCompute(), this); } private void SaveRenderTextureToFile(RenderTexture rt) { RenderTexture prev = RenderTexture.active; RenderTexture.active = rt; Texture2D toSave = new Texture2D(textureSize.x, textureSize.y, TextureFormat.ARGB32, false, true); toSave.ReadPixels(new Rect(0.0f, 0.0f, textureSize.x, textureSize.y), 0, 0); byte[] bytes = toSave.EncodeToTGA(); FileStream fs = File.OpenWrite(savePath + suffix); fs.Write(bytes); fs.Close(); AssetDatabase.Refresh(); TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix); ti.mipmapEnabled = false; ti.sRGBTexture = false; ti.SaveAndReimport(); Texture2D tempTexture = AssetDatabase.LoadAssetAtPath(savePath + suffix); EditorGUIUtility.PingObject(tempTexture); RenderTexture.active = prev; } private void Stop() { if (editorCoroutine != null) EditorCoroutineUtility.StopCoroutine(editorCoroutine); } private void OnDestroy() { foreach (var rt in rts) { if (rt != null) rt.Release(); } rts = new RenderTexture[2]; } } RCSMVisualizeShader.shader è®¡ç®—Parallaxçš„åœ°æ–¹åˆ†æˆä¸¤ä¸ªå¾ªç¯ï¼Œç¬¬ä¸€ä¸ªå¾ªç¯é€šè¿‡coneRatioå’Œæ·±åº¦å€¼è¿›è¡Œå…‰çº¿æ­¥è¿›ç›´åˆ°é‡‡æ ·ç‚¹åœ¨é«˜åº¦å›¾å†…éƒ¨ï¼Œç¬¬äºŒä¸ªå¾ªç¯é€šè¿‡äºŒåˆ†æ³•è·å¾—è¾ƒä¸ºå‡†ç¡®çš„uvã€‚\nShader \"zznewclear13/RCSMVisualizeShader\"\r{\rProperties\r{\r_BaseColor(\"Base Color\", Color) = (1, 1, 1, 1)\r_MainTex (\"Texture\", 2D) = \"white\" {}\r_RCSMTex(\"RCSM Texture\", 2D) = \"white\" {}\r_NormalMap(\"Normal Map\", 2D) = \"bump\" {}\r_NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1\r_ParallaxIntensity(\"Parallax Intensity\", Float) = 1\r_ParallaxIteration(\"Parallax Iteration\", Float) = 15\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\rsampler2D _MainTex;\rsampler2D _NormalMap;\rsampler2D _RCSMTex;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat _NormalIntensity;\rfloat _ParallaxIntensity;\rfloat _ParallaxIteration;\rCBUFFER_END\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 tbnView[3] : TEXCOORD1;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);\rfloat3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;\rfloat sign = (input.tangentOS.w  0.0 ? 1.0 : -1.0) * GetOddNegativeScale();\rfloat3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;\rfloat3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);\rfloat3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);\routput.positionCS = vpi.positionCS;\routput.uv = input.texcoord;\routput.tbnView[0] = float4(vni.tangentWS, viewTS.x);\routput.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);\routput.tbnView[2] = float4(vni.normalWS, viewTS.z);\rreturn output;\r}\rfloat2 sampleRCSM(float2 uv)\r{\rfloat2 rcsm = tex2D(_RCSMTex, uv).xy;\rreturn float2(1.0f - rcsm.x, rcsm.y);\r}\rfloat getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight)\r{\rfloat totalRatio = rayRatio / coneRatio + 1.0f;\rreturn (sampleHeight - rayHeight) / totalRatio;\r}\rfloat2 parallax(float2 uv, float3 view)\r{\rview.xy = -view.xy * _ParallaxIntensity;\rfloat3 samplePos = float3(uv, 0.0f);\rfloat2 rcsm = sampleRCSM(samplePos.xy);\rfloat rayRatio = length(view.xy);\rfloat coneRatio = rcsm.y;\rfloat rayHeight = samplePos.z;\rfloat sampleHeight = rcsm.x;\rfloat stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight); [unroll(30)]\rfor (int i = 0; i = rcsm.x)\r{\rsamplePos -= stepLength * view;\r}\relse if(samplePos.z = 0.0f ? 1.0f : -1.0f);\rfloat2 uv = parallax(input.uv, viewTS / z);\rfloat4 mainTex = tex2D(_MainTex, uv) * _BaseColor;\rfloat3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));\rfloat3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);\rLight mainLight = GetMainLight();\rfloat ndotl = max(0.0f, dot(n, mainLight.direction));\rfloat3 color = mainTex.rgb * mainLight.color * ndotl;\rfloat alpha = mainTex.a;\rreturn float4(color, alpha);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"}\rBlend SrcAlpha OneMinusSrcAlpha\rZWrite Off\rCull Back\rPass\r{\rHLSLPROGRAM\r#pragma vertex vert\r#pragma fragment frag\rENDHLSL\r}\r}\r}\rPOMShader.shader å¾ˆå¤§ç¨‹åº¦åœ°å‚è€ƒäº†normal vs parallaxçš„è®¡ç®—æ–¹å¼ã€‚\nShader \"zznewclear13/POMShader\"\r{\rProperties\r{\r_BaseColor(\"Base Color\", Color) = (1, 1, 1, 1)\r_MainTex (\"Texture\", 2D) = \"white\" {}\r_HeightMap(\"Height Map\", 2D) = \"white\" {}\r_NormalMap(\"Normal Map\", 2D) = \"bump\" {}\r_NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1\r_ParallaxIntensity (\"Parallax Intensity\", Float) = 1\r_ParallaxIteration (\"Parallax Iteration\", Float) = 15\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\rsampler2D _MainTex;\rsampler2D _HeightMap;\rsampler2D _NormalMap;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat _NormalIntensity;\rfloat _ParallaxIntensity;\rfloat _ParallaxIteration;\rCBUFFER_END\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 tbnView[3] : TEXCOORD1;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);\rfloat3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;\rfloat sign = (input.tangentOS.w  0.0 ? 1.0 : -1.0) * GetOddNegativeScale();\rfloat3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;\rfloat3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);\rfloat3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);\routput.positionCS = vpi.positionCS;\routput.uv = input.texcoord;\routput.tbnView[0] = float4(vni.tangentWS, viewTS.x);\routput.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);\routput.tbnView[2] = float4(vni.normalWS, viewTS.z);\rreturn output;\r}\rfloat sampleHeight(float2 uv)\r{\rreturn 1.0f - tex2D(_HeightMap, uv).r;\r}\rfloat2 parallax(float2 uv, float3 view)\r{\rfloat numLayers = _ParallaxIteration;\rfloat layerDepth = 1.0f / numLayers;\rfloat2 p = view.xy * _ParallaxIntensity;\rfloat2 deltaUVs = p / numLayers;\rfloat texd = sampleHeight(uv);\rfloat d = 0.0f;\r[unroll(30)]\rfor (; d = 0.0f ? 1.0f : -1.0f);\rfloat2 uv = parallax(input.uv, viewTS / z);\rfloat4 mainTex = tex2D(_MainTex, uv) * _BaseColor;\rfloat3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));\rfloat3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);\rLight mainLight = GetMainLight();\rfloat ndotl = max(0.0f, dot(n, mainLight.direction));\rfloat3 color = mainTex.rgb * mainLight.color * ndotl;\rfloat alpha = mainTex.a;\rreturn float4(color, alpha);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"}\rBlend SrcAlpha OneMinusSrcAlpha\rZWrite Off\rCull Back\rPass\r{\rHLSLPROGRAM\r#pragma vertex vert\r#pragma fragment frag\rENDHLSL\r}\r}\r}\råè®° å¤å¤©çœŸçš„å¥½çƒ­ï¼Œçƒ­åˆ°å¤´è„‘éƒ½ä¸æ˜¯å¾ˆæ¸…é†’äº†ï¼Œæ„Ÿè§‰RCSMåº”è¯¥è¦æ¯”POMå¥½å¾ˆå¤šæ‰å¯¹ï¼Œåœ¨è‡ªå·±çš„æµ‹è¯•ä¸­ä¹Ÿåªç¨å¾®å¥½äº†ä¸€äº›äº›ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘å“ªé‡Œæ²¡ç®—å¯¹äº†ã€‚ã€‚ã€‚ä¸è¿‡è›®å¥‡æ€ªçš„GPU Gems 3å‘è¡¨äº2007å¹´ï¼Œç›´åˆ°ä»Šå¤©æˆ‘ä¹Ÿæ²¡çœ‹åˆ°åˆ«çš„Unityä¸Šå®ç°RCSMçš„æ–‡ç« æˆ–è€…githubä»“åº“ï¼ŒUE5ä¹Ÿåªæœ‰Get Reliefè¿™ä¹ˆä¸€ä¸ªæ’ä»¶ã€‚æ˜¯å› ä¸ºæ›²é¢ç»†åˆ†å®åœ¨å¤ªå¥½ç”¨äº†çš„åŸå› å—ï¼Ÿæƒ³èµ·ä¹‹å‰çœ‹æœ€åç”Ÿè¿˜è€…2çš„æŠ€æœ¯åˆ†äº«ï¼Œé‡Œé¢å¤§é‡åœ°ä½¿ç”¨äº†é«˜åº¦å›¾ï¼Œéš¾é“ä¸»è¦æ˜¯ç”¨æ¥åšå¤šç§æè´¨çš„æ··åˆè€Œä¸æ˜¯åšè§†å·®æ•ˆæœå—ï¼Ÿ\n","wordCount":"1846","inLanguage":"en","image":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png","datePublished":"2023-07-01T19:00:00+08:00","dateModified":"2023-07-01T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</h1><div class=post-description>å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•.</div><div class=post-meta><span title="2023-07-01 19:00:00 +0800 CST">July 1, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/relaxed-cone-step-mapping-in-unity.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/RelaxedConeStepMapping.png alt="Relaxed Cone Step Mapping Cover"><p>Relaxed Cone Step Mapping Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</div></summary><div class=inner><ul><li><a href=#%e9%98%85%e8%af%bb%e5%89%8d%e6%8f%90%e7%a4%ba aria-label=é˜…è¯»å‰æç¤º>é˜…è¯»å‰æç¤º</a></li><li><a href=#%e8%a7%86%e5%b7%ae%e6%95%88%e6%9e%9c aria-label=è§†å·®æ•ˆæœ>è§†å·®æ•ˆæœ</a></li><li><a href=#%e7%94%9f%e6%88%90%e9%a2%84%e8%ae%a1%e7%ae%97%e7%9a%84%e8%b4%b4%e5%9b%be aria-label=ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾>ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç </a><ul><li><a href=#rcsmcomputeshadercompute aria-label=RCSMComputeShader.compute>RCSMComputeShader.compute</a></li><li><a href=#relaxedconestepmappinggeneratorcs aria-label=RelaxedConeStepMappingGenerator.cs>RelaxedConeStepMappingGenerator.cs</a></li><li><a href=#rcsmvisualizeshadershader aria-label=RCSMVisualizeShader.shader>RCSMVisualizeShader.shader</a></li><li><a href=#pomshadershader aria-label=POMShader.shader>POMShader.shader</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=é˜…è¯»å‰æç¤º>é˜…è¯»å‰æç¤º<a hidden class=anchor aria-hidden=true href=#é˜…è¯»å‰æç¤º>#</a></h2><p>ç”±äºæœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å‡ä¸ºLearnOpenGLç½‘ç«™ä¸Šçš„è´´å›¾ï¼Œå…¶æ³•çº¿è´´å›¾å’Œä¸€èˆ¬Unityæˆ–Unrealå¼•æ“ä¸­çš„æ³•çº¿è´´å›¾çš„Yåˆ†é‡æ˜¯ç›¸åçš„ï¼Œå› æ­¤åœ¨è®¡ç®—ä¸–ç•Œåæ ‡çš„bitangentçš„æ—¶å€™ä¼šé¢å¤–å†ä¹˜ä¸Šä¸€ä¸ªsignï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹æ˜¯ä¸éœ€è¦çš„ã€‚</p><h2 id=è§†å·®æ•ˆæœ>è§†å·®æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#è§†å·®æ•ˆæœ>#</a></h2><p>åœ¨ä¸‰è§’å½¢é¢æ•°æ¯”è¾ƒå—é™çš„æƒ…å†µä¸‹ï¼Œå¾€å¾€ä¼šè€ƒè™‘ä½¿ç”¨ä¸€å¼ é«˜åº¦å›¾ï¼Œé€šè¿‡è§†å·®çš„è®¡ç®—å»æ¸²æŸ“å‡ºä¸€ç§3Dçš„æ•ˆæœï¼ˆè™½ç„¶ç°åœ¨ç›´æ¥ç”¨æ›²é¢ç»†åˆ†Tessellationä¼¼ä¹æ˜¯ä¸€ç§æ›´æ™®éçš„ä¸”æ›´æœ‰æ•ˆçš„æ–¹æ³•ï¼‰ã€‚æœ‰ä¸¤ç§è®¡ç®—è§†å·®çš„æ–¹æ³•ï¼Œä¸€ç§å«åšParallax Occlusion Mappingï¼Œå…ˆå‡å®šé«˜åº¦çš„å±‚æ•°ï¼Œç„¶åå¯¹æ¯ä¸€å±‚è®¡ç®—å‡ºåˆé€‚çš„ä½ç½®å’Œé¢œè‰²ï¼Œä»è€Œè¾¾åˆ°3Dæ•ˆæœï¼›å¦ä¸€ç§å«åšCone Step Mappingï¼Œæ˜¯æ ¹æ®é«˜åº¦å›¾é¢„å…ˆè®¡ç®—å‡ºæ¯ä¸ªç‚¹å¯¹äºå…¶ä»–æ‰€æœ‰åƒç´ çš„æœ€å¤§çš„åœ†é”¥å¼ è§’ï¼ˆæœ‰ç‚¹åƒAOï¼‰ï¼Œæ ¹æ®åœ†é”¥å¼ è§’å¿«é€Ÿæ­¥è¿›ï¼Œæœ€åä½¿ç”¨äºŒåˆ†æ³•è®¡ç®—å‡ºæœ€ç»ˆçš„äº¤ç‚¹çš„é¢œè‰²ã€‚ç¬¬ä¸€ç§æ–¹æ³•æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„ç¼ºç‚¹ï¼Œå°±æ˜¯åœ¨è§†è§’æ¯”è¾ƒæ¥è¿‘å¹³é¢çš„æ—¶å€™ï¼Œå¦‚æœé‡‡æ ·æ¬¡æ•°ä¸æ˜¯å¾ˆé«˜ï¼Œå°±ä¼šçœ‹åˆ°ä¸€å±‚ä¸€å±‚çš„æ•ˆæœï¼Œå¯ä»¥é€šè¿‡å¯¹æœ€åä¸€æ¬¡è®¡ç®—æ·±åº¦è¿›è¡Œçº¿æ€§æ’å€¼åœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡è½»ä¸€å±‚ä¸€å±‚çš„é—®é¢˜ï¼›ç¬¬äºŒç§æ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼Œå½“é‡‡æ ·æ¬¡æ•°è¾ƒå°æ—¶ï¼Œäº§ç”Ÿçš„å›¾åƒä¼šæœ‰ä¸€å®šç¨‹åº¦çš„æ‰­æ›²ï¼Œä½†ä¸ä¼šæœ‰ä¸€å±‚ä¸€å±‚çš„æ„Ÿè§‰ï¼Œæ­¤å¤–ç›¸è¾ƒäºç¬¬ä¸€ç§ä¼šæœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œè¾ƒç»†ç‰©ä½“ä¸ä¼šè¢«è·³è¿‡ã€‚åœ¨<a href=https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-18-relaxed-cone-stepping-relief-mapping>GPU Gems 3</a>ä¸­æåˆ°äº†ä¸€ç§Cone Step Mappingçš„ä¼˜åŒ–ï¼Œå«åšRelaxed Cone Step Mappingï¼Œç›¸è¾ƒäºä¹‹å‰è®¡ç®—æœ€å¤§å¼ è§’çš„æ–¹å¼ï¼Œè¿™ç§ä¼˜åŒ–é€šè¿‡ç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œå‡å°‘äº†ä¸€å¼€å§‹åœ†é”¥æ­¥è¿›çš„æ¬¡æ•°ã€‚æœ¬æ–‡å°±ä¸»è¦ä½¿ç”¨è¿™ç§æ–¹æ³•è¿›è¡Œè®¡ç®—ï¼Œä¹Ÿè®¸å°†åœ†é”¥çš„é¡¶éƒ¨æ”¾åœ¨æ¯”å½“å‰é«˜åº¦å›¾æ›´æ·±çš„ä½ç½®èƒ½å¤Ÿæ›´åŠ å‡å°‘æ­¥è¿›çš„æ¬¡æ•°ï¼Œä¸è¿‡æˆ‘ç¨å¾®å°è¯•äº†ä¸€ä¸‹å¥½åƒæ•ˆæœå¹¶ä¸æ˜¯ç‰¹åˆ«ç†æƒ³ã€‚</p><p>Parallax Occlusion Mappingå¯ä»¥åœ¨<a href=https://learnopengl.com/Advanced-Lighting/Parallax-Mapping>Learn OpenGL</a>é‡Œæ‰¾åˆ°ä»‹ç»å’Œä¼˜åŒ–æ–¹æ¡ˆï¼Œ<a href=https://www.shadertoy.com/view/3ds3zf>Shadertoy</a>ä¸Šä¹Ÿæœ‰å¼€æºçš„ä»£ç å¯ä»¥å‚è€ƒã€‚UE5ä¸­æœ‰ä¸€ä¸ªå«<a href=https://www.unrealengine.com/marketplace/en-US/product/get-relief-rcsm-generator>Get Relief!</a>çš„æ’ä»¶ï¼Œå¯ä»¥ç”¨æ¥å¿«é€Ÿç”ŸæˆRelaxed Cone Step Mappingçš„é¢„è®¡ç®—çš„è´´å›¾ï¼Œä¹Ÿæä¾›äº†æ¸²æŸ“çš„Shaderã€‚è¿™ä¸ªæ’ä»¶çš„ä½œè€…Daniel Elliottä¹Ÿåœ¨GDC2023ä¸Šåˆ†äº«äº†<a href="https://docs.google.com/presentation/d/15XT0ZXkuJNhVLktKqzQLho6oNCUMam4C/edit?usp=sharing&ouid=112299818420501474198&rtpof=true&sd=true">åˆ¶ä½œçš„æ€è·¯</a>ï¼Œå¦‚æœé“¾æ¥æ‰“ä¸å¼€çš„è¯è¿™é‡Œè¿˜æœ‰ä¸€ä¸ª<a href=https://gdcvault.com/play/1029331/Technical-Artist-Summit-Approaching-Technical>GDC Vaultçš„é“¾æ¥</a>ã€‚</p><p>æœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å¯ä»¥åœ¨<a href=https://learnopengl.com/Advanced-Lighting/Parallax-Mapping>Learn OpenGL</a>ä¸­ç»™å‡ºçš„ä¸‹è½½é“¾æ¥ä¸­æ‰¾åˆ°ã€‚ä¸ºäº†çœ‹ä¸Šå»èˆ’æœä¸€äº›ï¼Œè¿™é‡Œå¯¹displacementè´´å›¾çš„é¢œè‰²è¿›è¡Œäº†åå‘ã€‚</p><p>ä¸‹å›¾æ˜¯ä¸¤ç§è§†å·®åšæ³•çš„æ¯”è¾ƒï¼Œå·¦è¾¹æ˜¯Parallax Occlusion Mappingï¼Œå³è¾¹æ˜¯Relaxed Cone Step Mappingï¼Œä¸¤è€…çš„é‡‡æ ·æ¬¡æ•°æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥çœ‹åˆ°POMåœ¨è¾ƒæé™çš„æƒ…å†µä¸‹ä¼šæœ‰åˆ†å±‚æ„Ÿè€ŒRCSMä¼šæœ‰æ‰­æ›²ã€‚RCSMä½¿ç”¨çš„è´´å›¾ä¹Ÿæ”¾åœ¨ä¸‹é¢äº†ï¼ŒRé€šé“æ˜¯é«˜åº¦å›¾ï¼ŒGé€šé“æ˜¯åœ†é”¥çš„å¼ è§’ã€‚æœ¬æ–‡ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ã€‚</p><p><img loading=lazy src=../images/RelaxedConeStepMapping.png#center alt="POM vs RCSM"></p><p><img loading=lazy src=../images/rcsm.png#center alt=rcsm.png></p><h2 id=ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾>ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾<a hidden class=anchor aria-hidden=true href=#ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾>#</a></h2><p>å’ŒParallax Occlusion Mappingç›´æ¥ä½¿ç”¨æ·±åº¦å›¾ä¸åŒçš„æ˜¯ï¼ŒCone Step Mappingéœ€è¦é¢„å…ˆè®¡ç®—å‡ºä¸€å¼ åœ†é”¥å¼ è§’çš„å›¾ï¼Œåœ†é”¥çš„å¼ è§’å¯ä»¥ä½¿ç”¨åœ†é”¥åº•çš„åŠå¾„é™¤ä»¥åœ†é”¥çš„é«˜æ¥è¡¨ç¤ºï¼Œè®°ä¸º<code>coneRatio</code>ã€‚æœ¬æ–‡ä¸­ä½¿ç”¨çš„æ˜¯é«˜åº¦å›¾ï¼Œä½†å®é™…è®¡ç®—ä¸­ä¼šä½¿ç”¨1å‡å»é«˜åº¦å€¼ï¼Œå¯¹åº”çš„æ˜¯ä»æ¨¡å‹è¡¨é¢åˆ°å®é™…é«˜åº¦çš„æ·±åº¦å€¼ã€‚ç”±äºæ·±åº¦å€¼åªä¼šåœ¨01ä¹‹é—´ï¼Œuvä¹Ÿåªä¼šåœ¨01ä¹‹é—´ï¼Œå› æ­¤å¯¹äºæœ€æ·±çš„ç‚¹ï¼Œå…¶æœ€å¤§çš„åœ†é”¥å¼ è§’ä¸ä¼šå¤§äº1ã€‚</p><p>â€œç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹â€ï¼Œå¯¹äºåœ†é”¥é¡¶éƒ¨çš„<code>currentPos</code>å’Œåœ†é”¥åº•éƒ¨çš„<code>rayStartPos</code>ï¼ˆè¿™ä¸ªåœ†é”¥æ˜¯ä¸€ä¸ªå€’ç«‹çš„åœ†é”¥ï¼Œå…¶åº•éƒ¨å’Œæ¨¡å‹è¡¨é¢ç›¸å¹³ï¼‰ï¼Œå¯ä»¥é‡‡æ ·ä¸€ä¸ªç›®æ ‡ç‚¹<code>cachedPos</code>ï¼Œå½“<code>cachedPos</code>çš„æ·±åº¦å°äº<code>currentPos</code>çš„æ·±åº¦æ—¶ï¼Œæ²¿ç€<code>cachedPos - rayStartPos</code>çš„æ–¹å‘ç§»åŠ¨<code>cachedPos</code>çš„ä½ç½®å¹¶ä¸€ç›´é‡‡æ ·æ‰€æœ‰åƒç´ <code>samplePos</code>ï¼Œç›´åˆ°<code>samplePos</code>çš„æ·±åº¦å€¼å°äº<code>cachedPos</code>ï¼ˆå³å°„çº¿ç©¿è¿‡é«˜åº¦å›¾å¹¶ç©¿å‡ºï¼‰ï¼Œæ ¹æ®<code>samplePos</code>å’Œ<code>currentPos</code>å°±èƒ½è®¡ç®—å‡ºä¸€ä¸ªåœ†é”¥çš„å¼ è§’<code>coneRatio</code>ã€‚å¾ªç¯æ‰€æœ‰çš„åƒç´ å°±èƒ½å¾—åˆ°æœ€å°çš„åœ†é”¥å¼ è§’äº†ã€‚</p><p>ä¸ºäº†å‡å°‘å•æ¬¡è®¡ç®—çš„æ¶ˆè€—ï¼Œæœ¬æ–‡ä¼šå…ˆå°†æ•´å¼ å›¾ç‰‡åˆ†æˆNxNå¤§å°çš„åŒºåŸŸï¼Œåœ¨ä¸€æ¬¡å¾ªç¯ä¸­ä¼šè®¡ç®—æ‰€æœ‰åƒç´ å¯¹äºè¿™NxNå¤§å°çš„åŒºåŸŸçš„åœ†é”¥å¼ è§’ï¼Œå¾ªç¯æ‰€æœ‰çš„åŒºåŸŸå°±èƒ½å¾—åˆ°æœ€åçš„åœ†é”¥å¼ è§’äº†ã€‚åŒæ—¶åªéœ€è¦è®©Nç­‰äº<code>THREAD_GROUP_SIZE</code>ï¼Œå°±èƒ½ä½¿ç”¨group shared memoryä»…é€šè¿‡ä¸€æ¬¡é‡‡æ ·ç¼“å­˜è¿™äº›åŒºåŸŸçš„æ·±åº¦å€¼ã€‚å†æœ‰å°±æ˜¯Early Exitçš„ä¼˜åŒ–ï¼Œå½“<code>cachedPos</code>åœ¨è´´å›¾å¤–éƒ¨ï¼Œå½“<code>cachedPos</code>çš„æ·±åº¦å¤§äº<code>currentPos</code>çš„æ·±åº¦ï¼Œå½“<code>cachedPos</code>çš„åœ†é”¥å¼ è§’å¤§äºå½“å‰æœ€å°çš„åœ†é”¥å¼ è§’ï¼Œåœ¨è¿™äº›æƒ…å†µä¸‹å¯ä»¥ç›´æ¥ç»“æŸå‘å¤–æ­¥è¿›çš„å¾ªç¯ã€‚æ›´å¤šçš„ä¼˜åŒ–æ–¹æ³•ä¹Ÿéƒ½èƒ½åœ¨<code>Get Relief!</code>çš„åˆ†äº«ä¸­æ‰¾åˆ°ã€‚</p><h2 id=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç <a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„ä»£ç >#</a></h2><h3 id=rcsmcomputeshadercompute>RCSMComputeShader.compute<a hidden class=anchor aria-hidden=true href=#rcsmcomputeshadercompute>#</a></h3><p>ç”¨äºç”ŸæˆRelaxed Cone Step Mappingçš„è´´å›¾ã€‚<code>PreProcessMain</code>ç”¨äºå¤„ç†æœ€ä¸€å¼€å§‹çš„æ·±åº¦å›¾ï¼Œé¢„å…ˆè®¾ç½®æœ€å¤§çš„<code>coneRatio</code>ä¸º1ã€‚Early Exitæ˜¯å‡å°‘è¿ç®—æ—¶é—´çš„å…³é”®ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel PreProcessMain
#pragma kernel RCSMMain

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

Texture2D&lt;float4&gt; _SourceTex;
RWTexture2D&lt;float4&gt; _RW_TargetTex;
SamplerState sampler_LinearClamp;
float4 _TextureSize;
float2 _CacheOffset;

#define THREAD_GROUP_SIZE 16u

[numthreads(8, 8, 1)]
void PreProcessMain(uint3 id : SV_DispatchThreadID)
{
    uint2 tempID = uint2(id.x, _TextureSize.y - 1.0f - id.y);
    float sourceTex = _SourceTex.Load(uint3(tempID, 0)).r;
    _RW_TargetTex[id.xy] = float4(sourceTex, 1.0f, 0.0f, 0.0f);
}

float3 LoadPos(uint2 coord)
{
    return float3((coord + 0.5f) * _TextureSize.zw, 1.0f - _SourceTex.Load(uint3(coord, 0)).r);
}

float3 LoadPos(uint2 coord, out float coneRatio)
{
    float2 sourceTex = _SourceTex.Load(uint3(coord, 0)).rg;
    coneRatio = sourceTex.y;
    return float3((coord + 0.5f) * _TextureSize.zw, 1.0f - sourceTex.x);
}

float3 SamplePos(float2 uv)
{
    return float3(uv, 1.0f - _SourceTex.SampleLevel(sampler_LinearClamp, uv, 0.0f).r);
}

const static uint CACHED_POS_SIZE = THREAD_GROUP_SIZE * THREAD_GROUP_SIZE;
groupshared float3 cachedPos[CACHED_POS_SIZE];
void SetCachedPos(float3 pos, uint index) { cachedPos[index] = pos; }
float3 GetCachedPos(uint index) { return cachedPos[index]; }
void CachePos(uint2 cacheStartPos, uint cacheIndex)
{
    uint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE);
    uint2 sampleCoord = cacheStartPos + offset;
    float3 pos = LoadPos(sampleCoord);
    SetCachedPos(pos, cacheIndex);
}

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void RCSMMain(uint3 groupID : SV_GroupID,
                uint3 groupThreadID : SV_GroupThreadID,
                uint groupIndex : SV_GroupIndex,
                uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint2 cacheStartPos = uint2(_CacheOffset)*THREAD_GROUP_SIZE;
    CachePos(cacheStartPos, groupIndex);
    GroupMemoryBarrierWithGroupSync();

    float coneRatio;
    float3 currentPos = LoadPos(dispatchThreadID.xy, coneRatio);
    float3 rayStartPos = float3(currentPos.xy, 0.0f);
    const int steps = 128;

    for (uint cacheIndex = 0; cacheIndex &lt; CACHED_POS_SIZE; cacheIndex++)
    {
        uint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE);
        uint2 sampleCoord = cacheStartPos + offset;
        if (any(float2(sampleCoord) &gt;= _TextureSize.xy)) continue;
        if (length((int2(sampleCoord.xy) - int2(dispatchThreadID.xy)) * _TextureSize.zw) &gt; coneRatio * currentPos.z) continue;
        if (all(sampleCoord == dispatchThreadID.xy)) continue;

        float3 cachedPos = GetCachedPos(cacheIndex);
        float3 dir = cachedPos - rayStartPos;
        float dirXYLength = length(dir.xy);
        float3 normalizedDir = dir / dirXYLength;
        float stepLength = 1.414 * _TextureSize.z;

        for (int j = 0; j &lt; steps; j++)
        {
            cachedPos += stepLength * normalizedDir;
            if (any(cachedPos.xy &gt;= 1.0f) || any(cachedPos.xy &lt;= 0.0f)) break;
            if (cachedPos.z &gt; currentPos.z) break;
            if (length(cachedPos.xy - currentPos.xy) / (currentPos.z - cachedPos.z) &gt; coneRatio) break;

            float3 samplePos = SamplePos(cachedPos.xy);
            if (samplePos.z &gt; currentPos.z) continue;
            float tempConeRatio = length(samplePos.xy - currentPos.xy) / (currentPos.z - samplePos.z);
            if (tempConeRatio &lt; coneRatio)
            {
                coneRatio = tempConeRatio;
            }
        }
    }

    _RW_TargetTex[dispatchThreadID.xy] = float4(1.0f - currentPos.z, coneRatio, 0.0f, 1.0f);
}
</code></pre><h3 id=relaxedconestepmappinggeneratorcs>RelaxedConeStepMappingGenerator.cs<a hidden class=anchor aria-hidden=true href=#relaxedconestepmappinggeneratorcs>#</a></h3><p>éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œä¿å­˜çš„æ ¼å¼æ˜¯tgaï¼Œå¦‚æœæ˜¯å­˜æˆjpgçš„è¯ä¼šæœ‰å‹ç¼©çš„é—®é¢˜ã€‚æ­¤å¤–è¿˜è¦æ³¨æ„æ·±åº¦å›¾å’Œé¢„è®¡ç®—çš„è´´å›¾å‚¨å­˜çš„ä¸æ˜¯é¢œè‰²å€¼ï¼Œå› æ­¤ä¸èƒ½å‹¾é€‰srgbï¼ŒconeRatioä¹Ÿä¸å¤ªé€‚åˆMipMapã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections;
<span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> UnityEditor;
<span style=color:#66d9ef>using</span> Unity.EditorCoroutines.Editor;
<span style=color:#66d9ef>using</span> System.IO;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RelaxedConeStepMappingGenerator</span> : EditorWindow
{
    <span style=color:#66d9ef>private</span> ComputeShader computeShader;
    <span style=color:#66d9ef>private</span> Texture2D texture;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> savePath = <span style=color:#e6db74>&#34;Assets/ParallaxMapping/rcsm&#34;</span>;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> suffix = <span style=color:#e6db74>&#34;.tga&#34;</span>;

    <span style=color:#66d9ef>private</span> Vector2Int textureSize;
    <span style=color:#66d9ef>private</span> RenderTexture[] rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
    <span style=color:#66d9ef>private</span> EditorCoroutine editorCoroutine;
    
    Rect rect
    {
        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20.0f</span>, <span style=color:#ae81ff>20.0f</span>, position.width - <span style=color:#ae81ff>40.0f</span>, position.height - <span style=color:#ae81ff>10.0f</span>); }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRTs()
    {
        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> rt <span style=color:#66d9ef>in</span> rts)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
        }
        rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height)
    {
        <span style=color:#66d9ef>if</span>(rt == <span style=color:#66d9ef>null</span> || rt.width != width || rt.height != height)
        {
            <span style=color:#66d9ef>if</span>(rt != <span style=color:#66d9ef>null</span>) rt.Release();
            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor
            {
                width = width,
                height = height,
                volumeDepth = <span style=color:#ae81ff>1</span>,
                dimension = UnityEngine.Rendering.TextureDimension.Tex2D,
                depthBufferBits = <span style=color:#ae81ff>0</span>,
                msaaSamples = <span style=color:#ae81ff>1</span>,
                graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm,
                enableRandomWrite = <span style=color:#66d9ef>true</span>
            };
            rt = <span style=color:#66d9ef>new</span> RenderTexture(desc);
            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
        }
    }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [MenuItem(&#34;zznewclear13/Relaxed Cone Step Mapping Generator&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Init()
    {
        RelaxedConeStepMappingGenerator window = GetWindow&lt;RelaxedConeStepMappingGenerator&gt;(<span style=color:#e6db74>&#34;Relaxed Cone Step Mapping Generator&#34;</span>);

        window.Show();
        window.Repaint();
        window.Focus();
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
    {
        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
        {
            computeShader = (ComputeShader)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Compute Shader&#34;</span>, computeShader, <span style=color:#66d9ef>typeof</span>(ComputeShader), <span style=color:#66d9ef>false</span>);
            texture = (Texture2D)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Texture&#34;</span>, texture, <span style=color:#66d9ef>typeof</span>(Texture2D), <span style=color:#66d9ef>false</span>);
            savePath = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Path&#34;</span>, savePath);

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!computeShader || !texture))
            {
                <span style=color:#66d9ef>if</span>(GUILayout.Button(<span style=color:#e6db74>&#34;Generate!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30.0f</span>) }))
                {
                    GenerateRCSM();
                }
            }
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Vector4 GetTextureSize(Vector2Int textureSize)
    {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(textureSize.x, textureSize.y, <span style=color:#ae81ff>1.0f</span> / textureSize.x, <span style=color:#ae81ff>1.0f</span> / textureSize.y);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PreProcess(RenderTexture target)
    {
        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;PreProcessMain&#34;</span>);
        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSize(textureSize));
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_SourceTex&#34;</span>, texture);
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, target);
        computeShader.Dispatch(kernelID,
            Mathf.CeilToInt(textureSize.x / x),
            Mathf.CeilToInt(textureSize.y / y),
            <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ComputeRCSM(Vector2Int offset, RenderTexture source, RenderTexture target)
    {
        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RCSMMain&#34;</span>);
        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSize(textureSize));
        computeShader.SetVector(<span style=color:#e6db74>&#34;_CacheOffset&#34;</span>, <span style=color:#66d9ef>new</span> Vector2(offset.x, offset.y));
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_SourceTex&#34;</span>, source);
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, target);
        computeShader.Dispatch(kernelID,
            Mathf.CeilToInt(textureSize.x / x),
            Mathf.CeilToInt(textureSize.y / y),
            <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> IEnumerator DispatchCompute()
    {
        PreProcess(rts[<span style=color:#ae81ff>0</span>]);
        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;

        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RCSMMain&#34;</span>);
        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        Vector2Int dispatchCount = <span style=color:#66d9ef>new</span> Vector2Int(Mathf.CeilToInt(textureSize.x / x),
                                                    Mathf.CeilToInt(textureSize.y / y));

        <span style=color:#66d9ef>int</span> fromID = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>bool</span> cancel = <span style=color:#66d9ef>false</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; dispatchCount.x; i++)
        {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; dispatchCount.y; j++)
            {
                ComputeRCSM(<span style=color:#66d9ef>new</span> Vector2Int(i, j), rts[fromID], rts[<span style=color:#ae81ff>1</span> - fromID]);
                fromID = <span style=color:#ae81ff>1</span> - fromID;
                <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
            }
            cancel = EditorUtility.DisplayCancelableProgressBar(<span style=color:#e6db74>&#34;In Progress...&#34;</span>, i + <span style=color:#e6db74>&#34;/&#34;</span> + dispatchCount.x, (<span style=color:#66d9ef>float</span>)i / dispatchCount.x);
            <span style=color:#66d9ef>if</span> (cancel) <span style=color:#66d9ef>break</span>;
        }
        EditorUtility.ClearProgressBar();
        <span style=color:#66d9ef>if</span> (!cancel) SaveRenderTextureToFile(rts[fromID]);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateRCSM()
    {
        textureSize = <span style=color:#66d9ef>new</span> Vector2Int(texture.width, texture.height);
        EnsureRTs();
        EnsureRT(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>0</span>], textureSize.x, textureSize.y);
        EnsureRT(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>1</span>], textureSize.x, textureSize.y);

        Stop();
        editorCoroutine = EditorCoroutineUtility.StartCoroutine(DispatchCompute(), <span style=color:#66d9ef>this</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveRenderTextureToFile(RenderTexture rt)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;

        Texture2D toSave = <span style=color:#66d9ef>new</span> Texture2D(textureSize.x, textureSize.y, TextureFormat.ARGB32, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
        toSave.ReadPixels(<span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, textureSize.x, textureSize.y), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>byte</span>[] bytes = toSave.EncodeToTGA();
        FileStream fs = File.OpenWrite(savePath + suffix);
        fs.Write(bytes);
        fs.Close();
        AssetDatabase.Refresh();

        TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix);
        ti.mipmapEnabled = <span style=color:#66d9ef>false</span>;
        ti.sRGBTexture = <span style=color:#66d9ef>false</span>;
        ti.SaveAndReimport();

        Texture2D tempTexture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(savePath + suffix);
        EditorGUIUtility.PingObject(tempTexture);

        RenderTexture.active = prev;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Stop()
    {
        <span style=color:#66d9ef>if</span> (editorCoroutine != <span style=color:#66d9ef>null</span>) EditorCoroutineUtility.StopCoroutine(editorCoroutine);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
    {
        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> rt <span style=color:#66d9ef>in</span> rts)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
        }
        rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
    }
}
</code></pre></div><h3 id=rcsmvisualizeshadershader>RCSMVisualizeShader.shader<a hidden class=anchor aria-hidden=true href=#rcsmvisualizeshadershader>#</a></h3><p>è®¡ç®—Parallaxçš„åœ°æ–¹åˆ†æˆä¸¤ä¸ªå¾ªç¯ï¼Œç¬¬ä¸€ä¸ªå¾ªç¯é€šè¿‡<code>coneRatio</code>å’Œæ·±åº¦å€¼è¿›è¡Œå…‰çº¿æ­¥è¿›ç›´åˆ°é‡‡æ ·ç‚¹åœ¨é«˜åº¦å›¾å†…éƒ¨ï¼Œç¬¬äºŒä¸ªå¾ªç¯é€šè¿‡äºŒåˆ†æ³•è·å¾—è¾ƒä¸ºå‡†ç¡®çš„uvã€‚</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/RCSMVisualizeShader&quot;
{
    Properties
    {
        _BaseColor(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _RCSMTex(&quot;RCSM Texture&quot;, 2D) = &quot;white&quot; {}
        _NormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _NormalIntensity(&quot;Normal Intensity&quot;, Range(0, 2)) = 1

        _ParallaxIntensity(&quot;Parallax Intensity&quot;, Float) = 1
        _ParallaxIteration(&quot;Parallax Iteration&quot;, Float) = 15
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

    sampler2D _MainTex;
    sampler2D _NormalMap;
    sampler2D _RCSMTex;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float _NormalIntensity;
    float _ParallaxIntensity;
    float _ParallaxIteration;
    CBUFFER_END

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float4 tangentOS    : TANGENT;
        float2 texcoord     : TEXCOORD0;
    };
    
    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float4 tbnView[3]   : TEXCOORD1;
    };
    
    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
        
        float3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;
        float sign = (input.tangentOS.w &gt; 0.0 ? 1.0 : -1.0) * GetOddNegativeScale();
        float3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;
        float3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);
        float3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);

        output.positionCS = vpi.positionCS;
        output.uv = input.texcoord;
        output.tbnView[0] = float4(vni.tangentWS, viewTS.x);
        output.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);
        output.tbnView[2] = float4(vni.normalWS, viewTS.z);
        return output;
    }

    float2 sampleRCSM(float2 uv)
    {
        float2 rcsm = tex2D(_RCSMTex, uv).xy;
        return float2(1.0f - rcsm.x, rcsm.y);
    }

    float getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight)
    {
        float totalRatio = rayRatio / coneRatio + 1.0f;
        return (sampleHeight - rayHeight) / totalRatio;
    }

    float2 parallax(float2 uv, float3 view)
    {
        view.xy = -view.xy * _ParallaxIntensity;
        float3 samplePos = float3(uv, 0.0f);
        float2 rcsm = sampleRCSM(samplePos.xy);
        float rayRatio = length(view.xy);
        float coneRatio = rcsm.y;
        float rayHeight = samplePos.z;
        float sampleHeight = rcsm.x;

        float stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);  
        [unroll(30)]
        for (int i = 0; i &lt; _ParallaxIteration; ++i)
        {
            samplePos += stepLength * view;
            rcsm = sampleRCSM(samplePos.xy);
            coneRatio = rcsm.y;
            rayHeight = samplePos.z;
            sampleHeight = rcsm.x;
            if (sampleHeight &lt;= rayHeight) break;
        
            stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);
        }

        stepLength *= 0.5f;
        samplePos -= stepLength * view;

        [unroll]
        for (int j = 0; j &lt; 5; ++j)
        {
            rcsm = sampleRCSM(samplePos.xy);
            stepLength *= 0.5f;
            if (samplePos.z &gt;= rcsm.x)
            {
                samplePos -= stepLength * view;
            }
            else if(samplePos.z &lt; rcsm.x)
            {
                samplePos += stepLength * view;
            }
        }

        return samplePos.xy;
    }


    float4 frag(Varyings input) : SV_TARGET
    {
        float3 viewTS = normalize(float3(input.tbnView[0].w, input.tbnView[1].w, input.tbnView[2].w));
        float3 tangentWS = normalize(input.tbnView[0].xyz);
        float3 bitangentWS = normalize(input.tbnView[1].xyz);
        float3 normalWS = normalize(input.tbnView[2].xyz);

        float z = max(abs(viewTS.z), 1e-5) * (viewTS.z &gt;= 0.0f ? 1.0f : -1.0f);
        float2 uv = parallax(input.uv, viewTS / z);

        float4 mainTex = tex2D(_MainTex, uv) * _BaseColor;
        float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
        
        float3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);
        Light mainLight = GetMainLight();
        float ndotl = max(0.0f, dot(n, mainLight.direction));

        float3 color = mainTex.rgb * mainLight.color * ndotl;
        float alpha = mainTex.a;
        return float4(color, alpha);
    }
            
    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot;=&quot;Transparent&quot;}
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite Off
        Cull Back

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h3 id=pomshadershader>POMShader.shader<a hidden class=anchor aria-hidden=true href=#pomshadershader>#</a></h3><p>å¾ˆå¤§ç¨‹åº¦åœ°å‚è€ƒäº†<a href=https://www.shadertoy.com/view/3ds3zf>normal vs parallax</a>çš„è®¡ç®—æ–¹å¼ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/POMShader&quot;
{
    Properties
    {
        _BaseColor(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _HeightMap(&quot;Height Map&quot;, 2D) = &quot;white&quot; {}
        _NormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _NormalIntensity(&quot;Normal Intensity&quot;, Range(0, 2)) = 1

        _ParallaxIntensity (&quot;Parallax Intensity&quot;, Float) = 1
        _ParallaxIteration (&quot;Parallax Iteration&quot;, Float) = 15
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

    sampler2D _MainTex;
    sampler2D _HeightMap;
    sampler2D _NormalMap;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float _NormalIntensity;
    float _ParallaxIntensity;
    float _ParallaxIteration;
    CBUFFER_END

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float4 tangentOS    : TANGENT;
        float2 texcoord     : TEXCOORD0;
    };
    
    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float4 tbnView[3]   : TEXCOORD1;
    };
    
    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
        
        float3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;
        float sign = (input.tangentOS.w &gt; 0.0 ? 1.0 : -1.0) * GetOddNegativeScale();
        float3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;
        float3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);
        float3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);

        output.positionCS = vpi.positionCS;
        output.uv = input.texcoord;
        output.tbnView[0] = float4(vni.tangentWS, viewTS.x);
        output.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);
        output.tbnView[2] = float4(vni.normalWS, viewTS.z);
        return output;
    }

    float sampleHeight(float2 uv)
    {
        return 1.0f - tex2D(_HeightMap, uv).r;
    }

    float2 parallax(float2 uv, float3 view)
    {
        float numLayers = _ParallaxIteration;
        float layerDepth = 1.0f / numLayers;

        float2 p = view.xy * _ParallaxIntensity;
        float2 deltaUVs = p / numLayers;

        float texd = sampleHeight(uv);
        float d = 0.0f;
        [unroll(30)]
        for (; d &lt; texd; d += layerDepth)
        {
            uv -= deltaUVs;
            texd = sampleHeight(uv);
        }

        float2 lastUVs = uv + deltaUVs;
        float after = texd - d;
        float before = sampleHeight(lastUVs) - d + layerDepth;
        float w = after / (after - before);

        return lerp(uv, lastUVs, w);
    }

    float4 frag(Varyings input) : SV_TARGET
    {
        float3 viewTS = normalize(float3(input.tbnView[0].w, input.tbnView[1].w, input.tbnView[2].w));
        float3 tangentWS = normalize(input.tbnView[0].xyz);
        float3 bitangentWS = normalize(input.tbnView[1].xyz);
        float3 normalWS = normalize(input.tbnView[2].xyz);

        float z = max(abs(viewTS.z), 1e-5) * (viewTS.z &gt;= 0.0f ? 1.0f : -1.0f);
        float2 uv = parallax(input.uv, viewTS / z);
        
        float4 mainTex = tex2D(_MainTex, uv) * _BaseColor;
        float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
        
        float3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);
        Light mainLight = GetMainLight();
        float ndotl = max(0.0f, dot(n, mainLight.direction));

        float3 color = mainTex.rgb * mainLight.color * ndotl;
        float alpha = mainTex.a;
        return float4(color, alpha);
    }
            
    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot;=&quot;Transparent&quot;}
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite Off
        Cull Back

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>å¤å¤©çœŸçš„å¥½çƒ­ï¼Œçƒ­åˆ°å¤´è„‘éƒ½ä¸æ˜¯å¾ˆæ¸…é†’äº†ï¼Œæ„Ÿè§‰RCSMåº”è¯¥è¦æ¯”POMå¥½å¾ˆå¤šæ‰å¯¹ï¼Œåœ¨è‡ªå·±çš„æµ‹è¯•ä¸­ä¹Ÿåªç¨å¾®å¥½äº†ä¸€äº›äº›ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘å“ªé‡Œæ²¡ç®—å¯¹äº†ã€‚ã€‚ã€‚ä¸è¿‡è›®å¥‡æ€ªçš„GPU Gems 3å‘è¡¨äº2007å¹´ï¼Œç›´åˆ°ä»Šå¤©æˆ‘ä¹Ÿæ²¡çœ‹åˆ°åˆ«çš„Unityä¸Šå®ç°RCSMçš„æ–‡ç« æˆ–è€…githubä»“åº“ï¼ŒUE5ä¹Ÿåªæœ‰Get Reliefè¿™ä¹ˆä¸€ä¸ªæ’ä»¶ã€‚æ˜¯å› ä¸ºæ›²é¢ç»†åˆ†å®åœ¨å¤ªå¥½ç”¨äº†çš„åŸå› å—ï¼Ÿæƒ³èµ·ä¹‹å‰çœ‹æœ€åç”Ÿè¿˜è€…2çš„æŠ€æœ¯åˆ†äº«ï¼Œé‡Œé¢å¤§é‡åœ°ä½¿ç”¨äº†é«˜åº¦å›¾ï¼Œéš¾é“ä¸»è¦æ˜¯ç”¨æ¥åšå¤šç§æè´¨çš„æ··åˆè€Œä¸æ˜¯åšè§†å·®æ•ˆæœå—ï¼Ÿ</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/relaxed-cone-step-mapping/>Relaxed Cone Step Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/parallax-occlusion-mapping/>Parallax Occlusion Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-high-quality-bloom/><span class=title>Â« Prev</span><br><span>Unityçš„é«˜è´¨é‡çš„Bloomæ•ˆæœ</span></a>
<a class=next href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><span class=title>Next Â»</span><br><span>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>