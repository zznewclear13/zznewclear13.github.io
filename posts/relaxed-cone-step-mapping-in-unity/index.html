<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在Unity里实现松散圆锥步进Relaxed Cone Step Mapping | ZZNEWCLEAR13</title><meta name=keywords content="Relaxed Cone Step Mapping,Parallax Occlusion Mapping,Compute Shader"><meta name=description content="对比一下RCSM和POM的效果和实现方法."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.min.e1da4ea728c11c74c3956764ea9040885d7c23ab4d30fea8cd5a8ea4071a3f6d.css integrity="sha256-4dpOpyjBHHTDlWdk6pBAiF18I6tNMP6ozVqOpAcaP20=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="在Unity里实现松散圆锥步进Relaxed Cone Step Mapping"><meta property="og:description" content="对比一下RCSM和POM的效果和实现方法."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-01T19:00:00+08:00"><meta property="article:modified_time" content="2023-07-01T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png"><meta name=twitter:title content="在Unity里实现松散圆锥步进Relaxed Cone Step Mapping"><meta name=twitter:description content="对比一下RCSM和POM的效果和实现方法."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在Unity里实现松散圆锥步进Relaxed Cone Step Mapping","item":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在Unity里实现松散圆锥步进Relaxed Cone Step Mapping","name":"在Unity里实现松散圆锥步进Relaxed Cone Step Mapping","description":"对比一下RCSM和POM的效果和实现方法.","keywords":["Relaxed Cone Step Mapping","Parallax Occlusion Mapping","Compute Shader"],"articleBody":"视差效果 在三角形面数比较受限的情况下，往往会考虑使用一张高度图，通过视差的计算去渲染出一种3D的效果（虽然现在直接用曲面细分Tessellation似乎是一种更普遍的且更有效的方法）。有两种计算视差的方法，一种叫做Parallax Occlusion Mapping，先假定高度的层数，然后对每一层计算出合适的位置和颜色，从而达到3D效果；另一种叫做Cone Step Mapping，是根据高度图预先计算出每个点对于其他所有像素的最大的圆锥张角（有点像AO），根据圆锥张角快速步进，最后使用二分法计算出最终的交点的颜色。第一种方法有一个比较大的缺点，就是在视角比较接近平面的时候，如果采样次数不是很高，就会看到一层一层的效果，可以通过对最后一次计算深度进行线性插值在一定程度上减轻一层一层的问题；第二种方法的缺点是，当采样次数较小时，产生的图像会有一定程度的扭曲，但不会有一层一层的感觉，此外相较于第一种会有一个优点，较细物体不会被跳过。在GPU Gems 3中提到了一种Cone Step Mapping的优化，叫做Relaxed Cone Step Mapping，相较于之前计算最大张角的方式，这种优化通过确保通过圆锥的射线与圆锥内部的高度图至多只有一个交点，减少了一开始圆锥步进的次数。本文就主要使用这种方法进行计算，也许将圆锥的顶部放在比当前高度图更深的位置能够更加减少步进的次数，不过我稍微尝试了一下好像效果并不是特别理想。\nParallax Occlusion Mapping可以在Learn OpenGL里找到介绍和优化方案，Shadertoy上也有开源的代码可以参考。UE5中有一个叫Get Relief!的插件，可以用来快速生成Relaxed Cone Step Mapping的预计算的贴图，也提供了渲染的Shader。这个插件的作者Daniel Elliott也在GDC2023上分享了制作的思路，如果链接打不开的话这里还有一个GDC Vault的链接。\n本文使用的贴图可以在Learn OpenGL中给出的下载链接中找到。为了看上去舒服一些，这里对displacement贴图的颜色进行了反向。\n下图是两种视差做法的比较，左边是Parallax Occlusion Mapping，右边是Relaxed Cone Step Mapping，两者的采样次数是相同的，可以看到POM在较极限的情况下会有分层感而RCSM会有扭曲。RCSM使用的贴图也放在下面了，R通道是高度图，G通道是圆锥的张角。本文使用的是Unity 2021.3.19f1c1。\n生成预计算的贴图 和Parallax Occlusion Mapping直接使用深度图不同的是，Cone Step Mapping需要预先计算出一张圆锥张角的图，圆锥的张角可以使用圆锥底的半径除以圆锥的高来表示，记为coneRatio。本文中使用的是高度图，但实际计算中会使用1减去高度值，对应的是从模型表面到实际高度的深度值。由于深度值只会在01之间，uv也只会在01之间，因此对于最深的点，其最大的圆锥张角不会大于1。\n“确保通过圆锥的射线与圆锥内部的高度图至多只有一个交点”，对于圆锥顶部的currentPos和圆锥底部的rayStartPos（这个圆锥是一个倒立的圆锥，其底部和模型表面相平），可以采样一个目标点cachedPos，当cachedPos的深度小于currentPos的深度时，沿着cachedPos - rayStartPos的方向移动cachedPos的位置并一直采样所有像素samplePos，直到samplePos的深度值小于cachedPos（即射线穿过高度图并穿出），根据samplePos和currentPos就能计算出一个圆锥的张角coneRatio。循环所有的像素就能得到最小的圆锥张角了。\n为了减少单次计算的消耗，本文会先将整张图片分成NxN大小的区域，在一次循环中会计算所有像素对于这NxN大小的区域的圆锥张角，循环所有的区域就能得到最后的圆锥张角了。同时只需要让N等于THREAD_GROUP_SIZE，就能使用group shared memory仅通过一次采样缓存这些区域的深度值。再有就是Early Exit的优化，当cachedPos在贴图外部，当cachedPos的深度大于currentPos的深度，当cachedPos的圆锥张角大于当前最小的圆锥张角，在这些情况下可以直接结束向外步进的循环。更多的优化方法也都能在Get Relief!的分享中找到。\n具体的代码 RCSMComputeShader.compute 用于生成Relaxed Cone Step Mapping的贴图。PreProcessMain用于处理最一开始的深度图，预先设置最大的coneRatio为1。Early Exit是减少运算时间的关键。\n#pragma kernel PreProcessMain\r#pragma kernel RCSMMain\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\rTexture2D _SourceTex;\rRWTexture2D _RW_TargetTex;\rSamplerState sampler_LinearClamp;\rfloat4 _TextureSize;\rfloat2 _CacheOffset;\r#define THREAD_GROUP_SIZE 16u\r[numthreads(8, 8, 1)]\rvoid PreProcessMain(uint3 id : SV_DispatchThreadID)\r{\ruint2 tempID = uint2(id.x, _TextureSize.y - 1.0f - id.y);\rfloat sourceTex = _SourceTex.Load(uint3(tempID, 0)).r;\r_RW_TargetTex[id.xy] = float4(sourceTex, 1.0f, 0.0f, 0.0f);\r}\rfloat3 LoadPos(uint2 coord)\r{\rreturn float3((coord + 0.5f) * _TextureSize.zw, 1.0f - _SourceTex.Load(uint3(coord, 0)).r);\r}\rfloat3 LoadPos(uint2 coord, out float coneRatio)\r{\rfloat2 sourceTex = _SourceTex.Load(uint3(coord, 0)).rg;\rconeRatio = sourceTex.y;\rreturn float3((coord + 0.5f) * _TextureSize.zw, 1.0f - sourceTex.x);\r}\rfloat3 SamplePos(float2 uv)\r{\rreturn float3(uv, 1.0f - _SourceTex.SampleLevel(sampler_LinearClamp, uv, 0.0f).r);\r}\rconst static uint CACHED_POS_SIZE = THREAD_GROUP_SIZE * THREAD_GROUP_SIZE;\rgroupshared float3 cachedPos[CACHED_POS_SIZE];\rvoid SetCachedPos(float3 pos, uint index) { cachedPos[index] = pos; }\rfloat3 GetCachedPos(uint index) { return cachedPos[index]; }\rvoid CachePos(uint2 cacheStartPos, uint cacheIndex)\r{\ruint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE);\ruint2 sampleCoord = cacheStartPos + offset;\rfloat3 pos = LoadPos(sampleCoord);\rSetCachedPos(pos, cacheIndex);\r}\r[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]\rvoid RCSMMain(uint3 groupID : SV_GroupID,\ruint3 groupThreadID : SV_GroupThreadID,\ruint groupIndex : SV_GroupIndex,\ruint3 dispatchThreadID : SV_DispatchThreadID)\r{\ruint2 cacheStartPos = uint2(_CacheOffset)*THREAD_GROUP_SIZE;\rCachePos(cacheStartPos, groupIndex);\rGroupMemoryBarrierWithGroupSync();\rfloat coneRatio;\rfloat3 currentPos = LoadPos(dispatchThreadID.xy, coneRatio);\rfloat3 rayStartPos = float3(currentPos.xy, 0.0f);\rconst int steps = 128;\rfor (uint cacheIndex = 0; cacheIndex = _TextureSize.xy)) continue;\rif (length((int2(sampleCoord.xy) - int2(dispatchThreadID.xy)) * _TextureSize.zw)  coneRatio * currentPos.z) continue;\rif (all(sampleCoord == dispatchThreadID.xy)) continue;\rfloat3 cachedPos = GetCachedPos(cacheIndex);\rfloat3 dir = cachedPos - rayStartPos;\rfloat dirXYLength = length(dir.xy);\rfloat3 normalizedDir = dir / dirXYLength;\rfloat stepLength = 1.414 * _TextureSize.z;\rfor (int j = 0; j = 1.0f) || any(cachedPos.xy currentPos.z) break;\rif (length(cachedPos.xy - currentPos.xy) / (currentPos.z - cachedPos.z)  coneRatio) break;\rfloat3 samplePos = SamplePos(cachedPos.xy);\rif (samplePos.z  currentPos.z) continue;\rfloat tempConeRatio = length(samplePos.xy - currentPos.xy) / (currentPos.z - samplePos.z);\rif (tempConeRatio RelaxedConeStepMappingGenerator.cs 需要注意的是这里保存的格式是tga，如果是存成jpg的话会有压缩的问题。此外还要注意深度图和预计算的贴图储存的不是颜色值，因此不能勾选srgb，coneRatio也不太适合MipMap。\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using Unity.EditorCoroutines.Editor; using System.IO; public class RelaxedConeStepMappingGenerator : EditorWindow { private ComputeShader computeShader; private Texture2D texture; private string savePath = \"Assets/ParallaxMapping/rcsm\"; private static readonly string suffix = \".tga\"; private Vector2Int textureSize; private RenderTexture[] rts = new RenderTexture[2]; private EditorCoroutine editorCoroutine; Rect rect { get { return new Rect(20.0f, 20.0f, position.width - 40.0f, position.height - 10.0f); } } private void EnsureRTs() { foreach (var rt in rts) { if (rt != null) rt.Release(); } rts = new RenderTexture[2]; } private void EnsureRT(ref RenderTexture rt, int width, int height) { if(rt == null || rt.width != width || rt.height != height) { if(rt != null) rt.Release(); RenderTextureDescriptor desc = new RenderTextureDescriptor { width = width, height = height, volumeDepth = 1, dimension = UnityEngine.Rendering.TextureDimension.Tex2D, depthBufferBits = 0, msaaSamples = 1, graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm, enableRandomWrite = true }; rt = new RenderTexture(desc); if (!rt.IsCreated()) rt.Create(); } } [MenuItem(\"zznewclear13/Relaxed Cone Step Mapping Generator\")] public static void Init() { RelaxedConeStepMappingGenerator window = GetWindow(\"Relaxed Cone Step Mapping Generator\"); window.Show(); window.Repaint(); window.Focus(); } private void OnGUI() { using (new GUILayout.AreaScope(rect)) { computeShader = (ComputeShader)EditorGUILayout.ObjectField(\"Compute Shader\", computeShader, typeof(ComputeShader), false); texture = (Texture2D)EditorGUILayout.ObjectField(\"Texture\", texture, typeof(Texture2D), false); savePath = EditorGUILayout.TextField(\"Save Path\", savePath); using (new EditorGUI.DisabledGroupScope(!computeShader || !texture)) { if(GUILayout.Button(\"Generate!\", new GUILayoutOption[] { GUILayout.Height(30.0f) })) { GenerateRCSM(); } } } } private static Vector4 GetTextureSize(Vector2Int textureSize) { return new Vector4(textureSize.x, textureSize.y, 1.0f / textureSize.x, 1.0f / textureSize.y); } private void PreProcess(RenderTexture target) { int kernelID = computeShader.FindKernel(\"PreProcessMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); computeShader.SetVector(\"_TextureSize\", GetTextureSize(textureSize)); computeShader.SetTexture(kernelID, \"_SourceTex\", texture); computeShader.SetTexture(kernelID, \"_RW_TargetTex\", target); computeShader.Dispatch(kernelID, Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y), 1); } private void ComputeRCSM(Vector2Int offset, RenderTexture source, RenderTexture target) { int kernelID = computeShader.FindKernel(\"RCSMMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); computeShader.SetVector(\"_TextureSize\", GetTextureSize(textureSize)); computeShader.SetVector(\"_CacheOffset\", new Vector2(offset.x, offset.y)); computeShader.SetTexture(kernelID, \"_SourceTex\", source); computeShader.SetTexture(kernelID, \"_RW_TargetTex\", target); computeShader.Dispatch(kernelID, Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y), 1); } private IEnumerator DispatchCompute() { PreProcess(rts[0]); yield return null; int kernelID = computeShader.FindKernel(\"RCSMMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); Vector2Int dispatchCount = new Vector2Int(Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y)); int fromID = 0; bool cancel = false; for (int i = 0; i for (int j = 0; j new Vector2Int(i, j), rts[fromID], rts[1 - fromID]); fromID = 1 - fromID; yield return null; } cancel = EditorUtility.DisplayCancelableProgressBar(\"In Progress...\", i + \"/\" + dispatchCount.x, (float)i / dispatchCount.x); if (cancel) break; } EditorUtility.ClearProgressBar(); if (!cancel) SaveRenderTextureToFile(rts[fromID]); } private void GenerateRCSM() { textureSize = new Vector2Int(texture.width, texture.height); EnsureRTs(); EnsureRT(ref rts[0], textureSize.x, textureSize.y); EnsureRT(ref rts[1], textureSize.x, textureSize.y); Stop(); editorCoroutine = EditorCoroutineUtility.StartCoroutine(DispatchCompute(), this); } private void SaveRenderTextureToFile(RenderTexture rt) { RenderTexture prev = RenderTexture.active; RenderTexture.active = rt; Texture2D toSave = new Texture2D(textureSize.x, textureSize.y, TextureFormat.ARGB32, false, true); toSave.ReadPixels(new Rect(0.0f, 0.0f, textureSize.x, textureSize.y), 0, 0); byte[] bytes = toSave.EncodeToTGA(); FileStream fs = File.OpenWrite(savePath + suffix); fs.Write(bytes); fs.Close(); AssetDatabase.Refresh(); TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix); ti.mipmapEnabled = false; ti.sRGBTexture = false; ti.SaveAndReimport(); Texture2D tempTexture = AssetDatabase.LoadAssetAtPath(savePath + suffix); EditorGUIUtility.PingObject(tempTexture); RenderTexture.active = prev; } private void Stop() { if (editorCoroutine != null) EditorCoroutineUtility.StopCoroutine(editorCoroutine); } private void OnDestroy() { foreach (var rt in rts) { if (rt != null) rt.Release(); } rts = new RenderTexture[2]; } } RCSMVisualizeShader.shader 计算Parallax的地方分成两个循环，第一个循环通过coneRatio和深度值进行光线步进直到采样点在高度图内部，第二个循环通过二分法获得较为准确的uv。\nShader \"zznewclear13/RCSMVisualizeShader\"\r{\rProperties\r{\r_BaseColor(\"Base Color\", Color) = (1, 1, 1, 1)\r_MainTex (\"Texture\", 2D) = \"white\" {}\r_RCSMTex(\"RCSM Texture\", 2D) = \"white\" {}\r_NormalMap(\"Normal Map\", 2D) = \"bump\" {}\r_NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1\r_ParallaxIntensity(\"Parallax Intensity\", Float) = 1\r_ParallaxIteration(\"Parallax Iteration\", Float) = 15\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\rsampler2D _MainTex;\rsampler2D _NormalMap;\rsampler2D _RCSMTex;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat _NormalIntensity;\rfloat _ParallaxIntensity;\rfloat _ParallaxIteration;\rCBUFFER_END\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 tbnView[3] : TEXCOORD1;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);\rfloat3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;\rfloat sign = (input.tangentOS.w  0.0 ? 1.0 : -1.0) * GetOddNegativeScale();\rfloat3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;\rfloat3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);\rfloat3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);\routput.positionCS = vpi.positionCS;\routput.uv = input.texcoord;\routput.tbnView[0] = float4(vni.tangentWS, viewTS.x);\routput.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);\routput.tbnView[2] = float4(vni.normalWS, viewTS.z);\rreturn output;\r}\rfloat2 sampleRCSM(float2 uv)\r{\rfloat2 rcsm = tex2D(_RCSMTex, uv).xy;\rreturn float2(1.0f - rcsm.x, rcsm.y);\r}\rfloat getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight)\r{\rfloat totalRatio = rayRatio / coneRatio + 1.0f;\rreturn (sampleHeight - rayHeight) / totalRatio;\r}\rfloat2 parallax(float2 uv, float3 view)\r{\rview.xy = -view.xy * _ParallaxIntensity;\rfloat3 samplePos = float3(uv, 0.0f);\rfloat2 rcsm = sampleRCSM(samplePos.xy);\rfloat rayRatio = length(view.xy);\rfloat coneRatio = rcsm.y;\rfloat rayHeight = samplePos.z;\rfloat sampleHeight = rcsm.x;\rfloat stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight); [unroll(30)]\rfor (int i = 0; i = rcsm.x)\r{\rsamplePos -= stepLength * view;\r}\relse if(samplePos.z = 0.0f ? 1.0f : -1.0f);\rfloat2 uv = parallax(input.uv, viewTS / z);\rfloat4 mainTex = tex2D(_MainTex, uv) * _BaseColor;\rfloat3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));\rfloat3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);\rLight mainLight = GetMainLight();\rfloat ndotl = max(0.0f, dot(n, mainLight.direction));\rfloat3 color = mainTex.rgb * mainLight.color * ndotl;\rfloat alpha = mainTex.a;\rreturn float4(color, alpha);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"}\rBlend SrcAlpha OneMinusSrcAlpha\rZWrite Off\rCull Back\rPass\r{\rHLSLPROGRAM\r#pragma vertex vert\r#pragma fragment frag\rENDHLSL\r}\r}\r}\rPOMShader.shader 很大程度地参考了normal vs parallax的计算方式。\nShader \"zznewclear13/POMShader\"\r{\rProperties\r{\r_BaseColor(\"Base Color\", Color) = (1, 1, 1, 1)\r_MainTex (\"Texture\", 2D) = \"white\" {}\r_HeightMap(\"Height Map\", 2D) = \"white\" {}\r_NormalMap(\"Normal Map\", 2D) = \"bump\" {}\r_NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1\r_ParallaxIntensity (\"Parallax Intensity\", Float) = 1\r_ParallaxIteration (\"Parallax Iteration\", Float) = 15\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\rsampler2D _MainTex;\rsampler2D _HeightMap;\rsampler2D _NormalMap;\rCBUFFER_START(UnityPerMaterial)\rfloat4 _BaseColor;\rfloat _NormalIntensity;\rfloat _ParallaxIntensity;\rfloat _ParallaxIteration;\rCBUFFER_END\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat3 normalOS : NORMAL;\rfloat4 tangentOS : TANGENT;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 uv : TEXCOORD0;\rfloat4 tbnView[3] : TEXCOORD1;\r};\rVaryings vert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);\rVertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);\rfloat3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;\rfloat sign = (input.tangentOS.w  0.0 ? 1.0 : -1.0) * GetOddNegativeScale();\rfloat3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;\rfloat3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);\rfloat3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);\routput.positionCS = vpi.positionCS;\routput.uv = input.texcoord;\routput.tbnView[0] = float4(vni.tangentWS, viewTS.x);\routput.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);\routput.tbnView[2] = float4(vni.normalWS, viewTS.z);\rreturn output;\r}\rfloat sampleHeight(float2 uv)\r{\rreturn 1.0f - tex2D(_HeightMap, uv).r;\r}\rfloat2 parallax(float2 uv, float3 view)\r{\rfloat numLayers = _ParallaxIteration;\rfloat layerDepth = 1.0f / numLayers;\rfloat2 p = view.xy * _ParallaxIntensity;\rfloat2 deltaUVs = p / numLayers;\rfloat texd = sampleHeight(uv);\rfloat d = 0.0f;\r[unroll(30)]\rfor (; d = 0.0f ? 1.0f : -1.0f);\rfloat2 uv = parallax(input.uv, viewTS / z);\rfloat4 mainTex = tex2D(_MainTex, uv) * _BaseColor;\rfloat3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));\rfloat3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);\rLight mainLight = GetMainLight();\rfloat ndotl = max(0.0f, dot(n, mainLight.direction));\rfloat3 color = mainTex.rgb * mainLight.color * ndotl;\rfloat alpha = mainTex.a;\rreturn float4(color, alpha);\r}\rENDHLSL\rSubShader\r{\rTags{ \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"}\rBlend SrcAlpha OneMinusSrcAlpha\rZWrite Off\rCull Back\rPass\r{\rHLSLPROGRAM\r#pragma vertex vert\r#pragma fragment frag\rENDHLSL\r}\r}\r}\r后记 夏天真的好热，热到头脑都不是很清醒了，感觉RCSM应该要比POM好很多才对，在自己的测试中也只稍微好了一些些，当然也有可能是我哪里没算对了。。。不过蛮奇怪的GPU Gems 3发表于2007年，直到今天我也没看到别的Unity上实现RCSM的文章或者github仓库，UE5也只有Get Relief这么一个插件。是因为曲面细分实在太好用了的原因吗？想起之前看最后生还者2的技术分享，里面大量地使用了高度图，难道主要是用来做多种材质的混合而不是做视差效果吗？\n","wordCount":"1844","inLanguage":"en","image":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png","datePublished":"2023-07-01T19:00:00+08:00","dateModified":"2023-07-01T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>在Unity里实现松散圆锥步进Relaxed Cone Step Mapping</h1><div class=post-description>对比一下RCSM和POM的效果和实现方法.</div><div class=post-meta>July 1, 2023&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/relaxed-cone-step-mapping-in-unity.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/RelaxedConeStepMapping.png alt="Relaxed Cone Step Mapping Cover"><p>Relaxed Cone Step Mapping Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在Unity里实现松散圆锥步进Relaxed Cone Step Mapping</div></summary><div class=inner><ul><li><a href=#%e8%a7%86%e5%b7%ae%e6%95%88%e6%9e%9c aria-label=视差效果>视差效果</a></li><li><a href=#%e7%94%9f%e6%88%90%e9%a2%84%e8%ae%a1%e7%ae%97%e7%9a%84%e8%b4%b4%e5%9b%be aria-label=生成预计算的贴图>生成预计算的贴图</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=具体的代码>具体的代码</a><ul><li><a href=#rcsmcomputeshadercompute aria-label=RCSMComputeShader.compute>RCSMComputeShader.compute</a></li><li><a href=#relaxedconestepmappinggeneratorcs aria-label=RelaxedConeStepMappingGenerator.cs>RelaxedConeStepMappingGenerator.cs</a></li><li><a href=#rcsmvisualizeshadershader aria-label=RCSMVisualizeShader.shader>RCSMVisualizeShader.shader</a></li><li><a href=#pomshadershader aria-label=POMShader.shader>POMShader.shader</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=视差效果>视差效果<a hidden class=anchor aria-hidden=true href=#视差效果>#</a></h2><p>在三角形面数比较受限的情况下，往往会考虑使用一张高度图，通过视差的计算去渲染出一种3D的效果（虽然现在直接用曲面细分Tessellation似乎是一种更普遍的且更有效的方法）。有两种计算视差的方法，一种叫做Parallax Occlusion Mapping，先假定高度的层数，然后对每一层计算出合适的位置和颜色，从而达到3D效果；另一种叫做Cone Step Mapping，是根据高度图预先计算出每个点对于其他所有像素的最大的圆锥张角（有点像AO），根据圆锥张角快速步进，最后使用二分法计算出最终的交点的颜色。第一种方法有一个比较大的缺点，就是在视角比较接近平面的时候，如果采样次数不是很高，就会看到一层一层的效果，可以通过对最后一次计算深度进行线性插值在一定程度上减轻一层一层的问题；第二种方法的缺点是，当采样次数较小时，产生的图像会有一定程度的扭曲，但不会有一层一层的感觉，此外相较于第一种会有一个优点，较细物体不会被跳过。在<a href=https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-18-relaxed-cone-stepping-relief-mapping>GPU Gems 3</a>中提到了一种Cone Step Mapping的优化，叫做Relaxed Cone Step Mapping，相较于之前计算最大张角的方式，这种优化通过确保通过圆锥的射线与圆锥内部的高度图至多只有一个交点，减少了一开始圆锥步进的次数。本文就主要使用这种方法进行计算，也许将圆锥的顶部放在比当前高度图更深的位置能够更加减少步进的次数，不过我稍微尝试了一下好像效果并不是特别理想。</p><p>Parallax Occlusion Mapping可以在<a href=https://learnopengl.com/Advanced-Lighting/Parallax-Mapping>Learn OpenGL</a>里找到介绍和优化方案，<a href=https://www.shadertoy.com/view/3ds3zf>Shadertoy</a>上也有开源的代码可以参考。UE5中有一个叫<a href=https://www.unrealengine.com/marketplace/en-US/product/get-relief-rcsm-generator>Get Relief!</a>的插件，可以用来快速生成Relaxed Cone Step Mapping的预计算的贴图，也提供了渲染的Shader。这个插件的作者Daniel Elliott也在GDC2023上分享了<a href="https://docs.google.com/presentation/d/15XT0ZXkuJNhVLktKqzQLho6oNCUMam4C/edit?usp=sharing&ouid=112299818420501474198&rtpof=true&sd=true">制作的思路</a>，如果链接打不开的话这里还有一个<a href=https://gdcvault.com/play/1029331/Technical-Artist-Summit-Approaching-Technical>GDC Vault的链接</a>。</p><p>本文使用的贴图可以在<a href=https://learnopengl.com/Advanced-Lighting/Parallax-Mapping>Learn OpenGL</a>中给出的下载链接中找到。为了看上去舒服一些，这里对displacement贴图的颜色进行了反向。</p><p>下图是两种视差做法的比较，左边是Parallax Occlusion Mapping，右边是Relaxed Cone Step Mapping，两者的采样次数是相同的，可以看到POM在较极限的情况下会有分层感而RCSM会有扭曲。RCSM使用的贴图也放在下面了，R通道是高度图，G通道是圆锥的张角。本文使用的是Unity 2021.3.19f1c1。</p><p><img loading=lazy src=../images/RelaxedConeStepMapping.png#center alt="POM vs RCSM"></p><p><img loading=lazy src=../images/rcsm.png#center alt=rcsm.png></p><h2 id=生成预计算的贴图>生成预计算的贴图<a hidden class=anchor aria-hidden=true href=#生成预计算的贴图>#</a></h2><p>和Parallax Occlusion Mapping直接使用深度图不同的是，Cone Step Mapping需要预先计算出一张圆锥张角的图，圆锥的张角可以使用圆锥底的半径除以圆锥的高来表示，记为<code>coneRatio</code>。本文中使用的是高度图，但实际计算中会使用1减去高度值，对应的是从模型表面到实际高度的深度值。由于深度值只会在01之间，uv也只会在01之间，因此对于最深的点，其最大的圆锥张角不会大于1。</p><p>“确保通过圆锥的射线与圆锥内部的高度图至多只有一个交点”，对于圆锥顶部的<code>currentPos</code>和圆锥底部的<code>rayStartPos</code>（这个圆锥是一个倒立的圆锥，其底部和模型表面相平），可以采样一个目标点<code>cachedPos</code>，当<code>cachedPos</code>的深度小于<code>currentPos</code>的深度时，沿着<code>cachedPos - rayStartPos</code>的方向移动<code>cachedPos</code>的位置并一直采样所有像素<code>samplePos</code>，直到<code>samplePos</code>的深度值小于<code>cachedPos</code>（即射线穿过高度图并穿出），根据<code>samplePos</code>和<code>currentPos</code>就能计算出一个圆锥的张角<code>coneRatio</code>。循环所有的像素就能得到最小的圆锥张角了。</p><p>为了减少单次计算的消耗，本文会先将整张图片分成NxN大小的区域，在一次循环中会计算所有像素对于这NxN大小的区域的圆锥张角，循环所有的区域就能得到最后的圆锥张角了。同时只需要让N等于<code>THREAD_GROUP_SIZE</code>，就能使用group shared memory仅通过一次采样缓存这些区域的深度值。再有就是Early Exit的优化，当<code>cachedPos</code>在贴图外部，当<code>cachedPos</code>的深度大于<code>currentPos</code>的深度，当<code>cachedPos</code>的圆锥张角大于当前最小的圆锥张角，在这些情况下可以直接结束向外步进的循环。更多的优化方法也都能在<code>Get Relief!</code>的分享中找到。</p><h2 id=具体的代码>具体的代码<a hidden class=anchor aria-hidden=true href=#具体的代码>#</a></h2><h3 id=rcsmcomputeshadercompute>RCSMComputeShader.compute<a hidden class=anchor aria-hidden=true href=#rcsmcomputeshadercompute>#</a></h3><p>用于生成Relaxed Cone Step Mapping的贴图。<code>PreProcessMain</code>用于处理最一开始的深度图，预先设置最大的<code>coneRatio</code>为1。Early Exit是减少运算时间的关键。</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel PreProcessMain
#pragma kernel RCSMMain

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

Texture2D&lt;float4&gt; _SourceTex;
RWTexture2D&lt;float4&gt; _RW_TargetTex;
SamplerState sampler_LinearClamp;
float4 _TextureSize;
float2 _CacheOffset;

#define THREAD_GROUP_SIZE 16u

[numthreads(8, 8, 1)]
void PreProcessMain(uint3 id : SV_DispatchThreadID)
{
    uint2 tempID = uint2(id.x, _TextureSize.y - 1.0f - id.y);
    float sourceTex = _SourceTex.Load(uint3(tempID, 0)).r;
    _RW_TargetTex[id.xy] = float4(sourceTex, 1.0f, 0.0f, 0.0f);
}

float3 LoadPos(uint2 coord)
{
    return float3((coord + 0.5f) * _TextureSize.zw, 1.0f - _SourceTex.Load(uint3(coord, 0)).r);
}

float3 LoadPos(uint2 coord, out float coneRatio)
{
    float2 sourceTex = _SourceTex.Load(uint3(coord, 0)).rg;
    coneRatio = sourceTex.y;
    return float3((coord + 0.5f) * _TextureSize.zw, 1.0f - sourceTex.x);
}

float3 SamplePos(float2 uv)
{
    return float3(uv, 1.0f - _SourceTex.SampleLevel(sampler_LinearClamp, uv, 0.0f).r);
}

const static uint CACHED_POS_SIZE = THREAD_GROUP_SIZE * THREAD_GROUP_SIZE;
groupshared float3 cachedPos[CACHED_POS_SIZE];
void SetCachedPos(float3 pos, uint index) { cachedPos[index] = pos; }
float3 GetCachedPos(uint index) { return cachedPos[index]; }
void CachePos(uint2 cacheStartPos, uint cacheIndex)
{
    uint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE);
    uint2 sampleCoord = cacheStartPos + offset;
    float3 pos = LoadPos(sampleCoord);
    SetCachedPos(pos, cacheIndex);
}

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void RCSMMain(uint3 groupID : SV_GroupID,
                uint3 groupThreadID : SV_GroupThreadID,
                uint groupIndex : SV_GroupIndex,
                uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint2 cacheStartPos = uint2(_CacheOffset)*THREAD_GROUP_SIZE;
    CachePos(cacheStartPos, groupIndex);
    GroupMemoryBarrierWithGroupSync();

    float coneRatio;
    float3 currentPos = LoadPos(dispatchThreadID.xy, coneRatio);
    float3 rayStartPos = float3(currentPos.xy, 0.0f);
    const int steps = 128;

    for (uint cacheIndex = 0; cacheIndex &lt; CACHED_POS_SIZE; cacheIndex++)
    {
        uint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE);
        uint2 sampleCoord = cacheStartPos + offset;
        if (any(float2(sampleCoord) &gt;= _TextureSize.xy)) continue;
        if (length((int2(sampleCoord.xy) - int2(dispatchThreadID.xy)) * _TextureSize.zw) &gt; coneRatio * currentPos.z) continue;
        if (all(sampleCoord == dispatchThreadID.xy)) continue;

        float3 cachedPos = GetCachedPos(cacheIndex);
        float3 dir = cachedPos - rayStartPos;
        float dirXYLength = length(dir.xy);
        float3 normalizedDir = dir / dirXYLength;
        float stepLength = 1.414 * _TextureSize.z;

        for (int j = 0; j &lt; steps; j++)
        {
            cachedPos += stepLength * normalizedDir;
            if (any(cachedPos.xy &gt;= 1.0f) || any(cachedPos.xy &lt;= 0.0f)) break;
            if (cachedPos.z &gt; currentPos.z) break;
            if (length(cachedPos.xy - currentPos.xy) / (currentPos.z - cachedPos.z) &gt; coneRatio) break;

            float3 samplePos = SamplePos(cachedPos.xy);
            if (samplePos.z &gt; currentPos.z) continue;
            float tempConeRatio = length(samplePos.xy - currentPos.xy) / (currentPos.z - samplePos.z);
            if (tempConeRatio &lt; coneRatio)
            {
                coneRatio = tempConeRatio;
            }
        }
    }

    _RW_TargetTex[dispatchThreadID.xy] = float4(1.0f - currentPos.z, coneRatio, 0.0f, 1.0f);
}
</code></pre><h3 id=relaxedconestepmappinggeneratorcs>RelaxedConeStepMappingGenerator.cs<a hidden class=anchor aria-hidden=true href=#relaxedconestepmappinggeneratorcs>#</a></h3><p>需要注意的是这里保存的格式是tga，如果是存成jpg的话会有压缩的问题。此外还要注意深度图和预计算的贴图储存的不是颜色值，因此不能勾选srgb，coneRatio也不太适合MipMap。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections;
<span style=color:#66d9ef>using</span> System.Collections.Generic;
<span style=color:#66d9ef>using</span> UnityEngine;
<span style=color:#66d9ef>using</span> UnityEditor;
<span style=color:#66d9ef>using</span> Unity.EditorCoroutines.Editor;
<span style=color:#66d9ef>using</span> System.IO;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RelaxedConeStepMappingGenerator</span> : EditorWindow
{
    <span style=color:#66d9ef>private</span> ComputeShader computeShader;
    <span style=color:#66d9ef>private</span> Texture2D texture;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> savePath = <span style=color:#e6db74>&#34;Assets/ParallaxMapping/rcsm&#34;</span>;
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> suffix = <span style=color:#e6db74>&#34;.tga&#34;</span>;

    <span style=color:#66d9ef>private</span> Vector2Int textureSize;
    <span style=color:#66d9ef>private</span> RenderTexture[] rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
    <span style=color:#66d9ef>private</span> EditorCoroutine editorCoroutine;
    
    Rect rect
    {
        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20.0f</span>, <span style=color:#ae81ff>20.0f</span>, position.width - <span style=color:#ae81ff>40.0f</span>, position.height - <span style=color:#ae81ff>10.0f</span>); }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRTs()
    {
        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> rt <span style=color:#66d9ef>in</span> rts)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
        }
        rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height)
    {
        <span style=color:#66d9ef>if</span>(rt == <span style=color:#66d9ef>null</span> || rt.width != width || rt.height != height)
        {
            <span style=color:#66d9ef>if</span>(rt != <span style=color:#66d9ef>null</span>) rt.Release();
            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor
            {
                width = width,
                height = height,
                volumeDepth = <span style=color:#ae81ff>1</span>,
                dimension = UnityEngine.Rendering.TextureDimension.Tex2D,
                depthBufferBits = <span style=color:#ae81ff>0</span>,
                msaaSamples = <span style=color:#ae81ff>1</span>,
                graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm,
                enableRandomWrite = <span style=color:#66d9ef>true</span>
            };
            rt = <span style=color:#66d9ef>new</span> RenderTexture(desc);
            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
        }
    }
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [MenuItem(&#34;zznewclear13/Relaxed Cone Step Mapping Generator&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Init()
    {
        RelaxedConeStepMappingGenerator window = GetWindow&lt;RelaxedConeStepMappingGenerator&gt;(<span style=color:#e6db74>&#34;Relaxed Cone Step Mapping Generator&#34;</span>);

        window.Show();
        window.Repaint();
        window.Focus();
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
    {
        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
        {
            computeShader = (ComputeShader)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Compute Shader&#34;</span>, computeShader, <span style=color:#66d9ef>typeof</span>(ComputeShader), <span style=color:#66d9ef>false</span>);
            texture = (Texture2D)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Texture&#34;</span>, texture, <span style=color:#66d9ef>typeof</span>(Texture2D), <span style=color:#66d9ef>false</span>);
            savePath = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Path&#34;</span>, savePath);

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!computeShader || !texture))
            {
                <span style=color:#66d9ef>if</span>(GUILayout.Button(<span style=color:#e6db74>&#34;Generate!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30.0f</span>) }))
                {
                    GenerateRCSM();
                }
            }
        }
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Vector4 GetTextureSize(Vector2Int textureSize)
    {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(textureSize.x, textureSize.y, <span style=color:#ae81ff>1.0f</span> / textureSize.x, <span style=color:#ae81ff>1.0f</span> / textureSize.y);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PreProcess(RenderTexture target)
    {
        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;PreProcessMain&#34;</span>);
        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSize(textureSize));
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_SourceTex&#34;</span>, texture);
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, target);
        computeShader.Dispatch(kernelID,
            Mathf.CeilToInt(textureSize.x / x),
            Mathf.CeilToInt(textureSize.y / y),
            <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ComputeRCSM(Vector2Int offset, RenderTexture source, RenderTexture target)
    {
        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RCSMMain&#34;</span>);
        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSize(textureSize));
        computeShader.SetVector(<span style=color:#e6db74>&#34;_CacheOffset&#34;</span>, <span style=color:#66d9ef>new</span> Vector2(offset.x, offset.y));
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_SourceTex&#34;</span>, source);
        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, target);
        computeShader.Dispatch(kernelID,
            Mathf.CeilToInt(textureSize.x / x),
            Mathf.CeilToInt(textureSize.y / y),
            <span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>private</span> IEnumerator DispatchCompute()
    {
        PreProcess(rts[<span style=color:#ae81ff>0</span>]);
        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;

        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RCSMMain&#34;</span>);
        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
        Vector2Int dispatchCount = <span style=color:#66d9ef>new</span> Vector2Int(Mathf.CeilToInt(textureSize.x / x),
                                                    Mathf.CeilToInt(textureSize.y / y));

        <span style=color:#66d9ef>int</span> fromID = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>bool</span> cancel = <span style=color:#66d9ef>false</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; dispatchCount.x; i++)
        {
            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; dispatchCount.y; j++)
            {
                ComputeRCSM(<span style=color:#66d9ef>new</span> Vector2Int(i, j), rts[fromID], rts[<span style=color:#ae81ff>1</span> - fromID]);
                fromID = <span style=color:#ae81ff>1</span> - fromID;
                <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
            }
            cancel = EditorUtility.DisplayCancelableProgressBar(<span style=color:#e6db74>&#34;In Progress...&#34;</span>, i + <span style=color:#e6db74>&#34;/&#34;</span> + dispatchCount.x, (<span style=color:#66d9ef>float</span>)i / dispatchCount.x);
            <span style=color:#66d9ef>if</span> (cancel) <span style=color:#66d9ef>break</span>;
        }
        EditorUtility.ClearProgressBar();
        <span style=color:#66d9ef>if</span> (!cancel) SaveRenderTextureToFile(rts[fromID]);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateRCSM()
    {
        textureSize = <span style=color:#66d9ef>new</span> Vector2Int(texture.width, texture.height);
        EnsureRTs();
        EnsureRT(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>0</span>], textureSize.x, textureSize.y);
        EnsureRT(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>1</span>], textureSize.x, textureSize.y);

        Stop();
        editorCoroutine = EditorCoroutineUtility.StartCoroutine(DispatchCompute(), <span style=color:#66d9ef>this</span>);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveRenderTextureToFile(RenderTexture rt)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;

        Texture2D toSave = <span style=color:#66d9ef>new</span> Texture2D(textureSize.x, textureSize.y, TextureFormat.ARGB32, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
        toSave.ReadPixels(<span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, textureSize.x, textureSize.y), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>byte</span>[] bytes = toSave.EncodeToTGA();
        FileStream fs = File.OpenWrite(savePath + suffix);
        fs.Write(bytes);
        fs.Close();
        AssetDatabase.Refresh();

        TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix);
        ti.mipmapEnabled = <span style=color:#66d9ef>false</span>;
        ti.sRGBTexture = <span style=color:#66d9ef>false</span>;
        ti.SaveAndReimport();

        Texture2D tempTexture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(savePath + suffix);
        EditorGUIUtility.PingObject(tempTexture);

        RenderTexture.active = prev;
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Stop()
    {
        <span style=color:#66d9ef>if</span> (editorCoroutine != <span style=color:#66d9ef>null</span>) EditorCoroutineUtility.StopCoroutine(editorCoroutine);
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
    {
        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> rt <span style=color:#66d9ef>in</span> rts)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
        }
        rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
    }
}
</code></pre></div><h3 id=rcsmvisualizeshadershader>RCSMVisualizeShader.shader<a hidden class=anchor aria-hidden=true href=#rcsmvisualizeshadershader>#</a></h3><p>计算Parallax的地方分成两个循环，第一个循环通过<code>coneRatio</code>和深度值进行光线步进直到采样点在高度图内部，第二个循环通过二分法获得较为准确的uv。</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/RCSMVisualizeShader&quot;
{
    Properties
    {
        _BaseColor(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _RCSMTex(&quot;RCSM Texture&quot;, 2D) = &quot;white&quot; {}
        _NormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _NormalIntensity(&quot;Normal Intensity&quot;, Range(0, 2)) = 1

        _ParallaxIntensity(&quot;Parallax Intensity&quot;, Float) = 1
        _ParallaxIteration(&quot;Parallax Iteration&quot;, Float) = 15
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

    sampler2D _MainTex;
    sampler2D _NormalMap;
    sampler2D _RCSMTex;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float _NormalIntensity;
    float _ParallaxIntensity;
    float _ParallaxIteration;
    CBUFFER_END

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float4 tangentOS    : TANGENT;
        float2 texcoord     : TEXCOORD0;
    };
    
    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float4 tbnView[3]   : TEXCOORD1;
    };
    
    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
        
        float3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;
        float sign = (input.tangentOS.w &gt; 0.0 ? 1.0 : -1.0) * GetOddNegativeScale();
        float3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;
        float3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);
        float3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);

        output.positionCS = vpi.positionCS;
        output.uv = input.texcoord;
        output.tbnView[0] = float4(vni.tangentWS, viewTS.x);
        output.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);
        output.tbnView[2] = float4(vni.normalWS, viewTS.z);
        return output;
    }

    float2 sampleRCSM(float2 uv)
    {
        float2 rcsm = tex2D(_RCSMTex, uv).xy;
        return float2(1.0f - rcsm.x, rcsm.y);
    }

    float getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight)
    {
        float totalRatio = rayRatio / coneRatio + 1.0f;
        return (sampleHeight - rayHeight) / totalRatio;
    }

    float2 parallax(float2 uv, float3 view)
    {
        view.xy = -view.xy * _ParallaxIntensity;
        float3 samplePos = float3(uv, 0.0f);
        float2 rcsm = sampleRCSM(samplePos.xy);
        float rayRatio = length(view.xy);
        float coneRatio = rcsm.y;
        float rayHeight = samplePos.z;
        float sampleHeight = rcsm.x;

        float stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);  
        [unroll(30)]
        for (int i = 0; i &lt; _ParallaxIteration; ++i)
        {
            samplePos += stepLength * view;
            rcsm = sampleRCSM(samplePos.xy);
            coneRatio = rcsm.y;
            rayHeight = samplePos.z;
            sampleHeight = rcsm.x;
            if (sampleHeight &lt;= rayHeight) break;
        
            stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);
        }

        stepLength *= 0.5f;
        samplePos -= stepLength * view;

        [unroll]
        for (int j = 0; j &lt; 5; ++j)
        {
            rcsm = sampleRCSM(samplePos.xy);
            stepLength *= 0.5f;
            if (samplePos.z &gt;= rcsm.x)
            {
                samplePos -= stepLength * view;
            }
            else if(samplePos.z &lt; rcsm.x)
            {
                samplePos += stepLength * view;
            }
        }

        return samplePos.xy;
    }


    float4 frag(Varyings input) : SV_TARGET
    {
        float3 viewTS = normalize(float3(input.tbnView[0].w, input.tbnView[1].w, input.tbnView[2].w));
        float3 tangentWS = normalize(input.tbnView[0].xyz);
        float3 bitangentWS = normalize(input.tbnView[1].xyz);
        float3 normalWS = normalize(input.tbnView[2].xyz);

        float z = max(abs(viewTS.z), 1e-5) * (viewTS.z &gt;= 0.0f ? 1.0f : -1.0f);
        float2 uv = parallax(input.uv, viewTS / z);

        float4 mainTex = tex2D(_MainTex, uv) * _BaseColor;
        float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
        
        float3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);
        Light mainLight = GetMainLight();
        float ndotl = max(0.0f, dot(n, mainLight.direction));

        float3 color = mainTex.rgb * mainLight.color * ndotl;
        float alpha = mainTex.a;
        return float4(color, alpha);
    }
            
    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot;=&quot;Transparent&quot;}
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite Off
        Cull Back

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h3 id=pomshadershader>POMShader.shader<a hidden class=anchor aria-hidden=true href=#pomshadershader>#</a></h3><p>很大程度地参考了<a href=https://www.shadertoy.com/view/3ds3zf>normal vs parallax</a>的计算方式。</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;zznewclear13/POMShader&quot;
{
    Properties
    {
        _BaseColor(&quot;Base Color&quot;, Color) = (1, 1, 1, 1)
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _HeightMap(&quot;Height Map&quot;, 2D) = &quot;white&quot; {}
        _NormalMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}
        _NormalIntensity(&quot;Normal Intensity&quot;, Range(0, 2)) = 1

        _ParallaxIntensity (&quot;Parallax Intensity&quot;, Float) = 1
        _ParallaxIteration (&quot;Parallax Iteration&quot;, Float) = 15
    }

    HLSLINCLUDE
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

    sampler2D _MainTex;
    sampler2D _HeightMap;
    sampler2D _NormalMap;
    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    float _NormalIntensity;
    float _ParallaxIntensity;
    float _ParallaxIteration;
    CBUFFER_END

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float3 normalOS     : NORMAL;
        float4 tangentOS    : TANGENT;
        float2 texcoord     : TEXCOORD0;
    };
    
    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 uv           : TEXCOORD0;
        float4 tbnView[3]   : TEXCOORD1;
    };
    
    Varyings vert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz);
        VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS);
        
        float3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz;
        float sign = (input.tangentOS.w &gt; 0.0 ? 1.0 : -1.0) * GetOddNegativeScale();
        float3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign;
        float3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS);
        float3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz);

        output.positionCS = vpi.positionCS;
        output.uv = input.texcoord;
        output.tbnView[0] = float4(vni.tangentWS, viewTS.x);
        output.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y);
        output.tbnView[2] = float4(vni.normalWS, viewTS.z);
        return output;
    }

    float sampleHeight(float2 uv)
    {
        return 1.0f - tex2D(_HeightMap, uv).r;
    }

    float2 parallax(float2 uv, float3 view)
    {
        float numLayers = _ParallaxIteration;
        float layerDepth = 1.0f / numLayers;

        float2 p = view.xy * _ParallaxIntensity;
        float2 deltaUVs = p / numLayers;

        float texd = sampleHeight(uv);
        float d = 0.0f;
        [unroll(30)]
        for (; d &lt; texd; d += layerDepth)
        {
            uv -= deltaUVs;
            texd = sampleHeight(uv);
        }

        float2 lastUVs = uv + deltaUVs;
        float after = texd - d;
        float before = sampleHeight(lastUVs) - d + layerDepth;
        float w = after / (after - before);

        return lerp(uv, lastUVs, w);
    }

    float4 frag(Varyings input) : SV_TARGET
    {
        float3 viewTS = normalize(float3(input.tbnView[0].w, input.tbnView[1].w, input.tbnView[2].w));
        float3 tangentWS = normalize(input.tbnView[0].xyz);
        float3 bitangentWS = normalize(input.tbnView[1].xyz);
        float3 normalWS = normalize(input.tbnView[2].xyz);

        float z = max(abs(viewTS.z), 1e-5) * (viewTS.z &gt;= 0.0f ? 1.0f : -1.0f);
        float2 uv = parallax(input.uv, viewTS / z);
        
        float4 mainTex = tex2D(_MainTex, uv) * _BaseColor;
        float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
        
        float3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS);
        Light mainLight = GetMainLight();
        float ndotl = max(0.0f, dot(n, mainLight.direction));

        float3 color = mainTex.rgb * mainLight.color * ndotl;
        float alpha = mainTex.a;
        return float4(color, alpha);
    }
            
    ENDHLSL

    SubShader
    {
        Tags{ &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot;=&quot;Transparent&quot;}
        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite Off
        Cull Back

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>夏天真的好热，热到头脑都不是很清醒了，感觉RCSM应该要比POM好很多才对，在自己的测试中也只稍微好了一些些，当然也有可能是我哪里没算对了。。。不过蛮奇怪的GPU Gems 3发表于2007年，直到今天我也没看到别的Unity上实现RCSM的文章或者github仓库，UE5也只有Get Relief这么一个插件。是因为曲面细分实在太好用了的原因吗？想起之前看最后生还者2的技术分享，里面大量地使用了高度图，难道主要是用来做多种材质的混合而不是做视差效果吗？</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/relaxed-cone-step-mapping/>Relaxed Cone Step Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/parallax-occlusion-mapping/>Parallax Occlusion Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-high-quality-bloom/><span class=title>« Prev Page</span><br><span>Unity的高质量的Bloom效果</span></a>
<a class=next href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><span class=title>Next Page »</span><br><span>几乎连续的双Kawase模糊</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>