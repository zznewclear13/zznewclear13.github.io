<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping | ZZNEWCLEAR13</title>
<meta name=keywords content="Relaxed Cone Step Mapping,Parallax Occlusion Mapping,Compute Shader"><meta name=description content="å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping"><meta property="og:description" content="å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"><meta property="og:image" content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-01T19:00:00+08:00"><meta property="article:modified_time" content="2023-07-01T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png"><meta name=twitter:title content="åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping"><meta name=twitter:description content="å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping","item":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping","name":"åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping","description":"å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•.","keywords":["Relaxed Cone Step Mapping","Parallax Occlusion Mapping","Compute Shader"],"articleBody":"é˜…è¯»å‰æç¤º ç”±äºæœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å‡ä¸ºLearnOpenGLç½‘ç«™ä¸Šçš„è´´å›¾ï¼Œå…¶æ³•çº¿è´´å›¾å’Œä¸€èˆ¬Unityæˆ–Unrealå¼•æ“ä¸­çš„æ³•çº¿è´´å›¾çš„Yåˆ†é‡æ˜¯ç›¸åçš„ï¼Œå› æ­¤åœ¨è®¡ç®—ä¸–ç•Œåæ ‡çš„bitangentçš„æ—¶å€™ä¼šé¢å¤–å†ä¹˜ä¸Šä¸€ä¸ªsignï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹æ˜¯ä¸éœ€è¦çš„ã€‚\nè§†å·®æ•ˆæœ åœ¨ä¸‰è§’å½¢é¢æ•°æ¯”è¾ƒå—é™çš„æƒ…å†µä¸‹ï¼Œå¾€å¾€ä¼šè€ƒè™‘ä½¿ç”¨ä¸€å¼ é«˜åº¦å›¾ï¼Œé€šè¿‡è§†å·®çš„è®¡ç®—å»æ¸²æŸ“å‡ºä¸€ç§3Dçš„æ•ˆæœï¼ˆè™½ç„¶ç°åœ¨ç›´æ¥ç”¨æ›²é¢ç»†åˆ†Tessellationä¼¼ä¹æ˜¯ä¸€ç§æ›´æ™®éçš„ä¸”æ›´æœ‰æ•ˆçš„æ–¹æ³•ï¼‰ã€‚æœ‰ä¸¤ç§è®¡ç®—è§†å·®çš„æ–¹æ³•ï¼Œä¸€ç§å«åšParallax Occlusion Mappingï¼Œå…ˆå‡å®šé«˜åº¦çš„å±‚æ•°ï¼Œç„¶åå¯¹æ¯ä¸€å±‚è®¡ç®—å‡ºåˆé€‚çš„ä½ç½®å’Œé¢œè‰²ï¼Œä»è€Œè¾¾åˆ°3Dæ•ˆæœï¼›å¦ä¸€ç§å«åšCone Step Mappingï¼Œæ˜¯æ ¹æ®é«˜åº¦å›¾é¢„å…ˆè®¡ç®—å‡ºæ¯ä¸ªç‚¹å¯¹äºå…¶ä»–æ‰€æœ‰åƒç´ çš„æœ€å¤§çš„åœ†é”¥å¼ è§’ï¼ˆæœ‰ç‚¹åƒAOï¼‰ï¼Œæ ¹æ®åœ†é”¥å¼ è§’å¿«é€Ÿæ­¥è¿›ï¼Œæœ€åä½¿ç”¨äºŒåˆ†æ³•è®¡ç®—å‡ºæœ€ç»ˆçš„äº¤ç‚¹çš„é¢œè‰²ã€‚ç¬¬ä¸€ç§æ–¹æ³•æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„ç¼ºç‚¹ï¼Œå°±æ˜¯åœ¨è§†è§’æ¯”è¾ƒæ¥è¿‘å¹³é¢çš„æ—¶å€™ï¼Œå¦‚æœé‡‡æ ·æ¬¡æ•°ä¸æ˜¯å¾ˆé«˜ï¼Œå°±ä¼šçœ‹åˆ°ä¸€å±‚ä¸€å±‚çš„æ•ˆæœï¼Œå¯ä»¥é€šè¿‡å¯¹æœ€åä¸€æ¬¡è®¡ç®—æ·±åº¦è¿›è¡Œçº¿æ€§æ’å€¼åœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡è½»ä¸€å±‚ä¸€å±‚çš„é—®é¢˜ï¼›ç¬¬äºŒç§æ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼Œå½“é‡‡æ ·æ¬¡æ•°è¾ƒå°æ—¶ï¼Œäº§ç”Ÿçš„å›¾åƒä¼šæœ‰ä¸€å®šç¨‹åº¦çš„æ‰­æ›²ï¼Œä½†ä¸ä¼šæœ‰ä¸€å±‚ä¸€å±‚çš„æ„Ÿè§‰ï¼Œæ­¤å¤–ç›¸è¾ƒäºç¬¬ä¸€ç§ä¼šæœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œè¾ƒç»†ç‰©ä½“ä¸ä¼šè¢«è·³è¿‡ã€‚åœ¨GPU Gems 3ä¸­æåˆ°äº†ä¸€ç§Cone Step Mappingçš„ä¼˜åŒ–ï¼Œå«åšRelaxed Cone Step Mappingï¼Œç›¸è¾ƒäºä¹‹å‰è®¡ç®—æœ€å¤§å¼ è§’çš„æ–¹å¼ï¼Œè¿™ç§ä¼˜åŒ–é€šè¿‡ç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œå‡å°‘äº†ä¸€å¼€å§‹åœ†é”¥æ­¥è¿›çš„æ¬¡æ•°ã€‚æœ¬æ–‡å°±ä¸»è¦ä½¿ç”¨è¿™ç§æ–¹æ³•è¿›è¡Œè®¡ç®—ï¼Œä¹Ÿè®¸å°†åœ†é”¥çš„é¡¶éƒ¨æ”¾åœ¨æ¯”å½“å‰é«˜åº¦å›¾æ›´æ·±çš„ä½ç½®èƒ½å¤Ÿæ›´åŠ å‡å°‘æ­¥è¿›çš„æ¬¡æ•°ï¼Œä¸è¿‡æˆ‘ç¨å¾®å°è¯•äº†ä¸€ä¸‹å¥½åƒæ•ˆæœå¹¶ä¸æ˜¯ç‰¹åˆ«ç†æƒ³ã€‚\nParallax Occlusion Mappingå¯ä»¥åœ¨Learn OpenGLé‡Œæ‰¾åˆ°ä»‹ç»å’Œä¼˜åŒ–æ–¹æ¡ˆï¼ŒShadertoyä¸Šä¹Ÿæœ‰å¼€æºçš„ä»£ç å¯ä»¥å‚è€ƒã€‚UE5ä¸­æœ‰ä¸€ä¸ªå«Get Relief!çš„æ’ä»¶ï¼Œå¯ä»¥ç”¨æ¥å¿«é€Ÿç”ŸæˆRelaxed Cone Step Mappingçš„é¢„è®¡ç®—çš„è´´å›¾ï¼Œä¹Ÿæä¾›äº†æ¸²æŸ“çš„Shaderã€‚è¿™ä¸ªæ’ä»¶çš„ä½œè€…Daniel Elliottä¹Ÿåœ¨GDC2023ä¸Šåˆ†äº«äº†åˆ¶ä½œçš„æ€è·¯ï¼Œå¦‚æœé“¾æ¥æ‰“ä¸å¼€çš„è¯è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªGDC Vaultçš„é“¾æ¥ã€‚\næœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å¯ä»¥åœ¨Learn OpenGLä¸­ç»™å‡ºçš„ä¸‹è½½é“¾æ¥ä¸­æ‰¾åˆ°ã€‚ä¸ºäº†çœ‹ä¸Šå»èˆ’æœä¸€äº›ï¼Œè¿™é‡Œå¯¹displacementè´´å›¾çš„é¢œè‰²è¿›è¡Œäº†åå‘ã€‚\nä¸‹å›¾æ˜¯ä¸¤ç§è§†å·®åšæ³•çš„æ¯”è¾ƒï¼Œå·¦è¾¹æ˜¯Parallax Occlusion Mappingï¼Œå³è¾¹æ˜¯Relaxed Cone Step Mappingï¼Œä¸¤è€…çš„é‡‡æ ·æ¬¡æ•°æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥çœ‹åˆ°POMåœ¨è¾ƒæé™çš„æƒ…å†µä¸‹ä¼šæœ‰åˆ†å±‚æ„Ÿè€ŒRCSMä¼šæœ‰æ‰­æ›²ã€‚RCSMä½¿ç”¨çš„è´´å›¾ä¹Ÿæ”¾åœ¨ä¸‹é¢äº†ï¼ŒRé€šé“æ˜¯é«˜åº¦å›¾ï¼ŒGé€šé“æ˜¯åœ†é”¥çš„å¼ è§’ã€‚æœ¬æ–‡ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ã€‚\nç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾ å’ŒParallax Occlusion Mappingç›´æ¥ä½¿ç”¨æ·±åº¦å›¾ä¸åŒçš„æ˜¯ï¼ŒCone Step Mappingéœ€è¦é¢„å…ˆè®¡ç®—å‡ºä¸€å¼ åœ†é”¥å¼ è§’çš„å›¾ï¼Œåœ†é”¥çš„å¼ è§’å¯ä»¥ä½¿ç”¨åœ†é”¥åº•çš„åŠå¾„é™¤ä»¥åœ†é”¥çš„é«˜æ¥è¡¨ç¤ºï¼Œè®°ä¸ºconeRatioã€‚æœ¬æ–‡ä¸­ä½¿ç”¨çš„æ˜¯é«˜åº¦å›¾ï¼Œä½†å®é™…è®¡ç®—ä¸­ä¼šä½¿ç”¨1å‡å»é«˜åº¦å€¼ï¼Œå¯¹åº”çš„æ˜¯ä»æ¨¡å‹è¡¨é¢åˆ°å®é™…é«˜åº¦çš„æ·±åº¦å€¼ã€‚ç”±äºæ·±åº¦å€¼åªä¼šåœ¨01ä¹‹é—´ï¼Œuvä¹Ÿåªä¼šåœ¨01ä¹‹é—´ï¼Œå› æ­¤å¯¹äºæœ€æ·±çš„ç‚¹ï¼Œå…¶æœ€å¤§çš„åœ†é”¥å¼ è§’ä¸ä¼šå¤§äº1ã€‚\nâ€œç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹â€ï¼Œå¯¹äºåœ†é”¥é¡¶éƒ¨çš„currentPoså’Œåœ†é”¥åº•éƒ¨çš„rayStartPosï¼ˆè¿™ä¸ªåœ†é”¥æ˜¯ä¸€ä¸ªå€’ç«‹çš„åœ†é”¥ï¼Œå…¶åº•éƒ¨å’Œæ¨¡å‹è¡¨é¢ç›¸å¹³ï¼‰ï¼Œå¯ä»¥é‡‡æ ·ä¸€ä¸ªç›®æ ‡ç‚¹cachedPosï¼Œå½“cachedPosçš„æ·±åº¦å°äºcurrentPosçš„æ·±åº¦æ—¶ï¼Œæ²¿ç€cachedPos - rayStartPosçš„æ–¹å‘ç§»åŠ¨cachedPosçš„ä½ç½®å¹¶ä¸€ç›´é‡‡æ ·æ‰€æœ‰åƒç´ samplePosï¼Œç›´åˆ°samplePosçš„æ·±åº¦å€¼å°äºcachedPosï¼ˆå³å°„çº¿ç©¿è¿‡é«˜åº¦å›¾å¹¶ç©¿å‡ºï¼‰ï¼Œæ ¹æ®samplePoså’ŒcurrentPoså°±èƒ½è®¡ç®—å‡ºä¸€ä¸ªåœ†é”¥çš„å¼ è§’coneRatioã€‚å¾ªç¯æ‰€æœ‰çš„åƒç´ å°±èƒ½å¾—åˆ°æœ€å°çš„åœ†é”¥å¼ è§’äº†ã€‚\nä¸ºäº†å‡å°‘å•æ¬¡è®¡ç®—çš„æ¶ˆè€—ï¼Œæœ¬æ–‡ä¼šå…ˆå°†æ•´å¼ å›¾ç‰‡åˆ†æˆNxNå¤§å°çš„åŒºåŸŸï¼Œåœ¨ä¸€æ¬¡å¾ªç¯ä¸­ä¼šè®¡ç®—æ‰€æœ‰åƒç´ å¯¹äºè¿™NxNå¤§å°çš„åŒºåŸŸçš„åœ†é”¥å¼ è§’ï¼Œå¾ªç¯æ‰€æœ‰çš„åŒºåŸŸå°±èƒ½å¾—åˆ°æœ€åçš„åœ†é”¥å¼ è§’äº†ã€‚åŒæ—¶åªéœ€è¦è®©Nç­‰äºTHREAD_GROUP_SIZEï¼Œå°±èƒ½ä½¿ç”¨group shared memoryä»…é€šè¿‡ä¸€æ¬¡é‡‡æ ·ç¼“å­˜è¿™äº›åŒºåŸŸçš„æ·±åº¦å€¼ã€‚å†æœ‰å°±æ˜¯Early Exitçš„ä¼˜åŒ–ï¼Œå½“cachedPosåœ¨è´´å›¾å¤–éƒ¨ï¼Œå½“cachedPosçš„æ·±åº¦å¤§äºcurrentPosçš„æ·±åº¦ï¼Œå½“cachedPosçš„åœ†é”¥å¼ è§’å¤§äºå½“å‰æœ€å°çš„åœ†é”¥å¼ è§’ï¼Œåœ¨è¿™äº›æƒ…å†µä¸‹å¯ä»¥ç›´æ¥ç»“æŸå‘å¤–æ­¥è¿›çš„å¾ªç¯ã€‚æ›´å¤šçš„ä¼˜åŒ–æ–¹æ³•ä¹Ÿéƒ½èƒ½åœ¨Get Relief!çš„åˆ†äº«ä¸­æ‰¾åˆ°ã€‚\nå…·ä½“çš„ä»£ç  RCSMComputeShader.compute ç”¨äºç”ŸæˆRelaxed Cone Step Mappingçš„è´´å›¾ã€‚PreProcessMainç”¨äºå¤„ç†æœ€ä¸€å¼€å§‹çš„æ·±åº¦å›¾ï¼Œé¢„å…ˆè®¾ç½®æœ€å¤§çš„coneRatioä¸º1ã€‚Early Exitæ˜¯å‡å°‘è¿ç®—æ—¶é—´çš„å…³é”®ã€‚\n#pragma kernel PreProcessMain #pragma kernel RCSMMain #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" Texture2D\u003cfloat4\u003e _SourceTex; RWTexture2D\u003cfloat4\u003e _RW_TargetTex; SamplerState sampler_LinearClamp; float4 _TextureSize; float2 _CacheOffset; #define THREAD_GROUP_SIZE 16u [numthreads(8, 8, 1)] void PreProcessMain(uint3 id : SV_DispatchThreadID) { uint2 tempID = uint2(id.x, _TextureSize.y - 1.0f - id.y); float sourceTex = _SourceTex.Load(uint3(tempID, 0)).r; _RW_TargetTex[id.xy] = float4(sourceTex, 1.0f, 0.0f, 0.0f); } float3 LoadPos(uint2 coord) { return float3((coord + 0.5f) * _TextureSize.zw, 1.0f - _SourceTex.Load(uint3(coord, 0)).r); } float3 LoadPos(uint2 coord, out float coneRatio) { float2 sourceTex = _SourceTex.Load(uint3(coord, 0)).rg; coneRatio = sourceTex.y; return float3((coord + 0.5f) * _TextureSize.zw, 1.0f - sourceTex.x); } float3 SamplePos(float2 uv) { return float3(uv, 1.0f - _SourceTex.SampleLevel(sampler_LinearClamp, uv, 0.0f).r); } const static uint CACHED_POS_SIZE = THREAD_GROUP_SIZE * THREAD_GROUP_SIZE; groupshared float3 cachedPos[CACHED_POS_SIZE]; void SetCachedPos(float3 pos, uint index) { cachedPos[index] = pos; } float3 GetCachedPos(uint index) { return cachedPos[index]; } void CachePos(uint2 cacheStartPos, uint cacheIndex) { uint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE); uint2 sampleCoord = cacheStartPos + offset; float3 pos = LoadPos(sampleCoord); SetCachedPos(pos, cacheIndex); } [numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)] void RCSMMain(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { uint2 cacheStartPos = uint2(_CacheOffset)*THREAD_GROUP_SIZE; CachePos(cacheStartPos, groupIndex); GroupMemoryBarrierWithGroupSync(); float coneRatio; float3 currentPos = LoadPos(dispatchThreadID.xy, coneRatio); float3 rayStartPos = float3(currentPos.xy, 0.0f); const int steps = 128; for (uint cacheIndex = 0; cacheIndex \u003c CACHED_POS_SIZE; cacheIndex++) { uint2 offset = uint2(cacheIndex % THREAD_GROUP_SIZE, cacheIndex / THREAD_GROUP_SIZE); uint2 sampleCoord = cacheStartPos + offset; if (any(float2(sampleCoord) \u003e= _TextureSize.xy)) continue; if (length((int2(sampleCoord.xy) - int2(dispatchThreadID.xy)) * _TextureSize.zw) \u003e coneRatio * currentPos.z) continue; if (all(sampleCoord == dispatchThreadID.xy)) continue; float3 cachedPos = GetCachedPos(cacheIndex); float3 dir = cachedPos - rayStartPos; float dirXYLength = length(dir.xy); float3 normalizedDir = dir / dirXYLength; float stepLength = 1.414 * _TextureSize.z; for (int j = 0; j \u003c steps; j++) { cachedPos += stepLength * normalizedDir; if (any(cachedPos.xy \u003e= 1.0f) || any(cachedPos.xy \u003c= 0.0f)) break; if (cachedPos.z \u003e currentPos.z) break; if (length(cachedPos.xy - currentPos.xy) / (currentPos.z - cachedPos.z) \u003e coneRatio) break; float3 samplePos = SamplePos(cachedPos.xy); if (samplePos.z \u003e currentPos.z) continue; float tempConeRatio = length(samplePos.xy - currentPos.xy) / (currentPos.z - samplePos.z); if (tempConeRatio \u003c coneRatio) { coneRatio = tempConeRatio; } } } _RW_TargetTex[dispatchThreadID.xy] = float4(1.0f - currentPos.z, coneRatio, 0.0f, 1.0f); } RelaxedConeStepMappingGenerator.cs éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œä¿å­˜çš„æ ¼å¼æ˜¯tgaï¼Œå¦‚æœæ˜¯å­˜æˆjpgçš„è¯ä¼šæœ‰å‹ç¼©çš„é—®é¢˜ã€‚æ­¤å¤–è¿˜è¦æ³¨æ„æ·±åº¦å›¾å’Œé¢„è®¡ç®—çš„è´´å›¾å‚¨å­˜çš„ä¸æ˜¯é¢œè‰²å€¼ï¼Œå› æ­¤ä¸èƒ½å‹¾é€‰srgbï¼ŒconeRatioä¹Ÿä¸å¤ªé€‚åˆMipMapã€‚\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using Unity.EditorCoroutines.Editor; using System.IO; public class RelaxedConeStepMappingGenerator : EditorWindow { private ComputeShader computeShader; private Texture2D texture; private string savePath = \"Assets/ParallaxMapping/rcsm\"; private static readonly string suffix = \".tga\"; private Vector2Int textureSize; private RenderTexture[] rts = new RenderTexture[2]; private EditorCoroutine editorCoroutine; Rect rect { get { return new Rect(20.0f, 20.0f, position.width - 40.0f, position.height - 10.0f); } } private void EnsureRTs() { foreach (var rt in rts) { if (rt != null) rt.Release(); } rts = new RenderTexture[2]; } private void EnsureRT(ref RenderTexture rt, int width, int height) { if(rt == null || rt.width != width || rt.height != height) { if(rt != null) rt.Release(); RenderTextureDescriptor desc = new RenderTextureDescriptor { width = width, height = height, volumeDepth = 1, dimension = UnityEngine.Rendering.TextureDimension.Tex2D, depthBufferBits = 0, msaaSamples = 1, graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm, enableRandomWrite = true }; rt = new RenderTexture(desc); if (!rt.IsCreated()) rt.Create(); } } [MenuItem(\"zznewclear13/Relaxed Cone Step Mapping Generator\")] public static void Init() { RelaxedConeStepMappingGenerator window = GetWindow(\"Relaxed Cone Step Mapping Generator\"); window.Show(); window.Repaint(); window.Focus(); } private void OnGUI() { using (new GUILayout.AreaScope(rect)) { computeShader = (ComputeShader)EditorGUILayout.ObjectField(\"Compute Shader\", computeShader, typeof(ComputeShader), false); texture = (Texture2D)EditorGUILayout.ObjectField(\"Texture\", texture, typeof(Texture2D), false); savePath = EditorGUILayout.TextField(\"Save Path\", savePath); using (new EditorGUI.DisabledGroupScope(!computeShader || !texture)) { if(GUILayout.Button(\"Generate!\", new GUILayoutOption[] { GUILayout.Height(30.0f) })) { GenerateRCSM(); } } } } private static Vector4 GetTextureSize(Vector2Int textureSize) { return new Vector4(textureSize.x, textureSize.y, 1.0f / textureSize.x, 1.0f / textureSize.y); } private void PreProcess(RenderTexture target) { int kernelID = computeShader.FindKernel(\"PreProcessMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); computeShader.SetVector(\"_TextureSize\", GetTextureSize(textureSize)); computeShader.SetTexture(kernelID, \"_SourceTex\", texture); computeShader.SetTexture(kernelID, \"_RW_TargetTex\", target); computeShader.Dispatch(kernelID, Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y), 1); } private void ComputeRCSM(Vector2Int offset, RenderTexture source, RenderTexture target) { int kernelID = computeShader.FindKernel(\"RCSMMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); computeShader.SetVector(\"_TextureSize\", GetTextureSize(textureSize)); computeShader.SetVector(\"_CacheOffset\", new Vector2(offset.x, offset.y)); computeShader.SetTexture(kernelID, \"_SourceTex\", source); computeShader.SetTexture(kernelID, \"_RW_TargetTex\", target); computeShader.Dispatch(kernelID, Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y), 1); } private IEnumerator DispatchCompute() { PreProcess(rts[0]); yield return null; int kernelID = computeShader.FindKernel(\"RCSMMain\"); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); Vector2Int dispatchCount = new Vector2Int(Mathf.CeilToInt(textureSize.x / x), Mathf.CeilToInt(textureSize.y / y)); int fromID = 0; bool cancel = false; for (int i = 0; i \u003c dispatchCount.x; i++) { for (int j = 0; j \u003c dispatchCount.y; j++) { ComputeRCSM(new Vector2Int(i, j), rts[fromID], rts[1 - fromID]); fromID = 1 - fromID; yield return null; } cancel = EditorUtility.DisplayCancelableProgressBar(\"In Progress...\", i + \"/\" + dispatchCount.x, (float)i / dispatchCount.x); if (cancel) break; } EditorUtility.ClearProgressBar(); if (!cancel) SaveRenderTextureToFile(rts[fromID]); } private void GenerateRCSM() { textureSize = new Vector2Int(texture.width, texture.height); EnsureRTs(); EnsureRT(ref rts[0], textureSize.x, textureSize.y); EnsureRT(ref rts[1], textureSize.x, textureSize.y); Stop(); editorCoroutine = EditorCoroutineUtility.StartCoroutine(DispatchCompute(), this); } private void SaveRenderTextureToFile(RenderTexture rt) { RenderTexture prev = RenderTexture.active; RenderTexture.active = rt; Texture2D toSave = new Texture2D(textureSize.x, textureSize.y, TextureFormat.ARGB32, false, true); toSave.ReadPixels(new Rect(0.0f, 0.0f, textureSize.x, textureSize.y), 0, 0); byte[] bytes = toSave.EncodeToTGA(); FileStream fs = File.OpenWrite(savePath + suffix); fs.Write(bytes); fs.Close(); AssetDatabase.Refresh(); TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix); ti.mipmapEnabled = false; ti.sRGBTexture = false; ti.SaveAndReimport(); Texture2D tempTexture = AssetDatabase.LoadAssetAtPath(savePath + suffix); EditorGUIUtility.PingObject(tempTexture); RenderTexture.active = prev; } private void Stop() { if (editorCoroutine != null) EditorCoroutineUtility.StopCoroutine(editorCoroutine); } private void OnDestroy() { foreach (var rt in rts) { if (rt != null) rt.Release(); } rts = new RenderTexture[2]; } } RCSMVisualizeShader.shader è®¡ç®—Parallaxçš„åœ°æ–¹åˆ†æˆä¸¤ä¸ªå¾ªç¯ï¼Œç¬¬ä¸€ä¸ªå¾ªç¯é€šè¿‡coneRatioå’Œæ·±åº¦å€¼è¿›è¡Œå…‰çº¿æ­¥è¿›ç›´åˆ°é‡‡æ ·ç‚¹åœ¨é«˜åº¦å›¾å†…éƒ¨ï¼Œç¬¬äºŒä¸ªå¾ªç¯é€šè¿‡äºŒåˆ†æ³•è·å¾—è¾ƒä¸ºå‡†ç¡®çš„uvã€‚\nShader \"zznewclear13/RCSMVisualizeShader\" { Properties { _BaseColor(\"Base Color\", Color) = (1, 1, 1, 1) _MainTex (\"Texture\", 2D) = \"white\" {} _RCSMTex(\"RCSM Texture\", 2D) = \"white\" {} _NormalMap(\"Normal Map\", 2D) = \"bump\" {} _NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1 _ParallaxIntensity(\"Parallax Intensity\", Float) = 1 _ParallaxIteration(\"Parallax Iteration\", Float) = 15 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" sampler2D _MainTex; sampler2D _NormalMap; sampler2D _RCSMTex; CBUFFER_START(UnityPerMaterial) float4 _BaseColor; float _NormalIntensity; float _ParallaxIntensity; float _ParallaxIteration; CBUFFER_END struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float4 tbnView[3] : TEXCOORD1; }; Varyings vert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS); float3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz; float sign = (input.tangentOS.w \u003e 0.0 ? 1.0 : -1.0) * GetOddNegativeScale(); float3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign; float3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS); float3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz); output.positionCS = vpi.positionCS; output.uv = input.texcoord; output.tbnView[0] = float4(vni.tangentWS, viewTS.x); output.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y); output.tbnView[2] = float4(vni.normalWS, viewTS.z); return output; } float2 sampleRCSM(float2 uv) { float2 rcsm = tex2D(_RCSMTex, uv).xy; return float2(1.0f - rcsm.x, rcsm.y); } float getStepLength(float rayRatio, float coneRatio, float rayHeight, float sampleHeight) { float totalRatio = rayRatio / coneRatio + 1.0f; return (sampleHeight - rayHeight) / totalRatio; } float2 parallax(float2 uv, float3 view) { view.xy = -view.xy * _ParallaxIntensity; float3 samplePos = float3(uv, 0.0f); float2 rcsm = sampleRCSM(samplePos.xy); float rayRatio = length(view.xy); float coneRatio = rcsm.y; float rayHeight = samplePos.z; float sampleHeight = rcsm.x; float stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight); [unroll(30)] for (int i = 0; i \u003c _ParallaxIteration; ++i) { samplePos += stepLength * view; rcsm = sampleRCSM(samplePos.xy); coneRatio = rcsm.y; rayHeight = samplePos.z; sampleHeight = rcsm.x; if (sampleHeight \u003c= rayHeight) break; stepLength = getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight); } stepLength *= 0.5f; samplePos -= stepLength * view; [unroll] for (int j = 0; j \u003c 5; ++j) { rcsm = sampleRCSM(samplePos.xy); stepLength *= 0.5f; if (samplePos.z \u003e= rcsm.x) { samplePos -= stepLength * view; } else if(samplePos.z \u003c rcsm.x) { samplePos += stepLength * view; } } return samplePos.xy; } float4 frag(Varyings input) : SV_TARGET { float3 viewTS = normalize(float3(input.tbnView[0].w, input.tbnView[1].w, input.tbnView[2].w)); float3 tangentWS = normalize(input.tbnView[0].xyz); float3 bitangentWS = normalize(input.tbnView[1].xyz); float3 normalWS = normalize(input.tbnView[2].xyz); float z = max(abs(viewTS.z), 1e-5) * (viewTS.z \u003e= 0.0f ? 1.0f : -1.0f); float2 uv = parallax(input.uv, viewTS / z); float4 mainTex = tex2D(_MainTex, uv) * _BaseColor; float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity)); float3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS); Light mainLight = GetMainLight(); float ndotl = max(0.0f, dot(n, mainLight.direction)); float3 color = mainTex.rgb * mainLight.color * ndotl; float alpha = mainTex.a; return float4(color, alpha); } ENDHLSL SubShader { Tags{ \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off Cull Back Pass { HLSLPROGRAM #pragma vertex vert #pragma fragment frag ENDHLSL } } } POMShader.shader å¾ˆå¤§ç¨‹åº¦åœ°å‚è€ƒäº†normal vs parallaxçš„è®¡ç®—æ–¹å¼ã€‚\nShader \"zznewclear13/POMShader\" { Properties { _BaseColor(\"Base Color\", Color) = (1, 1, 1, 1) _MainTex (\"Texture\", 2D) = \"white\" {} _HeightMap(\"Height Map\", 2D) = \"white\" {} _NormalMap(\"Normal Map\", 2D) = \"bump\" {} _NormalIntensity(\"Normal Intensity\", Range(0, 2)) = 1 _ParallaxIntensity (\"Parallax Intensity\", Float) = 1 _ParallaxIteration (\"Parallax Iteration\", Float) = 15 } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" sampler2D _MainTex; sampler2D _HeightMap; sampler2D _NormalMap; CBUFFER_START(UnityPerMaterial) float4 _BaseColor; float _NormalIntensity; float _ParallaxIntensity; float _ParallaxIteration; CBUFFER_END struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 uv : TEXCOORD0; float4 tbnView[3] : TEXCOORD1; }; Varyings vert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vpi = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs vni = GetVertexNormalInputs(input.normalOS, input.tangentOS); float3 cameraOS = mul(UNITY_MATRIX_I_M, float4(GetCameraPositionWS(), 1.0f)).xyz; float sign = (input.tangentOS.w \u003e 0.0 ? 1.0 : -1.0) * GetOddNegativeScale(); float3 bitangent = cross(input.normalOS, input.tangentOS.xyz) * sign; float3x3 tbnMat = float3x3(input.tangentOS.xyz, bitangent, input.normalOS); float3 viewTS = mul(tbnMat, cameraOS - input.positionOS.xyz); output.positionCS = vpi.positionCS; output.uv = input.texcoord; output.tbnView[0] = float4(vni.tangentWS, viewTS.x); output.tbnView[1] = float4(vni.bitangentWS * sign, viewTS.y); output.tbnView[2] = float4(vni.normalWS, viewTS.z); return output; } float sampleHeight(float2 uv) { return 1.0f - tex2D(_HeightMap, uv).r; } float2 parallax(float2 uv, float3 view) { float numLayers = _ParallaxIteration; float layerDepth = 1.0f / numLayers; float2 p = view.xy * _ParallaxIntensity; float2 deltaUVs = p / numLayers; float texd = sampleHeight(uv); float d = 0.0f; [unroll(30)] for (; d \u003c texd; d += layerDepth) { uv -= deltaUVs; texd = sampleHeight(uv); } float2 lastUVs = uv + deltaUVs; float after = texd - d; float before = sampleHeight(lastUVs) - d + layerDepth; float w = after / (after - before); return lerp(uv, lastUVs, w); } float4 frag(Varyings input) : SV_TARGET { float3 viewTS = normalize(float3(input.tbnView[0].w, input.tbnView[1].w, input.tbnView[2].w)); float3 tangentWS = normalize(input.tbnView[0].xyz); float3 bitangentWS = normalize(input.tbnView[1].xyz); float3 normalWS = normalize(input.tbnView[2].xyz); float z = max(abs(viewTS.z), 1e-5) * (viewTS.z \u003e= 0.0f ? 1.0f : -1.0f); float2 uv = parallax(input.uv, viewTS / z); float4 mainTex = tex2D(_MainTex, uv) * _BaseColor; float3 normalTS = normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity)); float3 n = normalize(normalTS.x * tangentWS + normalTS.y * bitangentWS + normalTS.z * normalWS); Light mainLight = GetMainLight(); float ndotl = max(0.0f, dot(n, mainLight.direction)); float3 color = mainTex.rgb * mainLight.color * ndotl; float alpha = mainTex.a; return float4(color, alpha); } ENDHLSL SubShader { Tags{ \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off Cull Back Pass { HLSLPROGRAM #pragma vertex vert #pragma fragment frag ENDHLSL } } } åè®° å¤å¤©çœŸçš„å¥½çƒ­ï¼Œçƒ­åˆ°å¤´è„‘éƒ½ä¸æ˜¯å¾ˆæ¸…é†’äº†ï¼Œæ„Ÿè§‰RCSMåº”è¯¥è¦æ¯”POMå¥½å¾ˆå¤šæ‰å¯¹ï¼Œåœ¨è‡ªå·±çš„æµ‹è¯•ä¸­ä¹Ÿåªç¨å¾®å¥½äº†ä¸€äº›äº›ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘å“ªé‡Œæ²¡ç®—å¯¹äº†ã€‚ã€‚ã€‚ä¸è¿‡è›®å¥‡æ€ªçš„GPU Gems 3å‘è¡¨äº2007å¹´ï¼Œç›´åˆ°ä»Šå¤©æˆ‘ä¹Ÿæ²¡çœ‹åˆ°åˆ«çš„Unityä¸Šå®ç°RCSMçš„æ–‡ç« æˆ–è€…githubä»“åº“ï¼ŒUE5ä¹Ÿåªæœ‰Get Reliefè¿™ä¹ˆä¸€ä¸ªæ’ä»¶ã€‚æ˜¯å› ä¸ºæ›²é¢ç»†åˆ†å®åœ¨å¤ªå¥½ç”¨äº†çš„åŸå› å—ï¼Ÿæƒ³èµ·ä¹‹å‰çœ‹æœ€åç”Ÿè¿˜è€…2çš„æŠ€æœ¯åˆ†äº«ï¼Œé‡Œé¢å¤§é‡åœ°ä½¿ç”¨äº†é«˜åº¦å›¾ï¼Œéš¾é“ä¸»è¦æ˜¯ç”¨æ¥åšå¤šç§æè´¨çš„æ··åˆè€Œä¸æ˜¯åšè§†å·®æ•ˆæœå—ï¼Ÿ\n","wordCount":"1846","inLanguage":"en","image":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/posts/images/RelaxedConeStepMapping.png","datePublished":"2023-07-01T19:00:00+08:00","dateModified":"2023-07-01T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</h1><div class=post-description>å¯¹æ¯”ä¸€ä¸‹RCSMå’ŒPOMçš„æ•ˆæœå’Œå®ç°æ–¹æ³•.</div><div class=post-meta><span title='2023-07-01 19:00:00 +0800 CST'>July 1, 2023</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/relaxed-cone-step-mapping-in-unity.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/RelaxedConeStepMapping.png alt="Relaxed Cone Step Mapping Cover"><p>Relaxed Cone Step Mapping Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨Unityé‡Œå®ç°æ¾æ•£åœ†é”¥æ­¥è¿›Relaxed Cone Step Mapping</div></summary><div class=inner><ul><li><a href=#%e9%98%85%e8%af%bb%e5%89%8d%e6%8f%90%e7%a4%ba aria-label=é˜…è¯»å‰æç¤º>é˜…è¯»å‰æç¤º</a></li><li><a href=#%e8%a7%86%e5%b7%ae%e6%95%88%e6%9e%9c aria-label=è§†å·®æ•ˆæœ>è§†å·®æ•ˆæœ</a></li><li><a href=#%e7%94%9f%e6%88%90%e9%a2%84%e8%ae%a1%e7%ae%97%e7%9a%84%e8%b4%b4%e5%9b%be aria-label=ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾>ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç </a><ul><li><a href=#rcsmcomputeshadercompute aria-label=RCSMComputeShader.compute>RCSMComputeShader.compute</a></li><li><a href=#relaxedconestepmappinggeneratorcs aria-label=RelaxedConeStepMappingGenerator.cs>RelaxedConeStepMappingGenerator.cs</a></li><li><a href=#rcsmvisualizeshadershader aria-label=RCSMVisualizeShader.shader>RCSMVisualizeShader.shader</a></li><li><a href=#pomshadershader aria-label=POMShader.shader>POMShader.shader</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=é˜…è¯»å‰æç¤º>é˜…è¯»å‰æç¤º<a hidden class=anchor aria-hidden=true href=#é˜…è¯»å‰æç¤º>#</a></h2><p>ç”±äºæœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å‡ä¸ºLearnOpenGLç½‘ç«™ä¸Šçš„è´´å›¾ï¼Œå…¶æ³•çº¿è´´å›¾å’Œä¸€èˆ¬Unityæˆ–Unrealå¼•æ“ä¸­çš„æ³•çº¿è´´å›¾çš„Yåˆ†é‡æ˜¯ç›¸åçš„ï¼Œå› æ­¤åœ¨è®¡ç®—ä¸–ç•Œåæ ‡çš„bitangentçš„æ—¶å€™ä¼šé¢å¤–å†ä¹˜ä¸Šä¸€ä¸ªsignï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹æ˜¯ä¸éœ€è¦çš„ã€‚</p><h2 id=è§†å·®æ•ˆæœ>è§†å·®æ•ˆæœ<a hidden class=anchor aria-hidden=true href=#è§†å·®æ•ˆæœ>#</a></h2><p>åœ¨ä¸‰è§’å½¢é¢æ•°æ¯”è¾ƒå—é™çš„æƒ…å†µä¸‹ï¼Œå¾€å¾€ä¼šè€ƒè™‘ä½¿ç”¨ä¸€å¼ é«˜åº¦å›¾ï¼Œé€šè¿‡è§†å·®çš„è®¡ç®—å»æ¸²æŸ“å‡ºä¸€ç§3Dçš„æ•ˆæœï¼ˆè™½ç„¶ç°åœ¨ç›´æ¥ç”¨æ›²é¢ç»†åˆ†Tessellationä¼¼ä¹æ˜¯ä¸€ç§æ›´æ™®éçš„ä¸”æ›´æœ‰æ•ˆçš„æ–¹æ³•ï¼‰ã€‚æœ‰ä¸¤ç§è®¡ç®—è§†å·®çš„æ–¹æ³•ï¼Œä¸€ç§å«åšParallax Occlusion Mappingï¼Œå…ˆå‡å®šé«˜åº¦çš„å±‚æ•°ï¼Œç„¶åå¯¹æ¯ä¸€å±‚è®¡ç®—å‡ºåˆé€‚çš„ä½ç½®å’Œé¢œè‰²ï¼Œä»è€Œè¾¾åˆ°3Dæ•ˆæœï¼›å¦ä¸€ç§å«åšCone Step Mappingï¼Œæ˜¯æ ¹æ®é«˜åº¦å›¾é¢„å…ˆè®¡ç®—å‡ºæ¯ä¸ªç‚¹å¯¹äºå…¶ä»–æ‰€æœ‰åƒç´ çš„æœ€å¤§çš„åœ†é”¥å¼ è§’ï¼ˆæœ‰ç‚¹åƒAOï¼‰ï¼Œæ ¹æ®åœ†é”¥å¼ è§’å¿«é€Ÿæ­¥è¿›ï¼Œæœ€åä½¿ç”¨äºŒåˆ†æ³•è®¡ç®—å‡ºæœ€ç»ˆçš„äº¤ç‚¹çš„é¢œè‰²ã€‚ç¬¬ä¸€ç§æ–¹æ³•æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„ç¼ºç‚¹ï¼Œå°±æ˜¯åœ¨è§†è§’æ¯”è¾ƒæ¥è¿‘å¹³é¢çš„æ—¶å€™ï¼Œå¦‚æœé‡‡æ ·æ¬¡æ•°ä¸æ˜¯å¾ˆé«˜ï¼Œå°±ä¼šçœ‹åˆ°ä¸€å±‚ä¸€å±‚çš„æ•ˆæœï¼Œå¯ä»¥é€šè¿‡å¯¹æœ€åä¸€æ¬¡è®¡ç®—æ·±åº¦è¿›è¡Œçº¿æ€§æ’å€¼åœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡è½»ä¸€å±‚ä¸€å±‚çš„é—®é¢˜ï¼›ç¬¬äºŒç§æ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼Œå½“é‡‡æ ·æ¬¡æ•°è¾ƒå°æ—¶ï¼Œäº§ç”Ÿçš„å›¾åƒä¼šæœ‰ä¸€å®šç¨‹åº¦çš„æ‰­æ›²ï¼Œä½†ä¸ä¼šæœ‰ä¸€å±‚ä¸€å±‚çš„æ„Ÿè§‰ï¼Œæ­¤å¤–ç›¸è¾ƒäºç¬¬ä¸€ç§ä¼šæœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œè¾ƒç»†ç‰©ä½“ä¸ä¼šè¢«è·³è¿‡ã€‚åœ¨<a href=https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-18-relaxed-cone-stepping-relief-mapping>GPU Gems 3</a>ä¸­æåˆ°äº†ä¸€ç§Cone Step Mappingçš„ä¼˜åŒ–ï¼Œå«åšRelaxed Cone Step Mappingï¼Œç›¸è¾ƒäºä¹‹å‰è®¡ç®—æœ€å¤§å¼ è§’çš„æ–¹å¼ï¼Œè¿™ç§ä¼˜åŒ–é€šè¿‡ç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œå‡å°‘äº†ä¸€å¼€å§‹åœ†é”¥æ­¥è¿›çš„æ¬¡æ•°ã€‚æœ¬æ–‡å°±ä¸»è¦ä½¿ç”¨è¿™ç§æ–¹æ³•è¿›è¡Œè®¡ç®—ï¼Œä¹Ÿè®¸å°†åœ†é”¥çš„é¡¶éƒ¨æ”¾åœ¨æ¯”å½“å‰é«˜åº¦å›¾æ›´æ·±çš„ä½ç½®èƒ½å¤Ÿæ›´åŠ å‡å°‘æ­¥è¿›çš„æ¬¡æ•°ï¼Œä¸è¿‡æˆ‘ç¨å¾®å°è¯•äº†ä¸€ä¸‹å¥½åƒæ•ˆæœå¹¶ä¸æ˜¯ç‰¹åˆ«ç†æƒ³ã€‚</p><p>Parallax Occlusion Mappingå¯ä»¥åœ¨<a href=https://learnopengl.com/Advanced-Lighting/Parallax-Mapping>Learn OpenGL</a>é‡Œæ‰¾åˆ°ä»‹ç»å’Œä¼˜åŒ–æ–¹æ¡ˆï¼Œ<a href=https://www.shadertoy.com/view/3ds3zf>Shadertoy</a>ä¸Šä¹Ÿæœ‰å¼€æºçš„ä»£ç å¯ä»¥å‚è€ƒã€‚UE5ä¸­æœ‰ä¸€ä¸ªå«<a href=https://www.unrealengine.com/marketplace/en-US/product/get-relief-rcsm-generator>Get Relief!</a>çš„æ’ä»¶ï¼Œå¯ä»¥ç”¨æ¥å¿«é€Ÿç”ŸæˆRelaxed Cone Step Mappingçš„é¢„è®¡ç®—çš„è´´å›¾ï¼Œä¹Ÿæä¾›äº†æ¸²æŸ“çš„Shaderã€‚è¿™ä¸ªæ’ä»¶çš„ä½œè€…Daniel Elliottä¹Ÿåœ¨GDC2023ä¸Šåˆ†äº«äº†<a href="https://docs.google.com/presentation/d/15XT0ZXkuJNhVLktKqzQLho6oNCUMam4C/edit?usp=sharing&amp;ouid=112299818420501474198&amp;rtpof=true&amp;sd=true">åˆ¶ä½œçš„æ€è·¯</a>ï¼Œå¦‚æœé“¾æ¥æ‰“ä¸å¼€çš„è¯è¿™é‡Œè¿˜æœ‰ä¸€ä¸ª<a href=https://gdcvault.com/play/1029331/Technical-Artist-Summit-Approaching-Technical>GDC Vaultçš„é“¾æ¥</a>ã€‚</p><p>æœ¬æ–‡ä½¿ç”¨çš„è´´å›¾å¯ä»¥åœ¨<a href=https://learnopengl.com/Advanced-Lighting/Parallax-Mapping>Learn OpenGL</a>ä¸­ç»™å‡ºçš„ä¸‹è½½é“¾æ¥ä¸­æ‰¾åˆ°ã€‚ä¸ºäº†çœ‹ä¸Šå»èˆ’æœä¸€äº›ï¼Œè¿™é‡Œå¯¹displacementè´´å›¾çš„é¢œè‰²è¿›è¡Œäº†åå‘ã€‚</p><p>ä¸‹å›¾æ˜¯ä¸¤ç§è§†å·®åšæ³•çš„æ¯”è¾ƒï¼Œå·¦è¾¹æ˜¯Parallax Occlusion Mappingï¼Œå³è¾¹æ˜¯Relaxed Cone Step Mappingï¼Œä¸¤è€…çš„é‡‡æ ·æ¬¡æ•°æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥çœ‹åˆ°POMåœ¨è¾ƒæé™çš„æƒ…å†µä¸‹ä¼šæœ‰åˆ†å±‚æ„Ÿè€ŒRCSMä¼šæœ‰æ‰­æ›²ã€‚RCSMä½¿ç”¨çš„è´´å›¾ä¹Ÿæ”¾åœ¨ä¸‹é¢äº†ï¼ŒRé€šé“æ˜¯é«˜åº¦å›¾ï¼ŒGé€šé“æ˜¯åœ†é”¥çš„å¼ è§’ã€‚æœ¬æ–‡ä½¿ç”¨çš„æ˜¯Unity 2021.3.19f1c1ã€‚</p><p><img loading=lazy src=../images/RelaxedConeStepMapping.png#center alt="POM vs RCSM"></p><p><img loading=lazy src=../images/rcsm.png#center alt=rcsm.png></p><h2 id=ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾>ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾<a hidden class=anchor aria-hidden=true href=#ç”Ÿæˆé¢„è®¡ç®—çš„è´´å›¾>#</a></h2><p>å’ŒParallax Occlusion Mappingç›´æ¥ä½¿ç”¨æ·±åº¦å›¾ä¸åŒçš„æ˜¯ï¼ŒCone Step Mappingéœ€è¦é¢„å…ˆè®¡ç®—å‡ºä¸€å¼ åœ†é”¥å¼ è§’çš„å›¾ï¼Œåœ†é”¥çš„å¼ è§’å¯ä»¥ä½¿ç”¨åœ†é”¥åº•çš„åŠå¾„é™¤ä»¥åœ†é”¥çš„é«˜æ¥è¡¨ç¤ºï¼Œè®°ä¸º<code>coneRatio</code>ã€‚æœ¬æ–‡ä¸­ä½¿ç”¨çš„æ˜¯é«˜åº¦å›¾ï¼Œä½†å®é™…è®¡ç®—ä¸­ä¼šä½¿ç”¨1å‡å»é«˜åº¦å€¼ï¼Œå¯¹åº”çš„æ˜¯ä»æ¨¡å‹è¡¨é¢åˆ°å®é™…é«˜åº¦çš„æ·±åº¦å€¼ã€‚ç”±äºæ·±åº¦å€¼åªä¼šåœ¨01ä¹‹é—´ï¼Œuvä¹Ÿåªä¼šåœ¨01ä¹‹é—´ï¼Œå› æ­¤å¯¹äºæœ€æ·±çš„ç‚¹ï¼Œå…¶æœ€å¤§çš„åœ†é”¥å¼ è§’ä¸ä¼šå¤§äº1ã€‚</p><p>â€œç¡®ä¿é€šè¿‡åœ†é”¥çš„å°„çº¿ä¸åœ†é”¥å†…éƒ¨çš„é«˜åº¦å›¾è‡³å¤šåªæœ‰ä¸€ä¸ªäº¤ç‚¹â€ï¼Œå¯¹äºåœ†é”¥é¡¶éƒ¨çš„<code>currentPos</code>å’Œåœ†é”¥åº•éƒ¨çš„<code>rayStartPos</code>ï¼ˆè¿™ä¸ªåœ†é”¥æ˜¯ä¸€ä¸ªå€’ç«‹çš„åœ†é”¥ï¼Œå…¶åº•éƒ¨å’Œæ¨¡å‹è¡¨é¢ç›¸å¹³ï¼‰ï¼Œå¯ä»¥é‡‡æ ·ä¸€ä¸ªç›®æ ‡ç‚¹<code>cachedPos</code>ï¼Œå½“<code>cachedPos</code>çš„æ·±åº¦å°äº<code>currentPos</code>çš„æ·±åº¦æ—¶ï¼Œæ²¿ç€<code>cachedPos - rayStartPos</code>çš„æ–¹å‘ç§»åŠ¨<code>cachedPos</code>çš„ä½ç½®å¹¶ä¸€ç›´é‡‡æ ·æ‰€æœ‰åƒç´ <code>samplePos</code>ï¼Œç›´åˆ°<code>samplePos</code>çš„æ·±åº¦å€¼å°äº<code>cachedPos</code>ï¼ˆå³å°„çº¿ç©¿è¿‡é«˜åº¦å›¾å¹¶ç©¿å‡ºï¼‰ï¼Œæ ¹æ®<code>samplePos</code>å’Œ<code>currentPos</code>å°±èƒ½è®¡ç®—å‡ºä¸€ä¸ªåœ†é”¥çš„å¼ è§’<code>coneRatio</code>ã€‚å¾ªç¯æ‰€æœ‰çš„åƒç´ å°±èƒ½å¾—åˆ°æœ€å°çš„åœ†é”¥å¼ è§’äº†ã€‚</p><p>ä¸ºäº†å‡å°‘å•æ¬¡è®¡ç®—çš„æ¶ˆè€—ï¼Œæœ¬æ–‡ä¼šå…ˆå°†æ•´å¼ å›¾ç‰‡åˆ†æˆNxNå¤§å°çš„åŒºåŸŸï¼Œåœ¨ä¸€æ¬¡å¾ªç¯ä¸­ä¼šè®¡ç®—æ‰€æœ‰åƒç´ å¯¹äºè¿™NxNå¤§å°çš„åŒºåŸŸçš„åœ†é”¥å¼ è§’ï¼Œå¾ªç¯æ‰€æœ‰çš„åŒºåŸŸå°±èƒ½å¾—åˆ°æœ€åçš„åœ†é”¥å¼ è§’äº†ã€‚åŒæ—¶åªéœ€è¦è®©Nç­‰äº<code>THREAD_GROUP_SIZE</code>ï¼Œå°±èƒ½ä½¿ç”¨group shared memoryä»…é€šè¿‡ä¸€æ¬¡é‡‡æ ·ç¼“å­˜è¿™äº›åŒºåŸŸçš„æ·±åº¦å€¼ã€‚å†æœ‰å°±æ˜¯Early Exitçš„ä¼˜åŒ–ï¼Œå½“<code>cachedPos</code>åœ¨è´´å›¾å¤–éƒ¨ï¼Œå½“<code>cachedPos</code>çš„æ·±åº¦å¤§äº<code>currentPos</code>çš„æ·±åº¦ï¼Œå½“<code>cachedPos</code>çš„åœ†é”¥å¼ è§’å¤§äºå½“å‰æœ€å°çš„åœ†é”¥å¼ è§’ï¼Œåœ¨è¿™äº›æƒ…å†µä¸‹å¯ä»¥ç›´æ¥ç»“æŸå‘å¤–æ­¥è¿›çš„å¾ªç¯ã€‚æ›´å¤šçš„ä¼˜åŒ–æ–¹æ³•ä¹Ÿéƒ½èƒ½åœ¨<code>Get Relief!</code>çš„åˆ†äº«ä¸­æ‰¾åˆ°ã€‚</p><h2 id=å…·ä½“çš„ä»£ç >å…·ä½“çš„ä»£ç <a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„ä»£ç >#</a></h2><h3 id=rcsmcomputeshadercompute>RCSMComputeShader.compute<a hidden class=anchor aria-hidden=true href=#rcsmcomputeshadercompute>#</a></h3><p>ç”¨äºç”ŸæˆRelaxed Cone Step Mappingçš„è´´å›¾ã€‚<code>PreProcessMain</code>ç”¨äºå¤„ç†æœ€ä¸€å¼€å§‹çš„æ·±åº¦å›¾ï¼Œé¢„å…ˆè®¾ç½®æœ€å¤§çš„<code>coneRatio</code>ä¸º1ã€‚Early Exitæ˜¯å‡å°‘è¿ç®—æ—¶é—´çš„å…³é”®ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel PreProcessMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel RCSMMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _SourceTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_TargetTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_LinearClamp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> _CacheOffset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define THREAD_GROUP_SIZE 16u</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> PreProcessMain(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint2</span> tempID <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint2</span>(id.x, _TextureSize.y <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> id.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> sourceTex <span style=color:#f92672>=</span> _SourceTex.Load(<span style=color:#66d9ef>uint3</span>(tempID, <span style=color:#ae81ff>0</span>)).r;
</span></span><span style=display:flex><span>    _RW_TargetTex[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(sourceTex, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> LoadPos(<span style=color:#66d9ef>uint2</span> coord)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float3</span>((coord <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> _TextureSize.zw, <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> _SourceTex.Load(<span style=color:#66d9ef>uint3</span>(coord, <span style=color:#ae81ff>0</span>)).r);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> LoadPos(<span style=color:#66d9ef>uint2</span> coord, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>float</span> coneRatio)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> sourceTex <span style=color:#f92672>=</span> _SourceTex.Load(<span style=color:#66d9ef>uint3</span>(coord, <span style=color:#ae81ff>0</span>)).rg;
</span></span><span style=display:flex><span>    coneRatio <span style=color:#f92672>=</span> sourceTex.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float3</span>((coord <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> _TextureSize.zw, <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> sourceTex.x);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> SamplePos(<span style=color:#66d9ef>float2</span> uv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float3</span>(uv, <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> _SourceTex.SampleLevel(sampler_LinearClamp, uv, <span style=color:#ae81ff>0.0f</span>).r);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint</span> CACHED_POS_SIZE <span style=color:#f92672>=</span> THREAD_GROUP_SIZE <span style=color:#f92672>*</span> THREAD_GROUP_SIZE;
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> <span style=color:#66d9ef>float3</span> cachedPos[CACHED_POS_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetCachedPos(<span style=color:#66d9ef>float3</span> pos, <span style=color:#66d9ef>uint</span> index) { cachedPos[index] <span style=color:#f92672>=</span> pos; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> GetCachedPos(<span style=color:#66d9ef>uint</span> index) { <span style=color:#66d9ef>return</span> cachedPos[index]; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CachePos(<span style=color:#66d9ef>uint2</span> cacheStartPos, <span style=color:#66d9ef>uint</span> cacheIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint2</span> offset <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint2</span>(cacheIndex <span style=color:#f92672>%</span> THREAD_GROUP_SIZE, cacheIndex <span style=color:#f92672>/</span> THREAD_GROUP_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint2</span> sampleCoord <span style=color:#f92672>=</span> cacheStartPos <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> pos <span style=color:#f92672>=</span> LoadPos(sampleCoord);
</span></span><span style=display:flex><span>    SetCachedPos(pos, cacheIndex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> RCSMMain(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint2</span> cacheStartPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint2</span>(_CacheOffset)<span style=color:#f92672>*</span>THREAD_GROUP_SIZE;
</span></span><span style=display:flex><span>    CachePos(cacheStartPos, groupIndex);
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> coneRatio;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> currentPos <span style=color:#f92672>=</span> LoadPos(dispatchThreadID.xy, coneRatio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> rayStartPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(currentPos.xy, <span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> steps <span style=color:#f92672>=</span> <span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> cacheIndex <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; cacheIndex <span style=color:#f92672>&lt;</span> CACHED_POS_SIZE; cacheIndex<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint2</span> offset <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint2</span>(cacheIndex <span style=color:#f92672>%</span> THREAD_GROUP_SIZE, cacheIndex <span style=color:#f92672>/</span> THREAD_GROUP_SIZE);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint2</span> sampleCoord <span style=color:#f92672>=</span> cacheStartPos <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (any(<span style=color:#66d9ef>float2</span>(sampleCoord) <span style=color:#f92672>&gt;=</span> _TextureSize.xy)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (length((<span style=color:#66d9ef>int2</span>(sampleCoord.xy) <span style=color:#f92672>-</span> <span style=color:#66d9ef>int2</span>(dispatchThreadID.xy)) <span style=color:#f92672>*</span> _TextureSize.zw) <span style=color:#f92672>&gt;</span> coneRatio <span style=color:#f92672>*</span> currentPos.z) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (all(sampleCoord <span style=color:#f92672>==</span> dispatchThreadID.xy)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cachedPos <span style=color:#f92672>=</span> GetCachedPos(cacheIndex);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> dir <span style=color:#f92672>=</span> cachedPos <span style=color:#f92672>-</span> rayStartPos;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> dirXYLength <span style=color:#f92672>=</span> length(dir.xy);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalizedDir <span style=color:#f92672>=</span> dir <span style=color:#f92672>/</span> dirXYLength;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> stepLength <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.414</span> <span style=color:#f92672>*</span> _TextureSize.z;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> steps; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            cachedPos <span style=color:#f92672>+=</span> stepLength <span style=color:#f92672>*</span> normalizedDir;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (any(cachedPos.xy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>||</span> any(cachedPos.xy <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0.0f</span>)) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cachedPos.z <span style=color:#f92672>&gt;</span> currentPos.z) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (length(cachedPos.xy <span style=color:#f92672>-</span> currentPos.xy) <span style=color:#f92672>/</span> (currentPos.z <span style=color:#f92672>-</span> cachedPos.z) <span style=color:#f92672>&gt;</span> coneRatio) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> samplePos <span style=color:#f92672>=</span> SamplePos(cachedPos.xy);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (samplePos.z <span style=color:#f92672>&gt;</span> currentPos.z) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> tempConeRatio <span style=color:#f92672>=</span> length(samplePos.xy <span style=color:#f92672>-</span> currentPos.xy) <span style=color:#f92672>/</span> (currentPos.z <span style=color:#f92672>-</span> samplePos.z);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (tempConeRatio <span style=color:#f92672>&lt;</span> coneRatio)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                coneRatio <span style=color:#f92672>=</span> tempConeRatio;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_TargetTex[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> currentPos.z, coneRatio, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=relaxedconestepmappinggeneratorcs>RelaxedConeStepMappingGenerator.cs<a hidden class=anchor aria-hidden=true href=#relaxedconestepmappinggeneratorcs>#</a></h3><p>éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œä¿å­˜çš„æ ¼å¼æ˜¯tgaï¼Œå¦‚æœæ˜¯å­˜æˆjpgçš„è¯ä¼šæœ‰å‹ç¼©çš„é—®é¢˜ã€‚æ­¤å¤–è¿˜è¦æ³¨æ„æ·±åº¦å›¾å’Œé¢„è®¡ç®—çš„è´´å›¾å‚¨å­˜çš„ä¸æ˜¯é¢œè‰²å€¼ï¼Œå› æ­¤ä¸èƒ½å‹¾é€‰srgbï¼ŒconeRatioä¹Ÿä¸å¤ªé€‚åˆMipMapã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.EditorCoroutines.Editor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.IO;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RelaxedConeStepMappingGenerator</span> : EditorWindow
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Texture2D texture;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>string</span> savePath = <span style=color:#e6db74>&#34;Assets/ParallaxMapping/rcsm&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> suffix = <span style=color:#e6db74>&#34;.tga&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Vector2Int textureSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RenderTexture[] rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> EditorCoroutine editorCoroutine;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Rect rect
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>20.0f</span>, <span style=color:#ae81ff>20.0f</span>, position.width - <span style=color:#ae81ff>40.0f</span>, position.height - <span style=color:#ae81ff>10.0f</span>); }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRTs()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> rt <span style=color:#66d9ef>in</span> rts)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(rt == <span style=color:#66d9ef>null</span> || rt.width != width || rt.height != height)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                width = width,
</span></span><span style=display:flex><span>                height = height,
</span></span><span style=display:flex><span>                volumeDepth = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                dimension = UnityEngine.Rendering.TextureDimension.Tex2D,
</span></span><span style=display:flex><span>                depthBufferBits = <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                msaaSamples = <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                graphicsFormat = UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm,
</span></span><span style=display:flex><span>                enableRandomWrite = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            rt = <span style=color:#66d9ef>new</span> RenderTexture(desc);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [MenuItem(&#34;zznewclear13/Relaxed Cone Step Mapping Generator&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Init()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        RelaxedConeStepMappingGenerator window = GetWindow&lt;RelaxedConeStepMappingGenerator&gt;(<span style=color:#e6db74>&#34;Relaxed Cone Step Mapping Generator&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        window.Show();
</span></span><span style=display:flex><span>        window.Repaint();
</span></span><span style=display:flex><span>        window.Focus();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> GUILayout.AreaScope(rect))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            computeShader = (ComputeShader)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Compute Shader&#34;</span>, computeShader, <span style=color:#66d9ef>typeof</span>(ComputeShader), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>            texture = (Texture2D)EditorGUILayout.ObjectField(<span style=color:#e6db74>&#34;Texture&#34;</span>, texture, <span style=color:#66d9ef>typeof</span>(Texture2D), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>            savePath = EditorGUILayout.TextField(<span style=color:#e6db74>&#34;Save Path&#34;</span>, savePath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> EditorGUI.DisabledGroupScope(!computeShader || !texture))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(GUILayout.Button(<span style=color:#e6db74>&#34;Generate!&#34;</span>, <span style=color:#66d9ef>new</span> GUILayoutOption[] { GUILayout.Height(<span style=color:#ae81ff>30.0f</span>) }))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    GenerateRCSM();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Vector4 GetTextureSize(Vector2Int textureSize)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(textureSize.x, textureSize.y, <span style=color:#ae81ff>1.0f</span> / textureSize.x, <span style=color:#ae81ff>1.0f</span> / textureSize.y);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> PreProcess(RenderTexture target)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;PreProcessMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSize(textureSize));
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_SourceTex&#34;</span>, texture);
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, target);
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernelID,
</span></span><span style=display:flex><span>            Mathf.CeilToInt(textureSize.x / x),
</span></span><span style=display:flex><span>            Mathf.CeilToInt(textureSize.y / y),
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ComputeRCSM(Vector2Int offset, RenderTexture source, RenderTexture target)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RCSMMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSize(textureSize));
</span></span><span style=display:flex><span>        computeShader.SetVector(<span style=color:#e6db74>&#34;_CacheOffset&#34;</span>, <span style=color:#66d9ef>new</span> Vector2(offset.x, offset.y));
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_SourceTex&#34;</span>, source);
</span></span><span style=display:flex><span>        computeShader.SetTexture(kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, target);
</span></span><span style=display:flex><span>        computeShader.Dispatch(kernelID,
</span></span><span style=display:flex><span>            Mathf.CeilToInt(textureSize.x / x),
</span></span><span style=display:flex><span>            Mathf.CeilToInt(textureSize.y / y),
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IEnumerator DispatchCompute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        PreProcess(rts[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;RCSMMain&#34;</span>);
</span></span><span style=display:flex><span>        computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>        Vector2Int dispatchCount = <span style=color:#66d9ef>new</span> Vector2Int(Mathf.CeilToInt(textureSize.x / x),
</span></span><span style=display:flex><span>                                                    Mathf.CeilToInt(textureSize.y / y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> fromID = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> cancel = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; dispatchCount.x; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; dispatchCount.y; j++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                ComputeRCSM(<span style=color:#66d9ef>new</span> Vector2Int(i, j), rts[fromID], rts[<span style=color:#ae81ff>1</span> - fromID]);
</span></span><span style=display:flex><span>                fromID = <span style=color:#ae81ff>1</span> - fromID;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cancel = EditorUtility.DisplayCancelableProgressBar(<span style=color:#e6db74>&#34;In Progress...&#34;</span>, i + <span style=color:#e6db74>&#34;/&#34;</span> + dispatchCount.x, (<span style=color:#66d9ef>float</span>)i / dispatchCount.x);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cancel) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        EditorUtility.ClearProgressBar();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!cancel) SaveRenderTextureToFile(rts[fromID]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateRCSM()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        textureSize = <span style=color:#66d9ef>new</span> Vector2Int(texture.width, texture.height);
</span></span><span style=display:flex><span>        EnsureRTs();
</span></span><span style=display:flex><span>        EnsureRT(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>0</span>], textureSize.x, textureSize.y);
</span></span><span style=display:flex><span>        EnsureRT(<span style=color:#66d9ef>ref</span> rts[<span style=color:#ae81ff>1</span>], textureSize.x, textureSize.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Stop();
</span></span><span style=display:flex><span>        editorCoroutine = EditorCoroutineUtility.StartCoroutine(DispatchCompute(), <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveRenderTextureToFile(RenderTexture rt)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        RenderTexture prev = RenderTexture.active;
</span></span><span style=display:flex><span>        RenderTexture.active = rt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Texture2D toSave = <span style=color:#66d9ef>new</span> Texture2D(textureSize.x, textureSize.y, TextureFormat.ARGB32, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        toSave.ReadPixels(<span style=color:#66d9ef>new</span> Rect(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, textureSize.x, textureSize.y), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>[] bytes = toSave.EncodeToTGA();
</span></span><span style=display:flex><span>        FileStream fs = File.OpenWrite(savePath + suffix);
</span></span><span style=display:flex><span>        fs.Write(bytes);
</span></span><span style=display:flex><span>        fs.Close();
</span></span><span style=display:flex><span>        AssetDatabase.Refresh();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TextureImporter ti = (TextureImporter)AssetImporter.GetAtPath(savePath + suffix);
</span></span><span style=display:flex><span>        ti.mipmapEnabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        ti.sRGBTexture = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        ti.SaveAndReimport();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Texture2D tempTexture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(savePath + suffix);
</span></span><span style=display:flex><span>        EditorGUIUtility.PingObject(tempTexture);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        RenderTexture.active = prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Stop()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (editorCoroutine != <span style=color:#66d9ef>null</span>) EditorCoroutineUtility.StopCoroutine(editorCoroutine);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> rt <span style=color:#66d9ef>in</span> rts)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span>) rt.Release();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        rts = <span style=color:#66d9ef>new</span> RenderTexture[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=rcsmvisualizeshadershader>RCSMVisualizeShader.shader<a hidden class=anchor aria-hidden=true href=#rcsmvisualizeshadershader>#</a></h3><p>è®¡ç®—Parallaxçš„åœ°æ–¹åˆ†æˆä¸¤ä¸ªå¾ªç¯ï¼Œç¬¬ä¸€ä¸ªå¾ªç¯é€šè¿‡<code>coneRatio</code>å’Œæ·±åº¦å€¼è¿›è¡Œå…‰çº¿æ­¥è¿›ç›´åˆ°é‡‡æ ·ç‚¹åœ¨é«˜åº¦å›¾å†…éƒ¨ï¼Œç¬¬äºŒä¸ªå¾ªç¯é€šè¿‡äºŒåˆ†æ³•è·å¾—è¾ƒä¸ºå‡†ç¡®çš„uvã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/RCSMVisualizeShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _BaseColor(<span style=color:#e6db74>&#34;Base Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _RCSMTex(<span style=color:#e6db74>&#34;RCSM Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalMap(<span style=color:#e6db74>&#34;Normal Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bump&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalIntensity(<span style=color:#e6db74>&#34;Normal Intensity&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _ParallaxIntensity(<span style=color:#e6db74>&#34;Parallax Intensity&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _ParallaxIteration(<span style=color:#e6db74>&#34;Parallax Iteration&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sampler2D _MainTex;
</span></span><span style=display:flex><span>    sampler2D _NormalMap;
</span></span><span style=display:flex><span>    sampler2D _RCSMTex;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _BaseColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _NormalIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIteration;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tbnView[<span style=color:#ae81ff>3</span>]   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Varyings vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS, input.tangentOS);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cameraOS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_I_M, <span style=color:#66d9ef>float4</span>(GetCameraPositionWS(), <span style=color:#ae81ff>1.0f</span>)).xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sign <span style=color:#f92672>=</span> (input.tangentOS.w <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> GetOddNegativeScale();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangent <span style=color:#f92672>=</span> cross(input.normalOS, input.tangentOS.xyz) <span style=color:#f92672>*</span> sign;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3x3</span> tbnMat <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3x3</span>(input.tangentOS.xyz, bitangent, input.normalOS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewTS <span style=color:#f92672>=</span> mul(tbnMat, cameraOS <span style=color:#f92672>-</span> input.positionOS.xyz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        output.tbnView[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.tangentWS, viewTS.x);
</span></span><span style=display:flex><span>        output.tbnView[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.bitangentWS <span style=color:#f92672>*</span> sign, viewTS.y);
</span></span><span style=display:flex><span>        output.tbnView[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.normalWS, viewTS.z);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> sampleRCSM(<span style=color:#66d9ef>float2</span> uv)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> rcsm <span style=color:#f92672>=</span> tex2D(_RCSMTex, uv).xy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> rcsm.x, rcsm.y);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> getStepLength(<span style=color:#66d9ef>float</span> rayRatio, <span style=color:#66d9ef>float</span> coneRatio, <span style=color:#66d9ef>float</span> rayHeight, <span style=color:#66d9ef>float</span> sampleHeight)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> totalRatio <span style=color:#f92672>=</span> rayRatio <span style=color:#f92672>/</span> coneRatio <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (sampleHeight <span style=color:#f92672>-</span> rayHeight) <span style=color:#f92672>/</span> totalRatio;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> parallax(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float3</span> view)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        view.xy <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>view.xy <span style=color:#f92672>*</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> samplePos <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(uv, <span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> rcsm <span style=color:#f92672>=</span> sampleRCSM(samplePos.xy);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> rayRatio <span style=color:#f92672>=</span> length(view.xy);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> coneRatio <span style=color:#f92672>=</span> rcsm.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> rayHeight <span style=color:#f92672>=</span> samplePos.z;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sampleHeight <span style=color:#f92672>=</span> rcsm.x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> stepLength <span style=color:#f92672>=</span> getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);  
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>30</span>)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> _ParallaxIteration; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            samplePos <span style=color:#f92672>+=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>            rcsm <span style=color:#f92672>=</span> sampleRCSM(samplePos.xy);
</span></span><span style=display:flex><span>            coneRatio <span style=color:#f92672>=</span> rcsm.y;
</span></span><span style=display:flex><span>            rayHeight <span style=color:#f92672>=</span> samplePos.z;
</span></span><span style=display:flex><span>            sampleHeight <span style=color:#f92672>=</span> rcsm.x;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (sampleHeight <span style=color:#f92672>&lt;=</span> rayHeight) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            stepLength <span style=color:#f92672>=</span> getStepLength(rayRatio, coneRatio, rayHeight, sampleHeight);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        stepLength <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>        samplePos <span style=color:#f92672>-=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            rcsm <span style=color:#f92672>=</span> sampleRCSM(samplePos.xy);
</span></span><span style=display:flex><span>            stepLength <span style=color:#f92672>*=</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (samplePos.z <span style=color:#f92672>&gt;=</span> rcsm.x)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                samplePos <span style=color:#f92672>-=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(samplePos.z <span style=color:#f92672>&lt;</span> rcsm.x)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                samplePos <span style=color:#f92672>+=</span> stepLength <span style=color:#f92672>*</span> view;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> samplePos.xy;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewTS <span style=color:#f92672>=</span> normalize(<span style=color:#66d9ef>float3</span>(input.tbnView[<span style=color:#ae81ff>0</span>].w, input.tbnView[<span style=color:#ae81ff>1</span>].w, input.tbnView[<span style=color:#ae81ff>2</span>].w));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tangentWS <span style=color:#f92672>=</span> normalize(input.tbnView[<span style=color:#ae81ff>0</span>].xyz);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangentWS <span style=color:#f92672>=</span> normalize(input.tbnView[<span style=color:#ae81ff>1</span>].xyz);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalWS <span style=color:#f92672>=</span> normalize(input.tbnView[<span style=color:#ae81ff>2</span>].xyz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> z <span style=color:#f92672>=</span> max(abs(viewTS.z), <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>) <span style=color:#f92672>*</span> (viewTS.z <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> parallax(input.uv, viewTS <span style=color:#f92672>/</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> mainTex <span style=color:#f92672>=</span> tex2D(_MainTex, uv) <span style=color:#f92672>*</span> _BaseColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalTS <span style=color:#f92672>=</span> normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> n <span style=color:#f92672>=</span> normalize(normalTS.x <span style=color:#f92672>*</span> tangentWS <span style=color:#f92672>+</span> normalTS.y <span style=color:#f92672>*</span> bitangentWS <span style=color:#f92672>+</span> normalTS.z <span style=color:#f92672>*</span> normalWS);
</span></span><span style=display:flex><span>        Light mainLight <span style=color:#f92672>=</span> GetMainLight();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ndotl <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.0f</span>, dot(n, mainLight.direction));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> mainTex.rgb <span style=color:#f92672>*</span> mainLight.color <span style=color:#f92672>*</span> ndotl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> mainTex.a;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(color, alpha);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags{ <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span>}
</span></span><span style=display:flex><span>        Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style=display:flex><span>        ZWrite Off
</span></span><span style=display:flex><span>        Cull Back
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=pomshadershader>POMShader.shader<a hidden class=anchor aria-hidden=true href=#pomshadershader>#</a></h3><p>å¾ˆå¤§ç¨‹åº¦åœ°å‚è€ƒäº†<a href=https://www.shadertoy.com/view/3ds3zf>normal vs parallax</a>çš„è®¡ç®—æ–¹å¼ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;zznewclear13/POMShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _BaseColor(<span style=color:#e6db74>&#34;Base Color&#34;</span>, Color) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        _MainTex (<span style=color:#e6db74>&#34;Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _HeightMap(<span style=color:#e6db74>&#34;Height Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalMap(<span style=color:#e6db74>&#34;Normal Map&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bump&#34;</span> {}
</span></span><span style=display:flex><span>        _NormalIntensity(<span style=color:#e6db74>&#34;Normal Intensity&#34;</span>, Range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _ParallaxIntensity (<span style=color:#e6db74>&#34;Parallax Intensity&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        _ParallaxIteration (<span style=color:#e6db74>&#34;Parallax Iteration&#34;</span>, Float) <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sampler2D _MainTex;
</span></span><span style=display:flex><span>    sampler2D _HeightMap;
</span></span><span style=display:flex><span>    sampler2D _NormalMap;
</span></span><span style=display:flex><span>    CBUFFER_START(UnityPerMaterial)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _BaseColor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _NormalIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> _ParallaxIteration;
</span></span><span style=display:flex><span>    CBUFFER_END
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalOS     <span style=color:#f92672>:</span> NORMAL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tangentOS    <span style=color:#f92672>:</span> TANGENT;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv           <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> tbnView[<span style=color:#ae81ff>3</span>]   <span style=color:#f92672>:</span> TEXCOORD1;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Varyings vert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vpi <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        VertexNormalInputs vni <span style=color:#f92672>=</span> GetVertexNormalInputs(input.normalOS, input.tangentOS);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cameraOS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_I_M, <span style=color:#66d9ef>float4</span>(GetCameraPositionWS(), <span style=color:#ae81ff>1.0f</span>)).xyz;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> sign <span style=color:#f92672>=</span> (input.tangentOS.w <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> GetOddNegativeScale();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangent <span style=color:#f92672>=</span> cross(input.normalOS, input.tangentOS.xyz) <span style=color:#f92672>*</span> sign;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3x3</span> tbnMat <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3x3</span>(input.tangentOS.xyz, bitangent, input.normalOS);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewTS <span style=color:#f92672>=</span> mul(tbnMat, cameraOS <span style=color:#f92672>-</span> input.positionOS.xyz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vpi.positionCS;
</span></span><span style=display:flex><span>        output.uv <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        output.tbnView[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.tangentWS, viewTS.x);
</span></span><span style=display:flex><span>        output.tbnView[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.bitangentWS <span style=color:#f92672>*</span> sign, viewTS.y);
</span></span><span style=display:flex><span>        output.tbnView[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(vni.normalWS, viewTS.z);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> sampleHeight(<span style=color:#66d9ef>float2</span> uv)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> tex2D(_HeightMap, uv).r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> parallax(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float3</span> view)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> numLayers <span style=color:#f92672>=</span> _ParallaxIteration;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> layerDepth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> numLayers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> p <span style=color:#f92672>=</span> view.xy <span style=color:#f92672>*</span> _ParallaxIntensity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> deltaUVs <span style=color:#f92672>=</span> p <span style=color:#f92672>/</span> numLayers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> texd <span style=color:#f92672>=</span> sampleHeight(uv);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>30</span>)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (; d <span style=color:#f92672>&lt;</span> texd; d <span style=color:#f92672>+=</span> layerDepth)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            uv <span style=color:#f92672>-=</span> deltaUVs;
</span></span><span style=display:flex><span>            texd <span style=color:#f92672>=</span> sampleHeight(uv);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> lastUVs <span style=color:#f92672>=</span> uv <span style=color:#f92672>+</span> deltaUVs;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> after <span style=color:#f92672>=</span> texd <span style=color:#f92672>-</span> d;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> before <span style=color:#f92672>=</span> sampleHeight(lastUVs) <span style=color:#f92672>-</span> d <span style=color:#f92672>+</span> layerDepth;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> w <span style=color:#f92672>=</span> after <span style=color:#f92672>/</span> (after <span style=color:#f92672>-</span> before);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> lerp(uv, lastUVs, w);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> frag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> viewTS <span style=color:#f92672>=</span> normalize(<span style=color:#66d9ef>float3</span>(input.tbnView[<span style=color:#ae81ff>0</span>].w, input.tbnView[<span style=color:#ae81ff>1</span>].w, input.tbnView[<span style=color:#ae81ff>2</span>].w));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tangentWS <span style=color:#f92672>=</span> normalize(input.tbnView[<span style=color:#ae81ff>0</span>].xyz);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> bitangentWS <span style=color:#f92672>=</span> normalize(input.tbnView[<span style=color:#ae81ff>1</span>].xyz);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalWS <span style=color:#f92672>=</span> normalize(input.tbnView[<span style=color:#ae81ff>2</span>].xyz);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> z <span style=color:#f92672>=</span> max(abs(viewTS.z), <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>) <span style=color:#f92672>*</span> (viewTS.z <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.0f</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> parallax(input.uv, viewTS <span style=color:#f92672>/</span> z);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> mainTex <span style=color:#f92672>=</span> tex2D(_MainTex, uv) <span style=color:#f92672>*</span> _BaseColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> normalTS <span style=color:#f92672>=</span> normalize(UnpackNormalScale(tex2D(_NormalMap, uv), _NormalIntensity));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> n <span style=color:#f92672>=</span> normalize(normalTS.x <span style=color:#f92672>*</span> tangentWS <span style=color:#f92672>+</span> normalTS.y <span style=color:#f92672>*</span> bitangentWS <span style=color:#f92672>+</span> normalTS.z <span style=color:#f92672>*</span> normalWS);
</span></span><span style=display:flex><span>        Light mainLight <span style=color:#f92672>=</span> GetMainLight();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ndotl <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.0f</span>, dot(n, mainLight.direction));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> mainTex.rgb <span style=color:#f92672>*</span> mainLight.color <span style=color:#f92672>*</span> ndotl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> alpha <span style=color:#f92672>=</span> mainTex.a;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(color, alpha);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Tags{ <span style=color:#e6db74>&#34;RenderType&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Transparent&#34;</span>}
</span></span><span style=display:flex><span>        Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style=display:flex><span>        ZWrite Off
</span></span><span style=display:flex><span>        Cull Back
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Pass
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex vert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment frag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>å¤å¤©çœŸçš„å¥½çƒ­ï¼Œçƒ­åˆ°å¤´è„‘éƒ½ä¸æ˜¯å¾ˆæ¸…é†’äº†ï¼Œæ„Ÿè§‰RCSMåº”è¯¥è¦æ¯”POMå¥½å¾ˆå¤šæ‰å¯¹ï¼Œåœ¨è‡ªå·±çš„æµ‹è¯•ä¸­ä¹Ÿåªç¨å¾®å¥½äº†ä¸€äº›äº›ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘å“ªé‡Œæ²¡ç®—å¯¹äº†ã€‚ã€‚ã€‚ä¸è¿‡è›®å¥‡æ€ªçš„GPU Gems 3å‘è¡¨äº2007å¹´ï¼Œç›´åˆ°ä»Šå¤©æˆ‘ä¹Ÿæ²¡çœ‹åˆ°åˆ«çš„Unityä¸Šå®ç°RCSMçš„æ–‡ç« æˆ–è€…githubä»“åº“ï¼ŒUE5ä¹Ÿåªæœ‰Get Reliefè¿™ä¹ˆä¸€ä¸ªæ’ä»¶ã€‚æ˜¯å› ä¸ºæ›²é¢ç»†åˆ†å®åœ¨å¤ªå¥½ç”¨äº†çš„åŸå› å—ï¼Ÿæƒ³èµ·ä¹‹å‰çœ‹æœ€åç”Ÿè¿˜è€…2çš„æŠ€æœ¯åˆ†äº«ï¼Œé‡Œé¢å¤§é‡åœ°ä½¿ç”¨äº†é«˜åº¦å›¾ï¼Œéš¾é“ä¸»è¦æ˜¯ç”¨æ¥åšå¤šç§æè´¨çš„æ··åˆè€Œä¸æ˜¯åšè§†å·®æ•ˆæœå—ï¼Ÿ</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/relaxed-cone-step-mapping/>Relaxed Cone Step Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/parallax-occlusion-mapping/>Parallax Occlusion Mapping</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/unity-high-quality-bloom/><span class=title>Â« Prev</span><br><span>Unityçš„é«˜è´¨é‡çš„Bloomæ•ˆæœ</span>
</a><a class=next href=https://zznewclear13.github.io/posts/almost-continuous-dual-kawase-blur/><span class=title>Next Â»</span><br><span>å‡ ä¹è¿ç»­çš„åŒKawaseæ¨¡ç³Š</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>