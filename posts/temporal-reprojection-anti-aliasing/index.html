<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ | ZZNEWCLEAR13</title><meta name=keywords content="Anti-Aliasing,Unity SRP"><meta name=description content="æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ"><meta property="og:description" content="æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"><meta property="og:image" content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-15T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg"><meta name=twitter:title content="åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ"><meta name=twitter:description content="æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ","item":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ","name":"åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ","description":"æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ.","keywords":["Anti-Aliasing","Unity SRP"],"articleBody":"TAAçš„åŸç† é¦–å…ˆæ˜¯è¦äº†è§£ç”»é¢ä¸Šçš„é”¯é½¿æ˜¯å¦‚ä½•äº§ç”Ÿçš„ã€‚é”¯é½¿å‘ç”Ÿåœ¨å…‰æ …åŒ–çš„é˜¶æ®µï¼Œå…‰æ …åŒ–çš„æ—¶å€™ä¼šä¸¢å¤±æ‰å°äºä¸€ä¸ªåƒç´ å®½çš„ç»†èŠ‚ï¼Œä¹Ÿå°±å¯¼è‡´äº†é”¯é½¿çš„äº§ç”Ÿã€‚\nä»å­—é¢ä¸Šæ¥çœ‹ï¼ŒTAA (Temporal Anti-Aliasing)çš„æŠ—é”¯é½¿æ•ˆæœæ¥æºäºTemporalä¸€è¯ï¼Œæ˜¯ä¸€ç§æ—¶é—´ä¸Šçš„æŠ—é”¯é½¿ã€‚TAAä¼šç»“åˆå½“å‰æ¸²æŸ“çš„ç”»é¢å’Œä¹‹å‰æ¸²æŸ“çš„ç”»é¢ï¼Œé€šè¿‡è¿™ä¸¤ä¸ªç”»é¢ä¹‹é—´çš„èåˆï¼Œè¾¾æˆæŠ—é”¯é½¿çš„æ•ˆæœã€‚åŸºæœ¬æ€æƒ³æ˜¯åœ¨å…‰æ …åŒ–çš„æ—¶å€™å¯¹ç”»é¢è¿›è¡ŒæŠ–åŠ¨ï¼Œè®©äºšåƒç´ çš„ç»†èŠ‚åœ¨ä¸åŒå¸§æ¸²æŸ“åˆ°ä¸åŒçš„åƒç´ ä¸Šï¼Œæœ€åå†å¯¹è¿™äº›åƒç´ æŒ‰æ—¶é—´çš„æƒé‡æ¥æ··åˆï¼Œå°±èƒ½è¾¾åˆ°æŠ—é”¯é½¿çš„æ•ˆæœã€‚\nTemporal Reprojection Anti-Aliasing Temporal Reprojection Anti-Aliasingæ˜¯ç”±PlayDeadåœ¨ä»–ä»¬çš„æ¸¸æˆInsideä¸­ä½¿ç”¨çš„ä¸€ç§TAAçš„æ–¹æ³•ï¼Œä»–ä»¬åœ¨GDC2016çš„æ¼”ç¤ºä¸­åˆ†äº«äº†è¿™ä¸ªæ–¹æ³•ã€‚ç›¸è¾ƒäºæ™®é€šçš„TAAæ¥è¯´ï¼ŒTemporal Reprojection Anti-Aliasingä¸­ä½¿ç”¨äº†Velocity Bufferä¸­çš„å±å¹•åƒç´ çš„é€Ÿåº¦ä¿¡æ¯å’ŒDepth Bufferä¸­å¯¹åº”çš„å±å¹•åƒç´ çš„ä¸–ç•Œåæ ‡ä¿¡æ¯ï¼Œè¿™æ ·å½“ç‰©ä½“ç§»åŠ¨æˆ–è€…ç›¸æœºç§»åŠ¨çš„æ—¶å€™ï¼Œåœ¨åšåˆ°æŠ—é”¯é½¿çš„åŒæ—¶ä¹Ÿå‡å°‘äº†TAAå¸¦æ¥çš„æ‹–å½±æ•ˆæœï¼ŒåŒæ—¶ä¹ŸæŠŠTAAå’Œè¿åŠ¨æ¨¡ç³Šç›¸ç»“åˆè¾¾åˆ°æ›´ç†æƒ³çš„æŠ—é”¯é½¿çš„æ•ˆæœã€‚\nPlayDeadæä¾›äº†å¯¹åº”çš„æºä»£ç ã€‚æœ¬åšå®¢ä¸­TAAåœ¨SRPä¸­çš„å®ç°ä¹Ÿå‚è€ƒäº†sienaiwunçš„TAAä»£ç ã€‚\nåœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ  æˆ‘ä»¬é€šè¿‡RendererFeatureçš„æ–¹å¼åœ¨æ¸²æŸ“ç®¡çº¿ä¸­åŠ å…¥TAAã€‚åœ¨ForwardRendererDataä¸­åŠ å…¥RendererFeatureåï¼Œå¾€Global Volumeä¸­æ·»åŠ Temporal Anti-Aliasingä»¥åœ¨åœºæ™¯ä¸­å¯ç”¨TAAæ•ˆæœã€‚å¯ç”¨TAAæ•ˆæœåï¼Œä¼šç°åœ¨æ¸²æŸ“ä¸é€æ˜ç‰©ä½“ä¹‹å‰è°ƒç”¨ä¸€ä¸ªJitter Passå¯¹ç›¸æœºçš„æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼›åœ¨æ¸²æŸ“TAA Passæ—¶ï¼ˆåœ¨Bloomç­‰è·Ÿç‰©ä½“æ¸²æŸ“ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹åï¼Œåœ¨Chromatic Aberrationç­‰è·Ÿå±å¹•ç©ºé—´ä½ç½®ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹å‰ï¼‰æ ¹æ®æŠ–åŠ¨å€¼è¿˜åŸå‡ºæ­£å¸¸çš„ä¸æŠ–åŠ¨çš„ç”»é¢ï¼Œå¹¶å’ŒAccumTextureè¿›è¡Œæ··åˆï¼Œè·å¾—æœ€ç»ˆçš„æ¸²æŸ“ç”»é¢ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦TAARendererFeatureã€TAAJitterPassã€TAARenderPassè¿™ä¸‰ä¸ªè„šæœ¬æ¥å¤„ç†æ¸²æŸ“ç®¡çº¿ï¼ŒTemporalAntiAliasingè¿™ä¸ªè„šæœ¬æ¥å¤„ç†Volumeï¼ŒTAAShaderè¿™ä¸ªShaderæ–‡ä»¶æ¥è¿›è¡ŒTAAçš„æ··åˆæ“ä½œã€‚ å¯¹æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼Œä¹Ÿå°±ç›¸å½“äºæ˜¯ä¿®æ”¹äº†ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µçš„ç¬¬ä¸€ç¬¬äºŒè¡Œçš„ç¬¬ä¸‰ä½çš„å€¼ï¼ŒæŠ–åŠ¨å€¼æœ€å¥½å’ŒTexelSizeç›¸ç»“åˆï¼Œè¿™æ ·åœ¨TAAåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸å€¼çš„æ—¶å€™ï¼Œåœ¨shaderä¸­ä¼šæ¯”è¾ƒå¥½å†™ã€‚æŠ–åŠ¨å€¼å’ŒTAAçš„åå‘æŠ–åŠ¨æ˜¯æ­£æ¯”å…³ç³»ï¼Œå› æ­¤å¯ä»¥ä¸éœ€è¦ç‰¹åˆ«çº ç»“äºè®¡ç®—ï¼Œåœ¨shaderä¸­ä¼ å…¥ä¸€ä¸ªdebugå€¼å†å’ŒæŠ–åŠ¨å€¼ç›¸ä¹˜ç”¨ä½œåå‘æŠ–åŠ¨ï¼Œè§‚å¯Ÿæœ€åçš„ç”»é¢æ˜¯å¦å­˜åœ¨æŠ–åŠ¨ï¼Œå°±èƒ½å¾ˆå¥½çš„åˆ¤æ–­å‡ºè¿™ä¸¤ä¸ªå€¼çš„æ¯”ä¾‹äº†ã€‚æŠ–åŠ¨çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œçº¯éšæœºçš„æŠ–åŠ¨ä¹Ÿå¯ä»¥é€‰æ‹©ï¼Œä¸è¿‡ç¨ä¸å¦‚ä½¿ç”¨å‡åŒ€åˆ†å¸ƒçš„éšæœºæŠ–åŠ¨çš„æ•ˆæœå¥½ï¼Œè¿™é‡Œä½¿ç”¨Insideä¸­çš„æ–¹å¼å³åˆ©ç”¨Haltonæ•°åˆ—è¿›è¡ŒæŠ–åŠ¨ã€‚ ä¸ºäº†è®©ç›¸æœºç§»åŠ¨æ—¶ä¹Ÿèƒ½æœ‰è¾ƒå¥½çš„æŠ—é”¯é½¿æ•ˆæœä¸”å‰Šå¼±æ‹–å½±ç°è±¡ï¼ŒTemporal Reprojection Anti-Aliasingéœ€è¦é‡‡æ ·å½“å‰çš„æ·±åº¦è´´å›¾ï¼Œè¿˜åŸå‡ºç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œå†è®¡ç®—å‡ºè¿™ä¸ªä¸–ç•Œç©ºé—´åœ¨AccumTextureä¸­çš„UVå€¼(Reprojection)ï¼Œä½¿ç”¨è¿™ä¸ªUVå€¼é‡‡æ ·AccumTextureå†å’Œå½“å‰æ¸²æŸ“ç”»é¢è¿›è¡Œèåˆã€‚ å› ä¸ºVelocity Bufferæ¯”è¾ƒéº»çƒ¦ï¼Œè¿™é‡Œæš‚ä¸”å¿½ç•¥æ‰ç‰©ä½“ç§»åŠ¨å¯¹TAAå¸¦æ¥çš„å½±å“ã€‚ åœ¨ScriptableRenderPassä¸­ä½¿ç”¨cmd.GetTemporaryRT()è·å¾—çš„Render Textureï¼Œåœ¨å½“å¸§è¿‡åå°±ä¼šè¢«å›æ”¶ï¼Œå› æ­¤AccumTextureéœ€è¦ä½¿ç”¨RenderTexture.GetTemporary()æ¥è·å–ã€‚è¿™é‡Œæˆ‘æŠŠAccumTextureæ”¾åœ¨TemporalAntiAliasing.csä¸­ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚  TemporalAntiAliasing.cs é™¤äº†æ™®é€šçš„Volumeçš„è®¾ç½®ä¹‹å¤–ï¼Œè¿˜éœ€è¦æä¾›Render Textureçš„æ¥å£ã€‚lastFrameçš„xå€¼å’Œyå€¼åˆ†åˆ«å¯¹åº”æœ€åæ¸²æŸ“ç”»é¢ä¸­å¯¹AccumTextureè¿›è¡Œçº¿æ€§æ’å€¼çš„æœ€å°å’Œæœ€å¤§ç³»æ•°ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"Post-processing/Temporal Anti-Aliasing\")] public class TemporalAntiAliasing : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public NoInterpFloatRangeParameter lastFrame = new NoInterpFloatRangeParameter(new Vector2(0.2f, 0.8f), 0f, 1f); public Vector2Parameter jitterIntensity = new Vector2Parameter(Vector2.one); private RenderTexture[] accumTextures; public bool IsActive() { return isEnabled.value; } public bool IsTileCompatible() { return false; } void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } bool EnsureRenderTarget(ref RenderTexture rt, int width, int height, RenderTextureFormat format, FilterMode filterMode, string name, int depthBits = 0, int antiAliasing = 1) { if (rt != null \u0026\u0026 (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing); rt.name = name; rt.filterMode = filterMode; rt.wrapMode = TextureWrapMode.Clamp; return true;// new target  } return false;// same target  } public void EnsureRT(RenderTextureDescriptor descriptor) { EnsureArray(ref accumTextures, 2); EnsureRenderTarget(ref accumTextures[0], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, \"TAA_Accum_One\"); EnsureRenderTarget(ref accumTextures[1], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, \"TAA_Accum_Two\"); } public RenderTexture GetRT(int index) { return accumTextures[index]; } } } TAARendererFeature.cs åœ¨TAARendererFeatureä¸­ç”Ÿæˆç›¸æœºæŠ–åŠ¨çš„å€¼ï¼Œé€šè¿‡TAAJitterPasså¯¹ç›¸æœºçš„æŠ•å½±çŸ©é˜µè¿›è¡ŒæŠ–åŠ¨ï¼Œé€šè¿‡TAARenderPassåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸çš„ç”»é¢ã€‚Haltonåºåˆ—çš„ç”Ÿæˆæ–¹å¼å¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œè¿™é‡Œæš‚ä¸”ç•¥è¿‡ã€‚è¿™é‡Œä¹Ÿæš‚ä¸”å¿½ç•¥äº†DX11å’ŒOpenGLçš„å¹³å°å·®å¼‚åŒ–å¤„ç†ï¼ˆæ— éå°±æ˜¯UVçš„Yè½´ç¿»è½¬çš„é—®é¢˜ï¼‰ã€‚\nnamespace UnityEngine.Rendering.Universal { public class TAARendererFeature : ScriptableRendererFeature { [System.Serializable] public class TAASettings { public bool isEnabled = true; //æœ€å¥½æ˜¯AfterRenderingPostProcessingï¼Œä¸è¿‡ä¼šæœ‰CameraTargetçš„é—®é¢˜ï¼Œéœ€è¦æ›´å¤šçš„è®¾ç½®  public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; } public TAASettings settings = new TAASettings(); TAARenderPass taaRenderPass; TAAJitterPass taaJitterPass; private TAAData taaData; private int haltonIndex = 0; private Vector2 lastOffset; private Matrix4x4 lastProj = Matrix4x4.identity; private Matrix4x4 lastView = Matrix4x4.identity; [SerializeField, HideInInspector] private Shader taaShader; public override void Create() { taaShader = Shader.Find(\"Hidden/Universal Render Pipeline/TAAShader\"); if (taaShader == null) { Debug.LogWarning(\"Shader was not found. Please ensure it compiles correctly\"); return; } taaData = new TAAData(); taaData.Initialize(); taaJitterPass = new TAAJitterPass(); taaRenderPass = new TAARenderPass(settings); } public struct TAAData { public Vector2 offset; public Vector2 lastOffset; public Matrix4x4 lastProj; public Matrix4x4 lastView; public Matrix4x4 jitteredProj; public Matrix4x4 currentView; public void Initialize() { offset = Vector2.zero; lastOffset = Vector2.zero; lastProj = Matrix4x4.identity; lastView = Matrix4x4.identity; jitteredProj = Matrix4x4.identity; currentView = Matrix4x4.identity; } } private float HaltonSeq(int prime, int index = 1/* NOT! zero-based */) { float r = 0.0f; float f = 1.0f; int i = index; while (i  0) { f /= prime; r += f * (i % prime); i = (int)Mathf.Floor(i / (float)prime); } return r; } //dx11 only?  private Matrix4x4 GetJitteredProjectionMatrix(Camera camera, Vector2 offset, Vector2 jitterIntensity) { Matrix4x4 originalProjMatrix = camera.nonJitteredProjectionMatrix; float near = camera.nearClipPlane; float far = camera.farClipPlane; Vector2 matrixOffset = offset * new Vector2(1f / camera.pixelWidth, 1f / camera.pixelHeight) * jitterIntensity; //[row, column]  originalProjMatrix[0, 2] = matrixOffset.x; originalProjMatrix[1, 2] = matrixOffset.y; return originalProjMatrix; } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { Camera camera = renderingData.cameraData.camera; TemporalAntiAliasing taaComponent = VolumeManager.instance.stack.GetComponent(); if(renderingData.cameraData.cameraType == CameraType.Game \u0026\u0026 taaComponent.IsActive()) { // è·å–Offsetå€¼  haltonIndex = (haltonIndex + 1) \u0026 1023; Vector2 offset = new Vector2( HaltonSeq(2, haltonIndex + 1) - 0.5f, HaltonSeq(3, haltonIndex + 1) - 0.5f); // è·å–jittered projection matrixï¼Œå¹¶è®°å½•ä¹‹å‰çš„matrix  // jittered projectionçš„abåº”è¯¥å¯¹åº”0.5 * texel_size.xy  lastOffset = taaData.offset; taaData.lastOffset = lastOffset; taaData.offset = new Vector2(offset.x / camera.pixelWidth, offset.y / camera.pixelHeight) * taaComponent.jitterIntensity.value; taaData.jitteredProj = GetJitteredProjectionMatrix(camera, offset, taaComponent.jitterIntensity.value); taaData.lastProj = lastProj; taaData.lastView = lastView; lastProj = camera.projectionMatrix; lastView = camera.worldToCameraMatrix; taaData.currentView = lastView; // ç¬¬ä¸€ä¸ªPasså¯¹ç›¸æœºä½¿ç”¨jittered projection matrix  taaJitterPass.Setup(taaData); renderer.EnqueuePass(taaJitterPass); //ç¬¬äºŒä¸ªPassæ‰§è¡ŒçœŸæ­£çš„TAA  //æš‚æ—¶ä¸è€ƒè™‘motion blur/è¿åŠ¨ç‰©ä½“çš„TAA  taaRenderPass.Setup(taaShader, taaData, taaComponent); renderer.EnqueuePass(taaRenderPass); } } } } TAAJitterPass.cs è¿™ä¸ªPassä»…ç”¨äºæ”¹å˜ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µï¼Œåœ¨æŸäº›æƒ…å†µä¸‹æ¸²æŸ“é€æ˜ç‰©ä½“æ—¶ä¼šé‡ç½®é€è§†å˜æ¢çŸ©é˜µï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦åœ¨BeforeRenderingTransparentçš„æ—¶å€™å†é¢å¤–æ‰§è¡Œä¸€éTAAJitterPassã€‚\nnamespace UnityEngine.Rendering.Universal { public class TAAJitterPass : ScriptableRenderPass { private const string profilerTag = \"TAA Jitter Pass\"; private ProfilingSampler taaSampler = new ProfilingSampler(\"TAA Jitter Pass\"); private TAARendererFeature.TAAData taaData; public TAAJitterPass() { profilingSampler = taaSampler; renderPassEvent = RenderPassEvent.BeforeRenderingOpaques; } public void Setup(TAARendererFeature.TAAData taaData) { this.taaData = taaData; } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, profilingSampler)) { CameraData cameraData = renderingData.cameraData; cmd.SetViewProjectionMatrices(cameraData.camera.worldToCameraMatrix, taaData.jitteredProj); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } } } TAARenderPass.cs ç”±äº_CameraColorTextureæ²¡æœ‰å¼€å¯éšæœºè¯»å†™ï¼Œä½¿ç”¨Compute Shaderè¿›è¡ŒTAAçš„è®¡ç®—ä¼šéœ€è¦é¢å¤–çš„blitï¼Œè¿™é‡Œå°±ä½¿ç”¨æ™®é€šçš„shaderæ¥è¿›è¡ŒTAAçš„æ“ä½œäº†ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { public class TAARenderPass : ScriptableRenderPass { private const string profilerTag = \"My TAA Pass\"; private ProfilingSampler taaSampler = new ProfilingSampler(\"TAA Pass\"); RenderTargetHandle cameraColorHandle; RenderTargetIdentifier cameraColorIden; RenderTargetHandle cameraDepthHandle; RenderTargetIdentifier cameraDepthIden; private Vector2Int screenSize; private int accumIndex; private TAARendererFeature.TAASettings settings; private TAARendererFeature.TAAData taaData; private Material taaMaterial; private TemporalAntiAliasing taaComponent; private Vector2 lastFrame; public TAARenderPass(TAARendererFeature.TAASettings settings) { profilingSampler = new ProfilingSampler(profilerTag); cameraColorHandle.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColorHandle.Identifier(); cameraDepthHandle.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepthHandle.Identifier(); this.settings = settings; } public void Setup(Shader taaShader, TAARendererFeature.TAAData taaData, TemporalAntiAliasing taaComponent) { this.taaData = taaData; renderPassEvent = settings.renderPassEvent; this.lastFrame = taaComponent.lastFrame.value; taaMaterial = new Material(taaShader); this.taaComponent = taaComponent; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor descriptor = cameraTextureDescriptor; screenSize = new Vector2Int(descriptor.width, descriptor.height); taaComponent.EnsureRT(descriptor); } private void DoTAA(CommandBuffer cmd, TemporalAntiAliasing taa, RenderTargetIdentifier colorid, int index) { RenderTexture accumRead = taa.GetRT(index); int tempIndex = 1 - index; RenderTexture accumWrite = taa.GetRT(tempIndex); taaMaterial.SetVector(\"_TAAOffsets\", new Vector4(taaData.offset.x, taaData.offset.y, taaData.lastOffset.x, taaData.lastOffset.y)); taaMaterial.SetVector(\"_TAALastFrame\", taaComponent.lastFrame.value); taaMaterial.SetVector(\"_TextureSize\", new Vector4(screenSize.x, screenSize.y, 1f / screenSize.x, 1f / screenSize.y)); Matrix4x4 lastViewProj = taaData.lastProj * taaData.lastView; taaMaterial.SetMatrix(\"_LastViewProj\", lastViewProj); taaMaterial.SetTexture(\"_AccumTexture\", accumRead); cmd.Blit(colorid, accumWrite, taaMaterial); cmd.Blit(accumWrite, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, taaSampler)) { DoTAA(cmd, taaComponent, cameraColorIden, accumIndex); accumIndex = 1 - accumIndex; } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { if (cmd == null) throw new ArgumentNullException(\"cmd\"); } } } TAAShader.shader å¤šæ¬¡é‡‡æ ·èƒ½å¤Ÿæ˜æ˜¾çš„å‰Šå¼±æ‹–å½±æ•ˆæœï¼ŒtempMain = min(mainTexture, color_avg * 1.25);è¿™ä¸€è¡Œèƒ½å¤Ÿåœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘é«˜å…‰çš„é—ªçƒï¼Œclip_aabbå’Œk_feedbackä¼¼ä¹ç”¨å¤„ä¸æ˜¯å¾ˆå¤§ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯å†™è¿›å»äº†ã€‚\nShader \"Hidden/Universal Render Pipeline/TAAShader\"\r{\rProperties\r{\r_MainTex(\"Main Texture\", 2D) = \"white\"{}\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\rtexture2D _MainTex;\rtexture2D _CameraDepthTexture;\rtexture2D _AccumTexture;\rSamplerState sampler_LinearClamp;\rSamplerState sampler_PointClamp;\rfloat4 _TAAOffsets;\rfloat2 _TAALastFrame;\rfloat4 _TextureSize;\rfloat4x4 _LastViewProj;\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 texcoord : TEXCOORD0;\r};\rfloat3 clip_aabb(float3 aabb_min, float3 aabb_max, float3 avg, float3 input_texel)\r{\rfloat3 p_clip = 0.5 * (aabb_max + aabb_min);\rfloat3 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS;\rfloat3 v_clip = input_texel - p_clip;\rfloat3 v_unit = v_clip / e_clip;\rfloat3 a_unit = abs(v_unit);\rfloat ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));\rif (ma_unit  1.0)\rreturn p_clip + v_clip / ma_unit;\relse\rreturn input_texel;\r}\rVaryings TAAVert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vertexPositionInputs = GetVertexPositionInputs(input.positionOS.xyz);\routput.positionCS = vertexPositionInputs.positionCS;\routput.texcoord = input.texcoord;\rreturn output;\r}\rfloat4 TAAFrag(Varyings input) : SV_TARGET\r{\rfloat2 sampleUV = input.texcoord;\rfloat2 currentOffset = _TAAOffsets.xy;\rfloat2 lastOffset = _TAAOffsets.zw;\rfloat2 unJitteredUV = sampleUV - 0.5 * currentOffset;\rfloat3 mainTexture = _MainTex.SampleLevel(sampler_LinearClamp, unJitteredUV, 0).rgb;\rfloat2 du = float2(_TextureSize.z, 0);\rfloat2 dv = float2(0, _TextureSize.w);\rfloat3 ctl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv - du).rgb;\rfloat3 ctc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv).rgb;\rfloat3 ctr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv + du).rgb;\rfloat3 cml = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - du).rgb;\rfloat3 cmc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV).rgb;\rfloat3 cmr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + du).rgb;\rfloat3 cbl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv - du).rgb;\rfloat3 cbc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv).rgb;\rfloat3 cbr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv + du).rgb;\rfloat3 color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));\rfloat3 color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));\rfloat3 color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;\rfloat depthTexture = _CameraDepthTexture.SampleLevel(sampler_PointClamp, unJitteredUV, 0).r;\rfloat4 positionNDC = float4(sampleUV * 2 - 1, depthTexture, 1);\r#if UNITY_UV_STARTS_AT_TOP\rpositionNDC.y = -positionNDC.y;\r#endif\rfloat4 worldPos = mul(UNITY_MATRIX_I_VP, positionNDC);\rworldPos /= worldPos.w;\rfloat4 lastPositionCS = mul(_LastViewProj, worldPos);\rfloat2 lastUV = lastPositionCS.xy / lastPositionCS.w;\rlastUV = lastUV * 0.5 + 0.5;\rfloat3 accumTexture = _AccumTexture.SampleLevel(sampler_LinearClamp, lastUV, 0).rgb;\rfloat3 tempMain = 0;\raccumTexture = clip_aabb(color_min, color_max, color_avg, accumTexture);\rtempMain = min(mainTexture, color_avg * 1.25);\rfloat lum0 = Luminance(mainTexture);\rfloat lum1 = Luminance(accumTexture);\rfloat unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));\rfloat unbiased_weight = 1.0 - unbiased_diff;\rfloat unbiased_weight_sqr = unbiased_weight * unbiased_weight;\rfloat k_feedback = lerp(_TAALastFrame.x, _TAALastFrame.y, unbiased_weight_sqr);\rfloat3 returnColor = lerp(tempMain, accumTexture, k_feedback);\rif (unJitteredUV.x = 0.5)\r{\rreturnColor = mainTexture;\r}\rreturn float4(returnColor, 1);\r}\rENDHLSL\rSubShader\r{\rZTest Always Cull Back ZWrite Off\rpass\r{\rName \"TAA Pass\"\rHLSLPROGRAM\r#pragma vertex TAAVert\r#pragma fragment TAAFrag\rENDHLSL\r}\r}\r}\rä¸€äº›æ€è€ƒ æ•ˆæœæ€»ä½“æ¥è¯´è¿˜æ˜¯ä¸é”™çš„ï¼Œä½†æ˜¯TAAShaderä¸­lerpå½“å‰æ¸²æŸ“ç”»é¢å’ŒAccumTextureçš„ç®—æ³•åº”è¯¥æœ‰å¾…æé«˜ï¼Œç›®å‰ç‰¹åˆ«ç»†é•¿çš„äºšåƒç´ ç‰¹å¾ï¼ˆå¦‚å‘ˆçº¿çŠ¶çš„é«˜å…‰ï¼‰ä¼šæœ‰é”¯é½¿çˆ¬è¡Œçš„æ„Ÿè§‰ï¼Œç”»é¢ä¸å¤Ÿç¨³å®šï¼Œç‰¹åˆ«å°çš„ç»†èŠ‚ä¼šæœ‰ä¸€é—ªä¸€é—ªçš„æ„Ÿè§‰ï¼Œåº”è¯¥è¿˜èƒ½å†ä¼˜åŒ–ä¼˜åŒ–ã€‚PlayDeadçš„æºä»£ç æœ‰ç‚¹çœ‹ä¸ä¸‹å»ã€‚ã€‚ã€‚å°±åƒµåœ¨è¿™é‡Œäº†ï¼Œå¤§æ¦‚æœ‰ä¸ª80åˆ†å§ã€‚\næˆ‘ä¹Ÿæƒ³å¤šæ”¾å›¾æ¥ç€ï¼Œä½†æ˜¯å®åœ¨æ²¡å•¥å¥½æ”¾çš„ã€‚ã€‚ã€‚å¯¼è‡´åšå®¢è¶Šæ¥è¶Šæ¯ç‡¥äº†ã€‚\n","wordCount":"1382","inLanguage":"en","image":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg","datePublished":"2021-07-15T19:00:00+08:00","dateModified":"2021-07-15T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ</h1><div class=post-description>æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ.</div><div class=post-meta><span title="2021-07-15 19:00:00 +0800 CST">July 15, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/temporal-reprojection-anti-aliasing.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/TemporalAntiAliasing.jpg alt="Temporal Anti-Aliasing Cover"><p>å·¦ä¾§ä¸ºTAAæ•ˆæœï¼Œå³ä¾§æ²¡æœ‰TAA</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ</div></summary><div class=inner><ul><li><a href=#taa%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=TAAçš„åŸç†>TAAçš„åŸç†</a></li><li><a href=#temporal-reprojection-anti-aliasing aria-label="Temporal Reprojection Anti-Aliasing">Temporal Reprojection Anti-Aliasing</a></li><li><a href=#%e5%9c%a8unity-srp%e4%b8%ad%e5%ae%9e%e7%8e%b0taa%e7%9a%84%e6%93%8d%e4%bd%9c aria-label="åœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ">åœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ</a><ul><li><a href=#temporalantialiasingcs aria-label=TemporalAntiAliasing.cs>TemporalAntiAliasing.cs</a></li><li><a href=#taarendererfeaturecs aria-label=TAARendererFeature.cs>TAARendererFeature.cs</a></li><li><a href=#taajitterpasscs aria-label=TAAJitterPass.cs>TAAJitterPass.cs</a></li><li><a href=#taarenderpasscs aria-label=TAARenderPass.cs>TAARenderPass.cs</a></li><li><a href=#taashadershader aria-label=TAAShader.shader>TAAShader.shader</a></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b%e6%80%9d%e8%80%83 aria-label=ä¸€äº›æ€è€ƒ>ä¸€äº›æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=taaçš„åŸç†>TAAçš„åŸç†<a hidden class=anchor aria-hidden=true href=#taaçš„åŸç†>#</a></h2><p>é¦–å…ˆæ˜¯è¦äº†è§£ç”»é¢ä¸Šçš„é”¯é½¿æ˜¯å¦‚ä½•äº§ç”Ÿçš„ã€‚é”¯é½¿å‘ç”Ÿåœ¨å…‰æ …åŒ–çš„é˜¶æ®µï¼Œå…‰æ …åŒ–çš„æ—¶å€™ä¼šä¸¢å¤±æ‰å°äºä¸€ä¸ªåƒç´ å®½çš„ç»†èŠ‚ï¼Œä¹Ÿå°±å¯¼è‡´äº†é”¯é½¿çš„äº§ç”Ÿã€‚</p><p>ä»å­—é¢ä¸Šæ¥çœ‹ï¼ŒTAA (Temporal Anti-Aliasing)çš„æŠ—é”¯é½¿æ•ˆæœæ¥æºäºTemporalä¸€è¯ï¼Œæ˜¯ä¸€ç§æ—¶é—´ä¸Šçš„æŠ—é”¯é½¿ã€‚TAAä¼šç»“åˆå½“å‰æ¸²æŸ“çš„ç”»é¢å’Œä¹‹å‰æ¸²æŸ“çš„ç”»é¢ï¼Œé€šè¿‡è¿™ä¸¤ä¸ªç”»é¢ä¹‹é—´çš„èåˆï¼Œè¾¾æˆæŠ—é”¯é½¿çš„æ•ˆæœã€‚åŸºæœ¬æ€æƒ³æ˜¯åœ¨å…‰æ …åŒ–çš„æ—¶å€™å¯¹ç”»é¢è¿›è¡ŒæŠ–åŠ¨ï¼Œè®©äºšåƒç´ çš„ç»†èŠ‚åœ¨ä¸åŒå¸§æ¸²æŸ“åˆ°ä¸åŒçš„åƒç´ ä¸Šï¼Œæœ€åå†å¯¹è¿™äº›åƒç´ æŒ‰æ—¶é—´çš„æƒé‡æ¥æ··åˆï¼Œå°±èƒ½è¾¾åˆ°æŠ—é”¯é½¿çš„æ•ˆæœã€‚</p><h2 id=temporal-reprojection-anti-aliasing>Temporal Reprojection Anti-Aliasing<a hidden class=anchor aria-hidden=true href=#temporal-reprojection-anti-aliasing>#</a></h2><p>Temporal Reprojection Anti-Aliasingæ˜¯ç”±PlayDeadåœ¨ä»–ä»¬çš„æ¸¸æˆInsideä¸­ä½¿ç”¨çš„ä¸€ç§TAAçš„æ–¹æ³•ï¼Œä»–ä»¬åœ¨<a href=https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in>GDC2016çš„æ¼”ç¤º</a>ä¸­åˆ†äº«äº†è¿™ä¸ªæ–¹æ³•ã€‚ç›¸è¾ƒäºæ™®é€šçš„TAAæ¥è¯´ï¼ŒTemporal Reprojection Anti-Aliasingä¸­ä½¿ç”¨äº†Velocity Bufferä¸­çš„å±å¹•åƒç´ çš„é€Ÿåº¦ä¿¡æ¯å’ŒDepth Bufferä¸­å¯¹åº”çš„å±å¹•åƒç´ çš„ä¸–ç•Œåæ ‡ä¿¡æ¯ï¼Œè¿™æ ·å½“ç‰©ä½“ç§»åŠ¨æˆ–è€…ç›¸æœºç§»åŠ¨çš„æ—¶å€™ï¼Œåœ¨åšåˆ°æŠ—é”¯é½¿çš„åŒæ—¶ä¹Ÿå‡å°‘äº†TAAå¸¦æ¥çš„æ‹–å½±æ•ˆæœï¼ŒåŒæ—¶ä¹ŸæŠŠTAAå’Œè¿åŠ¨æ¨¡ç³Šç›¸ç»“åˆè¾¾åˆ°æ›´ç†æƒ³çš„æŠ—é”¯é½¿çš„æ•ˆæœã€‚</p><p>PlayDeadæä¾›äº†å¯¹åº”çš„<a href=https://github.com/playdeadgames/temporal>æºä»£ç </a>ã€‚æœ¬åšå®¢ä¸­TAAåœ¨SRPä¸­çš„å®ç°ä¹Ÿå‚è€ƒäº†sienaiwunçš„<a href=https://github.com/sienaiwun/TAA_Unity_URP>TAAä»£ç </a>ã€‚</p><h2 id=åœ¨unity-srpä¸­å®ç°taaçš„æ“ä½œ>åœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#åœ¨unity-srpä¸­å®ç°taaçš„æ“ä½œ>#</a></h2><ol><li>æˆ‘ä»¬é€šè¿‡RendererFeatureçš„æ–¹å¼åœ¨æ¸²æŸ“ç®¡çº¿ä¸­åŠ å…¥TAAã€‚åœ¨ForwardRendererDataä¸­åŠ å…¥RendererFeatureåï¼Œå¾€Global Volumeä¸­æ·»åŠ Temporal Anti-Aliasingä»¥åœ¨åœºæ™¯ä¸­å¯ç”¨TAAæ•ˆæœã€‚å¯ç”¨TAAæ•ˆæœåï¼Œä¼šç°åœ¨æ¸²æŸ“ä¸é€æ˜ç‰©ä½“ä¹‹å‰è°ƒç”¨ä¸€ä¸ªJitter Passå¯¹ç›¸æœºçš„æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼›åœ¨æ¸²æŸ“TAA Passæ—¶ï¼ˆåœ¨Bloomç­‰è·Ÿç‰©ä½“æ¸²æŸ“ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹åï¼Œåœ¨Chromatic Aberrationç­‰è·Ÿå±å¹•ç©ºé—´ä½ç½®ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹å‰ï¼‰æ ¹æ®æŠ–åŠ¨å€¼è¿˜åŸå‡ºæ­£å¸¸çš„ä¸æŠ–åŠ¨çš„ç”»é¢ï¼Œå¹¶å’ŒAccumTextureè¿›è¡Œæ··åˆï¼Œè·å¾—æœ€ç»ˆçš„æ¸²æŸ“ç”»é¢ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦TAARendererFeatureã€TAAJitterPassã€TAARenderPassè¿™ä¸‰ä¸ªè„šæœ¬æ¥å¤„ç†æ¸²æŸ“ç®¡çº¿ï¼ŒTemporalAntiAliasingè¿™ä¸ªè„šæœ¬æ¥å¤„ç†Volumeï¼ŒTAAShaderè¿™ä¸ªShaderæ–‡ä»¶æ¥è¿›è¡ŒTAAçš„æ··åˆæ“ä½œã€‚</li><li>å¯¹æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼Œä¹Ÿå°±ç›¸å½“äºæ˜¯ä¿®æ”¹äº†ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µçš„ç¬¬ä¸€ç¬¬äºŒè¡Œçš„ç¬¬ä¸‰ä½çš„å€¼ï¼ŒæŠ–åŠ¨å€¼æœ€å¥½å’ŒTexelSizeç›¸ç»“åˆï¼Œè¿™æ ·åœ¨TAAåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸å€¼çš„æ—¶å€™ï¼Œåœ¨shaderä¸­ä¼šæ¯”è¾ƒå¥½å†™ã€‚æŠ–åŠ¨å€¼å’ŒTAAçš„åå‘æŠ–åŠ¨æ˜¯æ­£æ¯”å…³ç³»ï¼Œå› æ­¤å¯ä»¥ä¸éœ€è¦ç‰¹åˆ«çº ç»“äºè®¡ç®—ï¼Œåœ¨shaderä¸­ä¼ å…¥ä¸€ä¸ªdebugå€¼å†å’ŒæŠ–åŠ¨å€¼ç›¸ä¹˜ç”¨ä½œåå‘æŠ–åŠ¨ï¼Œè§‚å¯Ÿæœ€åçš„ç”»é¢æ˜¯å¦å­˜åœ¨æŠ–åŠ¨ï¼Œå°±èƒ½å¾ˆå¥½çš„åˆ¤æ–­å‡ºè¿™ä¸¤ä¸ªå€¼çš„æ¯”ä¾‹äº†ã€‚æŠ–åŠ¨çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œçº¯éšæœºçš„æŠ–åŠ¨ä¹Ÿå¯ä»¥é€‰æ‹©ï¼Œä¸è¿‡ç¨ä¸å¦‚ä½¿ç”¨å‡åŒ€åˆ†å¸ƒçš„éšæœºæŠ–åŠ¨çš„æ•ˆæœå¥½ï¼Œè¿™é‡Œä½¿ç”¨Insideä¸­çš„æ–¹å¼å³åˆ©ç”¨Haltonæ•°åˆ—è¿›è¡ŒæŠ–åŠ¨ã€‚</li><li>ä¸ºäº†è®©ç›¸æœºç§»åŠ¨æ—¶ä¹Ÿèƒ½æœ‰è¾ƒå¥½çš„æŠ—é”¯é½¿æ•ˆæœä¸”å‰Šå¼±æ‹–å½±ç°è±¡ï¼ŒTemporal Reprojection Anti-Aliasingéœ€è¦é‡‡æ ·å½“å‰çš„æ·±åº¦è´´å›¾ï¼Œè¿˜åŸå‡ºç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œå†è®¡ç®—å‡ºè¿™ä¸ªä¸–ç•Œç©ºé—´åœ¨AccumTextureä¸­çš„UVå€¼(Reprojection)ï¼Œä½¿ç”¨è¿™ä¸ªUVå€¼é‡‡æ ·AccumTextureå†å’Œå½“å‰æ¸²æŸ“ç”»é¢è¿›è¡Œèåˆã€‚</li><li>å› ä¸ºVelocity Bufferæ¯”è¾ƒéº»çƒ¦ï¼Œè¿™é‡Œæš‚ä¸”å¿½ç•¥æ‰ç‰©ä½“ç§»åŠ¨å¯¹TAAå¸¦æ¥çš„å½±å“ã€‚</li><li>åœ¨ScriptableRenderPassä¸­ä½¿ç”¨cmd.GetTemporaryRT()è·å¾—çš„Render Textureï¼Œåœ¨å½“å¸§è¿‡åå°±ä¼šè¢«å›æ”¶ï¼Œå› æ­¤AccumTextureéœ€è¦ä½¿ç”¨RenderTexture.GetTemporary()æ¥è·å–ã€‚è¿™é‡Œæˆ‘æŠŠAccumTextureæ”¾åœ¨TemporalAntiAliasing.csä¸­ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚</li></ol><h3 id=temporalantialiasingcs>TemporalAntiAliasing.cs<a hidden class=anchor aria-hidden=true href=#temporalantialiasingcs>#</a></h3><p>é™¤äº†æ™®é€šçš„Volumeçš„è®¾ç½®ä¹‹å¤–ï¼Œè¿˜éœ€è¦æä¾›Render Textureçš„æ¥å£ã€‚lastFrameçš„xå€¼å’Œyå€¼åˆ†åˆ«å¯¹åº”æœ€åæ¸²æŸ“ç”»é¢ä¸­å¯¹AccumTextureè¿›è¡Œçº¿æ€§æ’å€¼çš„æœ€å°å’Œæœ€å¤§ç³»æ•°ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;Post-processing/Temporal Anti-Aliasing&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TemporalAntiAliasing</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);

        <span style=color:#66d9ef>public</span> NoInterpFloatRangeParameter lastFrame = <span style=color:#66d9ef>new</span> NoInterpFloatRangeParameter(<span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.2f</span>, <span style=color:#ae81ff>0.8f</span>), <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1f</span>);

        <span style=color:#66d9ef>public</span> Vector2Parameter jitterIntensity = <span style=color:#66d9ef>new</span> Vector2Parameter(Vector2.one);

        <span style=color:#66d9ef>private</span> RenderTexture[] accumTextures;


        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }

        <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
        {
            <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
            {
                array = <span style=color:#66d9ef>new</span> T[size];
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
                    array[i] = initialValue;
            }
        }

        <span style=color:#66d9ef>bool</span> EnsureRenderTarget(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height, RenderTextureFormat format, FilterMode filterMode, <span style=color:#66d9ef>string</span> name, <span style=color:#66d9ef>int</span> depthBits = <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> antiAliasing = <span style=color:#ae81ff>1</span>)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing))
            {
                RenderTexture.ReleaseTemporary(rt);
                rt = <span style=color:#66d9ef>null</span>;
            }
            <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
            {
                rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing);
                rt.name = name;
                rt.filterMode = filterMode;
                rt.wrapMode = TextureWrapMode.Clamp;
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;<span style=color:#75715e>// new target
</span><span style=color:#75715e></span>            }
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;<span style=color:#75715e>// same target
</span><span style=color:#75715e></span>        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> EnsureRT(RenderTextureDescriptor descriptor)
        {
            EnsureArray(<span style=color:#66d9ef>ref</span> accumTextures, <span style=color:#ae81ff>2</span>);
            EnsureRenderTarget(<span style=color:#66d9ef>ref</span> accumTextures[<span style=color:#ae81ff>0</span>], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, <span style=color:#e6db74>&#34;TAA_Accum_One&#34;</span>);
            EnsureRenderTarget(<span style=color:#66d9ef>ref</span> accumTextures[<span style=color:#ae81ff>1</span>], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, <span style=color:#e6db74>&#34;TAA_Accum_Two&#34;</span>);
        }

        <span style=color:#66d9ef>public</span> RenderTexture GetRT(<span style=color:#66d9ef>int</span> index)
        {
            <span style=color:#66d9ef>return</span> accumTextures[index];
        }
    }
}
</code></pre></div><h3 id=taarendererfeaturecs>TAARendererFeature.cs<a hidden class=anchor aria-hidden=true href=#taarendererfeaturecs>#</a></h3><p>åœ¨TAARendererFeatureä¸­ç”Ÿæˆç›¸æœºæŠ–åŠ¨çš„å€¼ï¼Œé€šè¿‡TAAJitterPasså¯¹ç›¸æœºçš„æŠ•å½±çŸ©é˜µè¿›è¡ŒæŠ–åŠ¨ï¼Œé€šè¿‡TAARenderPassåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸çš„ç”»é¢ã€‚Haltonåºåˆ—çš„ç”Ÿæˆæ–¹å¼å¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œè¿™é‡Œæš‚ä¸”ç•¥è¿‡ã€‚è¿™é‡Œä¹Ÿæš‚ä¸”å¿½ç•¥äº†DX11å’ŒOpenGLçš„å¹³å°å·®å¼‚åŒ–å¤„ç†ï¼ˆæ— éå°±æ˜¯UVçš„Yè½´ç¿»è½¬çš„é—®é¢˜ï¼‰ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAARendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAASettings</span>
        {
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> isEnabled = <span style=color:#66d9ef>true</span>;
            <span style=color:#75715e>//æœ€å¥½æ˜¯AfterRenderingPostProcessingï¼Œä¸è¿‡ä¼šæœ‰CameraTargetçš„é—®é¢˜ï¼Œéœ€è¦æ›´å¤šçš„è®¾ç½®
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
        }

        <span style=color:#66d9ef>public</span> TAASettings settings = <span style=color:#66d9ef>new</span> TAASettings();
        TAARenderPass taaRenderPass;
        TAAJitterPass taaJitterPass;
        <span style=color:#66d9ef>private</span> TAAData taaData;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> haltonIndex = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>private</span> Vector2 lastOffset;
        <span style=color:#66d9ef>private</span> Matrix4x4 lastProj = Matrix4x4.identity;
        <span style=color:#66d9ef>private</span> Matrix4x4 lastView = Matrix4x4.identity;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [SerializeField, HideInInspector]</span>
        <span style=color:#66d9ef>private</span> Shader taaShader;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            taaShader = Shader.Find(<span style=color:#e6db74>&#34;Hidden/Universal Render Pipeline/TAAShader&#34;</span>);
            <span style=color:#66d9ef>if</span> (taaShader == <span style=color:#66d9ef>null</span>)
            {
                Debug.LogWarning(<span style=color:#e6db74>&#34;Shader was not found. Please ensure it compiles correctly&#34;</span>);
                <span style=color:#66d9ef>return</span>;
            }

            taaData = <span style=color:#66d9ef>new</span> TAAData();
            taaData.Initialize();
            taaJitterPass = <span style=color:#66d9ef>new</span> TAAJitterPass();
            taaRenderPass = <span style=color:#66d9ef>new</span> TAARenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TAAData</span>
        {
            <span style=color:#66d9ef>public</span> Vector2 offset;
            <span style=color:#66d9ef>public</span> Vector2 lastOffset;
            <span style=color:#66d9ef>public</span> Matrix4x4 lastProj;
            <span style=color:#66d9ef>public</span> Matrix4x4 lastView;
            <span style=color:#66d9ef>public</span> Matrix4x4 jitteredProj;
            <span style=color:#66d9ef>public</span> Matrix4x4 currentView;

            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
            {
                offset = Vector2.zero;
                lastOffset = Vector2.zero;
                lastProj = Matrix4x4.identity;
                lastView = Matrix4x4.identity;
                jitteredProj = Matrix4x4.identity;
                currentView = Matrix4x4.identity;
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> HaltonSeq(<span style=color:#66d9ef>int</span> prime, <span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>1</span><span style=color:#75715e>/* NOT! zero-based */</span>)
        {
            <span style=color:#66d9ef>float</span> r = <span style=color:#ae81ff>0.0f</span>;
            <span style=color:#66d9ef>float</span> f = <span style=color:#ae81ff>1.0f</span>;
            <span style=color:#66d9ef>int</span> i = index;
            <span style=color:#66d9ef>while</span> (i &gt; <span style=color:#ae81ff>0</span>)
            {
                f /= prime;
                r += f * (i % prime);
                i = (<span style=color:#66d9ef>int</span>)Mathf.Floor(i / (<span style=color:#66d9ef>float</span>)prime);
            }
            <span style=color:#66d9ef>return</span> r;
        }

        <span style=color:#75715e>//dx11 only?
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> Matrix4x4 GetJitteredProjectionMatrix(Camera camera, Vector2 offset, Vector2 jitterIntensity)
        {
            Matrix4x4 originalProjMatrix = camera.nonJitteredProjectionMatrix;

            <span style=color:#66d9ef>float</span> near = camera.nearClipPlane;
            <span style=color:#66d9ef>float</span> far = camera.farClipPlane;

            Vector2 matrixOffset = offset * <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1f</span> / camera.pixelWidth, <span style=color:#ae81ff>1f</span> / camera.pixelHeight) * jitterIntensity;
            <span style=color:#75715e>//[row, column]
</span><span style=color:#75715e></span>            originalProjMatrix[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>] = matrixOffset.x;
            originalProjMatrix[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>] = matrixOffset.y;
            <span style=color:#66d9ef>return</span> originalProjMatrix;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            Camera camera = renderingData.cameraData.camera;

            TemporalAntiAliasing taaComponent = VolumeManager.instance.stack.GetComponent&lt;TemporalAntiAliasing&gt;();
            <span style=color:#66d9ef>if</span>(renderingData.cameraData.cameraType == CameraType.Game &amp;&amp; taaComponent.IsActive())
            {
                <span style=color:#75715e>// è·å–Offsetå€¼
</span><span style=color:#75715e></span>                haltonIndex = (haltonIndex + <span style=color:#ae81ff>1</span>) &amp; <span style=color:#ae81ff>1023</span>;
                Vector2 offset = <span style=color:#66d9ef>new</span> Vector2(
                    HaltonSeq(<span style=color:#ae81ff>2</span>, haltonIndex + <span style=color:#ae81ff>1</span>) - <span style=color:#ae81ff>0.5f</span>,
                    HaltonSeq(<span style=color:#ae81ff>3</span>, haltonIndex + <span style=color:#ae81ff>1</span>) - <span style=color:#ae81ff>0.5f</span>);

                <span style=color:#75715e>// è·å–jittered projection matrixï¼Œå¹¶è®°å½•ä¹‹å‰çš„matrix
</span><span style=color:#75715e></span>                <span style=color:#75715e>// jittered projectionçš„abåº”è¯¥å¯¹åº”0.5 * texel_size.xy
</span><span style=color:#75715e></span>                lastOffset = taaData.offset;
                taaData.lastOffset = lastOffset;
                taaData.offset = <span style=color:#66d9ef>new</span> Vector2(offset.x / camera.pixelWidth, offset.y / camera.pixelHeight) * taaComponent.jitterIntensity.<span style=color:#66d9ef>value</span>;
                taaData.jitteredProj = GetJitteredProjectionMatrix(camera, offset, taaComponent.jitterIntensity.<span style=color:#66d9ef>value</span>);
                taaData.lastProj = lastProj;
                taaData.lastView = lastView;
                lastProj = camera.projectionMatrix;
                lastView = camera.worldToCameraMatrix;
                taaData.currentView = lastView;

                <span style=color:#75715e>// ç¬¬ä¸€ä¸ªPasså¯¹ç›¸æœºä½¿ç”¨jittered projection matrix
</span><span style=color:#75715e></span>                taaJitterPass.Setup(taaData);
                renderer.EnqueuePass(taaJitterPass);

                <span style=color:#75715e>//ç¬¬äºŒä¸ªPassæ‰§è¡ŒçœŸæ­£çš„TAA
</span><span style=color:#75715e></span>                <span style=color:#75715e>//æš‚æ—¶ä¸è€ƒè™‘motion blur/è¿åŠ¨ç‰©ä½“çš„TAA
</span><span style=color:#75715e></span>                taaRenderPass.Setup(taaShader, taaData, taaComponent);
                renderer.EnqueuePass(taaRenderPass);
            }
        }
    }
}
</code></pre></div><h3 id=taajitterpasscs>TAAJitterPass.cs<a hidden class=anchor aria-hidden=true href=#taajitterpasscs>#</a></h3><p>è¿™ä¸ªPassä»…ç”¨äºæ”¹å˜ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µï¼Œåœ¨æŸäº›æƒ…å†µä¸‹æ¸²æŸ“é€æ˜ç‰©ä½“æ—¶ä¼šé‡ç½®é€è§†å˜æ¢çŸ©é˜µï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦åœ¨BeforeRenderingTransparentçš„æ—¶å€™å†é¢å¤–æ‰§è¡Œä¸€éTAAJitterPassã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAAJitterPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;TAA Jitter Pass&#34;</span>;
        <span style=color:#66d9ef>private</span> ProfilingSampler taaSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;TAA Jitter Pass&#34;</span>);

        <span style=color:#66d9ef>private</span> TAARendererFeature.TAAData taaData;

        <span style=color:#66d9ef>public</span> TAAJitterPass()
        {
            profilingSampler = taaSampler;
            renderPassEvent = RenderPassEvent.BeforeRenderingOpaques;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(TAARendererFeature.TAAData taaData)
        {
            <span style=color:#66d9ef>this</span>.taaData = taaData;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                CameraData cameraData = renderingData.cameraData;
                cmd.SetViewProjectionMatrices(cameraData.camera.worldToCameraMatrix, taaData.jitteredProj);
            }
            context.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=taarenderpasscs>TAARenderPass.cs<a hidden class=anchor aria-hidden=true href=#taarenderpasscs>#</a></h3><p>ç”±äº<code>_CameraColorTexture</code>æ²¡æœ‰å¼€å¯éšæœºè¯»å†™ï¼Œä½¿ç”¨Compute Shaderè¿›è¡ŒTAAçš„è®¡ç®—ä¼šéœ€è¦é¢å¤–çš„blitï¼Œè¿™é‡Œå°±ä½¿ç”¨æ™®é€šçš„shaderæ¥è¿›è¡ŒTAAçš„æ“ä½œäº†ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAARenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;My TAA Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> ProfilingSampler taaSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;TAA Pass&#34;</span>);

        RenderTargetHandle cameraColorHandle;
        RenderTargetIdentifier cameraColorIden;
        RenderTargetHandle cameraDepthHandle;
        RenderTargetIdentifier cameraDepthIden;

        <span style=color:#66d9ef>private</span> Vector2Int screenSize;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> accumIndex;

        <span style=color:#66d9ef>private</span> TAARendererFeature.TAASettings settings;
        <span style=color:#66d9ef>private</span> TAARendererFeature.TAAData taaData;
        <span style=color:#66d9ef>private</span> Material taaMaterial;
        <span style=color:#66d9ef>private</span> TemporalAntiAliasing taaComponent;

        <span style=color:#66d9ef>private</span> Vector2 lastFrame;

        <span style=color:#66d9ef>public</span> TAARenderPass(TAARendererFeature.TAASettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
            cameraColorHandle.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
            cameraColorIden = cameraColorHandle.Identifier();
            cameraDepthHandle.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
            cameraDepthIden = cameraDepthHandle.Identifier();

            <span style=color:#66d9ef>this</span>.settings = settings;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(Shader taaShader, TAARendererFeature.TAAData taaData, TemporalAntiAliasing taaComponent)
        {
            <span style=color:#66d9ef>this</span>.taaData = taaData;
            renderPassEvent = settings.renderPassEvent;
            <span style=color:#66d9ef>this</span>.lastFrame = taaComponent.lastFrame.<span style=color:#66d9ef>value</span>;
            taaMaterial = <span style=color:#66d9ef>new</span> Material(taaShader);
            <span style=color:#66d9ef>this</span>.taaComponent = taaComponent;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            RenderTextureDescriptor descriptor = cameraTextureDescriptor;
            screenSize = <span style=color:#66d9ef>new</span> Vector2Int(descriptor.width, descriptor.height);
            taaComponent.EnsureRT(descriptor);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoTAA(CommandBuffer cmd, TemporalAntiAliasing taa, RenderTargetIdentifier colorid, <span style=color:#66d9ef>int</span> index)
        {
            RenderTexture accumRead = taa.GetRT(index);
            <span style=color:#66d9ef>int</span> tempIndex = <span style=color:#ae81ff>1</span> - index;
            RenderTexture accumWrite = taa.GetRT(tempIndex);

            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TAAOffsets&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(taaData.offset.x, taaData.offset.y, taaData.lastOffset.x, taaData.lastOffset.y));
            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TAALastFrame&#34;</span>, taaComponent.lastFrame.<span style=color:#66d9ef>value</span>);
            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(screenSize.x, screenSize.y, <span style=color:#ae81ff>1f</span> / screenSize.x, <span style=color:#ae81ff>1f</span> / screenSize.y));
            Matrix4x4 lastViewProj = taaData.lastProj * taaData.lastView;
            taaMaterial.SetMatrix(<span style=color:#e6db74>&#34;_LastViewProj&#34;</span>, lastViewProj);
            taaMaterial.SetTexture(<span style=color:#e6db74>&#34;_AccumTexture&#34;</span>, accumRead);

            cmd.Blit(colorid, accumWrite, taaMaterial);
            cmd.Blit(accumWrite, colorid);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, taaSampler))
            {
                DoTAA(cmd, taaComponent, cameraColorIden, accumIndex);
                accumIndex = <span style=color:#ae81ff>1</span> - accumIndex;
            }
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
        {
            <span style=color:#66d9ef>if</span> (cmd == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(<span style=color:#e6db74>&#34;cmd&#34;</span>);
        }
    }
}
</code></pre></div><h3 id=taashadershader>TAAShader.shader<a hidden class=anchor aria-hidden=true href=#taashadershader>#</a></h3><p>å¤šæ¬¡é‡‡æ ·èƒ½å¤Ÿæ˜æ˜¾çš„å‰Šå¼±æ‹–å½±æ•ˆæœï¼Œ<code>tempMain = min(mainTexture, color_avg * 1.25);</code>è¿™ä¸€è¡Œèƒ½å¤Ÿåœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘é«˜å…‰çš„é—ªçƒï¼Œ<code>clip_aabb</code>å’Œ<code>k_feedback</code>ä¼¼ä¹ç”¨å¤„ä¸æ˜¯å¾ˆå¤§ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯å†™è¿›å»äº†ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;Hidden/Universal Render Pipeline/TAAShader&quot;
{
    Properties
    {
        _MainTex(&quot;Main Texture&quot;, 2D) = &quot;white&quot;{}
    }

    HLSLINCLUDE
#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/core.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&quot;

    texture2D _MainTex;
    texture2D _CameraDepthTexture;
    texture2D _AccumTexture;

    SamplerState sampler_LinearClamp;
    SamplerState sampler_PointClamp;

    float4 _TAAOffsets;
    float2 _TAALastFrame;
    float4 _TextureSize;
    float4x4 _LastViewProj;

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float2 texcoord     : TEXCOORD0;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 texcoord     : TEXCOORD0;
    };

    float3 clip_aabb(float3 aabb_min, float3 aabb_max, float3 avg, float3 input_texel)
    {
        float3 p_clip = 0.5 * (aabb_max + aabb_min);
        float3 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
        float3 v_clip = input_texel - p_clip;
        float3 v_unit = v_clip / e_clip;
        float3 a_unit = abs(v_unit);
        float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

        if (ma_unit &gt; 1.0)
            return p_clip + v_clip / ma_unit;
        else
            return input_texel;
    }

    Varyings TAAVert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vertexPositionInputs = GetVertexPositionInputs(input.positionOS.xyz);
        output.positionCS = vertexPositionInputs.positionCS;
        output.texcoord = input.texcoord;
        return output;
    }

    float4 TAAFrag(Varyings input) : SV_TARGET
    {
        float2 sampleUV = input.texcoord;
        float2 currentOffset = _TAAOffsets.xy;
        float2 lastOffset = _TAAOffsets.zw;

        float2 unJitteredUV = sampleUV - 0.5 * currentOffset;

        float3 mainTexture = _MainTex.SampleLevel(sampler_LinearClamp, unJitteredUV, 0).rgb;

        float2 du = float2(_TextureSize.z, 0);
        float2 dv = float2(0, _TextureSize.w);

        float3 ctl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv - du).rgb;
        float3 ctc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv).rgb;
        float3 ctr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv + du).rgb;
        float3 cml = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - du).rgb;
        float3 cmc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV).rgb;
        float3 cmr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + du).rgb;
        float3 cbl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv - du).rgb;
        float3 cbc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv).rgb;
        float3 cbr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv + du).rgb;

        float3 color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
        float3 color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
        float3 color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;

        float depthTexture = _CameraDepthTexture.SampleLevel(sampler_PointClamp, unJitteredUV, 0).r;

        float4 positionNDC = float4(sampleUV * 2 - 1, depthTexture, 1);
#if UNITY_UV_STARTS_AT_TOP
        positionNDC.y = -positionNDC.y;
#endif

        float4 worldPos = mul(UNITY_MATRIX_I_VP, positionNDC);
        worldPos /= worldPos.w;
        float4 lastPositionCS = mul(_LastViewProj, worldPos);
        float2 lastUV = lastPositionCS.xy / lastPositionCS.w;
        lastUV = lastUV * 0.5 + 0.5;

        float3 accumTexture = _AccumTexture.SampleLevel(sampler_LinearClamp, lastUV, 0).rgb;
        float3 tempMain = 0;
        accumTexture = clip_aabb(color_min, color_max, color_avg, accumTexture);
        tempMain = min(mainTexture, color_avg * 1.25);

        float lum0 = Luminance(mainTexture);
        float lum1 = Luminance(accumTexture);

        float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
        float unbiased_weight = 1.0 - unbiased_diff;
        float unbiased_weight_sqr = unbiased_weight * unbiased_weight;
        float k_feedback = lerp(_TAALastFrame.x, _TAALastFrame.y, unbiased_weight_sqr);

        float3 returnColor = lerp(tempMain, accumTexture, k_feedback);
        if (unJitteredUV.x &gt;= 0.5)
        {
            returnColor = mainTexture;
        }
        return float4(returnColor, 1);
    }

    ENDHLSL

    SubShader
    {
        ZTest Always Cull Back ZWrite Off
    
        pass
        {
            Name &quot;TAA Pass&quot;
            HLSLPROGRAM
            #pragma vertex TAAVert
            #pragma fragment TAAFrag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=ä¸€äº›æ€è€ƒ>ä¸€äº›æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#ä¸€äº›æ€è€ƒ>#</a></h2><p>æ•ˆæœæ€»ä½“æ¥è¯´è¿˜æ˜¯ä¸é”™çš„ï¼Œä½†æ˜¯TAAShaderä¸­lerpå½“å‰æ¸²æŸ“ç”»é¢å’ŒAccumTextureçš„ç®—æ³•åº”è¯¥æœ‰å¾…æé«˜ï¼Œç›®å‰ç‰¹åˆ«ç»†é•¿çš„äºšåƒç´ ç‰¹å¾ï¼ˆå¦‚å‘ˆçº¿çŠ¶çš„é«˜å…‰ï¼‰ä¼šæœ‰é”¯é½¿çˆ¬è¡Œçš„æ„Ÿè§‰ï¼Œç”»é¢ä¸å¤Ÿç¨³å®šï¼Œç‰¹åˆ«å°çš„ç»†èŠ‚ä¼šæœ‰ä¸€é—ªä¸€é—ªçš„æ„Ÿè§‰ï¼Œåº”è¯¥è¿˜èƒ½å†ä¼˜åŒ–ä¼˜åŒ–ã€‚PlayDeadçš„æºä»£ç æœ‰ç‚¹çœ‹ä¸ä¸‹å»ã€‚ã€‚ã€‚å°±åƒµåœ¨è¿™é‡Œäº†ï¼Œå¤§æ¦‚æœ‰ä¸ª80åˆ†å§ã€‚</p><p>æˆ‘ä¹Ÿæƒ³å¤šæ”¾å›¾æ¥ç€ï¼Œä½†æ˜¯å®åœ¨æ²¡å•¥å¥½æ”¾çš„ã€‚ã€‚ã€‚å¯¼è‡´åšå®¢è¶Šæ¥è¶Šæ¯ç‡¥äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li><li><a href=https://zznewclear13.github.io/tags/unity-srp/>Unity SRP</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/accelerate-gaussian-blur-using-group-shared-memory/><span class=title>Â« Prev</span><br><span>ä½¿ç”¨Group Shared MemoryåŠ é€Ÿé«˜æ–¯æ¨¡ç³Š</span></a>
<a class=next href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><span class=title>Next Â»</span><br><span>æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const b=document.getElementById('comments');let c=currentHugoTheme=='dark'?'photon-dark':'github-light',a=document.createElement('script');a.src='https://utteranc.es/client.js',a.setAttribute('repo','zznewclear13/zznewclear13.github.io'),a.setAttribute('issue-term','pathname'),a.setAttribute('label','utterances'),a.setAttribute('theme',c),a.setAttribute('crossorigin','anonymous'),a.setAttribute('async',''),b.innerHTML='',b.appendChild(a)}loadComment(),document.getElementById('theme-toggle').onclick=async()=>{await new Promise(a=>setTimeout(a,200));let a=window.localStorage.getItem('pref-theme');a!=currentHugoTheme&&(currentHugoTheme=a,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>