<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>在Unity SRP中实现TAA效果 | ZZNEWCLEAR13</title><meta name=keywords content="Anti-Aliasing,Unity SRP"><meta name=description content="抖动相机来实现TAA抗锯齿效果."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="在Unity SRP中实现TAA效果"><meta property="og:description" content="抖动相机来实现TAA抗锯齿效果."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"><meta property="og:image" content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-15T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg"><meta name=twitter:title content="在Unity SRP中实现TAA效果"><meta name=twitter:description content="抖动相机来实现TAA抗锯齿效果."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"在Unity SRP中实现TAA效果","item":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"在Unity SRP中实现TAA效果","name":"在Unity SRP中实现TAA效果","description":"抖动相机来实现TAA抗锯齿效果.","keywords":["Anti-Aliasing","Unity SRP"],"articleBody":"TAA的原理 首先是要了解画面上的锯齿是如何产生的。锯齿发生在光栅化的阶段，光栅化的时候会丢失掉小于一个像素宽的细节，也就导致了锯齿的产生。\n从字面上来看，TAA (Temporal Anti-Aliasing)的抗锯齿效果来源于Temporal一词，是一种时间上的抗锯齿。TAA会结合当前渲染的画面和之前渲染的画面，通过这两个画面之间的融合，达成抗锯齿的效果。基本思想是在光栅化的时候对画面进行抖动，让亚像素的细节在不同帧渲染到不同的像素上，最后再对这些像素按时间的权重来混合，就能达到抗锯齿的效果。\nTemporal Reprojection Anti-Aliasing Temporal Reprojection Anti-Aliasing是由PlayDead在他们的游戏Inside中使用的一种TAA的方法，他们在GDC2016的演示中分享了这个方法。相较于普通的TAA来说，Temporal Reprojection Anti-Aliasing中使用了Velocity Buffer中的屏幕像素的速度信息和Depth Buffer中对应的屏幕像素的世界坐标信息，这样当物体移动或者相机移动的时候，在做到抗锯齿的同时也减少了TAA带来的拖影效果，同时也把TAA和运动模糊相结合达到更理想的抗锯齿的效果。\nPlayDead提供了对应的源代码。本博客中TAA在SRP中的实现也参考了sienaiwun的TAA代码。\n在Unity SRP中实现TAA的操作  我们通过RendererFeature的方式在渲染管线中加入TAA。在ForwardRendererData中加入RendererFeature后，往Global Volume中添加Temporal Anti-Aliasing以在场景中启用TAA效果。启用TAA效果后，会现在渲染不透明物体之前调用一个Jitter Pass对相机的栅格化阶段进行抖动；在渲染TAA Pass时（在Bloom等跟物体渲染相关的后处理效果之后，在Chromatic Aberration等跟屏幕空间位置相关的后处理效果之前）根据抖动值还原出正常的不抖动的画面，并和AccumTexture进行混合，获得最终的渲染画面。因此我们需要TAARendererFeature、TAAJitterPass、TAARenderPass这三个脚本来处理渲染管线，TemporalAntiAliasing这个脚本来处理Volume，TAAShader这个Shader文件来进行TAA的混合操作。 对栅格化阶段进行抖动，也就相当于是修改了相机的透视变换矩阵的第一第二行的第三位的值，抖动值最好和TexelSize相结合，这样在TAA反向抖动还原正常值的时候，在shader中会比较好写。抖动值和TAA的反向抖动是正比关系，因此可以不需要特别纠结于计算，在shader中传入一个debug值再和抖动值相乘用作反向抖动，观察最后的画面是否存在抖动，就能很好的判断出这两个值的比例了。抖动的方式有很多，纯随机的抖动也可以选择，不过稍不如使用均匀分布的随机抖动的效果好，这里使用Inside中的方式即利用Halton数列进行抖动。 为了让相机移动时也能有较好的抗锯齿效果且削弱拖影现象，Temporal Reprojection Anti-Aliasing需要采样当前的深度贴图，还原出物体的世界空间的坐标，再计算出这个世界空间在AccumTexture中的UV值(Reprojection)，使用这个UV值采样AccumTexture再和当前渲染画面进行融合。 因为Velocity Buffer比较麻烦，这里暂且忽略掉物体移动对TAA带来的影响。 在ScriptableRenderPass中使用cmd.GetTemporaryRT()获得的Render Texture，在当帧过后就会被回收，因此AccumTexture需要使用RenderTexture.GetTemporary()来获取。这里我把AccumTexture放在TemporalAntiAliasing.cs中，方便使用。  TemporalAntiAliasing.cs 除了普通的Volume的设置之外，还需要提供Render Texture的接口。lastFrame的x值和y值分别对应最后渲染画面中对AccumTexture进行线性插值的最小和最大系数。\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"Post-processing/Temporal Anti-Aliasing\")] public class TemporalAntiAliasing : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public NoInterpFloatRangeParameter lastFrame = new NoInterpFloatRangeParameter(new Vector2(0.2f, 0.8f), 0f, 1f); public Vector2Parameter jitterIntensity = new Vector2Parameter(Vector2.one); private RenderTexture[] accumTextures; public bool IsActive() { return isEnabled.value; } public bool IsTileCompatible() { return false; } void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } bool EnsureRenderTarget(ref RenderTexture rt, int width, int height, RenderTextureFormat format, FilterMode filterMode, string name, int depthBits = 0, int antiAliasing = 1) { if (rt != null \u0026\u0026 (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing); rt.name = name; rt.filterMode = filterMode; rt.wrapMode = TextureWrapMode.Clamp; return true;// new target  } return false;// same target  } public void EnsureRT(RenderTextureDescriptor descriptor) { EnsureArray(ref accumTextures, 2); EnsureRenderTarget(ref accumTextures[0], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, \"TAA_Accum_One\"); EnsureRenderTarget(ref accumTextures[1], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, \"TAA_Accum_Two\"); } public RenderTexture GetRT(int index) { return accumTextures[index]; } } } TAARendererFeature.cs 在TAARendererFeature中生成相机抖动的值，通过TAAJitterPass对相机的投影矩阵进行抖动，通过TAARenderPass反向抖动还原正常的画面。Halton序列的生成方式可以进行优化，这里暂且略过。这里也暂且忽略了DX11和OpenGL的平台差异化处理（无非就是UV的Y轴翻转的问题）。\nnamespace UnityEngine.Rendering.Universal { public class TAARendererFeature : ScriptableRendererFeature { [System.Serializable] public class TAASettings { public bool isEnabled = true; //最好是AfterRenderingPostProcessing，不过会有CameraTarget的问题，需要更多的设置  public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; } public TAASettings settings = new TAASettings(); TAARenderPass taaRenderPass; TAAJitterPass taaJitterPass; private TAAData taaData; private int haltonIndex = 0; private Vector2 lastOffset; private Matrix4x4 lastProj = Matrix4x4.identity; private Matrix4x4 lastView = Matrix4x4.identity; [SerializeField, HideInInspector] private Shader taaShader; public override void Create() { taaShader = Shader.Find(\"Hidden/Universal Render Pipeline/TAAShader\"); if (taaShader == null) { Debug.LogWarning(\"Shader was not found. Please ensure it compiles correctly\"); return; } taaData = new TAAData(); taaData.Initialize(); taaJitterPass = new TAAJitterPass(); taaRenderPass = new TAARenderPass(settings); } public struct TAAData { public Vector2 offset; public Vector2 lastOffset; public Matrix4x4 lastProj; public Matrix4x4 lastView; public Matrix4x4 jitteredProj; public Matrix4x4 currentView; public void Initialize() { offset = Vector2.zero; lastOffset = Vector2.zero; lastProj = Matrix4x4.identity; lastView = Matrix4x4.identity; jitteredProj = Matrix4x4.identity; currentView = Matrix4x4.identity; } } private float HaltonSeq(int prime, int index = 1/* NOT! zero-based */) { float r = 0.0f; float f = 1.0f; int i = index; while (i  0) { f /= prime; r += f * (i % prime); i = (int)Mathf.Floor(i / (float)prime); } return r; } //dx11 only?  private Matrix4x4 GetJitteredProjectionMatrix(Camera camera, Vector2 offset, Vector2 jitterIntensity) { Matrix4x4 originalProjMatrix = camera.nonJitteredProjectionMatrix; float near = camera.nearClipPlane; float far = camera.farClipPlane; Vector2 matrixOffset = offset * new Vector2(1f / camera.pixelWidth, 1f / camera.pixelHeight) * jitterIntensity; //[row, column]  originalProjMatrix[0, 2] = matrixOffset.x; originalProjMatrix[1, 2] = matrixOffset.y; return originalProjMatrix; } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { Camera camera = renderingData.cameraData.camera; TemporalAntiAliasing taaComponent = VolumeManager.instance.stack.GetComponent(); if(renderingData.cameraData.cameraType == CameraType.Game \u0026\u0026 taaComponent.IsActive()) { // 获取Offset值  haltonIndex = (haltonIndex + 1) \u0026 1023; Vector2 offset = new Vector2( HaltonSeq(2, haltonIndex + 1) - 0.5f, HaltonSeq(3, haltonIndex + 1) - 0.5f); // 获取jittered projection matrix，并记录之前的matrix  // jittered projection的ab应该对应0.5 * texel_size.xy  lastOffset = taaData.offset; taaData.lastOffset = lastOffset; taaData.offset = new Vector2(offset.x / camera.pixelWidth, offset.y / camera.pixelHeight) * taaComponent.jitterIntensity.value; taaData.jitteredProj = GetJitteredProjectionMatrix(camera, offset, taaComponent.jitterIntensity.value); taaData.lastProj = lastProj; taaData.lastView = lastView; lastProj = camera.projectionMatrix; lastView = camera.worldToCameraMatrix; taaData.currentView = lastView; // 第一个Pass对相机使用jittered projection matrix  taaJitterPass.Setup(taaData); renderer.EnqueuePass(taaJitterPass); //第二个Pass执行真正的TAA  //暂时不考虑motion blur/运动物体的TAA  taaRenderPass.Setup(taaShader, taaData, taaComponent); renderer.EnqueuePass(taaRenderPass); } } } } TAAJitterPass.cs 这个Pass仅用于改变相机的透视变换矩阵，在某些情况下渲染透明物体时会重置透视变换矩阵，这种情况下需要在BeforeRenderingTransparent的时候再额外执行一遍TAAJitterPass。\nnamespace UnityEngine.Rendering.Universal { public class TAAJitterPass : ScriptableRenderPass { private const string profilerTag = \"TAA Jitter Pass\"; private ProfilingSampler taaSampler = new ProfilingSampler(\"TAA Jitter Pass\"); private TAARendererFeature.TAAData taaData; public TAAJitterPass() { profilingSampler = taaSampler; renderPassEvent = RenderPassEvent.BeforeRenderingOpaques; } public void Setup(TAARendererFeature.TAAData taaData) { this.taaData = taaData; } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, profilingSampler)) { CameraData cameraData = renderingData.cameraData; cmd.SetViewProjectionMatrices(cameraData.camera.worldToCameraMatrix, taaData.jitteredProj); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } } } TAARenderPass.cs 由于_CameraColorTexture没有开启随机读写，使用Compute Shader进行TAA的计算会需要额外的blit，这里就使用普通的shader来进行TAA的操作了。\nusing System; namespace UnityEngine.Rendering.Universal { public class TAARenderPass : ScriptableRenderPass { private const string profilerTag = \"My TAA Pass\"; private ProfilingSampler taaSampler = new ProfilingSampler(\"TAA Pass\"); RenderTargetHandle cameraColorHandle; RenderTargetIdentifier cameraColorIden; RenderTargetHandle cameraDepthHandle; RenderTargetIdentifier cameraDepthIden; private Vector2Int screenSize; private int accumIndex; private TAARendererFeature.TAASettings settings; private TAARendererFeature.TAAData taaData; private Material taaMaterial; private TemporalAntiAliasing taaComponent; private Vector2 lastFrame; public TAARenderPass(TAARendererFeature.TAASettings settings) { profilingSampler = new ProfilingSampler(profilerTag); cameraColorHandle.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColorHandle.Identifier(); cameraDepthHandle.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepthHandle.Identifier(); this.settings = settings; } public void Setup(Shader taaShader, TAARendererFeature.TAAData taaData, TemporalAntiAliasing taaComponent) { this.taaData = taaData; renderPassEvent = settings.renderPassEvent; this.lastFrame = taaComponent.lastFrame.value; taaMaterial = new Material(taaShader); this.taaComponent = taaComponent; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor descriptor = cameraTextureDescriptor; screenSize = new Vector2Int(descriptor.width, descriptor.height); taaComponent.EnsureRT(descriptor); } private void DoTAA(CommandBuffer cmd, TemporalAntiAliasing taa, RenderTargetIdentifier colorid, int index) { RenderTexture accumRead = taa.GetRT(index); int tempIndex = 1 - index; RenderTexture accumWrite = taa.GetRT(tempIndex); taaMaterial.SetVector(\"_TAAOffsets\", new Vector4(taaData.offset.x, taaData.offset.y, taaData.lastOffset.x, taaData.lastOffset.y)); taaMaterial.SetVector(\"_TAALastFrame\", taaComponent.lastFrame.value); taaMaterial.SetVector(\"_TextureSize\", new Vector4(screenSize.x, screenSize.y, 1f / screenSize.x, 1f / screenSize.y)); Matrix4x4 lastViewProj = taaData.lastProj * taaData.lastView; taaMaterial.SetMatrix(\"_LastViewProj\", lastViewProj); taaMaterial.SetTexture(\"_AccumTexture\", accumRead); cmd.Blit(colorid, accumWrite, taaMaterial); cmd.Blit(accumWrite, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, taaSampler)) { DoTAA(cmd, taaComponent, cameraColorIden, accumIndex); accumIndex = 1 - accumIndex; } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { if (cmd == null) throw new ArgumentNullException(\"cmd\"); } } } TAAShader.shader 多次采样能够明显的削弱拖影效果，tempMain = min(mainTexture, color_avg * 1.25);这一行能够在一定程度上减少高光的闪烁，clip_aabb和k_feedback似乎用处不是很大，不过我还是写进去了。\nShader \"Hidden/Universal Render Pipeline/TAAShader\"\r{\rProperties\r{\r_MainTex(\"Main Texture\", 2D) = \"white\"{}\r}\rHLSLINCLUDE\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\rtexture2D _MainTex;\rtexture2D _CameraDepthTexture;\rtexture2D _AccumTexture;\rSamplerState sampler_LinearClamp;\rSamplerState sampler_PointClamp;\rfloat4 _TAAOffsets;\rfloat2 _TAALastFrame;\rfloat4 _TextureSize;\rfloat4x4 _LastViewProj;\rstruct Attributes\r{\rfloat4 positionOS : POSITION;\rfloat2 texcoord : TEXCOORD0;\r};\rstruct Varyings\r{\rfloat4 positionCS : SV_POSITION;\rfloat2 texcoord : TEXCOORD0;\r};\rfloat3 clip_aabb(float3 aabb_min, float3 aabb_max, float3 avg, float3 input_texel)\r{\rfloat3 p_clip = 0.5 * (aabb_max + aabb_min);\rfloat3 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS;\rfloat3 v_clip = input_texel - p_clip;\rfloat3 v_unit = v_clip / e_clip;\rfloat3 a_unit = abs(v_unit);\rfloat ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));\rif (ma_unit  1.0)\rreturn p_clip + v_clip / ma_unit;\relse\rreturn input_texel;\r}\rVaryings TAAVert(Attributes input)\r{\rVaryings output = (Varyings)0;\rVertexPositionInputs vertexPositionInputs = GetVertexPositionInputs(input.positionOS.xyz);\routput.positionCS = vertexPositionInputs.positionCS;\routput.texcoord = input.texcoord;\rreturn output;\r}\rfloat4 TAAFrag(Varyings input) : SV_TARGET\r{\rfloat2 sampleUV = input.texcoord;\rfloat2 currentOffset = _TAAOffsets.xy;\rfloat2 lastOffset = _TAAOffsets.zw;\rfloat2 unJitteredUV = sampleUV - 0.5 * currentOffset;\rfloat3 mainTexture = _MainTex.SampleLevel(sampler_LinearClamp, unJitteredUV, 0).rgb;\rfloat2 du = float2(_TextureSize.z, 0);\rfloat2 dv = float2(0, _TextureSize.w);\rfloat3 ctl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv - du).rgb;\rfloat3 ctc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv).rgb;\rfloat3 ctr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv + du).rgb;\rfloat3 cml = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - du).rgb;\rfloat3 cmc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV).rgb;\rfloat3 cmr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + du).rgb;\rfloat3 cbl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv - du).rgb;\rfloat3 cbc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv).rgb;\rfloat3 cbr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv + du).rgb;\rfloat3 color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));\rfloat3 color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));\rfloat3 color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;\rfloat depthTexture = _CameraDepthTexture.SampleLevel(sampler_PointClamp, unJitteredUV, 0).r;\rfloat4 positionNDC = float4(sampleUV * 2 - 1, depthTexture, 1);\r#if UNITY_UV_STARTS_AT_TOP\rpositionNDC.y = -positionNDC.y;\r#endif\rfloat4 worldPos = mul(UNITY_MATRIX_I_VP, positionNDC);\rworldPos /= worldPos.w;\rfloat4 lastPositionCS = mul(_LastViewProj, worldPos);\rfloat2 lastUV = lastPositionCS.xy / lastPositionCS.w;\rlastUV = lastUV * 0.5 + 0.5;\rfloat3 accumTexture = _AccumTexture.SampleLevel(sampler_LinearClamp, lastUV, 0).rgb;\rfloat3 tempMain = 0;\raccumTexture = clip_aabb(color_min, color_max, color_avg, accumTexture);\rtempMain = min(mainTexture, color_avg * 1.25);\rfloat lum0 = Luminance(mainTexture);\rfloat lum1 = Luminance(accumTexture);\rfloat unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));\rfloat unbiased_weight = 1.0 - unbiased_diff;\rfloat unbiased_weight_sqr = unbiased_weight * unbiased_weight;\rfloat k_feedback = lerp(_TAALastFrame.x, _TAALastFrame.y, unbiased_weight_sqr);\rfloat3 returnColor = lerp(tempMain, accumTexture, k_feedback);\rif (unJitteredUV.x = 0.5)\r{\rreturnColor = mainTexture;\r}\rreturn float4(returnColor, 1);\r}\rENDHLSL\rSubShader\r{\rZTest Always Cull Back ZWrite Off\rpass\r{\rName \"TAA Pass\"\rHLSLPROGRAM\r#pragma vertex TAAVert\r#pragma fragment TAAFrag\rENDHLSL\r}\r}\r}\r一些思考 效果总体来说还是不错的，但是TAAShader中lerp当前渲染画面和AccumTexture的算法应该有待提高，目前特别细长的亚像素特征（如呈线状的高光）会有锯齿爬行的感觉，画面不够稳定，特别小的细节会有一闪一闪的感觉，应该还能再优化优化。PlayDead的源代码有点看不下去。。。就僵在这里了，大概有个80分吧。\n我也想多放图来着，但是实在没啥好放的。。。导致博客越来越枯燥了。\n","wordCount":"1382","inLanguage":"en","image":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg","datePublished":"2021-07-15T19:00:00+08:00","dateModified":"2021-07-15T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">在Unity SRP中实现TAA效果</h1><div class=post-description>抖动相机来实现TAA抗锯齿效果.</div><div class=post-meta><span title="2021-07-15 19:00:00 +0800 CST">July 15, 2021</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/temporal-reprojection-anti-aliasing.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/TemporalAntiAliasing.jpg alt="Temporal Anti-Aliasing Cover"><p>左侧为TAA效果，右侧没有TAA</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>在Unity SRP中实现TAA效果</div></summary><div class=inner><ul><li><a href=#taa%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=TAA的原理>TAA的原理</a></li><li><a href=#temporal-reprojection-anti-aliasing aria-label="Temporal Reprojection Anti-Aliasing">Temporal Reprojection Anti-Aliasing</a></li><li><a href=#%e5%9c%a8unity-srp%e4%b8%ad%e5%ae%9e%e7%8e%b0taa%e7%9a%84%e6%93%8d%e4%bd%9c aria-label="在Unity SRP中实现TAA的操作">在Unity SRP中实现TAA的操作</a><ul><li><a href=#temporalantialiasingcs aria-label=TemporalAntiAliasing.cs>TemporalAntiAliasing.cs</a></li><li><a href=#taarendererfeaturecs aria-label=TAARendererFeature.cs>TAARendererFeature.cs</a></li><li><a href=#taajitterpasscs aria-label=TAAJitterPass.cs>TAAJitterPass.cs</a></li><li><a href=#taarenderpasscs aria-label=TAARenderPass.cs>TAARenderPass.cs</a></li><li><a href=#taashadershader aria-label=TAAShader.shader>TAAShader.shader</a></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b%e6%80%9d%e8%80%83 aria-label=一些思考>一些思考</a></li></ul></div></details></div><div class=post-content><h2 id=taa的原理>TAA的原理<a hidden class=anchor aria-hidden=true href=#taa的原理>#</a></h2><p>首先是要了解画面上的锯齿是如何产生的。锯齿发生在光栅化的阶段，光栅化的时候会丢失掉小于一个像素宽的细节，也就导致了锯齿的产生。</p><p>从字面上来看，TAA (Temporal Anti-Aliasing)的抗锯齿效果来源于Temporal一词，是一种时间上的抗锯齿。TAA会结合当前渲染的画面和之前渲染的画面，通过这两个画面之间的融合，达成抗锯齿的效果。基本思想是在光栅化的时候对画面进行抖动，让亚像素的细节在不同帧渲染到不同的像素上，最后再对这些像素按时间的权重来混合，就能达到抗锯齿的效果。</p><h2 id=temporal-reprojection-anti-aliasing>Temporal Reprojection Anti-Aliasing<a hidden class=anchor aria-hidden=true href=#temporal-reprojection-anti-aliasing>#</a></h2><p>Temporal Reprojection Anti-Aliasing是由PlayDead在他们的游戏Inside中使用的一种TAA的方法，他们在<a href=https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in>GDC2016的演示</a>中分享了这个方法。相较于普通的TAA来说，Temporal Reprojection Anti-Aliasing中使用了Velocity Buffer中的屏幕像素的速度信息和Depth Buffer中对应的屏幕像素的世界坐标信息，这样当物体移动或者相机移动的时候，在做到抗锯齿的同时也减少了TAA带来的拖影效果，同时也把TAA和运动模糊相结合达到更理想的抗锯齿的效果。</p><p>PlayDead提供了对应的<a href=https://github.com/playdeadgames/temporal>源代码</a>。本博客中TAA在SRP中的实现也参考了sienaiwun的<a href=https://github.com/sienaiwun/TAA_Unity_URP>TAA代码</a>。</p><h2 id=在unity-srp中实现taa的操作>在Unity SRP中实现TAA的操作<a hidden class=anchor aria-hidden=true href=#在unity-srp中实现taa的操作>#</a></h2><ol><li>我们通过RendererFeature的方式在渲染管线中加入TAA。在ForwardRendererData中加入RendererFeature后，往Global Volume中添加Temporal Anti-Aliasing以在场景中启用TAA效果。启用TAA效果后，会现在渲染不透明物体之前调用一个Jitter Pass对相机的栅格化阶段进行抖动；在渲染TAA Pass时（在Bloom等跟物体渲染相关的后处理效果之后，在Chromatic Aberration等跟屏幕空间位置相关的后处理效果之前）根据抖动值还原出正常的不抖动的画面，并和AccumTexture进行混合，获得最终的渲染画面。因此我们需要TAARendererFeature、TAAJitterPass、TAARenderPass这三个脚本来处理渲染管线，TemporalAntiAliasing这个脚本来处理Volume，TAAShader这个Shader文件来进行TAA的混合操作。</li><li>对栅格化阶段进行抖动，也就相当于是修改了相机的透视变换矩阵的第一第二行的第三位的值，抖动值最好和TexelSize相结合，这样在TAA反向抖动还原正常值的时候，在shader中会比较好写。抖动值和TAA的反向抖动是正比关系，因此可以不需要特别纠结于计算，在shader中传入一个debug值再和抖动值相乘用作反向抖动，观察最后的画面是否存在抖动，就能很好的判断出这两个值的比例了。抖动的方式有很多，纯随机的抖动也可以选择，不过稍不如使用均匀分布的随机抖动的效果好，这里使用Inside中的方式即利用Halton数列进行抖动。</li><li>为了让相机移动时也能有较好的抗锯齿效果且削弱拖影现象，Temporal Reprojection Anti-Aliasing需要采样当前的深度贴图，还原出物体的世界空间的坐标，再计算出这个世界空间在AccumTexture中的UV值(Reprojection)，使用这个UV值采样AccumTexture再和当前渲染画面进行融合。</li><li>因为Velocity Buffer比较麻烦，这里暂且忽略掉物体移动对TAA带来的影响。</li><li>在ScriptableRenderPass中使用cmd.GetTemporaryRT()获得的Render Texture，在当帧过后就会被回收，因此AccumTexture需要使用RenderTexture.GetTemporary()来获取。这里我把AccumTexture放在TemporalAntiAliasing.cs中，方便使用。</li></ol><h3 id=temporalantialiasingcs>TemporalAntiAliasing.cs<a hidden class=anchor aria-hidden=true href=#temporalantialiasingcs>#</a></h3><p>除了普通的Volume的设置之外，还需要提供Render Texture的接口。lastFrame的x值和y值分别对应最后渲染画面中对AccumTexture进行线性插值的最小和最大系数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;Post-processing/Temporal Anti-Aliasing&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TemporalAntiAliasing</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);

        <span style=color:#66d9ef>public</span> NoInterpFloatRangeParameter lastFrame = <span style=color:#66d9ef>new</span> NoInterpFloatRangeParameter(<span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.2f</span>, <span style=color:#ae81ff>0.8f</span>), <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1f</span>);

        <span style=color:#66d9ef>public</span> Vector2Parameter jitterIntensity = <span style=color:#66d9ef>new</span> Vector2Parameter(Vector2.one);

        <span style=color:#66d9ef>private</span> RenderTexture[] accumTextures;


        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }

        <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
        {
            <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
            {
                array = <span style=color:#66d9ef>new</span> T[size];
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
                    array[i] = initialValue;
            }
        }

        <span style=color:#66d9ef>bool</span> EnsureRenderTarget(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height, RenderTextureFormat format, FilterMode filterMode, <span style=color:#66d9ef>string</span> name, <span style=color:#66d9ef>int</span> depthBits = <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> antiAliasing = <span style=color:#ae81ff>1</span>)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing))
            {
                RenderTexture.ReleaseTemporary(rt);
                rt = <span style=color:#66d9ef>null</span>;
            }
            <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
            {
                rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing);
                rt.name = name;
                rt.filterMode = filterMode;
                rt.wrapMode = TextureWrapMode.Clamp;
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;<span style=color:#75715e>// new target
</span><span style=color:#75715e></span>            }
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;<span style=color:#75715e>// same target
</span><span style=color:#75715e></span>        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> EnsureRT(RenderTextureDescriptor descriptor)
        {
            EnsureArray(<span style=color:#66d9ef>ref</span> accumTextures, <span style=color:#ae81ff>2</span>);
            EnsureRenderTarget(<span style=color:#66d9ef>ref</span> accumTextures[<span style=color:#ae81ff>0</span>], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, <span style=color:#e6db74>&#34;TAA_Accum_One&#34;</span>);
            EnsureRenderTarget(<span style=color:#66d9ef>ref</span> accumTextures[<span style=color:#ae81ff>1</span>], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, <span style=color:#e6db74>&#34;TAA_Accum_Two&#34;</span>);
        }

        <span style=color:#66d9ef>public</span> RenderTexture GetRT(<span style=color:#66d9ef>int</span> index)
        {
            <span style=color:#66d9ef>return</span> accumTextures[index];
        }
    }
}
</code></pre></div><h3 id=taarendererfeaturecs>TAARendererFeature.cs<a hidden class=anchor aria-hidden=true href=#taarendererfeaturecs>#</a></h3><p>在TAARendererFeature中生成相机抖动的值，通过TAAJitterPass对相机的投影矩阵进行抖动，通过TAARenderPass反向抖动还原正常的画面。Halton序列的生成方式可以进行优化，这里暂且略过。这里也暂且忽略了DX11和OpenGL的平台差异化处理（无非就是UV的Y轴翻转的问题）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAARendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAASettings</span>
        {
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> isEnabled = <span style=color:#66d9ef>true</span>;
            <span style=color:#75715e>//最好是AfterRenderingPostProcessing，不过会有CameraTarget的问题，需要更多的设置
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
        }

        <span style=color:#66d9ef>public</span> TAASettings settings = <span style=color:#66d9ef>new</span> TAASettings();
        TAARenderPass taaRenderPass;
        TAAJitterPass taaJitterPass;
        <span style=color:#66d9ef>private</span> TAAData taaData;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> haltonIndex = <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>private</span> Vector2 lastOffset;
        <span style=color:#66d9ef>private</span> Matrix4x4 lastProj = Matrix4x4.identity;
        <span style=color:#66d9ef>private</span> Matrix4x4 lastView = Matrix4x4.identity;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [SerializeField, HideInInspector]</span>
        <span style=color:#66d9ef>private</span> Shader taaShader;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            taaShader = Shader.Find(<span style=color:#e6db74>&#34;Hidden/Universal Render Pipeline/TAAShader&#34;</span>);
            <span style=color:#66d9ef>if</span> (taaShader == <span style=color:#66d9ef>null</span>)
            {
                Debug.LogWarning(<span style=color:#e6db74>&#34;Shader was not found. Please ensure it compiles correctly&#34;</span>);
                <span style=color:#66d9ef>return</span>;
            }

            taaData = <span style=color:#66d9ef>new</span> TAAData();
            taaData.Initialize();
            taaJitterPass = <span style=color:#66d9ef>new</span> TAAJitterPass();
            taaRenderPass = <span style=color:#66d9ef>new</span> TAARenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TAAData</span>
        {
            <span style=color:#66d9ef>public</span> Vector2 offset;
            <span style=color:#66d9ef>public</span> Vector2 lastOffset;
            <span style=color:#66d9ef>public</span> Matrix4x4 lastProj;
            <span style=color:#66d9ef>public</span> Matrix4x4 lastView;
            <span style=color:#66d9ef>public</span> Matrix4x4 jitteredProj;
            <span style=color:#66d9ef>public</span> Matrix4x4 currentView;

            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
            {
                offset = Vector2.zero;
                lastOffset = Vector2.zero;
                lastProj = Matrix4x4.identity;
                lastView = Matrix4x4.identity;
                jitteredProj = Matrix4x4.identity;
                currentView = Matrix4x4.identity;
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> HaltonSeq(<span style=color:#66d9ef>int</span> prime, <span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>1</span><span style=color:#75715e>/* NOT! zero-based */</span>)
        {
            <span style=color:#66d9ef>float</span> r = <span style=color:#ae81ff>0.0f</span>;
            <span style=color:#66d9ef>float</span> f = <span style=color:#ae81ff>1.0f</span>;
            <span style=color:#66d9ef>int</span> i = index;
            <span style=color:#66d9ef>while</span> (i &gt; <span style=color:#ae81ff>0</span>)
            {
                f /= prime;
                r += f * (i % prime);
                i = (<span style=color:#66d9ef>int</span>)Mathf.Floor(i / (<span style=color:#66d9ef>float</span>)prime);
            }
            <span style=color:#66d9ef>return</span> r;
        }

        <span style=color:#75715e>//dx11 only?
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>private</span> Matrix4x4 GetJitteredProjectionMatrix(Camera camera, Vector2 offset, Vector2 jitterIntensity)
        {
            Matrix4x4 originalProjMatrix = camera.nonJitteredProjectionMatrix;

            <span style=color:#66d9ef>float</span> near = camera.nearClipPlane;
            <span style=color:#66d9ef>float</span> far = camera.farClipPlane;

            Vector2 matrixOffset = offset * <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1f</span> / camera.pixelWidth, <span style=color:#ae81ff>1f</span> / camera.pixelHeight) * jitterIntensity;
            <span style=color:#75715e>//[row, column]
</span><span style=color:#75715e></span>            originalProjMatrix[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>] = matrixOffset.x;
            originalProjMatrix[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>] = matrixOffset.y;
            <span style=color:#66d9ef>return</span> originalProjMatrix;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            Camera camera = renderingData.cameraData.camera;

            TemporalAntiAliasing taaComponent = VolumeManager.instance.stack.GetComponent&lt;TemporalAntiAliasing&gt;();
            <span style=color:#66d9ef>if</span>(renderingData.cameraData.cameraType == CameraType.Game &amp;&amp; taaComponent.IsActive())
            {
                <span style=color:#75715e>// 获取Offset值
</span><span style=color:#75715e></span>                haltonIndex = (haltonIndex + <span style=color:#ae81ff>1</span>) &amp; <span style=color:#ae81ff>1023</span>;
                Vector2 offset = <span style=color:#66d9ef>new</span> Vector2(
                    HaltonSeq(<span style=color:#ae81ff>2</span>, haltonIndex + <span style=color:#ae81ff>1</span>) - <span style=color:#ae81ff>0.5f</span>,
                    HaltonSeq(<span style=color:#ae81ff>3</span>, haltonIndex + <span style=color:#ae81ff>1</span>) - <span style=color:#ae81ff>0.5f</span>);

                <span style=color:#75715e>// 获取jittered projection matrix，并记录之前的matrix
</span><span style=color:#75715e></span>                <span style=color:#75715e>// jittered projection的ab应该对应0.5 * texel_size.xy
</span><span style=color:#75715e></span>                lastOffset = taaData.offset;
                taaData.lastOffset = lastOffset;
                taaData.offset = <span style=color:#66d9ef>new</span> Vector2(offset.x / camera.pixelWidth, offset.y / camera.pixelHeight) * taaComponent.jitterIntensity.<span style=color:#66d9ef>value</span>;
                taaData.jitteredProj = GetJitteredProjectionMatrix(camera, offset, taaComponent.jitterIntensity.<span style=color:#66d9ef>value</span>);
                taaData.lastProj = lastProj;
                taaData.lastView = lastView;
                lastProj = camera.projectionMatrix;
                lastView = camera.worldToCameraMatrix;
                taaData.currentView = lastView;

                <span style=color:#75715e>// 第一个Pass对相机使用jittered projection matrix
</span><span style=color:#75715e></span>                taaJitterPass.Setup(taaData);
                renderer.EnqueuePass(taaJitterPass);

                <span style=color:#75715e>//第二个Pass执行真正的TAA
</span><span style=color:#75715e></span>                <span style=color:#75715e>//暂时不考虑motion blur/运动物体的TAA
</span><span style=color:#75715e></span>                taaRenderPass.Setup(taaShader, taaData, taaComponent);
                renderer.EnqueuePass(taaRenderPass);
            }
        }
    }
}
</code></pre></div><h3 id=taajitterpasscs>TAAJitterPass.cs<a hidden class=anchor aria-hidden=true href=#taajitterpasscs>#</a></h3><p>这个Pass仅用于改变相机的透视变换矩阵，在某些情况下渲染透明物体时会重置透视变换矩阵，这种情况下需要在BeforeRenderingTransparent的时候再额外执行一遍TAAJitterPass。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAAJitterPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;TAA Jitter Pass&#34;</span>;
        <span style=color:#66d9ef>private</span> ProfilingSampler taaSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;TAA Jitter Pass&#34;</span>);

        <span style=color:#66d9ef>private</span> TAARendererFeature.TAAData taaData;

        <span style=color:#66d9ef>public</span> TAAJitterPass()
        {
            profilingSampler = taaSampler;
            renderPassEvent = RenderPassEvent.BeforeRenderingOpaques;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(TAARendererFeature.TAAData taaData)
        {
            <span style=color:#66d9ef>this</span>.taaData = taaData;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                CameraData cameraData = renderingData.cameraData;
                cmd.SetViewProjectionMatrices(cameraData.camera.worldToCameraMatrix, taaData.jitteredProj);
            }
            context.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=taarenderpasscs>TAARenderPass.cs<a hidden class=anchor aria-hidden=true href=#taarenderpasscs>#</a></h3><p>由于<code>_CameraColorTexture</code>没有开启随机读写，使用Compute Shader进行TAA的计算会需要额外的blit，这里就使用普通的shader来进行TAA的操作了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAARenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;My TAA Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> ProfilingSampler taaSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;TAA Pass&#34;</span>);

        RenderTargetHandle cameraColorHandle;
        RenderTargetIdentifier cameraColorIden;
        RenderTargetHandle cameraDepthHandle;
        RenderTargetIdentifier cameraDepthIden;

        <span style=color:#66d9ef>private</span> Vector2Int screenSize;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> accumIndex;

        <span style=color:#66d9ef>private</span> TAARendererFeature.TAASettings settings;
        <span style=color:#66d9ef>private</span> TAARendererFeature.TAAData taaData;
        <span style=color:#66d9ef>private</span> Material taaMaterial;
        <span style=color:#66d9ef>private</span> TemporalAntiAliasing taaComponent;

        <span style=color:#66d9ef>private</span> Vector2 lastFrame;

        <span style=color:#66d9ef>public</span> TAARenderPass(TAARendererFeature.TAASettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
            cameraColorHandle.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
            cameraColorIden = cameraColorHandle.Identifier();
            cameraDepthHandle.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
            cameraDepthIden = cameraDepthHandle.Identifier();

            <span style=color:#66d9ef>this</span>.settings = settings;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(Shader taaShader, TAARendererFeature.TAAData taaData, TemporalAntiAliasing taaComponent)
        {
            <span style=color:#66d9ef>this</span>.taaData = taaData;
            renderPassEvent = settings.renderPassEvent;
            <span style=color:#66d9ef>this</span>.lastFrame = taaComponent.lastFrame.<span style=color:#66d9ef>value</span>;
            taaMaterial = <span style=color:#66d9ef>new</span> Material(taaShader);
            <span style=color:#66d9ef>this</span>.taaComponent = taaComponent;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            RenderTextureDescriptor descriptor = cameraTextureDescriptor;
            screenSize = <span style=color:#66d9ef>new</span> Vector2Int(descriptor.width, descriptor.height);
            taaComponent.EnsureRT(descriptor);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoTAA(CommandBuffer cmd, TemporalAntiAliasing taa, RenderTargetIdentifier colorid, <span style=color:#66d9ef>int</span> index)
        {
            RenderTexture accumRead = taa.GetRT(index);
            <span style=color:#66d9ef>int</span> tempIndex = <span style=color:#ae81ff>1</span> - index;
            RenderTexture accumWrite = taa.GetRT(tempIndex);

            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TAAOffsets&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(taaData.offset.x, taaData.offset.y, taaData.lastOffset.x, taaData.lastOffset.y));
            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TAALastFrame&#34;</span>, taaComponent.lastFrame.<span style=color:#66d9ef>value</span>);
            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(screenSize.x, screenSize.y, <span style=color:#ae81ff>1f</span> / screenSize.x, <span style=color:#ae81ff>1f</span> / screenSize.y));
            Matrix4x4 lastViewProj = taaData.lastProj * taaData.lastView;
            taaMaterial.SetMatrix(<span style=color:#e6db74>&#34;_LastViewProj&#34;</span>, lastViewProj);
            taaMaterial.SetTexture(<span style=color:#e6db74>&#34;_AccumTexture&#34;</span>, accumRead);

            cmd.Blit(colorid, accumWrite, taaMaterial);
            cmd.Blit(accumWrite, colorid);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, taaSampler))
            {
                DoTAA(cmd, taaComponent, cameraColorIden, accumIndex);
                accumIndex = <span style=color:#ae81ff>1</span> - accumIndex;
            }
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
        {
            <span style=color:#66d9ef>if</span> (cmd == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(<span style=color:#e6db74>&#34;cmd&#34;</span>);
        }
    }
}
</code></pre></div><h3 id=taashadershader>TAAShader.shader<a hidden class=anchor aria-hidden=true href=#taashadershader>#</a></h3><p>多次采样能够明显的削弱拖影效果，<code>tempMain = min(mainTexture, color_avg * 1.25);</code>这一行能够在一定程度上减少高光的闪烁，<code>clip_aabb</code>和<code>k_feedback</code>似乎用处不是很大，不过我还是写进去了。</p><pre><code class=language-HLSL data-lang=HLSL>Shader &quot;Hidden/Universal Render Pipeline/TAAShader&quot;
{
    Properties
    {
        _MainTex(&quot;Main Texture&quot;, 2D) = &quot;white&quot;{}
    }

    HLSLINCLUDE
#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/core.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&quot;

    texture2D _MainTex;
    texture2D _CameraDepthTexture;
    texture2D _AccumTexture;

    SamplerState sampler_LinearClamp;
    SamplerState sampler_PointClamp;

    float4 _TAAOffsets;
    float2 _TAALastFrame;
    float4 _TextureSize;
    float4x4 _LastViewProj;

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float2 texcoord     : TEXCOORD0;
    };

    struct Varyings
    {
        float4 positionCS   : SV_POSITION;
        float2 texcoord     : TEXCOORD0;
    };

    float3 clip_aabb(float3 aabb_min, float3 aabb_max, float3 avg, float3 input_texel)
    {
        float3 p_clip = 0.5 * (aabb_max + aabb_min);
        float3 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
        float3 v_clip = input_texel - p_clip;
        float3 v_unit = v_clip / e_clip;
        float3 a_unit = abs(v_unit);
        float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

        if (ma_unit &gt; 1.0)
            return p_clip + v_clip / ma_unit;
        else
            return input_texel;
    }

    Varyings TAAVert(Attributes input)
    {
        Varyings output = (Varyings)0;
        VertexPositionInputs vertexPositionInputs = GetVertexPositionInputs(input.positionOS.xyz);
        output.positionCS = vertexPositionInputs.positionCS;
        output.texcoord = input.texcoord;
        return output;
    }

    float4 TAAFrag(Varyings input) : SV_TARGET
    {
        float2 sampleUV = input.texcoord;
        float2 currentOffset = _TAAOffsets.xy;
        float2 lastOffset = _TAAOffsets.zw;

        float2 unJitteredUV = sampleUV - 0.5 * currentOffset;

        float3 mainTexture = _MainTex.SampleLevel(sampler_LinearClamp, unJitteredUV, 0).rgb;

        float2 du = float2(_TextureSize.z, 0);
        float2 dv = float2(0, _TextureSize.w);

        float3 ctl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv - du).rgb;
        float3 ctc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv).rgb;
        float3 ctr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv + du).rgb;
        float3 cml = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - du).rgb;
        float3 cmc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV).rgb;
        float3 cmr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + du).rgb;
        float3 cbl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv - du).rgb;
        float3 cbc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv).rgb;
        float3 cbr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv + du).rgb;

        float3 color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
        float3 color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
        float3 color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;

        float depthTexture = _CameraDepthTexture.SampleLevel(sampler_PointClamp, unJitteredUV, 0).r;

        float4 positionNDC = float4(sampleUV * 2 - 1, depthTexture, 1);
#if UNITY_UV_STARTS_AT_TOP
        positionNDC.y = -positionNDC.y;
#endif

        float4 worldPos = mul(UNITY_MATRIX_I_VP, positionNDC);
        worldPos /= worldPos.w;
        float4 lastPositionCS = mul(_LastViewProj, worldPos);
        float2 lastUV = lastPositionCS.xy / lastPositionCS.w;
        lastUV = lastUV * 0.5 + 0.5;

        float3 accumTexture = _AccumTexture.SampleLevel(sampler_LinearClamp, lastUV, 0).rgb;
        float3 tempMain = 0;
        accumTexture = clip_aabb(color_min, color_max, color_avg, accumTexture);
        tempMain = min(mainTexture, color_avg * 1.25);

        float lum0 = Luminance(mainTexture);
        float lum1 = Luminance(accumTexture);

        float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
        float unbiased_weight = 1.0 - unbiased_diff;
        float unbiased_weight_sqr = unbiased_weight * unbiased_weight;
        float k_feedback = lerp(_TAALastFrame.x, _TAALastFrame.y, unbiased_weight_sqr);

        float3 returnColor = lerp(tempMain, accumTexture, k_feedback);
        if (unJitteredUV.x &gt;= 0.5)
        {
            returnColor = mainTexture;
        }
        return float4(returnColor, 1);
    }

    ENDHLSL

    SubShader
    {
        ZTest Always Cull Back ZWrite Off
    
        pass
        {
            Name &quot;TAA Pass&quot;
            HLSLPROGRAM
            #pragma vertex TAAVert
            #pragma fragment TAAFrag
            ENDHLSL
        }
    }
}
</code></pre><h2 id=一些思考>一些思考<a hidden class=anchor aria-hidden=true href=#一些思考>#</a></h2><p>效果总体来说还是不错的，但是TAAShader中lerp当前渲染画面和AccumTexture的算法应该有待提高，目前特别细长的亚像素特征（如呈线状的高光）会有锯齿爬行的感觉，画面不够稳定，特别小的细节会有一闪一闪的感觉，应该还能再优化优化。PlayDead的源代码有点看不下去。。。就僵在这里了，大概有个80分吧。</p><p>我也想多放图来着，但是实在没啥好放的。。。导致博客越来越枯燥了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li><li><a href=https://zznewclear13.github.io/tags/unity-srp/>Unity SRP</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/accelerate-gaussian-blur-using-group-shared-memory/><span class=title>« Prev</span><br><span>使用Group Shared Memory加速高斯模糊</span></a>
<a class=next href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><span class=title>Next »</span><br><span>支持Animator Controller的实时GPU蒙皮</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const b=document.getElementById('comments');let c=currentHugoTheme=='dark'?'photon-dark':'github-light',a=document.createElement('script');a.src='https://utteranc.es/client.js',a.setAttribute('repo','zznewclear13/zznewclear13.github.io'),a.setAttribute('issue-term','pathname'),a.setAttribute('label','utterances'),a.setAttribute('theme',c),a.setAttribute('crossorigin','anonymous'),a.setAttribute('async',''),b.innerHTML='',b.appendChild(a)}loadComment(),document.getElementById('theme-toggle').onclick=async()=>{await new Promise(a=>setTimeout(a,200));let a=window.localStorage.getItem('pref-theme');a!=currentHugoTheme&&(currentHugoTheme=a,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>