<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ | ZZNEWCLEAR13</title>
<meta name=keywords content="Anti-Aliasing"><meta name=description content="æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5",{anonymize_ip:!1})}</script><meta property="og:title" content="åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ"><meta property="og:description" content="æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"><meta property="og:image" content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-15T19:00:00+08:00"><meta property="article:modified_time" content="2021-07-15T19:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg"><meta name=twitter:title content="åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ"><meta name=twitter:description content="æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ","item":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ","name":"åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ","description":"æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ.","keywords":["Anti-Aliasing"],"articleBody":"TAAçš„åŸç† é¦–å…ˆæ˜¯è¦äº†è§£ç”»é¢ä¸Šçš„é”¯é½¿æ˜¯å¦‚ä½•äº§ç”Ÿçš„ã€‚é”¯é½¿å‘ç”Ÿåœ¨å…‰æ …åŒ–çš„é˜¶æ®µï¼Œå…‰æ …åŒ–çš„æ—¶å€™ä¼šä¸¢å¤±æ‰å°äºä¸€ä¸ªåƒç´ å®½çš„ç»†èŠ‚ï¼Œä¹Ÿå°±å¯¼è‡´äº†é”¯é½¿çš„äº§ç”Ÿã€‚\nä»å­—é¢ä¸Šæ¥çœ‹ï¼ŒTAA (Temporal Anti-Aliasing)çš„æŠ—é”¯é½¿æ•ˆæœæ¥æºäºTemporalä¸€è¯ï¼Œæ˜¯ä¸€ç§æ—¶é—´ä¸Šçš„æŠ—é”¯é½¿ã€‚TAAä¼šç»“åˆå½“å‰æ¸²æŸ“çš„ç”»é¢å’Œä¹‹å‰æ¸²æŸ“çš„ç”»é¢ï¼Œé€šè¿‡è¿™ä¸¤ä¸ªç”»é¢ä¹‹é—´çš„èåˆï¼Œè¾¾æˆæŠ—é”¯é½¿çš„æ•ˆæœã€‚åŸºæœ¬æ€æƒ³æ˜¯åœ¨å…‰æ …åŒ–çš„æ—¶å€™å¯¹ç”»é¢è¿›è¡ŒæŠ–åŠ¨ï¼Œè®©äºšåƒç´ çš„ç»†èŠ‚åœ¨ä¸åŒå¸§æ¸²æŸ“åˆ°ä¸åŒçš„åƒç´ ä¸Šï¼Œæœ€åå†å¯¹è¿™äº›åƒç´ æŒ‰æ—¶é—´çš„æƒé‡æ¥æ··åˆï¼Œå°±èƒ½è¾¾åˆ°æŠ—é”¯é½¿çš„æ•ˆæœã€‚\nTemporal Reprojection Anti-Aliasing Temporal Reprojection Anti-Aliasingæ˜¯ç”±PlayDeadåœ¨ä»–ä»¬çš„æ¸¸æˆInsideä¸­ä½¿ç”¨çš„ä¸€ç§TAAçš„æ–¹æ³•ï¼Œä»–ä»¬åœ¨GDC2016çš„æ¼”ç¤ºä¸­åˆ†äº«äº†è¿™ä¸ªæ–¹æ³•ã€‚ç›¸è¾ƒäºæ™®é€šçš„TAAæ¥è¯´ï¼ŒTemporal Reprojection Anti-Aliasingä¸­ä½¿ç”¨äº†Velocity Bufferä¸­çš„å±å¹•åƒç´ çš„é€Ÿåº¦ä¿¡æ¯å’ŒDepth Bufferä¸­å¯¹åº”çš„å±å¹•åƒç´ çš„ä¸–ç•Œåæ ‡ä¿¡æ¯ï¼Œè¿™æ ·å½“ç‰©ä½“ç§»åŠ¨æˆ–è€…ç›¸æœºç§»åŠ¨çš„æ—¶å€™ï¼Œåœ¨åšåˆ°æŠ—é”¯é½¿çš„åŒæ—¶ä¹Ÿå‡å°‘äº†TAAå¸¦æ¥çš„æ‹–å½±æ•ˆæœï¼ŒåŒæ—¶ä¹ŸæŠŠTAAå’Œè¿åŠ¨æ¨¡ç³Šç›¸ç»“åˆè¾¾åˆ°æ›´ç†æƒ³çš„æŠ—é”¯é½¿çš„æ•ˆæœã€‚\nPlayDeadæä¾›äº†å¯¹åº”çš„æºä»£ç ã€‚æœ¬åšå®¢ä¸­TAAåœ¨SRPä¸­çš„å®ç°ä¹Ÿå‚è€ƒäº†sienaiwunçš„TAAä»£ç ã€‚\nåœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ æˆ‘ä»¬é€šè¿‡RendererFeatureçš„æ–¹å¼åœ¨æ¸²æŸ“ç®¡çº¿ä¸­åŠ å…¥TAAã€‚åœ¨ForwardRendererDataä¸­åŠ å…¥RendererFeatureåï¼Œå¾€Global Volumeä¸­æ·»åŠ Temporal Anti-Aliasingä»¥åœ¨åœºæ™¯ä¸­å¯ç”¨TAAæ•ˆæœã€‚å¯ç”¨TAAæ•ˆæœåï¼Œä¼šç°åœ¨æ¸²æŸ“ä¸é€æ˜ç‰©ä½“ä¹‹å‰è°ƒç”¨ä¸€ä¸ªJitter Passå¯¹ç›¸æœºçš„æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼›åœ¨æ¸²æŸ“TAA Passæ—¶ï¼ˆåœ¨Bloomç­‰è·Ÿç‰©ä½“æ¸²æŸ“ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹åï¼Œåœ¨Chromatic Aberrationç­‰è·Ÿå±å¹•ç©ºé—´ä½ç½®ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹å‰ï¼‰æ ¹æ®æŠ–åŠ¨å€¼è¿˜åŸå‡ºæ­£å¸¸çš„ä¸æŠ–åŠ¨çš„ç”»é¢ï¼Œå¹¶å’ŒAccumTextureè¿›è¡Œæ··åˆï¼Œè·å¾—æœ€ç»ˆçš„æ¸²æŸ“ç”»é¢ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦TAARendererFeatureã€TAAJitterPassã€TAARenderPassè¿™ä¸‰ä¸ªè„šæœ¬æ¥å¤„ç†æ¸²æŸ“ç®¡çº¿ï¼ŒTemporalAntiAliasingè¿™ä¸ªè„šæœ¬æ¥å¤„ç†Volumeï¼ŒTAAShaderè¿™ä¸ªShaderæ–‡ä»¶æ¥è¿›è¡ŒTAAçš„æ··åˆæ“ä½œã€‚ å¯¹æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼Œä¹Ÿå°±ç›¸å½“äºæ˜¯ä¿®æ”¹äº†ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µçš„ç¬¬ä¸€ç¬¬äºŒè¡Œçš„ç¬¬ä¸‰ä½çš„å€¼ï¼ŒæŠ–åŠ¨å€¼æœ€å¥½å’ŒTexelSizeç›¸ç»“åˆï¼Œè¿™æ ·åœ¨TAAåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸å€¼çš„æ—¶å€™ï¼Œåœ¨shaderä¸­ä¼šæ¯”è¾ƒå¥½å†™ã€‚æŠ–åŠ¨å€¼å’ŒTAAçš„åå‘æŠ–åŠ¨æ˜¯æ­£æ¯”å…³ç³»ï¼Œå› æ­¤å¯ä»¥ä¸éœ€è¦ç‰¹åˆ«çº ç»“äºè®¡ç®—ï¼Œåœ¨shaderä¸­ä¼ å…¥ä¸€ä¸ªdebugå€¼å†å’ŒæŠ–åŠ¨å€¼ç›¸ä¹˜ç”¨ä½œåå‘æŠ–åŠ¨ï¼Œè§‚å¯Ÿæœ€åçš„ç”»é¢æ˜¯å¦å­˜åœ¨æŠ–åŠ¨ï¼Œå°±èƒ½å¾ˆå¥½çš„åˆ¤æ–­å‡ºè¿™ä¸¤ä¸ªå€¼çš„æ¯”ä¾‹äº†ã€‚æŠ–åŠ¨çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œçº¯éšæœºçš„æŠ–åŠ¨ä¹Ÿå¯ä»¥é€‰æ‹©ï¼Œä¸è¿‡ç¨ä¸å¦‚ä½¿ç”¨å‡åŒ€åˆ†å¸ƒçš„éšæœºæŠ–åŠ¨çš„æ•ˆæœå¥½ï¼Œè¿™é‡Œä½¿ç”¨Insideä¸­çš„æ–¹å¼å³åˆ©ç”¨Haltonæ•°åˆ—è¿›è¡ŒæŠ–åŠ¨ã€‚ ä¸ºäº†è®©ç›¸æœºç§»åŠ¨æ—¶ä¹Ÿèƒ½æœ‰è¾ƒå¥½çš„æŠ—é”¯é½¿æ•ˆæœä¸”å‰Šå¼±æ‹–å½±ç°è±¡ï¼ŒTemporal Reprojection Anti-Aliasingéœ€è¦é‡‡æ ·å½“å‰çš„æ·±åº¦è´´å›¾ï¼Œè¿˜åŸå‡ºç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œå†è®¡ç®—å‡ºè¿™ä¸ªä¸–ç•Œç©ºé—´åœ¨AccumTextureä¸­çš„UVå€¼(Reprojection)ï¼Œä½¿ç”¨è¿™ä¸ªUVå€¼é‡‡æ ·AccumTextureå†å’Œå½“å‰æ¸²æŸ“ç”»é¢è¿›è¡Œèåˆã€‚ å› ä¸ºVelocity Bufferæ¯”è¾ƒéº»çƒ¦ï¼Œè¿™é‡Œæš‚ä¸”å¿½ç•¥æ‰ç‰©ä½“ç§»åŠ¨å¯¹TAAå¸¦æ¥çš„å½±å“ã€‚ åœ¨ScriptableRenderPassä¸­ä½¿ç”¨cmd.GetTemporaryRT()è·å¾—çš„Render Textureï¼Œåœ¨å½“å¸§è¿‡åå°±ä¼šè¢«å›æ”¶ï¼Œå› æ­¤AccumTextureéœ€è¦ä½¿ç”¨RenderTexture.GetTemporary()æ¥è·å–ã€‚è¿™é‡Œæˆ‘æŠŠAccumTextureæ”¾åœ¨TemporalAntiAliasing.csä¸­ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚ TemporalAntiAliasing.cs é™¤äº†æ™®é€šçš„Volumeçš„è®¾ç½®ä¹‹å¤–ï¼Œè¿˜éœ€è¦æä¾›Render Textureçš„æ¥å£ã€‚lastFrameçš„xå€¼å’Œyå€¼åˆ†åˆ«å¯¹åº”æœ€åæ¸²æŸ“ç”»é¢ä¸­å¯¹AccumTextureè¿›è¡Œçº¿æ€§æ’å€¼çš„æœ€å°å’Œæœ€å¤§ç³»æ•°ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"Post-processing/Temporal Anti-Aliasing\")] public class TemporalAntiAliasing : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public NoInterpFloatRangeParameter lastFrame = new NoInterpFloatRangeParameter(new Vector2(0.2f, 0.8f), 0f, 1f); public Vector2Parameter jitterIntensity = new Vector2Parameter(Vector2.one); private RenderTexture[] accumTextures; public bool IsActive() { return isEnabled.value; } public bool IsTileCompatible() { return false; } void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } bool EnsureRenderTarget(ref RenderTexture rt, int width, int height, RenderTextureFormat format, FilterMode filterMode, string name, int depthBits = 0, int antiAliasing = 1) { if (rt != null \u0026\u0026 (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing); rt.name = name; rt.filterMode = filterMode; rt.wrapMode = TextureWrapMode.Clamp; return true;// new target } return false;// same target } public void EnsureRT(RenderTextureDescriptor descriptor) { EnsureArray(ref accumTextures, 2); EnsureRenderTarget(ref accumTextures[0], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, \"TAA_Accum_One\"); EnsureRenderTarget(ref accumTextures[1], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, \"TAA_Accum_Two\"); } public RenderTexture GetRT(int index) { return accumTextures[index]; } } } TAARendererFeature.cs åœ¨TAARendererFeatureä¸­ç”Ÿæˆç›¸æœºæŠ–åŠ¨çš„å€¼ï¼Œé€šè¿‡TAAJitterPasså¯¹ç›¸æœºçš„æŠ•å½±çŸ©é˜µè¿›è¡ŒæŠ–åŠ¨ï¼Œé€šè¿‡TAARenderPassåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸çš„ç”»é¢ã€‚Haltonåºåˆ—çš„ç”Ÿæˆæ–¹å¼å¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œè¿™é‡Œæš‚ä¸”ç•¥è¿‡ã€‚è¿™é‡Œä¹Ÿæš‚ä¸”å¿½ç•¥äº†DX11å’ŒOpenGLçš„å¹³å°å·®å¼‚åŒ–å¤„ç†ï¼ˆæ— éå°±æ˜¯UVçš„Yè½´ç¿»è½¬çš„é—®é¢˜ï¼‰ã€‚\nnamespace UnityEngine.Rendering.Universal { public class TAARendererFeature : ScriptableRendererFeature { [System.Serializable] public class TAASettings { public bool isEnabled = true; //æœ€å¥½æ˜¯AfterRenderingPostProcessingï¼Œä¸è¿‡ä¼šæœ‰CameraTargetçš„é—®é¢˜ï¼Œéœ€è¦æ›´å¤šçš„è®¾ç½® public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; } public TAASettings settings = new TAASettings(); TAARenderPass taaRenderPass; TAAJitterPass taaJitterPass; private TAAData taaData; private int haltonIndex = 0; private Vector2 lastOffset; private Matrix4x4 lastProj = Matrix4x4.identity; private Matrix4x4 lastView = Matrix4x4.identity; [SerializeField, HideInInspector] private Shader taaShader; public override void Create() { taaShader = Shader.Find(\"Hidden/Universal Render Pipeline/TAAShader\"); if (taaShader == null) { Debug.LogWarning(\"Shader was not found. Please ensure it compiles correctly\"); return; } taaData = new TAAData(); taaData.Initialize(); taaJitterPass = new TAAJitterPass(); taaRenderPass = new TAARenderPass(settings); } public struct TAAData { public Vector2 offset; public Vector2 lastOffset; public Matrix4x4 lastProj; public Matrix4x4 lastView; public Matrix4x4 jitteredProj; public Matrix4x4 currentView; public void Initialize() { offset = Vector2.zero; lastOffset = Vector2.zero; lastProj = Matrix4x4.identity; lastView = Matrix4x4.identity; jitteredProj = Matrix4x4.identity; currentView = Matrix4x4.identity; } } private float HaltonSeq(int prime, int index = 1/* NOT! zero-based */) { float r = 0.0f; float f = 1.0f; int i = index; while (i \u003e 0) { f /= prime; r += f * (i % prime); i = (int)Mathf.Floor(i / (float)prime); } return r; } //dx11 only? private Matrix4x4 GetJitteredProjectionMatrix(Camera camera, Vector2 offset, Vector2 jitterIntensity) { Matrix4x4 originalProjMatrix = camera.nonJitteredProjectionMatrix; float near = camera.nearClipPlane; float far = camera.farClipPlane; Vector2 matrixOffset = offset * new Vector2(1f / camera.pixelWidth, 1f / camera.pixelHeight) * jitterIntensity; //[row, column] originalProjMatrix[0, 2] = matrixOffset.x; originalProjMatrix[1, 2] = matrixOffset.y; return originalProjMatrix; } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { Camera camera = renderingData.cameraData.camera; TemporalAntiAliasing taaComponent = VolumeManager.instance.stack.GetComponent(); if(renderingData.cameraData.cameraType == CameraType.Game \u0026\u0026 taaComponent.IsActive()) { // è·å–Offsetå€¼ haltonIndex = (haltonIndex + 1) \u0026 1023; Vector2 offset = new Vector2( HaltonSeq(2, haltonIndex + 1) - 0.5f, HaltonSeq(3, haltonIndex + 1) - 0.5f); // è·å–jittered projection matrixï¼Œå¹¶è®°å½•ä¹‹å‰çš„matrix // jittered projectionçš„abåº”è¯¥å¯¹åº”0.5 * texel_size.xy lastOffset = taaData.offset; taaData.lastOffset = lastOffset; taaData.offset = new Vector2(offset.x / camera.pixelWidth, offset.y / camera.pixelHeight) * taaComponent.jitterIntensity.value; taaData.jitteredProj = GetJitteredProjectionMatrix(camera, offset, taaComponent.jitterIntensity.value); taaData.lastProj = lastProj; taaData.lastView = lastView; lastProj = camera.projectionMatrix; lastView = camera.worldToCameraMatrix; taaData.currentView = lastView; // ç¬¬ä¸€ä¸ªPasså¯¹ç›¸æœºä½¿ç”¨jittered projection matrix taaJitterPass.Setup(taaData); renderer.EnqueuePass(taaJitterPass); //ç¬¬äºŒä¸ªPassæ‰§è¡ŒçœŸæ­£çš„TAA //æš‚æ—¶ä¸è€ƒè™‘motion blur/è¿åŠ¨ç‰©ä½“çš„TAA taaRenderPass.Setup(taaShader, taaData, taaComponent); renderer.EnqueuePass(taaRenderPass); } } } } TAAJitterPass.cs è¿™ä¸ªPassä»…ç”¨äºæ”¹å˜ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µï¼Œåœ¨æŸäº›æƒ…å†µä¸‹æ¸²æŸ“é€æ˜ç‰©ä½“æ—¶ä¼šé‡ç½®é€è§†å˜æ¢çŸ©é˜µï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦åœ¨BeforeRenderingTransparentçš„æ—¶å€™å†é¢å¤–æ‰§è¡Œä¸€éTAAJitterPassã€‚\nnamespace UnityEngine.Rendering.Universal { public class TAAJitterPass : ScriptableRenderPass { private const string profilerTag = \"TAA Jitter Pass\"; private ProfilingSampler taaSampler = new ProfilingSampler(\"TAA Jitter Pass\"); private TAARendererFeature.TAAData taaData; public TAAJitterPass() { profilingSampler = taaSampler; renderPassEvent = RenderPassEvent.BeforeRenderingOpaques; } public void Setup(TAARendererFeature.TAAData taaData) { this.taaData = taaData; } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, profilingSampler)) { CameraData cameraData = renderingData.cameraData; cmd.SetViewProjectionMatrices(cameraData.camera.worldToCameraMatrix, taaData.jitteredProj); } context.ExecuteCommandBuffer(cmd); CommandBufferPool.Release(cmd); } } } TAARenderPass.cs ç”±äº_CameraColorTextureæ²¡æœ‰å¼€å¯éšæœºè¯»å†™ï¼Œä½¿ç”¨Compute Shaderè¿›è¡ŒTAAçš„è®¡ç®—ä¼šéœ€è¦é¢å¤–çš„blitï¼Œè¿™é‡Œå°±ä½¿ç”¨æ™®é€šçš„shaderæ¥è¿›è¡ŒTAAçš„æ“ä½œäº†ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { public class TAARenderPass : ScriptableRenderPass { private const string profilerTag = \"My TAA Pass\"; private ProfilingSampler taaSampler = new ProfilingSampler(\"TAA Pass\"); RenderTargetHandle cameraColorHandle; RenderTargetIdentifier cameraColorIden; RenderTargetHandle cameraDepthHandle; RenderTargetIdentifier cameraDepthIden; private Vector2Int screenSize; private int accumIndex; private TAARendererFeature.TAASettings settings; private TAARendererFeature.TAAData taaData; private Material taaMaterial; private TemporalAntiAliasing taaComponent; private Vector2 lastFrame; public TAARenderPass(TAARendererFeature.TAASettings settings) { profilingSampler = new ProfilingSampler(profilerTag); cameraColorHandle.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColorHandle.Identifier(); cameraDepthHandle.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepthHandle.Identifier(); this.settings = settings; } public void Setup(Shader taaShader, TAARendererFeature.TAAData taaData, TemporalAntiAliasing taaComponent) { this.taaData = taaData; renderPassEvent = settings.renderPassEvent; this.lastFrame = taaComponent.lastFrame.value; taaMaterial = new Material(taaShader); this.taaComponent = taaComponent; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor descriptor = cameraTextureDescriptor; screenSize = new Vector2Int(descriptor.width, descriptor.height); taaComponent.EnsureRT(descriptor); } private void DoTAA(CommandBuffer cmd, TemporalAntiAliasing taa, RenderTargetIdentifier colorid, int index) { RenderTexture accumRead = taa.GetRT(index); int tempIndex = 1 - index; RenderTexture accumWrite = taa.GetRT(tempIndex); taaMaterial.SetVector(\"_TAAOffsets\", new Vector4(taaData.offset.x, taaData.offset.y, taaData.lastOffset.x, taaData.lastOffset.y)); taaMaterial.SetVector(\"_TAALastFrame\", taaComponent.lastFrame.value); taaMaterial.SetVector(\"_TextureSize\", new Vector4(screenSize.x, screenSize.y, 1f / screenSize.x, 1f / screenSize.y)); Matrix4x4 lastViewProj = taaData.lastProj * taaData.lastView; taaMaterial.SetMatrix(\"_LastViewProj\", lastViewProj); taaMaterial.SetTexture(\"_AccumTexture\", accumRead); cmd.Blit(colorid, accumWrite, taaMaterial); cmd.Blit(accumWrite, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, taaSampler)) { DoTAA(cmd, taaComponent, cameraColorIden, accumIndex); accumIndex = 1 - accumIndex; } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { if (cmd == null) throw new ArgumentNullException(\"cmd\"); } } } TAAShader.shader å¤šæ¬¡é‡‡æ ·èƒ½å¤Ÿæ˜æ˜¾çš„å‰Šå¼±æ‹–å½±æ•ˆæœï¼ŒtempMain = min(mainTexture, color_avg * 1.25);è¿™ä¸€è¡Œèƒ½å¤Ÿåœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘é«˜å…‰çš„é—ªçƒï¼Œclip_aabbå’Œk_feedbackä¼¼ä¹ç”¨å¤„ä¸æ˜¯å¾ˆå¤§ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯å†™è¿›å»äº†ã€‚\nShader \"Hidden/Universal Render Pipeline/TAAShader\" { Properties { _MainTex(\"Main Texture\", 2D) = \"white\"{} } HLSLINCLUDE #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/core.hlsl\" #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\" texture2D _MainTex; texture2D _CameraDepthTexture; texture2D _AccumTexture; SamplerState sampler_LinearClamp; SamplerState sampler_PointClamp; float4 _TAAOffsets; float2 _TAALastFrame; float4 _TextureSize; float4x4 _LastViewProj; struct Attributes { float4 positionOS : POSITION; float2 texcoord : TEXCOORD0; }; struct Varyings { float4 positionCS : SV_POSITION; float2 texcoord : TEXCOORD0; }; float3 clip_aabb(float3 aabb_min, float3 aabb_max, float3 avg, float3 input_texel) { float3 p_clip = 0.5 * (aabb_max + aabb_min); float3 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS; float3 v_clip = input_texel - p_clip; float3 v_unit = v_clip / e_clip; float3 a_unit = abs(v_unit); float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z)); if (ma_unit \u003e 1.0) return p_clip + v_clip / ma_unit; else return input_texel; } Varyings TAAVert(Attributes input) { Varyings output = (Varyings)0; VertexPositionInputs vertexPositionInputs = GetVertexPositionInputs(input.positionOS.xyz); output.positionCS = vertexPositionInputs.positionCS; output.texcoord = input.texcoord; return output; } float4 TAAFrag(Varyings input) : SV_TARGET { float2 sampleUV = input.texcoord; float2 currentOffset = _TAAOffsets.xy; float2 lastOffset = _TAAOffsets.zw; float2 unJitteredUV = sampleUV - 0.5 * currentOffset; float3 mainTexture = _MainTex.SampleLevel(sampler_LinearClamp, unJitteredUV, 0).rgb; float2 du = float2(_TextureSize.z, 0); float2 dv = float2(0, _TextureSize.w); float3 ctl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv - du).rgb; float3 ctc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv).rgb; float3 ctr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - dv + du).rgb; float3 cml = _MainTex.Sample(sampler_LinearClamp, unJitteredUV - du).rgb; float3 cmc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV).rgb; float3 cmr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + du).rgb; float3 cbl = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv - du).rgb; float3 cbc = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv).rgb; float3 cbr = _MainTex.Sample(sampler_LinearClamp, unJitteredUV + dv + du).rgb; float3 color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr)))))))); float3 color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr)))))))); float3 color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0; float depthTexture = _CameraDepthTexture.SampleLevel(sampler_PointClamp, unJitteredUV, 0).r; float4 positionNDC = float4(sampleUV * 2 - 1, depthTexture, 1); #if UNITY_UV_STARTS_AT_TOP positionNDC.y = -positionNDC.y; #endif float4 worldPos = mul(UNITY_MATRIX_I_VP, positionNDC); worldPos /= worldPos.w; float4 lastPositionCS = mul(_LastViewProj, worldPos); float2 lastUV = lastPositionCS.xy / lastPositionCS.w; lastUV = lastUV * 0.5 + 0.5; float3 accumTexture = _AccumTexture.SampleLevel(sampler_LinearClamp, lastUV, 0).rgb; float3 tempMain = 0; accumTexture = clip_aabb(color_min, color_max, color_avg, accumTexture); tempMain = min(mainTexture, color_avg * 1.25); float lum0 = Luminance(mainTexture); float lum1 = Luminance(accumTexture); float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2)); float unbiased_weight = 1.0 - unbiased_diff; float unbiased_weight_sqr = unbiased_weight * unbiased_weight; float k_feedback = lerp(_TAALastFrame.x, _TAALastFrame.y, unbiased_weight_sqr); float3 returnColor = lerp(tempMain, accumTexture, k_feedback); if (unJitteredUV.x \u003e= 0.5) { returnColor = mainTexture; } return float4(returnColor, 1); } ENDHLSL SubShader { ZTest Always Cull Back ZWrite Off pass { Name \"TAA Pass\" HLSLPROGRAM #pragma vertex TAAVert #pragma fragment TAAFrag ENDHLSL } } } ä¸€äº›æ€è€ƒ æ•ˆæœæ€»ä½“æ¥è¯´è¿˜æ˜¯ä¸é”™çš„ï¼Œä½†æ˜¯TAAShaderä¸­lerpå½“å‰æ¸²æŸ“ç”»é¢å’ŒAccumTextureçš„ç®—æ³•åº”è¯¥æœ‰å¾…æé«˜ï¼Œç›®å‰ç‰¹åˆ«ç»†é•¿çš„äºšåƒç´ ç‰¹å¾ï¼ˆå¦‚å‘ˆçº¿çŠ¶çš„é«˜å…‰ï¼‰ä¼šæœ‰é”¯é½¿çˆ¬è¡Œçš„æ„Ÿè§‰ï¼Œç”»é¢ä¸å¤Ÿç¨³å®šï¼Œç‰¹åˆ«å°çš„ç»†èŠ‚ä¼šæœ‰ä¸€é—ªä¸€é—ªçš„æ„Ÿè§‰ï¼Œåº”è¯¥è¿˜èƒ½å†ä¼˜åŒ–ä¼˜åŒ–ã€‚PlayDeadçš„æºä»£ç æœ‰ç‚¹çœ‹ä¸ä¸‹å»ã€‚ã€‚ã€‚å°±åƒµåœ¨è¿™é‡Œäº†ï¼Œå¤§æ¦‚æœ‰ä¸ª80åˆ†å§ã€‚\næˆ‘ä¹Ÿæƒ³å¤šæ”¾å›¾æ¥ç€ï¼Œä½†æ˜¯å®åœ¨æ²¡å•¥å¥½æ”¾çš„ã€‚ã€‚ã€‚å¯¼è‡´åšå®¢è¶Šæ¥è¶Šæ¯ç‡¥äº†ã€‚\n","wordCount":"1382","inLanguage":"en","image":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/posts/images/TemporalAntiAliasing.jpg","datePublished":"2021-07-15T19:00:00+08:00","dateModified":"2021-07-15T19:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/temporal-reprojection-anti-aliasing/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ</h1><div class=post-description>æŠ–åŠ¨ç›¸æœºæ¥å®ç°TAAæŠ—é”¯é½¿æ•ˆæœ.</div><div class=post-meta><span title='2021-07-15 19:00:00 +0800 CST'>July 15, 2021</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/temporal-reprojection-anti-aliasing.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/TemporalAntiAliasing.jpg alt="Temporal Anti-Aliasing Cover"><p>å·¦ä¾§ä¸ºTAAæ•ˆæœï¼Œå³ä¾§æ²¡æœ‰TAA</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>åœ¨Unity SRPä¸­å®ç°TAAæ•ˆæœ</div></summary><div class=inner><ul><li><a href=#taa%e7%9a%84%e5%8e%9f%e7%90%86 aria-label=TAAçš„åŸç†>TAAçš„åŸç†</a></li><li><a href=#temporal-reprojection-anti-aliasing aria-label="Temporal Reprojection Anti-Aliasing">Temporal Reprojection Anti-Aliasing</a></li><li><a href=#%e5%9c%a8unity-srp%e4%b8%ad%e5%ae%9e%e7%8e%b0taa%e7%9a%84%e6%93%8d%e4%bd%9c aria-label="åœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ">åœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ</a><ul><li><a href=#temporalantialiasingcs aria-label=TemporalAntiAliasing.cs>TemporalAntiAliasing.cs</a></li><li><a href=#taarendererfeaturecs aria-label=TAARendererFeature.cs>TAARendererFeature.cs</a></li><li><a href=#taajitterpasscs aria-label=TAAJitterPass.cs>TAAJitterPass.cs</a></li><li><a href=#taarenderpasscs aria-label=TAARenderPass.cs>TAARenderPass.cs</a></li><li><a href=#taashadershader aria-label=TAAShader.shader>TAAShader.shader</a></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b%e6%80%9d%e8%80%83 aria-label=ä¸€äº›æ€è€ƒ>ä¸€äº›æ€è€ƒ</a></li></ul></div></details></div><div class=post-content><h2 id=taaçš„åŸç†>TAAçš„åŸç†<a hidden class=anchor aria-hidden=true href=#taaçš„åŸç†>#</a></h2><p>é¦–å…ˆæ˜¯è¦äº†è§£ç”»é¢ä¸Šçš„é”¯é½¿æ˜¯å¦‚ä½•äº§ç”Ÿçš„ã€‚é”¯é½¿å‘ç”Ÿåœ¨å…‰æ …åŒ–çš„é˜¶æ®µï¼Œå…‰æ …åŒ–çš„æ—¶å€™ä¼šä¸¢å¤±æ‰å°äºä¸€ä¸ªåƒç´ å®½çš„ç»†èŠ‚ï¼Œä¹Ÿå°±å¯¼è‡´äº†é”¯é½¿çš„äº§ç”Ÿã€‚</p><p>ä»å­—é¢ä¸Šæ¥çœ‹ï¼ŒTAA (Temporal Anti-Aliasing)çš„æŠ—é”¯é½¿æ•ˆæœæ¥æºäºTemporalä¸€è¯ï¼Œæ˜¯ä¸€ç§æ—¶é—´ä¸Šçš„æŠ—é”¯é½¿ã€‚TAAä¼šç»“åˆå½“å‰æ¸²æŸ“çš„ç”»é¢å’Œä¹‹å‰æ¸²æŸ“çš„ç”»é¢ï¼Œé€šè¿‡è¿™ä¸¤ä¸ªç”»é¢ä¹‹é—´çš„èåˆï¼Œè¾¾æˆæŠ—é”¯é½¿çš„æ•ˆæœã€‚åŸºæœ¬æ€æƒ³æ˜¯åœ¨å…‰æ …åŒ–çš„æ—¶å€™å¯¹ç”»é¢è¿›è¡ŒæŠ–åŠ¨ï¼Œè®©äºšåƒç´ çš„ç»†èŠ‚åœ¨ä¸åŒå¸§æ¸²æŸ“åˆ°ä¸åŒçš„åƒç´ ä¸Šï¼Œæœ€åå†å¯¹è¿™äº›åƒç´ æŒ‰æ—¶é—´çš„æƒé‡æ¥æ··åˆï¼Œå°±èƒ½è¾¾åˆ°æŠ—é”¯é½¿çš„æ•ˆæœã€‚</p><h2 id=temporal-reprojection-anti-aliasing>Temporal Reprojection Anti-Aliasing<a hidden class=anchor aria-hidden=true href=#temporal-reprojection-anti-aliasing>#</a></h2><p>Temporal Reprojection Anti-Aliasingæ˜¯ç”±PlayDeadåœ¨ä»–ä»¬çš„æ¸¸æˆInsideä¸­ä½¿ç”¨çš„ä¸€ç§TAAçš„æ–¹æ³•ï¼Œä»–ä»¬åœ¨<a href=https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in>GDC2016çš„æ¼”ç¤º</a>ä¸­åˆ†äº«äº†è¿™ä¸ªæ–¹æ³•ã€‚ç›¸è¾ƒäºæ™®é€šçš„TAAæ¥è¯´ï¼ŒTemporal Reprojection Anti-Aliasingä¸­ä½¿ç”¨äº†Velocity Bufferä¸­çš„å±å¹•åƒç´ çš„é€Ÿåº¦ä¿¡æ¯å’ŒDepth Bufferä¸­å¯¹åº”çš„å±å¹•åƒç´ çš„ä¸–ç•Œåæ ‡ä¿¡æ¯ï¼Œè¿™æ ·å½“ç‰©ä½“ç§»åŠ¨æˆ–è€…ç›¸æœºç§»åŠ¨çš„æ—¶å€™ï¼Œåœ¨åšåˆ°æŠ—é”¯é½¿çš„åŒæ—¶ä¹Ÿå‡å°‘äº†TAAå¸¦æ¥çš„æ‹–å½±æ•ˆæœï¼ŒåŒæ—¶ä¹ŸæŠŠTAAå’Œè¿åŠ¨æ¨¡ç³Šç›¸ç»“åˆè¾¾åˆ°æ›´ç†æƒ³çš„æŠ—é”¯é½¿çš„æ•ˆæœã€‚</p><p>PlayDeadæä¾›äº†å¯¹åº”çš„<a href=https://github.com/playdeadgames/temporal>æºä»£ç </a>ã€‚æœ¬åšå®¢ä¸­TAAåœ¨SRPä¸­çš„å®ç°ä¹Ÿå‚è€ƒäº†sienaiwunçš„<a href=https://github.com/sienaiwun/TAA_Unity_URP>TAAä»£ç </a>ã€‚</p><h2 id=åœ¨unity-srpä¸­å®ç°taaçš„æ“ä½œ>åœ¨Unity SRPä¸­å®ç°TAAçš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#åœ¨unity-srpä¸­å®ç°taaçš„æ“ä½œ>#</a></h2><ol><li>æˆ‘ä»¬é€šè¿‡RendererFeatureçš„æ–¹å¼åœ¨æ¸²æŸ“ç®¡çº¿ä¸­åŠ å…¥TAAã€‚åœ¨ForwardRendererDataä¸­åŠ å…¥RendererFeatureåï¼Œå¾€Global Volumeä¸­æ·»åŠ Temporal Anti-Aliasingä»¥åœ¨åœºæ™¯ä¸­å¯ç”¨TAAæ•ˆæœã€‚å¯ç”¨TAAæ•ˆæœåï¼Œä¼šç°åœ¨æ¸²æŸ“ä¸é€æ˜ç‰©ä½“ä¹‹å‰è°ƒç”¨ä¸€ä¸ªJitter Passå¯¹ç›¸æœºçš„æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼›åœ¨æ¸²æŸ“TAA Passæ—¶ï¼ˆåœ¨Bloomç­‰è·Ÿç‰©ä½“æ¸²æŸ“ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹åï¼Œåœ¨Chromatic Aberrationç­‰è·Ÿå±å¹•ç©ºé—´ä½ç½®ç›¸å…³çš„åå¤„ç†æ•ˆæœä¹‹å‰ï¼‰æ ¹æ®æŠ–åŠ¨å€¼è¿˜åŸå‡ºæ­£å¸¸çš„ä¸æŠ–åŠ¨çš„ç”»é¢ï¼Œå¹¶å’ŒAccumTextureè¿›è¡Œæ··åˆï¼Œè·å¾—æœ€ç»ˆçš„æ¸²æŸ“ç”»é¢ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦TAARendererFeatureã€TAAJitterPassã€TAARenderPassè¿™ä¸‰ä¸ªè„šæœ¬æ¥å¤„ç†æ¸²æŸ“ç®¡çº¿ï¼ŒTemporalAntiAliasingè¿™ä¸ªè„šæœ¬æ¥å¤„ç†Volumeï¼ŒTAAShaderè¿™ä¸ªShaderæ–‡ä»¶æ¥è¿›è¡ŒTAAçš„æ··åˆæ“ä½œã€‚</li><li>å¯¹æ …æ ¼åŒ–é˜¶æ®µè¿›è¡ŒæŠ–åŠ¨ï¼Œä¹Ÿå°±ç›¸å½“äºæ˜¯ä¿®æ”¹äº†ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µçš„ç¬¬ä¸€ç¬¬äºŒè¡Œçš„ç¬¬ä¸‰ä½çš„å€¼ï¼ŒæŠ–åŠ¨å€¼æœ€å¥½å’ŒTexelSizeç›¸ç»“åˆï¼Œè¿™æ ·åœ¨TAAåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸å€¼çš„æ—¶å€™ï¼Œåœ¨shaderä¸­ä¼šæ¯”è¾ƒå¥½å†™ã€‚æŠ–åŠ¨å€¼å’ŒTAAçš„åå‘æŠ–åŠ¨æ˜¯æ­£æ¯”å…³ç³»ï¼Œå› æ­¤å¯ä»¥ä¸éœ€è¦ç‰¹åˆ«çº ç»“äºè®¡ç®—ï¼Œåœ¨shaderä¸­ä¼ å…¥ä¸€ä¸ªdebugå€¼å†å’ŒæŠ–åŠ¨å€¼ç›¸ä¹˜ç”¨ä½œåå‘æŠ–åŠ¨ï¼Œè§‚å¯Ÿæœ€åçš„ç”»é¢æ˜¯å¦å­˜åœ¨æŠ–åŠ¨ï¼Œå°±èƒ½å¾ˆå¥½çš„åˆ¤æ–­å‡ºè¿™ä¸¤ä¸ªå€¼çš„æ¯”ä¾‹äº†ã€‚æŠ–åŠ¨çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œçº¯éšæœºçš„æŠ–åŠ¨ä¹Ÿå¯ä»¥é€‰æ‹©ï¼Œä¸è¿‡ç¨ä¸å¦‚ä½¿ç”¨å‡åŒ€åˆ†å¸ƒçš„éšæœºæŠ–åŠ¨çš„æ•ˆæœå¥½ï¼Œè¿™é‡Œä½¿ç”¨Insideä¸­çš„æ–¹å¼å³åˆ©ç”¨Haltonæ•°åˆ—è¿›è¡ŒæŠ–åŠ¨ã€‚</li><li>ä¸ºäº†è®©ç›¸æœºç§»åŠ¨æ—¶ä¹Ÿèƒ½æœ‰è¾ƒå¥½çš„æŠ—é”¯é½¿æ•ˆæœä¸”å‰Šå¼±æ‹–å½±ç°è±¡ï¼ŒTemporal Reprojection Anti-Aliasingéœ€è¦é‡‡æ ·å½“å‰çš„æ·±åº¦è´´å›¾ï¼Œè¿˜åŸå‡ºç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œå†è®¡ç®—å‡ºè¿™ä¸ªä¸–ç•Œç©ºé—´åœ¨AccumTextureä¸­çš„UVå€¼(Reprojection)ï¼Œä½¿ç”¨è¿™ä¸ªUVå€¼é‡‡æ ·AccumTextureå†å’Œå½“å‰æ¸²æŸ“ç”»é¢è¿›è¡Œèåˆã€‚</li><li>å› ä¸ºVelocity Bufferæ¯”è¾ƒéº»çƒ¦ï¼Œè¿™é‡Œæš‚ä¸”å¿½ç•¥æ‰ç‰©ä½“ç§»åŠ¨å¯¹TAAå¸¦æ¥çš„å½±å“ã€‚</li><li>åœ¨ScriptableRenderPassä¸­ä½¿ç”¨cmd.GetTemporaryRT()è·å¾—çš„Render Textureï¼Œåœ¨å½“å¸§è¿‡åå°±ä¼šè¢«å›æ”¶ï¼Œå› æ­¤AccumTextureéœ€è¦ä½¿ç”¨RenderTexture.GetTemporary()æ¥è·å–ã€‚è¿™é‡Œæˆ‘æŠŠAccumTextureæ”¾åœ¨TemporalAntiAliasing.csä¸­ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚</li></ol><h3 id=temporalantialiasingcs>TemporalAntiAliasing.cs<a hidden class=anchor aria-hidden=true href=#temporalantialiasingcs>#</a></h3><p>é™¤äº†æ™®é€šçš„Volumeçš„è®¾ç½®ä¹‹å¤–ï¼Œè¿˜éœ€è¦æä¾›Render Textureçš„æ¥å£ã€‚lastFrameçš„xå€¼å’Œyå€¼åˆ†åˆ«å¯¹åº”æœ€åæ¸²æŸ“ç”»é¢ä¸­å¯¹AccumTextureè¿›è¡Œçº¿æ€§æ’å€¼çš„æœ€å°å’Œæœ€å¤§ç³»æ•°ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;Post-processing/Temporal Anti-Aliasing&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TemporalAntiAliasing</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> NoInterpFloatRangeParameter lastFrame = <span style=color:#66d9ef>new</span> NoInterpFloatRangeParameter(<span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.2f</span>, <span style=color:#ae81ff>0.8f</span>), <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Vector2Parameter jitterIntensity = <span style=color:#66d9ef>new</span> Vector2Parameter(Vector2.one);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTexture[] accumTextures;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                array = <span style=color:#66d9ef>new</span> T[size];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
</span></span><span style=display:flex><span>                    array[i] = initialValue;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> EnsureRenderTarget(<span style=color:#66d9ef>ref</span> RenderTexture rt, <span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height, RenderTextureFormat format, FilterMode filterMode, <span style=color:#66d9ef>string</span> name, <span style=color:#66d9ef>int</span> depthBits = <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> antiAliasing = <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                RenderTexture.ReleaseTemporary(rt);
</span></span><span style=display:flex><span>                rt = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing);
</span></span><span style=display:flex><span>                rt.name = name;
</span></span><span style=display:flex><span>                rt.filterMode = filterMode;
</span></span><span style=display:flex><span>                rt.wrapMode = TextureWrapMode.Clamp;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;<span style=color:#75715e>// new target</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;<span style=color:#75715e>// same target</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> EnsureRT(RenderTextureDescriptor descriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            EnsureArray(<span style=color:#66d9ef>ref</span> accumTextures, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>            EnsureRenderTarget(<span style=color:#66d9ef>ref</span> accumTextures[<span style=color:#ae81ff>0</span>], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, <span style=color:#e6db74>&#34;TAA_Accum_One&#34;</span>);
</span></span><span style=display:flex><span>            EnsureRenderTarget(<span style=color:#66d9ef>ref</span> accumTextures[<span style=color:#ae81ff>1</span>], descriptor.width, descriptor.height, descriptor.colorFormat, FilterMode.Bilinear, <span style=color:#e6db74>&#34;TAA_Accum_Two&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> RenderTexture GetRT(<span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> accumTextures[index];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=taarendererfeaturecs>TAARendererFeature.cs<a hidden class=anchor aria-hidden=true href=#taarendererfeaturecs>#</a></h3><p>åœ¨TAARendererFeatureä¸­ç”Ÿæˆç›¸æœºæŠ–åŠ¨çš„å€¼ï¼Œé€šè¿‡TAAJitterPasså¯¹ç›¸æœºçš„æŠ•å½±çŸ©é˜µè¿›è¡ŒæŠ–åŠ¨ï¼Œé€šè¿‡TAARenderPassåå‘æŠ–åŠ¨è¿˜åŸæ­£å¸¸çš„ç”»é¢ã€‚Haltonåºåˆ—çš„ç”Ÿæˆæ–¹å¼å¯ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œè¿™é‡Œæš‚ä¸”ç•¥è¿‡ã€‚è¿™é‡Œä¹Ÿæš‚ä¸”å¿½ç•¥äº†DX11å’ŒOpenGLçš„å¹³å°å·®å¼‚åŒ–å¤„ç†ï¼ˆæ— éå°±æ˜¯UVçš„Yè½´ç¿»è½¬çš„é—®é¢˜ï¼‰ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAARendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAASettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> isEnabled = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//æœ€å¥½æ˜¯AfterRenderingPostProcessingï¼Œä¸è¿‡ä¼šæœ‰CameraTargetçš„é—®é¢˜ï¼Œéœ€è¦æ›´å¤šçš„è®¾ç½®</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> TAASettings settings = <span style=color:#66d9ef>new</span> TAASettings();
</span></span><span style=display:flex><span>        TAARenderPass taaRenderPass;
</span></span><span style=display:flex><span>        TAAJitterPass taaJitterPass;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TAAData taaData;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> haltonIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2 lastOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4 lastProj = Matrix4x4.identity;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4 lastView = Matrix4x4.identity;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [SerializeField, HideInInspector]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Shader taaShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            taaShader = Shader.Find(<span style=color:#e6db74>&#34;Hidden/Universal Render Pipeline/TAAShader&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (taaShader == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Debug.LogWarning(<span style=color:#e6db74>&#34;Shader was not found. Please ensure it compiles correctly&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            taaData = <span style=color:#66d9ef>new</span> TAAData();
</span></span><span style=display:flex><span>            taaData.Initialize();
</span></span><span style=display:flex><span>            taaJitterPass = <span style=color:#66d9ef>new</span> TAAJitterPass();
</span></span><span style=display:flex><span>            taaRenderPass = <span style=color:#66d9ef>new</span> TAARenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TAAData</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Vector2 offset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Vector2 lastOffset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Matrix4x4 lastProj;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Matrix4x4 lastView;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Matrix4x4 jitteredProj;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Matrix4x4 currentView;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialize()
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                offset = Vector2.zero;
</span></span><span style=display:flex><span>                lastOffset = Vector2.zero;
</span></span><span style=display:flex><span>                lastProj = Matrix4x4.identity;
</span></span><span style=display:flex><span>                lastView = Matrix4x4.identity;
</span></span><span style=display:flex><span>                jitteredProj = Matrix4x4.identity;
</span></span><span style=display:flex><span>                currentView = Matrix4x4.identity;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> HaltonSeq(<span style=color:#66d9ef>int</span> prime, <span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>1</span><span style=color:#75715e>/* NOT! zero-based */</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> r = <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> f = <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i = index;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (i &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                f /= prime;
</span></span><span style=display:flex><span>                r += f * (i % prime);
</span></span><span style=display:flex><span>                i = (<span style=color:#66d9ef>int</span>)Mathf.Floor(i / (<span style=color:#66d9ef>float</span>)prime);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//dx11 only?</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4 GetJitteredProjectionMatrix(Camera camera, Vector2 offset, Vector2 jitterIntensity)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Matrix4x4 originalProjMatrix = camera.nonJitteredProjectionMatrix;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> near = camera.nearClipPlane;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> far = camera.farClipPlane;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Vector2 matrixOffset = offset * <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1f</span> / camera.pixelWidth, <span style=color:#ae81ff>1f</span> / camera.pixelHeight) * jitterIntensity;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//[row, column]</span>
</span></span><span style=display:flex><span>            originalProjMatrix[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>] = matrixOffset.x;
</span></span><span style=display:flex><span>            originalProjMatrix[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>] = matrixOffset.y;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> originalProjMatrix;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Camera camera = renderingData.cameraData.camera;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            TemporalAntiAliasing taaComponent = VolumeManager.instance.stack.GetComponent&lt;TemporalAntiAliasing&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(renderingData.cameraData.cameraType == CameraType.Game &amp;&amp; taaComponent.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// è·å–Offsetå€¼</span>
</span></span><span style=display:flex><span>                haltonIndex = (haltonIndex + <span style=color:#ae81ff>1</span>) &amp; <span style=color:#ae81ff>1023</span>;
</span></span><span style=display:flex><span>                Vector2 offset = <span style=color:#66d9ef>new</span> Vector2(
</span></span><span style=display:flex><span>                    HaltonSeq(<span style=color:#ae81ff>2</span>, haltonIndex + <span style=color:#ae81ff>1</span>) - <span style=color:#ae81ff>0.5f</span>,
</span></span><span style=display:flex><span>                    HaltonSeq(<span style=color:#ae81ff>3</span>, haltonIndex + <span style=color:#ae81ff>1</span>) - <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// è·å–jittered projection matrixï¼Œå¹¶è®°å½•ä¹‹å‰çš„matrix</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// jittered projectionçš„abåº”è¯¥å¯¹åº”0.5 * texel_size.xy</span>
</span></span><span style=display:flex><span>                lastOffset = taaData.offset;
</span></span><span style=display:flex><span>                taaData.lastOffset = lastOffset;
</span></span><span style=display:flex><span>                taaData.offset = <span style=color:#66d9ef>new</span> Vector2(offset.x / camera.pixelWidth, offset.y / camera.pixelHeight) * taaComponent.jitterIntensity.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>                taaData.jitteredProj = GetJitteredProjectionMatrix(camera, offset, taaComponent.jitterIntensity.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>                taaData.lastProj = lastProj;
</span></span><span style=display:flex><span>                taaData.lastView = lastView;
</span></span><span style=display:flex><span>                lastProj = camera.projectionMatrix;
</span></span><span style=display:flex><span>                lastView = camera.worldToCameraMatrix;
</span></span><span style=display:flex><span>                taaData.currentView = lastView;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ç¬¬ä¸€ä¸ªPasså¯¹ç›¸æœºä½¿ç”¨jittered projection matrix</span>
</span></span><span style=display:flex><span>                taaJitterPass.Setup(taaData);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(taaJitterPass);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//ç¬¬äºŒä¸ªPassæ‰§è¡ŒçœŸæ­£çš„TAA</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//æš‚æ—¶ä¸è€ƒè™‘motion blur/è¿åŠ¨ç‰©ä½“çš„TAA</span>
</span></span><span style=display:flex><span>                taaRenderPass.Setup(taaShader, taaData, taaComponent);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(taaRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=taajitterpasscs>TAAJitterPass.cs<a hidden class=anchor aria-hidden=true href=#taajitterpasscs>#</a></h3><p>è¿™ä¸ªPassä»…ç”¨äºæ”¹å˜ç›¸æœºçš„é€è§†å˜æ¢çŸ©é˜µï¼Œåœ¨æŸäº›æƒ…å†µä¸‹æ¸²æŸ“é€æ˜ç‰©ä½“æ—¶ä¼šé‡ç½®é€è§†å˜æ¢çŸ©é˜µï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦åœ¨BeforeRenderingTransparentçš„æ—¶å€™å†é¢å¤–æ‰§è¡Œä¸€éTAAJitterPassã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAAJitterPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;TAA Jitter Pass&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler taaSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;TAA Jitter Pass&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TAARendererFeature.TAAData taaData;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> TAAJitterPass()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            profilingSampler = taaSampler;
</span></span><span style=display:flex><span>            renderPassEvent = RenderPassEvent.BeforeRenderingOpaques;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(TAARendererFeature.TAAData taaData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.taaData = taaData;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                CameraData cameraData = renderingData.cameraData;
</span></span><span style=display:flex><span>                cmd.SetViewProjectionMatrices(cameraData.camera.worldToCameraMatrix, taaData.jitteredProj);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=taarenderpasscs>TAARenderPass.cs<a hidden class=anchor aria-hidden=true href=#taarenderpasscs>#</a></h3><p>ç”±äº<code>_CameraColorTexture</code>æ²¡æœ‰å¼€å¯éšæœºè¯»å†™ï¼Œä½¿ç”¨Compute Shaderè¿›è¡ŒTAAçš„è®¡ç®—ä¼šéœ€è¦é¢å¤–çš„blitï¼Œè¿™é‡Œå°±ä½¿ç”¨æ™®é€šçš„shaderæ¥è¿›è¡ŒTAAçš„æ“ä½œäº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TAARenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;My TAA Pass&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler taaSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;TAA Pass&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        RenderTargetHandle cameraColorHandle;
</span></span><span style=display:flex><span>        RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>        RenderTargetHandle cameraDepthHandle;
</span></span><span style=display:flex><span>        RenderTargetIdentifier cameraDepthIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int screenSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> accumIndex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TAARendererFeature.TAASettings settings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TAARendererFeature.TAAData taaData;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Material taaMaterial;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> TemporalAntiAliasing taaComponent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2 lastFrame;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> TAARenderPass(TAARendererFeature.TAASettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
</span></span><span style=display:flex><span>            cameraColorHandle.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraColorIden = cameraColorHandle.Identifier();
</span></span><span style=display:flex><span>            cameraDepthHandle.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthIden = cameraDepthHandle.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(Shader taaShader, TAARendererFeature.TAAData taaData, TemporalAntiAliasing taaComponent)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.taaData = taaData;
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.lastFrame = taaComponent.lastFrame.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>            taaMaterial = <span style=color:#66d9ef>new</span> Material(taaShader);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.taaComponent = taaComponent;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTextureDescriptor descriptor = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            screenSize = <span style=color:#66d9ef>new</span> Vector2Int(descriptor.width, descriptor.height);
</span></span><span style=display:flex><span>            taaComponent.EnsureRT(descriptor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoTAA(CommandBuffer cmd, TemporalAntiAliasing taa, RenderTargetIdentifier colorid, <span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTexture accumRead = taa.GetRT(index);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> tempIndex = <span style=color:#ae81ff>1</span> - index;
</span></span><span style=display:flex><span>            RenderTexture accumWrite = taa.GetRT(tempIndex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TAAOffsets&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(taaData.offset.x, taaData.offset.y, taaData.lastOffset.x, taaData.lastOffset.y));
</span></span><span style=display:flex><span>            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TAALastFrame&#34;</span>, taaComponent.lastFrame.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            taaMaterial.SetVector(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>, <span style=color:#66d9ef>new</span> Vector4(screenSize.x, screenSize.y, <span style=color:#ae81ff>1f</span> / screenSize.x, <span style=color:#ae81ff>1f</span> / screenSize.y));
</span></span><span style=display:flex><span>            Matrix4x4 lastViewProj = taaData.lastProj * taaData.lastView;
</span></span><span style=display:flex><span>            taaMaterial.SetMatrix(<span style=color:#e6db74>&#34;_LastViewProj&#34;</span>, lastViewProj);
</span></span><span style=display:flex><span>            taaMaterial.SetTexture(<span style=color:#e6db74>&#34;_AccumTexture&#34;</span>, accumRead);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.Blit(colorid, accumWrite, taaMaterial);
</span></span><span style=display:flex><span>            cmd.Blit(accumWrite, colorid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, taaSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                DoTAA(cmd, taaComponent, cameraColorIden, accumIndex);
</span></span><span style=display:flex><span>                accumIndex = <span style=color:#ae81ff>1</span> - accumIndex;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cmd == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ArgumentNullException(<span style=color:#e6db74>&#34;cmd&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=taashadershader>TAAShader.shader<a hidden class=anchor aria-hidden=true href=#taashadershader>#</a></h3><p>å¤šæ¬¡é‡‡æ ·èƒ½å¤Ÿæ˜æ˜¾çš„å‰Šå¼±æ‹–å½±æ•ˆæœï¼Œ<code>tempMain = min(mainTexture, color_avg * 1.25);</code>è¿™ä¸€è¡Œèƒ½å¤Ÿåœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘é«˜å…‰çš„é—ªçƒï¼Œ<code>clip_aabb</code>å’Œ<code>k_feedback</code>ä¼¼ä¹ç”¨å¤„ä¸æ˜¯å¾ˆå¤§ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯å†™è¿›å»äº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;Hidden/Universal Render Pipeline/TAAShader&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Properties
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _MainTex(<span style=color:#e6db74>&#34;Main Texture&#34;</span>, <span style=color:#ae81ff>2</span>D) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;white&#34;</span>{}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HLSLINCLUDE
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/core.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    texture2D _MainTex;
</span></span><span style=display:flex><span>    texture2D _CameraDepthTexture;
</span></span><span style=display:flex><span>    texture2D _AccumTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SamplerState</span> sampler_LinearClamp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SamplerState</span> sampler_PointClamp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _TAAOffsets;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> _TAALastFrame;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> _LastViewProj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Attributes
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionOS   <span style=color:#f92672>:</span> POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Varyings
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionCS   <span style=color:#f92672>:</span> SV_POSITION;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> texcoord     <span style=color:#f92672>:</span> TEXCOORD0;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> clip_aabb(<span style=color:#66d9ef>float3</span> aabb_min, <span style=color:#66d9ef>float3</span> aabb_max, <span style=color:#66d9ef>float3</span> avg, <span style=color:#66d9ef>float3</span> input_texel)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> p_clip <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (aabb_max <span style=color:#f92672>+</span> aabb_min);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> e_clip <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (aabb_max <span style=color:#f92672>-</span> aabb_min) <span style=color:#f92672>+</span> FLT_EPS;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> v_clip <span style=color:#f92672>=</span> input_texel <span style=color:#f92672>-</span> p_clip;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> v_unit <span style=color:#f92672>=</span> v_clip <span style=color:#f92672>/</span> e_clip;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> a_unit <span style=color:#f92672>=</span> abs(v_unit);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ma_unit <span style=color:#f92672>=</span> max(a_unit.x, max(a_unit.y, a_unit.z));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ma_unit <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> p_clip <span style=color:#f92672>+</span> v_clip <span style=color:#f92672>/</span> ma_unit;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> input_texel;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Varyings TAAVert(Attributes input)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Varyings output <span style=color:#f92672>=</span> (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        VertexPositionInputs vertexPositionInputs <span style=color:#f92672>=</span> GetVertexPositionInputs(input.positionOS.xyz);
</span></span><span style=display:flex><span>        output.positionCS <span style=color:#f92672>=</span> vertexPositionInputs.positionCS;
</span></span><span style=display:flex><span>        output.texcoord <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> TAAFrag(Varyings input) <span style=color:#f92672>:</span> SV_TARGET
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> sampleUV <span style=color:#f92672>=</span> input.texcoord;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> currentOffset <span style=color:#f92672>=</span> _TAAOffsets.xy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> lastOffset <span style=color:#f92672>=</span> _TAAOffsets.zw;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> unJitteredUV <span style=color:#f92672>=</span> sampleUV <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> currentOffset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> mainTexture <span style=color:#f92672>=</span> _MainTex.SampleLevel(sampler_LinearClamp, unJitteredUV, <span style=color:#ae81ff>0</span>).rgb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> du <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(_TextureSize.z, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> dv <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0</span>, _TextureSize.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> ctl <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>-</span> dv <span style=color:#f92672>-</span> du).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> ctc <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>-</span> dv).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> ctr <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>-</span> dv <span style=color:#f92672>+</span> du).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cml <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>-</span> du).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cmc <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cmr <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>+</span> du).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cbl <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>+</span> dv <span style=color:#f92672>-</span> du).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cbc <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>+</span> dv).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> cbr <span style=color:#f92672>=</span> _MainTex.Sample(sampler_LinearClamp, unJitteredUV <span style=color:#f92672>+</span> dv <span style=color:#f92672>+</span> du).rgb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color_min <span style=color:#f92672>=</span> min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color_max <span style=color:#f92672>=</span> max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> color_avg <span style=color:#f92672>=</span> (ctl <span style=color:#f92672>+</span> ctc <span style=color:#f92672>+</span> ctr <span style=color:#f92672>+</span> cml <span style=color:#f92672>+</span> cmc <span style=color:#f92672>+</span> cmr <span style=color:#f92672>+</span> cbl <span style=color:#f92672>+</span> cbc <span style=color:#f92672>+</span> cbr) <span style=color:#f92672>/</span> <span style=color:#ae81ff>9.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> depthTexture <span style=color:#f92672>=</span> _CameraDepthTexture.SampleLevel(sampler_PointClamp, unJitteredUV, <span style=color:#ae81ff>0</span>).r;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> positionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(sampleUV <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, depthTexture, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#if UNITY_UV_STARTS_AT_TOP</span>
</span></span><span style=display:flex><span>        positionNDC.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>positionNDC.y;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> worldPos <span style=color:#f92672>=</span> mul(UNITY_MATRIX_I_VP, positionNDC);
</span></span><span style=display:flex><span>        worldPos <span style=color:#f92672>/=</span> worldPos.w;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> lastPositionCS <span style=color:#f92672>=</span> mul(_LastViewProj, worldPos);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float2</span> lastUV <span style=color:#f92672>=</span> lastPositionCS.xy <span style=color:#f92672>/</span> lastPositionCS.w;
</span></span><span style=display:flex><span>        lastUV <span style=color:#f92672>=</span> lastUV <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> accumTexture <span style=color:#f92672>=</span> _AccumTexture.SampleLevel(sampler_LinearClamp, lastUV, <span style=color:#ae81ff>0</span>).rgb;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> tempMain <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        accumTexture <span style=color:#f92672>=</span> clip_aabb(color_min, color_max, color_avg, accumTexture);
</span></span><span style=display:flex><span>        tempMain <span style=color:#f92672>=</span> min(mainTexture, color_avg <span style=color:#f92672>*</span> <span style=color:#ae81ff>1.25</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lum0 <span style=color:#f92672>=</span> Luminance(mainTexture);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lum1 <span style=color:#f92672>=</span> Luminance(accumTexture);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> unbiased_diff <span style=color:#f92672>=</span> abs(lum0 <span style=color:#f92672>-</span> lum1) <span style=color:#f92672>/</span> max(lum0, max(lum1, <span style=color:#ae81ff>0.2</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> unbiased_weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> unbiased_diff;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> unbiased_weight_sqr <span style=color:#f92672>=</span> unbiased_weight <span style=color:#f92672>*</span> unbiased_weight;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> k_feedback <span style=color:#f92672>=</span> lerp(_TAALastFrame.x, _TAALastFrame.y, unbiased_weight_sqr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float3</span> returnColor <span style=color:#f92672>=</span> lerp(tempMain, accumTexture, k_feedback);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (unJitteredUV.x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            returnColor <span style=color:#f92672>=</span> mainTexture;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(returnColor, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENDHLSL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SubShader
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ZTest Always Cull Back ZWrite Off
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Name <span style=color:#e6db74>&#34;TAA Pass&#34;</span>
</span></span><span style=display:flex><span>            HLSLPROGRAM
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma vertex TAAVert
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>#</span>pragma fragment TAAFrag
</span></span><span style=display:flex><span>            ENDHLSL
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ä¸€äº›æ€è€ƒ>ä¸€äº›æ€è€ƒ<a hidden class=anchor aria-hidden=true href=#ä¸€äº›æ€è€ƒ>#</a></h2><p>æ•ˆæœæ€»ä½“æ¥è¯´è¿˜æ˜¯ä¸é”™çš„ï¼Œä½†æ˜¯TAAShaderä¸­lerpå½“å‰æ¸²æŸ“ç”»é¢å’ŒAccumTextureçš„ç®—æ³•åº”è¯¥æœ‰å¾…æé«˜ï¼Œç›®å‰ç‰¹åˆ«ç»†é•¿çš„äºšåƒç´ ç‰¹å¾ï¼ˆå¦‚å‘ˆçº¿çŠ¶çš„é«˜å…‰ï¼‰ä¼šæœ‰é”¯é½¿çˆ¬è¡Œçš„æ„Ÿè§‰ï¼Œç”»é¢ä¸å¤Ÿç¨³å®šï¼Œç‰¹åˆ«å°çš„ç»†èŠ‚ä¼šæœ‰ä¸€é—ªä¸€é—ªçš„æ„Ÿè§‰ï¼Œåº”è¯¥è¿˜èƒ½å†ä¼˜åŒ–ä¼˜åŒ–ã€‚PlayDeadçš„æºä»£ç æœ‰ç‚¹çœ‹ä¸ä¸‹å»ã€‚ã€‚ã€‚å°±åƒµåœ¨è¿™é‡Œäº†ï¼Œå¤§æ¦‚æœ‰ä¸ª80åˆ†å§ã€‚</p><p>æˆ‘ä¹Ÿæƒ³å¤šæ”¾å›¾æ¥ç€ï¼Œä½†æ˜¯å®åœ¨æ²¡å•¥å¥½æ”¾çš„ã€‚ã€‚ã€‚å¯¼è‡´åšå®¢è¶Šæ¥è¶Šæ¯ç‡¥äº†ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/anti-aliasing/>Anti-Aliasing</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/accelerate-gaussian-blur-using-group-shared-memory/><span class=title>Â« Prev</span><br><span>ä½¿ç”¨Group Shared MemoryåŠ é€Ÿé«˜æ–¯æ¨¡ç³Š</span>
</a><a class=next href=https://zznewclear13.github.io/posts/unity-gpu-skinning-with-animator-controller/><span class=title>Next Â»</span><br><span>æ”¯æŒAnimator Controllerçš„å®æ—¶GPUè’™çš®</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>