<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unity的高质量的Bloom效果 | ZZNEWCLEAR13</title><meta name=keywords content="Bloom,Post-Process"><meta name=description content="使用Dual Kawase Blur制作高质量的Bloom效果."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-high-quality-bloom/><link crossorigin=anonymous href=/assets/css/stylesheet.min.50ec5873d43aafdb2c832cfa897c60d6e146a48ba3bacc322156221e9661fdc6.css integrity="sha256-UOxYc9Q6r9ssgyz6iXxg1uFGpIujuswyIVYiHpZh/cY=" rel="preload stylesheet" as=style><link rel=preload href=/images/address.png as=image><link rel=preload href=/apple-touch-icon.png as=image><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Unity的高质量的Bloom效果"><meta property="og:description" content="使用Dual Kawase Blur制作高质量的Bloom效果."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-high-quality-bloom/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-high-quality-bloom/posts/images/HighQualityBloom.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-22T12:00:00+08:00"><meta property="article:modified_time" content="2023-07-22T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13 - Should I say something cool here?"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-high-quality-bloom/posts/images/HighQualityBloom.png"><meta name=twitter:title content="Unity的高质量的Bloom效果"><meta name=twitter:description content="使用Dual Kawase Blur制作高质量的Bloom效果."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Unity的高质量的Bloom效果","item":"https://zznewclear13.github.io/posts/unity-high-quality-bloom/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unity的高质量的Bloom效果","name":"Unity的高质量的Bloom效果","description":"使用Dual Kawase Blur制作高质量的Bloom效果.","keywords":["Bloom","Post-Process"],"articleBody":"Bloom辉光效果 一直都想做一个Bloom效果，Bloom是一个很简单的效果，几乎所有介绍后处理的教程里都会提到Bloom效果的制作，但是Bloom又是一个不那么简单的效果，大部分教程制作出来的Bloom看上去都不太好看。\n想要做好Bloom，首先得认识到什么是Bloom效果。Bloom是由于透镜不能完美地让光线聚焦与同一点而导致图像上的高亮区域的颜色向周围溢出的效果，和体积雾这样的由于多次散射和折射形成的溢出效果在原理上就不相同。在计算机图形学里往往使用多次模糊的方式来表现这种效果。\n而在讨论什么是好的Bloom之前，我们先来看看差的Bloom的效果。Matthew Gallant在他的文章Bloom Disasters中就给出了很多当时的极糟糕的Bloom效果的例子。可以看到Bloom很重要的一点是，Bloom之前的画面必须要是HDR的画面，如果整个画面被限制在01之间，那么白色的T恤和特别亮以至于看上去是白色的太阳带来的Bloom效果就会相同。在LearnOpenGL上有那么一篇文章，其中说到，为了模拟我们眼睛的工作原理，我们不对颜色进行阈值限制，而是直接对HDR画面进行模糊再和原HDR画面进行插值。我认为这是一种十分错误的方式。最合理的方式应当是，画面上的每个颜色确实会向周围溢出自己的颜色，但是更亮的颜色的溢出半径会更大，对于较暗的颜色，由于溢出半径小于半个像素宽，在最后的画面中就看不到颜色的溢出了。但是根据明度来控制溢出的半径是一件很复杂的事情（这和景深的原理是一样的，所以我到现在都没有掌握一个很好的景深的算法），因此我们在计算的时候通过仅模糊超出阈值的颜色来模拟这种效果。模糊半径也是一个决定Bloom质量的关键要素，如果模糊的半径比较小，看上去就像高光套了一个稍弱的圈一样，不够美观。\nJorge Jimenez在2014年Siggraph多的Advances in Real-Time Rendering课程上介绍了他为使命召唤现代战争所做的次世代后处理效果。他的PPT里介绍了使命召唤现代战争中运动模糊、散景、次表面散射、Bloom和阴影采样的做法，十分值得一看。本文在整体的算法上就使用了他介绍的方法，而采样则使用了Dual Kawase Blur的算法，可以看我之前的文章。\nBloom的算法 主流的Bloom算法都会使用一个阈值，第一个Pass提取出大于这个阈值的颜色（使用减法，这样能够和小于阈值的颜色形成自然的过渡），然后进行一系列的降采样升采样以减少采样的次数，最后将之前所有的升采样的模糊结果（就相当于是Mip的每一级）叠加到一开始的颜色上。为了减少最后一步采样所有的Mip等级带来的消耗，根据Jorge Jimenez的做法，我们会在每一步升采样时叠加当前Mip的颜色。但是最后叠加不是一个很好的处理方法，由于叠加了各个Mip的颜色，会导致原来高光的区域的亮度会被提高到原来的两倍甚至更多，不过我们之后的Tone Mapping能够一定程度上缓解这个问题。然后是对微小的高亮物体的处理，Jorge Jimenez使用了1/(1 + Luma)的方式进行加权处理，不过如果我们将Bloom移动到TAA之后，这个问题能够很好的解决掉。至于模糊，在我之前那么多文章的铺垫下，也就不是什么难点了。\n我自己在实现的时候，会在最后一步叠加Mip到最一开始的图像时，将模糊后的颜色除以所有的降采样次数，这样能够稍微弥补一下多个Mip带来的亮度剧烈增加的问题。事实上我也想过将因为阈值而丢失的亮度储存在透明通道里，和颜色一起参与模糊，在最后的时候加回之前丢失的亮度，最后和原始颜色线性插值，不过似乎不那么好做。\n这里可以对比一下Unity自带的Bloom和我的Bloom之间的效果差异。Unity第一个Pass预过滤会进行13次采样，之后每一次降采样分成横竖两个方向，横向9次采样，竖向5次采样，升采样则是在2次采样中线性插值。我的则是每次降采样进行5次采样，每次升采样进行8+1次采样，不需要分横竖采样。下图上边是Unity自带的Bloom，下边是我的Bloom，最后均使用Aces Tonemapping，场景里的大立方体的大小是相邻小立方体的1.5倍，而小立方体的亮度是相邻大立方体的1.5倍。我尽量地将参数调的差不多，Unity一共22个Draw最高Mip为7，我的一共17个Draw最高Mip为8，可以观察到Unity的会有稍微明显一点的Banding，中间亮度的中间大小的物体带来的Bloom比我的稍微大一些。\nUnity Default Bloom\n\rMy High Quality Bloom\n\rBloom的具体实现 HQBloomComputeShader.compute 这里有四个Kernel，HQBloomWeightedDownsample用于第一次降采样时减去阈值并加权进行模糊，HQBloomDownsample是和Dual Kawase Blur一样的降采样的模糊，HQBloomAdditiveUpsample是在Dual Kawase Blur的升采样的基础上和低一级的Mip叠加，HQBloomComposite则是将最低一级Mip和原始颜色进行混合。\n#pragma kernel HQBloomDownsample\r#pragma kernel HQBloomWeightedDownsample\r#pragma kernel HQBloomAdditiveUpsample\r#pragma kernel HQBloomComposite\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\rTexture2D _SourceTexture;\rTexture2D _ColorTexture;\rRWTexture2D _RW_TargetTexture;\rSamplerState sampler_LinearClamp;\rfloat4 _SourceSize;\rfloat4 _TargetSize;\rfloat _Threshold;\rfloat _InvDownsampleCount;\rfloat _BloomIntensity;\rfloat3 applyThreshold(float3 color, out float luma)\r{\rluma = Luminance(color);\rreturn color * max(0.0f, luma - _Threshold);\r}\rfloat getLumaWeight(float luma)\r{\rreturn rcp(1.0f + luma);\r}\rfloat getLumaWeight(float3 color)\r{\rfloat luma = Luminance(color);\rreturn rcp(1.0f + luma);\r}\rfloat3 sampleSource(float2 center, float2 offset)\r{\rreturn _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset, 0.0f).rgb;\r}\r[numthreads(8, 8, 1)]\rvoid HQBloomDownsample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 halfPixel = 0.5f * _TargetSize.zw;\rfloat3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f));\rfloat3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f;\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid HQBloomWeightedDownsample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 halfPixel = 0.5f * _TargetSize.zw;\rfloat lumac, lumatl, lumatr, lumabl, lumabr;\rfloat3 c = applyThreshold(sampleSource(uv, float2(0.0f, 0.0f)), lumac);\rfloat3 tl = applyThreshold(sampleSource(uv, halfPixel * float2(-1.0f, +1.0f)), lumatl);\rfloat3 tr = applyThreshold(sampleSource(uv, halfPixel * float2(+1.0f, +1.0f)), lumatr);\rfloat3 bl = applyThreshold(sampleSource(uv, halfPixel * float2(-1.0f, -1.0f)), lumabl);\rfloat3 br = applyThreshold(sampleSource(uv, halfPixel * float2(+1.0f, -1.0f)), lumabr);\rfloat3 wc = getLumaWeight(lumac);\rfloat3 wtl = getLumaWeight(lumatl);\rfloat3 wtr = getLumaWeight(lumatr);\rfloat3 wbl = getLumaWeight(lumabl);\rfloat3 wbr = getLumaWeight(lumabr);\rfloat3 colorSum = tl * wtl + tr * wtr + bl * wbl + br * wbr + c * wc * 4.0f;\rfloat3 weightSum = wtl + wtr + wbl + wbr + wc * 4.0f;\rfloat3 color = colorSum / weightSum;\r_RW_TargetTexture[id.xy] = float4(color, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid HQBloomAdditiveUpsample(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 onePixel = 1.0f * _TargetSize.zw;\r// float3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));\rfloat3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));\rfloat3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));\rfloat3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));\rfloat3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));\rfloat3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\rfloat3 prevTarget = _RW_TargetTexture.Load(uint3(id.xy, 0));\r_RW_TargetTexture[id.xy] = float4(color + prevTarget, 1.0f);\r}\r[numthreads(8, 8, 1)]\rvoid HQBloomComposite(uint3 id : SV_DispatchThreadID)\r{\rfloat2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;\rfloat2 onePixel = 1.0f * _TargetSize.zw;\r// float3 c = sampleSource(uv, float2(0.0f, 0.0f));\rfloat3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));\rfloat3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));\rfloat3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));\rfloat3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));\rfloat3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));\rfloat3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));\rfloat3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));\rfloat3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));\rfloat3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\rfloat3 colorTexture = _ColorTexture.Load(uint3(id.xy, 0));\rfloat3 bloomColor = colorTexture + color * _BloomIntensity * _InvDownsampleCount;\r_RW_TargetTexture[id.xy] = float4(bloomColor, 1.0f);\r}\rHQBloom.cs 没啥好说的。\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/HQ Bloom\", typeof(UniversalRenderPipeline))] public sealed class HQBloom : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public ClampedFloatParameter intensity = new ClampedFloatParameter(1.0f, 0.0f, 1.0f); public ClampedFloatParameter threshold = new ClampedFloatParameter(0.9f, 0.0f, 5.0f); public ClampedIntParameter downsampleCount = new ClampedIntParameter(7, 3, 10); public bool IsActive() { return isEnabled.value \u0026\u0026 intensity.value  0.0f; } public bool IsTileCompatible() { return false; } } } HQBloomRenderPass.cs 这个脚本相较于Dual Kawase Blur来说要稍微简单一点，因为Bloom效果往往只会调整其强弱，而不会调整半径，不需要在两个降采样之间再做线性插值了。\nusing System.Collections.Generic; namespace UnityEngine.Rendering.Universal { public class HQBloomRenderPass : ScriptableRenderPass { static readonly string passName = \"HQ Bloom Render Pass\"; private HQBloomRendererFeature.HQBloomSettings settings; private HQBloom hqBloom; private ComputeShader computeShader; static readonly string cameraColorTextureName = \"_CameraColorAttachmentA\"; static readonly int cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName); RenderTargetIdentifier cameraColorIden; private Vector2Int textureSize; private RenderTextureDescriptor desc; public HQBloomRenderPass(HQBloomRendererFeature.HQBloomSettings settings) { profilingSampler = new ProfilingSampler(passName); this.settings = settings; renderPassEvent = settings.renderPassEvent; computeShader = settings.computeShader; cameraColorIden = new RenderTargetIdentifier(cameraColorTextureID); } public void Setup(HQBloom hqBloom) { this.hqBloom = hqBloom; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { textureSize = new Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height); desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.msaaSamples = 1; desc.depthBufferBits = 0; } private Vector4 GetTextureSizeParams(Vector2Int size) { return new Vector4(size.x, size.y, 1.0f / size.x, 1.0f / size.y); } private void DoHQBloomDownsample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, Vector2Int targetSize, bool firstDownsample, ComputeShader computeShader) { if (!computeShader) return; string kernelName = firstDownsample ? \"HQBloomWeightedDownsample\" : \"HQBloomDownsample\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeVectorParam(computeShader, \"_TargetSize\", GetTextureSizeParams(targetSize)); cmd.SetComputeFloatParam(computeShader, \"_Threshold\", hqBloom.threshold.value); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)targetSize.x / x), Mathf.CeilToInt((float)targetSize.y / y), 1); } private void DoHQBloomAdditiveUpsample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid, Vector2Int sourceSize, Vector2Int targetSize, ComputeShader computeShader) { if (!computeShader) return; string kernelName = \"HQBloomAdditiveUpsample\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeVectorParam(computeShader, \"_TargetSize\", GetTextureSizeParams(targetSize)); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)targetSize.x / x), Mathf.CeilToInt((float)targetSize.y / y), 1); } private void DoHQloomComposite(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier colorid, RenderTargetIdentifier targetid, Vector2Int sourceSize, Vector2Int targetSize, ComputeShader computeShader) { if (!computeShader) return; string kernelName = \"HQBloomComposite\"; int kernelID = computeShader.FindKernel(kernelName); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, kernelID, \"_SourceTexture\", sourceid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_ColorTexture\", colorid); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTexture\", targetid); cmd.SetComputeVectorParam(computeShader, \"_SourceSize\", GetTextureSizeParams(sourceSize)); cmd.SetComputeVectorParam(computeShader, \"_TargetSize\", GetTextureSizeParams(targetSize)); cmd.SetComputeFloatParam(computeShader, \"_InvDownsampleCount\", 1.0f / hqBloom.downsampleCount.value); cmd.SetComputeFloatParam(computeShader, \"_BloomIntensity\", hqBloom.intensity.value); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)targetSize.x / x), Mathf.CeilToInt((float)targetSize.y / y), 1); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(); using (new ProfilingScope(cmd, profilingSampler)) { Listint rtIDs = new Listint(); List rtSizes = new List(); RenderTextureDescriptor tempDesc = desc; string bloomRT = \"_BloomRT\"; int bloomRTID = Shader.PropertyToID(bloomRT); cmd.GetTemporaryRT(bloomRTID, tempDesc); rtIDs.Add(bloomRTID); rtSizes.Add(textureSize); Vector2Int lastSize = textureSize; int lastID = cameraColorTextureID; int downsampleCount = hqBloom.downsampleCount.value; for (int i = 0; i string rtName = \"_BloomRT\" + i.ToString(); int rtID = Shader.PropertyToID(rtName); Vector2Int rtSize = new Vector2Int((lastSize.x + 1) / 2, (lastSize.y + 1) / 2); tempDesc.width = rtSize.x; tempDesc.height = rtSize.y; cmd.GetTemporaryRT(rtID, tempDesc); rtIDs.Add(rtID); rtSizes.Add(rtSize); DoHQBloomDownsample(cmd, lastID, rtID, lastSize, rtSize, i == 0, computeShader); lastID = rtID; lastSize = rtSize; } for (int i = downsampleCount; i = 1; i--) { int sourceID = rtIDs[i]; Vector2Int sourceSize = rtSizes[i]; int targetID = rtIDs[i-1]; Vector2Int targetSize = rtSizes[i-1]; if(i == 1) { DoHQloomComposite(cmd, sourceID, cameraColorIden, targetID, sourceSize, targetSize, computeShader); cmd.Blit(targetID, cameraColorIden); cmd.ReleaseTemporaryRT(targetID); } else { DoHQBloomAdditiveUpsample(cmd, sourceID, targetID, sourceSize, targetSize, computeShader); } cmd.ReleaseTemporaryRT(sourceID); } } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } } } HQBloomRendererFeature.cs 没啥好说的。\nnamespace UnityEngine.Rendering.Universal { public class HQBloomRendererFeature : ScriptableRendererFeature { [System.Serializable] public class HQBloomSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader computeShader; } public HQBloomSettings settings = new HQBloomSettings(); private HQBloomRenderPass hqBloomRenderPass; public override void Create() { hqBloomRenderPass = new HQBloomRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { HQBloom HQBloom = VolumeManager.instance.stack.GetComponent(); if (HQBloom != null \u0026\u0026 HQBloom.IsActive()) { hqBloomRenderPass.Setup(HQBloom); renderer.EnqueuePass(hqBloomRenderPass); } } } } ","wordCount":"1256","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-high-quality-bloom/posts/images/HighQualityBloom.png","datePublished":"2023-07-22T12:00:00+08:00","dateModified":"2023-07-22T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-high-quality-bloom/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>ZZNEWCLEAR13</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class=post-title>Unity的高质量的Bloom效果</h1><div class=post-description>使用Dual Kawase Blur制作高质量的Bloom效果.</div><div class=post-meta>July 22, 2023&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-high-quality-bloom.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=lazy src=https://zznewclear13.github.io/posts/images/HighQualityBloom.png alt="High Quality Bloom Cover"><p>High Quality Bloom Result</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Unity的高质量的Bloom效果</div></summary><div class=inner><ul><li><a href=#bloom%e8%be%89%e5%85%89%e6%95%88%e6%9e%9c aria-label=Bloom辉光效果>Bloom辉光效果</a></li><li><a href=#bloom%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=Bloom的算法>Bloom的算法</a></li><li><a href=#bloom%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0 aria-label=Bloom的具体实现>Bloom的具体实现</a><ul><li><a href=#hqbloomcomputeshadercompute aria-label=HQBloomComputeShader.compute>HQBloomComputeShader.compute</a></li><li><a href=#hqbloomcs aria-label=HQBloom.cs>HQBloom.cs</a></li><li><a href=#hqbloomrenderpasscs aria-label=HQBloomRenderPass.cs>HQBloomRenderPass.cs</a></li><li><a href=#hqbloomrendererfeaturecs aria-label=HQBloomRendererFeature.cs>HQBloomRendererFeature.cs</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=bloom辉光效果>Bloom辉光效果<a hidden class=anchor aria-hidden=true href=#bloom辉光效果>#</a></h2><p>一直都想做一个Bloom效果，Bloom是一个很简单的效果，几乎所有介绍后处理的教程里都会提到Bloom效果的制作，但是Bloom又是一个不那么简单的效果，大部分教程制作出来的Bloom看上去都不太好看。</p><p>想要做好Bloom，首先得认识到什么是Bloom效果。Bloom是由于透镜不能完美地让光线聚焦与同一点而导致图像上的高亮区域的颜色向周围溢出的效果，和体积雾这样的由于多次散射和折射形成的溢出效果在原理上就不相同。在计算机图形学里往往使用多次模糊的方式来表现这种效果。</p><p>而在讨论什么是好的Bloom之前，我们先来看看差的Bloom的效果。Matthew Gallant在他的文章<a href=http://gangles.ca/2008/07/18/bloom-disasters/>Bloom Disasters</a>中就给出了很多当时的极糟糕的Bloom效果的例子。可以看到Bloom很重要的一点是，Bloom之前的画面必须要是HDR的画面，如果整个画面被限制在01之间，那么白色的T恤和特别亮以至于看上去是白色的太阳带来的Bloom效果就会相同。在LearnOpenGL上有那么一篇<a href=https://learnopengl.com/Guest-Articles/2022/Phys.-Based-Bloom>文章</a>，其中说到，为了模拟我们眼睛的工作原理，我们不对颜色进行阈值限制，而是直接对HDR画面进行模糊再和原HDR画面进行插值。我认为这是一种十分错误的方式。最合理的方式应当是，画面上的每个颜色确实会向周围溢出自己的颜色，但是更亮的颜色的溢出半径会更大，对于较暗的颜色，由于溢出半径小于半个像素宽，在最后的画面中就看不到颜色的溢出了。但是根据明度来控制溢出的半径是一件很复杂的事情（这和景深的原理是一样的，所以我到现在都没有掌握一个很好的景深的算法），因此我们在计算的时候通过仅模糊超出阈值的颜色来模拟这种效果。模糊半径也是一个决定Bloom质量的关键要素，如果模糊的半径比较小，看上去就像高光套了一个稍弱的圈一样，不够美观。</p><p>Jorge Jimenez在2014年Siggraph多的Advances in Real-Time Rendering课程上介绍了他为使命召唤现代战争所做的<a href=http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare>次世代后处理效果</a>。他的PPT里介绍了使命召唤现代战争中运动模糊、散景、次表面散射、Bloom和阴影采样的做法，十分值得一看。本文在整体的算法上就使用了他介绍的方法，而采样则使用了Dual Kawase Blur的算法，可以看我之前的<a href=../almost-continuous-dual-kawase-blur/>文章</a>。</p><h2 id=bloom的算法>Bloom的算法<a hidden class=anchor aria-hidden=true href=#bloom的算法>#</a></h2><p>主流的Bloom算法都会使用一个阈值，第一个Pass提取出大于这个阈值的颜色（使用减法，这样能够和小于阈值的颜色形成自然的过渡），然后进行一系列的降采样升采样以减少采样的次数，最后将之前所有的升采样的模糊结果（就相当于是Mip的每一级）叠加到一开始的颜色上。为了减少最后一步采样所有的Mip等级带来的消耗，根据Jorge Jimenez的做法，我们会在每一步升采样时叠加当前Mip的颜色。但是最后叠加不是一个很好的处理方法，由于叠加了各个Mip的颜色，会导致原来高光的区域的亮度会被提高到原来的两倍甚至更多，不过我们之后的Tone Mapping能够一定程度上缓解这个问题。然后是对微小的高亮物体的处理，Jorge Jimenez使用了<code>1/(1 + Luma)</code>的方式进行加权处理，不过如果我们将Bloom移动到TAA之后，这个问题能够很好的解决掉。至于模糊，在我之前那么多文章的铺垫下，也就不是什么难点了。</p><p>我自己在实现的时候，会在最后一步叠加Mip到最一开始的图像时，将模糊后的颜色除以所有的降采样次数，这样能够稍微弥补一下多个Mip带来的亮度剧烈增加的问题。事实上我也想过将因为阈值而丢失的亮度储存在透明通道里，和颜色一起参与模糊，在最后的时候加回之前丢失的亮度，最后和原始颜色线性插值，不过似乎不那么好做。</p><p>这里可以对比一下Unity自带的Bloom和我的Bloom之间的效果差异。Unity第一个Pass预过滤会进行13次采样，之后每一次降采样分成横竖两个方向，横向9次采样，竖向5次采样，升采样则是在2次采样中线性插值。我的则是每次降采样进行5次采样，每次升采样进行8+1次采样，不需要分横竖采样。下图上边是Unity自带的Bloom，下边是我的Bloom，最后均使用Aces Tonemapping，场景里的大立方体的大小是相邻小立方体的1.5倍，而小立方体的亮度是相邻大立方体的1.5倍。我尽量地将参数调的差不多，Unity一共22个Draw最高Mip为7，我的一共17个Draw最高Mip为8，可以观察到Unity的会有稍微明显一点的Banding，中间亮度的中间大小的物体带来的Bloom比我的稍微大一些。</p><figure class=entry-cover><img loading=lazy src=../images/UnityDefaultBloom.png alt="Unity Default Bloom"><p>Unity Default Bloom</p></figure><figure class=entry-cover><img loading=lazy src=../images/HighQualityBloom.png alt="My High Quality Bloom"><p>My High Quality Bloom</p></figure><h2 id=bloom的具体实现>Bloom的具体实现<a hidden class=anchor aria-hidden=true href=#bloom的具体实现>#</a></h2><h3 id=hqbloomcomputeshadercompute>HQBloomComputeShader.compute<a hidden class=anchor aria-hidden=true href=#hqbloomcomputeshadercompute>#</a></h3><p>这里有四个Kernel，<code>HQBloomWeightedDownsample</code>用于第一次降采样时减去阈值并加权进行模糊，<code>HQBloomDownsample</code>是和Dual Kawase Blur一样的降采样的模糊，<code>HQBloomAdditiveUpsample</code>是在Dual Kawase Blur的升采样的基础上和低一级的Mip叠加，<code>HQBloomComposite</code>则是将最低一级Mip和原始颜色进行混合。</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel HQBloomDownsample
#pragma kernel HQBloomWeightedDownsample
#pragma kernel HQBloomAdditiveUpsample
#pragma kernel HQBloomComposite

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;

Texture2D&lt;float4&gt; _SourceTexture;
Texture2D&lt;float4&gt; _ColorTexture;
RWTexture2D&lt;float4&gt; _RW_TargetTexture;
SamplerState sampler_LinearClamp;
float4 _SourceSize;
float4 _TargetSize;
float _Threshold;
float _InvDownsampleCount;
float _BloomIntensity;

float3 applyThreshold(float3 color, out float luma)
{
	luma = Luminance(color);
	return color * max(0.0f, luma - _Threshold);
}

float getLumaWeight(float luma)
{
	return rcp(1.0f + luma);
}

float getLumaWeight(float3 color)
{
	float luma = Luminance(color);
	return rcp(1.0f + luma);
}

float3 sampleSource(float2 center, float2 offset)
{
    return _SourceTexture.SampleLevel(sampler_LinearClamp, center + offset, 0.0f).rgb;
}

[numthreads(8, 8, 1)]
void HQBloomDownsample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 halfPixel = 0.5f * _TargetSize.zw;

	float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 tl = sampleSource(uv, halfPixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, halfPixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, halfPixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, halfPixel * float2(+1.0f, -1.0f));

	float3 color = (tl + tr + bl + br + c * 4.0f) / 8.0f;
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void HQBloomWeightedDownsample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 halfPixel = 0.5f * _TargetSize.zw;

	float lumac, lumatl, lumatr, lumabl, lumabr;
	float3 c = applyThreshold(sampleSource(uv, float2(0.0f, 0.0f)), lumac);
	float3 tl = applyThreshold(sampleSource(uv, halfPixel * float2(-1.0f, +1.0f)), lumatl);
	float3 tr = applyThreshold(sampleSource(uv, halfPixel * float2(+1.0f, +1.0f)), lumatr);
	float3 bl = applyThreshold(sampleSource(uv, halfPixel * float2(-1.0f, -1.0f)), lumabl);
	float3 br = applyThreshold(sampleSource(uv, halfPixel * float2(+1.0f, -1.0f)), lumabr);

	float3 wc = getLumaWeight(lumac);
	float3 wtl = getLumaWeight(lumatl);
	float3 wtr = getLumaWeight(lumatr);
	float3 wbl = getLumaWeight(lumabl);
	float3 wbr = getLumaWeight(lumabr);

	float3 colorSum = tl * wtl + tr * wtr + bl * wbl + br * wbr + c * wc * 4.0f;
	float3 weightSum = wtl + wtr + wbl + wbr + wc * 4.0f;

	float3 color = colorSum / weightSum;
	_RW_TargetTexture[id.xy] = float4(color, 1.0f);
}

[numthreads(8, 8, 1)]
void HQBloomAdditiveUpsample(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 onePixel = 1.0f * _TargetSize.zw;

	// float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));
	float3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));
	float3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));
	float3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));
	float3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));

	float3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;
	float3 prevTarget = _RW_TargetTexture.Load(uint3(id.xy, 0));

	_RW_TargetTexture[id.xy] = float4(color + prevTarget, 1.0f);
}

[numthreads(8, 8, 1)]
void HQBloomComposite(uint3 id : SV_DispatchThreadID)
{
	float2 uv = (float2(id.xy) + 0.5f) * _TargetSize.zw;
	float2 onePixel = 1.0f * _TargetSize.zw;

	// float3 c = sampleSource(uv, float2(0.0f, 0.0f));
	float3 t2 = sampleSource(uv, onePixel * float2(+0.0f, +2.0f));
	float3 b2 = sampleSource(uv, onePixel * float2(+0.0f, -2.0f));
	float3 l2 = sampleSource(uv, onePixel * float2(-2.0f, +0.0f));
	float3 r2 = sampleSource(uv, onePixel * float2(+2.0f, +0.0f));
	float3 tl = sampleSource(uv, onePixel * float2(-1.0f, +1.0f));
	float3 tr = sampleSource(uv, onePixel * float2(+1.0f, +1.0f));
	float3 bl = sampleSource(uv, onePixel * float2(-1.0f, -1.0f));
	float3 br = sampleSource(uv, onePixel * float2(+1.0f, -1.0f));

	float3 color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;
	float3 colorTexture = _ColorTexture.Load(uint3(id.xy, 0));

	float3 bloomColor = colorTexture + color * _BloomIntensity * _InvDownsampleCount;
	_RW_TargetTexture[id.xy] = float4(bloomColor, 1.0f);
}
</code></pre><h3 id=hqbloomcs>HQBloom.cs<a hidden class=anchor aria-hidden=true href=#hqbloomcs>#</a></h3><p>没啥好说的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/HQ Bloom&#34;, typeof(UniversalRenderPipeline))]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HQBloom</span> : VolumeComponent, IPostProcessComponent
    {
        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
        <span style=color:#66d9ef>public</span> ClampedFloatParameter threshold = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.9f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>5.0f</span>);
        <span style=color:#66d9ef>public</span> ClampedIntParameter downsampleCount = <span style=color:#66d9ef>new</span> ClampedIntParameter(<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>10</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
        {
            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span> &amp;&amp; intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        }
    }
}
</code></pre></div><h3 id=hqbloomrenderpasscs>HQBloomRenderPass.cs<a hidden class=anchor aria-hidden=true href=#hqbloomrenderpasscs>#</a></h3><p>这个脚本相较于Dual Kawase Blur来说要稍微简单一点，因为Bloom效果往往只会调整其强弱，而不会调整半径，不需要在两个降采样之间再做线性插值了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System.Collections.Generic;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HQBloomRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;HQ Bloom Render Pass&#34;</span>;

        <span style=color:#66d9ef>private</span> HQBloomRendererFeature.HQBloomSettings settings;
        <span style=color:#66d9ef>private</span> HQBloom hqBloom;
        <span style=color:#66d9ef>private</span> ComputeShader computeShader;

        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> cameraColorTextureName = <span style=color:#e6db74>&#34;_CameraColorAttachmentA&#34;</span>;
        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> cameraColorTextureID = Shader.PropertyToID(cameraColorTextureName);
        RenderTargetIdentifier cameraColorIden;

        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
        <span style=color:#66d9ef>private</span> RenderTextureDescriptor desc;

        <span style=color:#66d9ef>public</span> HQBloomRenderPass(HQBloomRendererFeature.HQBloomSettings settings)
        {
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);

            <span style=color:#66d9ef>this</span>.settings = settings;
            renderPassEvent = settings.renderPassEvent;
            computeShader = settings.computeShader;

            cameraColorIden = <span style=color:#66d9ef>new</span> RenderTargetIdentifier(cameraColorTextureID);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(HQBloom hqBloom)
        {
            <span style=color:#66d9ef>this</span>.hqBloom = hqBloom;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(cameraTextureDescriptor.width, cameraTextureDescriptor.height);
            desc = cameraTextureDescriptor;
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
        }

        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParams(Vector2Int size)
        {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(size.x, size.y, <span style=color:#ae81ff>1.0f</span> / size.x, <span style=color:#ae81ff>1.0f</span> / size.y);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoHQBloomDownsample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
                                        Vector2Int sourceSize, Vector2Int targetSize,
                                        <span style=color:#66d9ef>bool</span> firstDownsample, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = firstDownsample ? <span style=color:#e6db74>&#34;HQBloomWeightedDownsample&#34;</span> : <span style=color:#e6db74>&#34;HQBloomDownsample&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TargetSize&#34;</span>, GetTextureSizeParams(targetSize));
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Threshold&#34;</span>, hqBloom.threshold.<span style=color:#66d9ef>value</span>);
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoHQBloomAdditiveUpsample(CommandBuffer cmd, RenderTargetIdentifier sourceid, RenderTargetIdentifier targetid,
                                        Vector2Int sourceSize, Vector2Int targetSize,
                                        ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = <span style=color:#e6db74>&#34;HQBloomAdditiveUpsample&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TargetSize&#34;</span>, GetTextureSizeParams(targetSize));
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoHQloomComposite(CommandBuffer cmd,
                                        RenderTargetIdentifier sourceid, RenderTargetIdentifier colorid, RenderTargetIdentifier targetid,
                                        Vector2Int sourceSize, Vector2Int targetSize,
                                        ComputeShader computeShader)
        {
            <span style=color:#66d9ef>if</span> (!computeShader) <span style=color:#66d9ef>return</span>;
            <span style=color:#66d9ef>string</span> kernelName = <span style=color:#e6db74>&#34;HQBloomComposite&#34;</span>;
            <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(kernelName);
            computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_SourceTexture&#34;</span>, sourceid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_ColorTexture&#34;</span>, colorid);
            cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTexture&#34;</span>, targetid);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_SourceSize&#34;</span>, GetTextureSizeParams(sourceSize));
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TargetSize&#34;</span>, GetTextureSizeParams(targetSize));
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_InvDownsampleCount&#34;</span>, <span style=color:#ae81ff>1.0f</span> / hqBloom.downsampleCount.<span style=color:#66d9ef>value</span>);
            cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_BloomIntensity&#34;</span>, hqBloom.intensity.<span style=color:#66d9ef>value</span>);
            cmd.DispatchCompute(computeShader, kernelID,
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.x / x),
                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)targetSize.y / y),
                                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get();
            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
            {
                List&lt;<span style=color:#66d9ef>int</span>&gt; rtIDs = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>int</span>&gt;();
                List&lt;Vector2Int&gt; rtSizes = <span style=color:#66d9ef>new</span> List&lt;Vector2Int&gt;();

                RenderTextureDescriptor tempDesc = desc;
                <span style=color:#66d9ef>string</span> bloomRT = <span style=color:#e6db74>&#34;_BloomRT&#34;</span>;
                <span style=color:#66d9ef>int</span> bloomRTID = Shader.PropertyToID(bloomRT);
                cmd.GetTemporaryRT(bloomRTID, tempDesc);

                rtIDs.Add(bloomRTID);
                rtSizes.Add(textureSize);

                Vector2Int lastSize = textureSize;
                <span style=color:#66d9ef>int</span> lastID = cameraColorTextureID;
                <span style=color:#66d9ef>int</span> downsampleCount = hqBloom.downsampleCount.<span style=color:#66d9ef>value</span>;
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; downsampleCount; i++)
                {
                    <span style=color:#66d9ef>string</span> rtName = <span style=color:#e6db74>&#34;_BloomRT&#34;</span> + i.ToString();
                    <span style=color:#66d9ef>int</span> rtID = Shader.PropertyToID(rtName);
                    Vector2Int rtSize = <span style=color:#66d9ef>new</span> Vector2Int((lastSize.x + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>, (lastSize.y + <span style=color:#ae81ff>1</span>) / <span style=color:#ae81ff>2</span>);
                    tempDesc.width = rtSize.x;
                    tempDesc.height = rtSize.y;
                    cmd.GetTemporaryRT(rtID, tempDesc);

                    rtIDs.Add(rtID);
                    rtSizes.Add(rtSize);

                    DoHQBloomDownsample(cmd, lastID, rtID, lastSize, rtSize, i == <span style=color:#ae81ff>0</span>, computeShader);
                    lastID = rtID;
                    lastSize = rtSize;
                }

                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = downsampleCount; i &gt;= <span style=color:#ae81ff>1</span>; i--)
                {
                    <span style=color:#66d9ef>int</span> sourceID = rtIDs[i];
                    Vector2Int sourceSize = rtSizes[i];
                    <span style=color:#66d9ef>int</span> targetID = rtIDs[i-<span style=color:#ae81ff>1</span>];
                    Vector2Int targetSize = rtSizes[i-<span style=color:#ae81ff>1</span>];

                    <span style=color:#66d9ef>if</span>(i == <span style=color:#ae81ff>1</span>)
                    {
                        DoHQloomComposite(cmd, sourceID, cameraColorIden, targetID, sourceSize, targetSize, computeShader);
                        cmd.Blit(targetID, cameraColorIden);
                        cmd.ReleaseTemporaryRT(targetID);
                    }
                    <span style=color:#66d9ef>else</span>
                    {
                        DoHQBloomAdditiveUpsample(cmd, sourceID, targetID, sourceSize, targetSize, computeShader);
                    }
                    cmd.ReleaseTemporaryRT(sourceID);
                }
            }
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }
    }
}
</code></pre></div><h3 id=hqbloomrendererfeaturecs>HQBloomRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#hqbloomrendererfeaturecs>#</a></h3><p>没啥好说的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HQBloomRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HQBloomSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
        }

        <span style=color:#66d9ef>public</span> HQBloomSettings settings = <span style=color:#66d9ef>new</span> HQBloomSettings();
        <span style=color:#66d9ef>private</span> HQBloomRenderPass hqBloomRenderPass;

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            hqBloomRenderPass = <span style=color:#66d9ef>new</span> HQBloomRenderPass(settings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            HQBloom HQBloom = VolumeManager.instance.stack.GetComponent&lt;HQBloom&gt;();
            <span style=color:#66d9ef>if</span> (HQBloom != <span style=color:#66d9ef>null</span> &amp;&amp; HQBloom.IsActive())
            {
                hqBloomRenderPass.Setup(HQBloom);
                renderer.EnqueuePass(hqBloomRenderPass);
            }
        }
    }
}
</code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/bloom/>Bloom</a></li><li><a href=https://zznewclear13.github.io/tags/post-process/>Post-Process</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/screen-space-reflection/><span class=title>« Prev Page</span><br><span>屏幕空间反射</span></a>
<a class=next href=https://zznewclear13.github.io/posts/relaxed-cone-step-mapping-in-unity/><span class=title>Next Page »</span><br><span>在Unity里实现松散圆锥步进Relaxed Cone Step Mapping</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>