<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾ | ZZNEWCLEAR13</title>
<meta name=keywords content="Volumetric Fog,Compute Shader"><meta name=description content="ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5",{anonymize_ip:!1})}</script><meta property="og:title" content="ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾"><meta property="og:description" content="ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"><meta property="og:image" content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-23T12:00:00+08:00"><meta property="article:modified_time" content="2022-08-23T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg"><meta name=twitter:title content="ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾"><meta name=twitter:description content="ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾","item":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾","name":"ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾","description":"ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾.","keywords":["Volumetric Fog","Compute Shader"],"articleBody":"ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾ å› ä¸ºå®ƒå°±åœ¨é‚£é‡Œã€‚\nå½“ç„¶äº†ï¼Œæ›´é‡è¦çš„æ˜¯å› ä¸ºä½“ç§¯é›¾èƒ½è¿…é€Ÿçš„è¥é€ å‡ºåœºæ™¯çš„çœŸå®æ„Ÿä¸æ°›å›´æ„Ÿï¼Œè°ä¸å–œæ¬¢å…‰æºè¾¹ä¸Šè¿˜æœ‰ä¸€å°åœˆå…‰æ™•å‘¢ï¼Œå¦‚æœä»€ä¹ˆé«˜äº®çš„ç‰©ä½“éƒ½èƒ½å½±å“ä½“ç§¯é›¾çš„è¯ï¼Œæ˜¯ä¸æ˜¯å°±ä¸å¤ªéœ€è¦bloomæ•ˆæœäº†å‘¢ã€‚æˆ‘å®é™…åœ°åœ¨ç”Ÿæ´»ä¸­è§‚å¯Ÿäº†ä¸€ä¸‹ï¼Œå‘ç°äººçœ¼æ‰€çœ‹åˆ°çš„å…‰æ™•çš„æ•ˆæœï¼Œæ˜¯å…‰çº¿è¿›å…¥çœ¼ç›ä¹‹åäº§ç”Ÿçš„ï¼Œä¹Ÿå°±æ˜¯è¯´bloomå’Œä½“ç§¯é›¾ç¡®ç¡®å®å®æ˜¯ä¸¤ç§ä¸åŒçš„æ•ˆæœã€‚\nä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³• ä½“ç§¯é›¾ä¸€èˆ¬æœ‰ä¸¤ç§æ¸²æŸ“æ–¹æ³•ï¼Œä¸€ç§æ˜¯å•çº¯çš„ä»ç›¸æœºå‡ºå‘å¯¹åœºæ™¯è¿›è¡ŒRay Marchingï¼Œæ¯æ¬¡è¿›è¡Œé‡‡æ ·å’Œæ··åˆã€‚è¿™ç§æ–¹æ³•ä¸»è¦çš„ç¼ºç‚¹æ˜¯Ray Marchingçš„æ¬¡æ•°ä¼šæ¯”è¾ƒé«˜æ‰èƒ½æœ‰è¾ƒå¥½çš„æ¸²æŸ“æ•ˆæœã€‚åœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œå¼€å¯TAAçš„æ—¶å€™ï¼Œ20æ¬¡Ray Marchingå°±èƒ½å¾—åˆ°å¾ˆå¥½çš„ä½“ç§¯é›¾æ•ˆæœäº†ï¼›ä½†æ˜¯ä¸å¼€å¯TAAçš„è¯ï¼Œå¯èƒ½ä¼šéœ€è¦60æ¬¡ç”šè‡³æ›´é«˜çš„Ray Marchingæ‰èƒ½å¾—åˆ°å’ŒTAAç±»ä¼¼çš„æ•ˆæœã€‚åŒæ—¶ï¼ŒRay Marchingä½“ç§¯é›¾åªèƒ½åœ¨åå¤„ç†é˜¶æ®µä½¿ç”¨ï¼Œåœ¨å¤„ç†ä¸å†™æ·±åº¦çš„é€æ˜ç‰©ä½“çš„æ—¶å€™ï¼Œä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚\nå¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€å¼ 3Dçº¹ç†ï¼Œå°†æ•´ä¸ªåœºæ™¯çš„ä½“ç§¯é›¾å‚¨å­˜åœ¨è¿™å¼ 3Dçº¹ç†ä¸­ï¼Œå½“ç»˜åˆ¶ç‰©ä½“çš„æ—¶å€™ä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´åæ ‡é‡‡æ ·è¿™å¼ 3Dçº¹ç†ï¼Œç›´æ¥åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­è®¡ç®—é›¾æ•ˆä¹‹åçš„é¢œè‰²ã€‚è¿™ç§æ–¹æ³•ä½¿ç”¨çš„3Dçº¹ç†ä¼šå ç”¨æ›´å¤šçš„å†…å­˜ï¼Œä½†æ˜¯ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿæ­£ç¡®çš„æ¸²æŸ“æ‰€æœ‰ç‰©ä½“ï¼Œå’Œ60æ¬¡Ray Marchingç›¸æ¯”ï¼Œæ€§èƒ½ä¸Šä¹Ÿè¯´ä¸å®šä¼šæœ‰ä¸€äº›ä¼˜åŠ¿ã€‚\næœ¬æ–‡çš„ä½“ç§¯é›¾å®ç°ï¼Œå‚è€ƒäº†EAçš„å¯’éœœå¼•æ“åœ¨Siggraph 2015å¹´æ—¶çš„æ¼”è®²å’Œdiharawçš„OpenGLçš„ä½“ç§¯é›¾æ•ˆæœã€‚å€¼å¾—ä¸€çœ‹çš„è¿˜æœ‰Bart Wronskiåœ¨Siggraph 2014å¹´çš„æ¼”è®²ï¼Œä»¥åŠä¹‹åçš„è’é‡å¤§é•–å®¢åœ¨Siggraph 2019å¹´çš„è¯¾ç¨‹ã€‚ä½¿ç”¨çš„æ˜¯Unity2019.4.29çš„URPå·¥ç¨‹ã€‚\nå…·ä½“çš„å®ç°æ–¹æ³• å°†åœºæ™¯ä¸­çš„éœ€è¦æ¸²æŸ“çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯å‚¨å­˜åˆ°ä¸€å¼ å’Œç›¸æœºçš„è§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†ä¸­ã€‚æŒ‰ç…§å¯’éœœå¼•æ“çš„åšæ³•ï¼Œçº¹ç†å¤§å°ä¸º(åˆ†è¾¨ç‡å®½/8)x(åˆ†è¾¨ç‡é«˜/8)x64ï¼Œè¿™æ ·å°±å’Œå±å¹•å¤§å°çš„2Dçº¹ç†å ç”¨çš„å†…å­˜å¤§å°ä¸€è‡´äº†ï¼Œä½†æˆ‘çœ‹Unityå®˜æ–¹çš„ä½“ç§¯é›¾å·¥ç¨‹ä¸­ï¼Œ3Dçº¹ç†çš„æ·±åº¦ä¸º128ï¼Œå°±ä¹ŸæŠŠè‡ªå·±çš„è®¾ç½®æˆ128äº†ï¼Œçº¹ç†æ·±åº¦è¶Šæ·±ï¼Œä½“ç§¯é›¾çš„ç»†èŠ‚å°±èƒ½è¶Šé«˜ã€‚3Dçº¹ç†çš„å®½é«˜å’Œè§†é”¥ä½“å¯¹é½ï¼Œè¿™å¾ˆå¥½ç†è§£ï¼Œè€Œè¿™å¼ è´´å›¾çš„çºµå‘æ·±åº¦å’Œå®é™…çš„æ·±åº¦è¦æ€ä¹ˆå¯¹é½å‘¢ï¼Ÿæœ€ç®€å•çš„å°±æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œä½†æ˜¯è¿™ä¼šå¯¼è‡´è¿‘å¤„ä½“ç§¯é›¾çš„åˆ†è¾¨ç‡ä¸å¤Ÿï¼›å¦ä¸€ç§æ˜¯å’Œè£å‰ªç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œç»è¿‡ä¸€äº›åˆ†æå¯ä»¥çŸ¥é“è¿™æ¯”ä¹‹å‰çš„æ–¹æ³•æ›´ç³Ÿç³•ï¼›ç›®å‰æˆ‘çœ‹ä¸‹æ¥æœ€å¥½çš„åº”è¯¥æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦æŒ‡æ•°å‹å¯¹åº”ï¼Œè¿™æ ·ç¦»ç›¸æœºè¶Šè¿‘3Dçº¹ç†çš„åƒç´ ä¼šè¶Šå¤šï¼Œè¶Šè¿œåˆ™è¶Šå°‘ã€‚æœ¬æ–‡åªä½¿ç”¨äº†å‡ä¸€çš„é›¾ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ä¸–ç•Œç©ºé—´çš„åæ ‡ã€å™ªæ³¢å’Œä¸€ç³»åˆ—çš„è¿ç®—ï¼Œè®¡ç®—å‡ºæŸä¸€ç‚¹çš„ä½“ç§¯é›¾çš„æµ“åº¦ã€‚ ä½¿ç”¨ä¸Šé¢çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯è®¡ç®—å‡ºæ•£å°„çš„å€¼Lscatï¼Œä»ä¸‹é¢çš„å›¾å¯ä»¥çœ‹åˆ°Lscatæ˜¯å¯¹æ‰€æœ‰çš„å…‰æºï¼ˆæœ¬æ–‡åªæœ‰ä¸»å…‰æºï¼‰è®¡ç®—\\(f(v, l)Vis(x, l)Li(x, l)\\)çš„å’Œï¼Œ\\(Vis(x, l)\\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å¯è§æ€§ï¼Œå¯ä»¥é€šè¿‡é‡‡æ ·é˜´å½±è´´å›¾æ¥è·å¾—ï¼Œ\\(Li(x, l)\\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å…‰å¼ºï¼Œå¯ä»¥ç®€å•çš„è®¡ç®—è·å¾—ï¼Œ\\(f(v, l)\\)ç”¨æ¥è¡¨è¿°åœ¨vçš„æ–¹å‘è§‚å¯Ÿé›¾æ—¶å¾—åˆ°lçš„æ•£å°„é‡ï¼Œä¸€èˆ¬è¢«å«åšPhase Functionï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯Henyey-Greenstein Phase Functionï¼Œå…¶ä¸­å‚æ•°gæ˜¯é›¾çš„å„å‘å¼‚æ€§çš„ç¨‹åº¦ï¼Œè¶Šé è¿‘1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¿æŒä¹‹å‰çš„æ–¹å‘ï¼Œè¶Šé è¿‘0è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶å‡åŒ€çš„æ•£å°„ï¼Œè¶Šé è¿‘-1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¼šè¿›è¡Œåå°„ï¼ˆåœ¨å®é™…çš„å…‰ç…§ä¸­ï¼Œæˆ‘ä»¬ä¼šå»æ‰\\(\\pi\\)è¿™ä¸€é¡¹ï¼Œè¿™æ ·èƒ½å’ŒUnityçš„å…‰ç…§æ¨¡å‹ä¿æŒä¸€è‡´ï¼‰ã€‚æ—¶ç©ºæ··åˆä¹Ÿåœ¨è¿™ä¸€æ­¥å¯ä»¥å®Œæˆã€‚ $$ \\tag{Henyey-Greenstein} p(\\theta) = \\frac 1 {4\\pi} \\frac {1 - g^2} {(1 + g^2 - 2g \\cos \\theta)^{\\frac 3 2}} $$\nå¯¹3Dçº¹ç†ä»ç›¸æœºè¿‘ç‚¹åˆ°è¿œç‚¹è¿›è¡Œæ··åˆï¼Œè¿™å…¶å®æ˜¯ä¸€ç§Ray Marchingï¼Œä¸è¿‡æ˜¯åœ¨3Dçº¹ç†çš„çº¹ç†ç©ºé—´è¿›è¡ŒRay Marchingï¼Œä¸€æ¬¡å‰è¿›ä¸€ä¸ªåƒç´ ã€‚å½“æ··åˆå½“å‰åƒç´ å’Œä¸Šä¸€ä¸ªåƒç´ æ—¶ï¼Œéœ€è¦è€ƒè™‘ç¬¦åˆç‰©ç†çš„é€å…‰ç‡(transmittance), \\(\\varepsilon\\)æ˜¯ä¸€ä¸ªç”¨äºå½’ä¸€åŒ–çš„å¸¸é‡ï¼Œlæ˜¯ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œcæ˜¯ä»‹è´¨çš„å¸æ”¶ç‡ï¼ˆä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç”¨é›¾çš„å¯†åº¦æ¥è¡¨ç¤ºï¼‰ã€‚å…·ä½“çš„æ··åˆçš„è®¡ç®—å’Œè¯´æ˜å¯ä»¥çœ‹EAå¯’éœœå¼•æ“çš„PPTç¬¬28ã€29é¡µã€‚ $$ \\tag{Beer-Lambert} transmittance = e^{-\\varepsilon l c} $$\næœ€ç»ˆåœ¨ç»˜åˆ¶ç‰©ä½“æ—¶ï¼Œä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œè½¬æ¢åˆ°3Dçº¹ç†çš„åæ ‡ï¼Œé‡‡æ ·3Dçº¹ç†ï¼Œä½¿ç”¨é€å…‰ç‡ä¹˜ä¸Šç‰©ä½“æœ¬èº«çš„é¢œè‰²ï¼Œå†åŠ ä¸Šé›¾çš„é¢œè‰²ï¼Œå°±å¾—åˆ°äº†æœ€ç»ˆçš„ä½“ç§¯é›¾çš„æ•ˆæœäº†ã€‚ ç›¸å…³ä»£ç å’Œè¯´æ˜ VolumetricFog.cs ç”¨äºGlobal Volumeä¸­æ–¹ä¾¿æ·»åŠ ä½“ç§¯é›¾å’Œæ§åˆ¶å„ç§å‚æ•°ã€‚å€¼å¾—è€ƒè™‘çš„æ˜¯maxTransmittanceçš„å€¼ï¼Œå› ä¸ºç›¸æœºè¿œè£å‰ªé¢ä¼šæ¯”è¾ƒè¿œï¼Œå³ä½¿é›¾å¹¶ä¸æ˜¯å¾ˆå¤§ï¼Œåœ¨æœ€è¿œå¤„ä¹Ÿæ€»æ˜¯èƒ½å˜æˆå•ä¸€çš„é¢œè‰²ï¼Œè¿™ä¸ªå€¼ç”¨æ¥é˜²æ­¢è¿™ç§æƒ…å†µï¼Œäººä¸ºåœ°é™åˆ¶äº†æœ€å¤§ä¸é€å…‰ç‡ï¼ˆä½†æ˜¯è¿˜æ˜¯å«maxTransmittanceï¼‰ã€‚fogNearè¿™ä¸ªå‚æ•°å®é™…æ˜¯å½±å“äº†3Dçº¹ç†å’Œç›¸æœºä¹‹é—´çš„è·ç¦»ï¼Œæœ€å¥½è¿˜æ˜¯è®¾ç½®æˆ0ï¼Œä¸ç„¶æ—¶ç©ºæ··åˆæ—¶ä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"Post-processing/Volumetric Fog\")] public class VolumetricFog : VolumeComponent, IPostProcessComponent { [Tooltip(\"æ˜¯å¦å¯ç”¨ä½“ç§¯é›¾\")] public BoolParameter enabled = new BoolParameter(false); [Tooltip(\"æ•´ä½“æ§åˆ¶ä½“ç§¯é›¾å¼ºåº¦\")] public ClampedFloatParameter intensity = new ClampedFloatParameter(1.0f, 0f, 1.0f); [Tooltip(\"ä½“ç§¯é›¾æœ€å¤§çš„é€æ˜ç¨‹åº¦ï¼ˆç”¨äºå’Œå¤©ç©ºæ··åˆï¼‰\")] public ClampedFloatParameter maxTransmittance = new ClampedFloatParameter(1.0f, 0f, 1.0f); [Tooltip(\"ä½“ç§¯é›¾çš„é¢œè‰²å€¾å‘ï¼Œç›®å‰å¼ºåº¦ä¸º0.03\")] public ColorParameter fogTint = new ColorParameter(Color.white); [Tooltip(\"ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿‘çš„è·ç¦»\")] public ClampedFloatParameter fogNear = new ClampedFloatParameter(0.1f, 0.01f, 10f); [Tooltip(\"ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿œçš„è·ç¦»\")] public ClampedFloatParameter fogFar = new ClampedFloatParameter(100f, 1.0f, 1000.0f); [Tooltip(\"ä½“ç§¯é›¾çš„å¯†åº¦ï¼Œè¶Šå¯†æ•ˆæœè¶Šæ˜æ˜¾\")] public ClampedFloatParameter density = new ClampedFloatParameter(3.0f, 0f, 10.0f); [Tooltip(\"ä½“ç§¯é›¾å—å…‰çš„å„å‘å¼‚æ€§ç¨‹åº¦\")] public ClampedFloatParameter phase = new ClampedFloatParameter(0.0f, -0.9f, 0.9f); public bool IsActive() =\u003e (enabled.value \u0026\u0026 (density.value \u003e 0.0f) \u0026\u0026 (intensity.value \u003e 0.0f)); public bool IsTileCompatible() =\u003e false; } } VolumetricFogRendererFeature.cs å¹³å¹³å¸¸å¸¸çš„RendererFeatureï¼Œäº‹å®ä¸ŠRenderPassEventåº”è¯¥åœ¨DepthPrePassä¹‹åï¼Œä½†æˆ‘æ²¡æ”¹ç‰©ä½“çš„shaderï¼Œå°±æ”¾åœ¨åå¤„ç†ä¹‹å‰äº†ã€‚\nnamespace UnityEngine.Rendering.Universal { public class VolumetricFogRendererFeature : ScriptableRendererFeature { [System.Serializable] public class VolumetricFogSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader volumetricFogComputeShader; } private VolumetricFogRenderPass volumetricFogRenderPass; public VolumetricFogSettings volumetricFogSettings = new VolumetricFogSettings(); public override void Create() { volumetricFogRenderPass = new VolumetricFogRenderPass(volumetricFogSettings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { if (renderingData.cameraData.cameraType == CameraType.Game) { VolumetricFog volumetricFog = VolumeManager.instance.stack.GetComponent(); if (volumetricFog \u0026\u0026 volumetricFog.IsActive()) { volumetricFogRenderPass.Setup(volumetricFog); renderer.EnqueuePass(volumetricFogRenderPass); } } } } } VolumetricFogRenderPass.cs å¹³å¹³å¸¸å¸¸çš„RenderPassï¼Œå®é™…ä½¿ç”¨çš„æ—¶å€™ï¼Œåªä¼šç”¨åˆ°Froxel Generate Passå’ŒScatter Passï¼ŒComposite Passå®Œå…¨å¯ä»¥ç”¨ç‰©ä»¶æœ¬èº«çš„æ¸²æŸ“æ¥ä»£æ›¿ã€‚\nnamespace UnityEngine.Rendering.Universal { public class VolumetricFogRenderPass : ScriptableRenderPass { private const string profilerTag = \"Volumetric Fog Pass\"; private ProfilingSampler profilingSampler; private ProfilingSampler froxelSampler = new ProfilingSampler(\"Froxel Generate Pass\"); private ProfilingSampler scatterSampler = new ProfilingSampler(\"Scatter Pass\"); private ProfilingSampler compositeSampler = new ProfilingSampler(\"Composite Pass\"); private RenderTargetHandle cameraColor; private RenderTargetIdentifier cameraColorIden; private RenderTargetHandle cameraDepth; private RenderTargetIdentifier cameraDepthIden; private RenderTargetHandle cameraDepthAttachment; private RenderTargetIdentifier cameraDepthAttachmentIden; private VolumetricFog volumetricFog; private ComputeShader volumetricFogComputeShader; private VolumetricFogRendererFeature.VolumetricFogSettings settings; private RenderTexture[] froxelTextures; private RenderTextureDescriptor cubeDesc; private static readonly string froxelTextureOneName = \"_FroxelBufferOne\"; private static readonly int froxelTextureOneID = Shader.PropertyToID(froxelTextureOneName); private RenderTargetHandle froxelTextureOneHandle; private RenderTargetIdentifier froxelTextureOneIden; private static readonly string froxelTextureTwoName = \"_FroxelBufferTwo\"; private static readonly int froxelTextureTwoID = Shader.PropertyToID(froxelTextureTwoName); private RenderTargetHandle froxelTextureTwoHandle; private RenderTargetIdentifier froxelTextureTwoIden; private static readonly string scatterTextureName = \"_ScatterBuffer\"; private static readonly int scatterTextureID = Shader.PropertyToID(scatterTextureName); private RenderTargetHandle scatterTextureHandle; private RenderTargetIdentifier scatterTextureIden; private static readonly string compositeTextureName = \"_CompositeBuffer\"; private static readonly int compositeTextureID = Shader.PropertyToID(compositeTextureName); private RenderTargetHandle compositeTextureHandle; private RenderTargetIdentifier compositeTextureIden; private Vector2 colorTextureSize; private Vector2 invColorTextureSize; private Vector3 froxelTextureSize; private Vector3 invFroxelTextureSize; private Matrix4x4 lastViewProjMatrix; private int flipReadWrite = 0; public VolumetricFogRenderPass(VolumetricFogRendererFeature.VolumetricFogSettings settings) { this.settings = settings; profilingSampler = new ProfilingSampler(profilerTag); renderPassEvent = settings.renderPassEvent; volumetricFogComputeShader = settings.volumetricFogComputeShader; cameraColor.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColor.Identifier(); cameraDepth.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepth.Identifier(); cameraDepthAttachment.Init(\"_CameraDepthAttachment\"); cameraDepthAttachmentIden = cameraDepthAttachment.Identifier(); froxelTextureOneHandle.Init(froxelTextureOneName); froxelTextureOneIden = froxelTextureOneHandle.Identifier(); froxelTextureTwoHandle.Init(froxelTextureTwoName); froxelTextureTwoIden = froxelTextureTwoHandle.Identifier(); scatterTextureHandle.Init(scatterTextureName); scatterTextureIden = scatterTextureHandle.Identifier(); compositeTextureHandle.Init(compositeTextureName); compositeTextureIden = compositeTextureHandle.Identifier(); lastViewProjMatrix = Matrix4x4.identity; } public void Setup(VolumetricFog volumetricFog) { this.volumetricFog = volumetricFog; } private static void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } private static void EnsureRenderTexture(ref RenderTexture rt, RenderTextureDescriptor descriptor, string RTName) { if (rt != null \u0026\u0026 (rt.width != descriptor.width || rt.height != descriptor.height)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { RenderTextureDescriptor desc = descriptor; desc.depthBufferBits = 0; desc.msaaSamples = 1; rt = RenderTexture.GetTemporary(desc); //rt = new RenderTexture(desc); rt.name = RTName; if (!rt.IsCreated()) rt.Create(); } } public static void EnsureRT(ref RenderTexture[] froxelTexs, RenderTextureDescriptor descriptor) { EnsureArray(ref froxelTexs, 2); EnsureRenderTexture(ref froxelTexs[0], descriptor, \"Froxel Tex One\"); EnsureRenderTexture(ref froxelTexs[1], descriptor, \"Froxel Tex Two\"); } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; cmd.GetTemporaryRT(compositeTextureID, desc); colorTextureSize = new Vector2(desc.width, desc.height); invColorTextureSize = new Vector2(1.0f / desc.width, 1.0f / desc.height); int width = desc.width / 8; int height = desc.height / 8; int volmeDepth = 128; cubeDesc = new RenderTextureDescriptor( width, height, Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat, 0); cubeDesc.volumeDepth = volmeDepth; cubeDesc.dimension = TextureDimension.Tex3D; cubeDesc.enableRandomWrite = true; froxelTextureSize = new Vector3(width, height, volmeDepth); invFroxelTextureSize = new Vector3(1.0f / (width-0), 1.0f / (height-0), 1.0f / (volmeDepth-0)); cmd.GetTemporaryRT(scatterTextureID, cubeDesc); } private void GenerateFroxel(CommandBuffer cmd, CameraData camData, RenderTargetIdentifier depthid, RenderTexture froxelReadid, RenderTexture froxelWriteid, ComputeShader computeShader) { int froxelKernel = computeShader.FindKernel(\"FroxelMain\"); computeShader.GetKernelThreadGroupSizes(froxelKernel, out uint x, out uint y, out uint z); cmd.SetComputeVectorParam(computeShader, \"_FroxelTextureSize\", froxelTextureSize); cmd.SetComputeVectorParam(computeShader, \"_ColorTextureSize\", colorTextureSize); cmd.SetComputeMatrixParam(computeShader, \"_LastViewProj\", lastViewProjMatrix); Matrix4x4 projMat = camData.GetGPUProjectionMatrix(); Matrix4x4 viewMat = camData.GetViewMatrix(); lastViewProjMatrix = projMat * viewMat; cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_DepthTexture\", depthid); cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_FroxelTexture\", froxelReadid); cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_RW_FroxelTexture\", froxelWriteid); Color fogTint = volumetricFog.fogTint.value; fogTint.a = 0.03f; volumetricFog.fogTint.Override(fogTint); cmd.SetComputeVectorParam(computeShader, \"_FogTint\", volumetricFog.fogTint.value); cmd.SetComputeVectorParam(computeShader, \"_NearFar\", new Vector4(camData.camera.nearClipPlane, camData.camera.farClipPlane, volumetricFog.fogNear.value, volumetricFog.fogFar.value)); cmd.SetComputeVectorParam(computeShader, \"_VolumetricFogParams\", new Vector4(volumetricFog.phase.value, volumetricFog.density.value, volumetricFog.intensity.value, volumetricFog.maxTransmittance.value)); cmd.DispatchCompute(computeShader, froxelKernel, Mathf.CeilToInt(froxelTextureSize.x / x), Mathf.CeilToInt(froxelTextureSize.y / y), Mathf.CeilToInt(froxelTextureSize.z / z)); } private void ScatterFog(CommandBuffer cmd, RenderTexture froxelid, RenderTargetIdentifier scatterid, ComputeShader computeShader) { int scatterKernel = computeShader.FindKernel(\"ScatterMain\"); computeShader.GetKernelThreadGroupSizes(scatterKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, scatterKernel, \"_FroxelTexture\", froxelid); cmd.SetComputeTextureParam(computeShader, scatterKernel, \"_RW_ScatterTexture\", scatterid); cmd.DispatchCompute(computeShader, scatterKernel, Mathf.CeilToInt(froxelTextureSize.x / x), Mathf.CeilToInt(froxelTextureSize.y / y), 1); } private void CompositeVolumetricFog(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier depthid, RenderTargetIdentifier scatterid, RenderTargetIdentifier compositeid, ComputeShader computeShader) { int compositeKernel = computeShader.FindKernel(\"CompositeMain\"); computeShader.GetKernelThreadGroupSizes(compositeKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_ColorTexture\", colorid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_DepthTexture\", depthid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_ScatterTexture\", scatterid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_RW_CompositeTexture\", compositeid); cmd.DispatchCompute(computeShader, compositeKernel, Mathf.CeilToInt(colorTextureSize.x / x), Mathf.CeilToInt(colorTextureSize.y / y), 1); cmd.Blit(compositeid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); EnsureRT(ref froxelTextures, cubeDesc); RenderTexture froxelReadTex = froxelTextures[flipReadWrite]; RenderTexture froxelWriteTex = froxelTextures[1 - flipReadWrite]; flipReadWrite = 1 - flipReadWrite; using (new ProfilingScope(cmd, froxelSampler)) { GenerateFroxel(cmd, renderingData.cameraData, cameraDepthAttachmentIden, froxelReadTex, froxelWriteTex, volumetricFogComputeShader); } using (new ProfilingScope(cmd, scatterSampler)) { ScatterFog(cmd, froxelWriteTex, scatterTextureIden, volumetricFogComputeShader); } using (new ProfilingScope(cmd, compositeSampler)) { CompositeVolumetricFog(cmd, cameraColorIden, cameraDepthAttachmentIden, scatterTextureIden, compositeTextureIden, volumetricFogComputeShader); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(scatterTextureID); cmd.ReleaseTemporaryRT(compositeTextureID); } } } VolumetricFogComputeShader.compute é‡å¤´æˆæ¥äº†ï¼Œè¿™ä¸ªCompute Shaderä¸€å…±æœ‰3ä¸ªkernelã€‚ç¬¬ä¸€ä¸ªç”¨æ¥é€šè¿‡é›¾çš„ä¿¡æ¯å’Œé˜´å½±çš„ä¿¡æ¯è®¡ç®—å…‰ç…§å¹¶å‚¨å­˜åˆ°_RW_FroxelTextureä¸­ï¼ŒåŒæ—¶ä¹Ÿåšäº†è‡ªèº«çš„å’Œå†å²çš„æ··åˆï¼Œä¹Ÿå¯¹TAAåšäº†é€‚é…ã€‚ç¬¬äºŒä¸ªç”¨æ¥åšçº¹ç†ç©ºé—´çš„Ray Marchingï¼Œè®¡ç®—æ•£å°„çš„é¢œè‰²å’Œé€å…‰ç‡ã€‚ç¬¬ä¸‰ä¸ªå…¶å®æ˜¯ä¸€ä¸ªå±å¹•åå¤„ç†çš„æ•ˆæœï¼Œå°†é›¾æ•ˆç”»åˆ°å±å¹•ä¸Šï¼Œå½“åœ¨ç‰©ä»¶shaderä¸­è®¡ç®—é›¾æ•ˆæ—¶ï¼Œå°±ä¸éœ€è¦è¿™ä¸ªkerneläº†ã€‚\nGetDepthæ˜¯å°†çº¹ç†çš„zè½¬æ¢åˆ°è§†ç©ºé—´çš„çº¿æ€§æ·±åº¦(Linear Eye Depth)ï¼ŒGetRatioåˆ™æ˜¯ç›¸åï¼ŒæŠŠçº¿æ€§çš„è§†ç©ºé—´çš„æ·±åº¦è½¬æ¢åˆ°çº¹ç†çš„zåæ ‡ï¼Œ NOT_SIMPLIFIEDè¿™ä¸ªå®å¯ä»¥è®©äººæ›´å¥½çš„ç†è§£æŒ‡æ•°å‹åˆ†å¸ƒçš„è®¡ç®—è¿‡ç¨‹ã€‚\nä¸ºäº†ç®€åŒ–é—®é¢˜ï¼Œè¿™è¾¹åªè€ƒè™‘äº†ä¸»å…‰æºä½¿ç”¨è”çº§é˜´å½±æ—¶çš„ä½“ç§¯é›¾æ•ˆæœï¼Œä¹Ÿæ²¡æœ‰è€ƒè™‘é›†æˆSHæ¥è®¡ç®—å…¨å±€å…‰ç…§å¯¹ä½“ç§¯é›¾çš„å½±å“ã€‚\n#pragma kernel FroxelMain #pragma kernel ScatterMain #pragma kernel CompositeMain #define _MAIN_LIGHT_SHADOWS #define _MAIN_LIGHT_SHADOWS_CASCADE #define _SHADOWS_SOFT #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" Texture2D\u003cfloat\u003e _DepthTexture; Texture2D\u003cfloat4\u003e _ColorTexture; Texture3D\u003cfloat4\u003e _FroxelTexture; Texture3D\u003cfloat4\u003e _ScatterTexture; RWTexture3D\u003cfloat4\u003e _RW_FroxelTexture; RWTexture3D\u003cfloat4\u003e _RW_ScatterTexture; RWTexture2D\u003cfloat4\u003e _RW_CompositeTexture; SamplerState sampler_LinearClamp; SamplerState sampler_PointClamp; float4 _ColorTextureSize; //float4 _InvColorTextureSize; float4 _FroxelTextureSize; //float4 _InvFroxelTextureSize; float _StepCount; float4 _NearFar; float4 _FogTint; float4 _VolumetricFogParams; // x: cam near, y: cam far, z: fog near, w: fog far #define _Phase _VolumetricFogParams.x #define _Density _VolumetricFogParams.y #define _Intensity _VolumetricFogParams.z #define _MaxTransmittance _VolumetricFogParams.w float4 _TAAOffsets; float4x4 _LastViewProj; float3 NDCToWorld(float3 ndc) { ndc.xy = 2.0f * ndc.xy - 1.0f; ndc.y = -ndc.y; float4x4 invJitteredVP = UNITY_MATRIX_I_VP;//mul(UNITY_MATRIX_I_V, _InvJitteredProj); float4 positionWS = mul(invJitteredVP, float4(ndc, 1.0f)); return positionWS.xyz / positionWS.w; } float Linear01DepthToRawDepth(float z, float4 zBufferParams) { return (rcp(z) - zBufferParams.y) / zBufferParams.x; } float LinearEyeToRawDepth(float depth, float4 zBufferParams) { return (1.0f / depth - zBufferParams.w) / zBufferParams.z; } float GetDepth(float2 camNearFar, float2 vfNearFar, float ratio) { #if NOT_SIMPLIFIED float valLeft = log(vfNearFar.x / camNearFar.x); float valRight = log(vfNearFar.y / camNearFar.x); float val = lerp(valLeft, valRight, ratio); float depthVal = camNearFar.x * exp(val); return depthVal; #else float valLeft = log(vfNearFar.x); float valRight = log(vfNearFar.y); float val = lerp(valLeft, valRight, ratio); float depthVal = exp(val); return depthVal; #endif } float GetRatio(float2 camNearFar, float2 vfNearFar, float linearDepth) { #if NOT_SIMPLIFIED float valLeft = log(vfNearFar.x / camNearFar.x); float valRight = log(vfNearFar.y / camNearFar.x); float val = log(linearDepth / camNearFar.x); float ratio = (val - valLeft) / (valRight - valLeft); return ratio; #else float valLeft = log(vfNearFar.x); float valRight = log(vfNearFar.y); float val = log(linearDepth); float ratio = (val - valLeft) / (valRight - valLeft); return ratio; #endif } float HGPhaseFunction(float g, float cosTheta) { float g2 = g * g; float denominator = 1.0f + g2 - 2 * g * cosTheta; return 0.25 * (1.0f - g2) * rsqrt(denominator * denominator * denominator); } float3 GetFogColor(float3 color, float3 lightDir, float3 viewDir, float g) { float cosVal = dot(-lightDir, viewDir); return color * HGPhaseFunction(g, cosVal); } float Hash13(float3 p) { p = frac(p * 0.1031); p += dot(p, p.zyx + 31.32); return frac((p.x + p.y) * p.z); } [numthreads(8,8,8)] void FroxelMain (uint3 id : SV_DispatchThreadID) { float2 texcoord = (id.xy + 0.5f) / _FroxelTextureSize.xy; texcoord += 0.5f * _TAAOffsets.xy; float jitter = Hash13(float3(texcoord, _Time.y * id.z)); float ratio = (id.z + jitter) / _FroxelTextureSize.z; float depthVal = GetDepth(_NearFar.xy, _NearFar.zw, ratio); float rawDepth = LinearEyeToRawDepth(depthVal, _ZBufferParams); float3 positionNDC = float3(texcoord, rawDepth); float3 positionWS = NDCToWorld(positionNDC); float3 viewDir = normalize(GetCameraPositionWS() - positionWS); float4 shadowCoord = TransformWorldToShadowCoord(positionWS); Light mainLight = GetMainLight(shadowCoord); float3 lightColor = mainLight.color * mainLight.shadowAttenuation; float3 lightDir = mainLight.direction; float3 fogColor = GetFogColor(lightColor, lightDir, viewDir, _Phase); fogColor += _FogTint.rgb * _FogTint.a; float density = _Density; float4 finalFroxel = float4(fogColor, density); // Reprojection Temporal Filter float ujRatio = (id.z + 0.5) / _FroxelTextureSize.z; float ujDepthVal = GetDepth(_NearFar.xy, _NearFar.zw, ujRatio); float ujRawDepth = LinearEyeToRawDepth(ujDepthVal, _ZBufferParams); float3 ujPositionNDC = float3(texcoord, ujRawDepth); float3 ujPositionWS = NDCToWorld(ujPositionNDC); float4 lastPositionCS = mul(_LastViewProj, float4(ujPositionWS, 1.0f)); lastPositionCS /= lastPositionCS.w; lastPositionCS.y = -lastPositionCS.y; float3 lastNDC = float3(lastPositionCS.xy * 0.5 + 0.5, lastPositionCS.z); lastNDC.xy -= 0.5f * _TAAOffsets.zw; if(all(lastNDC \u003e 0.0) \u0026\u0026 all(lastNDC \u003c 1.0f)) { float linearEyeDepth = LinearEyeDepth(lastNDC.z, _ZBufferParams); float reprojRatio = GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth); float4 froxelTex = _FroxelTexture.SampleLevel(sampler_LinearClamp, float3(lastNDC.xy, reprojRatio), 0); finalFroxel = lerp(finalFroxel, froxelTex, 0.95); } _RW_FroxelTexture[id] = finalFroxel; } float SliceThickness(int z) { float ratioThis = z / _FroxelTextureSize.z; float depthThis = GetDepth(_NearFar.xy, _NearFar.zw, ratioThis); float ratioNext = (z+1.0f) / _FroxelTextureSize.z; float depthNext = GetDepth(_NearFar.xy, _NearFar.zw, ratioNext); return depthNext - depthThis; } float4 AccumScatter(int z, float4 accum, float4 slice) { slice.a = max(slice.a, 1e-5); float thickness = SliceThickness(z); float sliceTransmittance = exp(-slice.a * thickness * 0.01f); float3 sliceScattering = slice.rgb * (1.0f - sliceTransmittance); float3 accumScattering = accum.rgb + sliceScattering * accum.a; float accumTransmittance = accum.a * sliceTransmittance; return float4(accumScattering, accumTransmittance); } [numthreads(16,16,1)] void ScatterMain (uint3 id : SV_DispatchThreadID) { float4 accum = float4(0.0f, 0.0f, 0.0f, 1.0f); for (int z=0; z\u003c_FroxelTextureSize.z; z++) { int3 coord = int3(id.xy, z); float4 slice = _FroxelTexture[coord]; accum = AccumScatter(z, accum, slice); //_RW_ScatterTexture[coord] = slice; _RW_ScatterTexture[coord] = accum; } } [numthreads(16,16,1)] void CompositeMain (uint3 id : SV_DispatchThreadID) { float2 texcoord = (id.xy + 0.5f) * rcp(_ColorTextureSize.xy); float3 colorTex = _ColorTexture.SampleLevel(sampler_PointClamp, texcoord, 0).rgb; float depthTex = _DepthTexture.SampleLevel(sampler_PointClamp, texcoord, 0); float linearEyeDepth = LinearEyeDepth(depthTex, _ZBufferParams); float ratio = GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth); float4 froxelTex = _ScatterTexture.SampleLevel(sampler_LinearClamp, float3(texcoord, ratio), 0); float3 accumScatter = froxelTex.rgb; float accumTrans = max(1.0f - _MaxTransmittance, froxelTex.a); float3 finalColor = colorTex * accumTrans + froxelTex.rgb; finalColor = lerp(colorTex.rgb, finalColor, _Intensity); _RW_CompositeTexture[id.xy] = float4(finalColor, 1.0f); } åè®° å¥½ä¹…æ²¡æœ‰å†™æ–°çš„åšå®¢å•¦ï¼Œä¹‹å‰ä¸€ç›´åœ¨å­¦c++ï¼Œä¸æ€ä¹ˆæœ‰æ—¶é—´åšæ–°çš„ä¸œè¥¿ã€‚ä½“ç§¯é›¾è¿˜æ˜¯ä¸€ä¸ªè›®é‡è¦çš„æ•ˆæœï¼Œä¹‹å‰åšRay Marchingçš„æ—¶å€™è€æ˜¯æŠŠæ¡ä¸ä½è¯¥æ­¥è¿›å¤šå°‘ï¼Œç”¨äº†æŒ‡æ•°å‹çš„æ­¥è¿›ä¹‹åå°±æ„Ÿè§‰è±ç„¶å¼€æœ—äº†ã€‚TAAå…¶å®ä¹Ÿåšäº†ä¸€ç‰ˆæ–°çš„ï¼Œè¿˜æ²¡æ¥å¾—åŠå†™ï¼ŒGTAOä¹Ÿå­¦äº†ä¸€éï¼Œå°±ä¹‹åå†è¯´å§ã€‚\n","wordCount":"1730","inLanguage":"en","image":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg","datePublished":"2022-08-23T12:00:00+08:00","dateModified":"2022-08-23T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾</h1><div class=post-description>ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾.</div><div class=post-meta><span title='2022-08-23 12:00:00 +0800 CST'>August 23, 2022</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/create-volumetric-fog-using-view-aligned-3D-texture.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/VolumetricFog.jpg alt="Volumetric Fog Cover"><p>Volumetric Fog Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%b8%b2%e6%9f%93%e4%bd%93%e7%a7%af%e9%9b%be aria-label=ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾>ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾</a></li><li><a href=#%e4%bd%93%e7%a7%af%e9%9b%be%e7%9a%84%e6%b8%b2%e6%9f%93%e6%96%b9%e6%b3%95 aria-label=ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•>ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81%e5%92%8c%e8%af%b4%e6%98%8e aria-label=ç›¸å…³ä»£ç å’Œè¯´æ˜>ç›¸å…³ä»£ç å’Œè¯´æ˜</a><ul><li><a href=#volumetricfogcs aria-label=VolumetricFog.cs>VolumetricFog.cs</a></li><li><a href=#volumetricfogrendererfeaturecs aria-label=VolumetricFogRendererFeature.cs>VolumetricFogRendererFeature.cs</a></li><li><a href=#volumetricfogrenderpasscs aria-label=VolumetricFogRenderPass.cs>VolumetricFogRenderPass.cs</a></li><li><a href=#volumetricfogcomputeshadercompute aria-label=VolumetricFogComputeShader.compute>VolumetricFogComputeShader.compute</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾>ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾<a hidden class=anchor aria-hidden=true href=#ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾>#</a></h2><p>å› ä¸ºå®ƒå°±åœ¨é‚£é‡Œã€‚</p><p>å½“ç„¶äº†ï¼Œæ›´é‡è¦çš„æ˜¯å› ä¸ºä½“ç§¯é›¾èƒ½è¿…é€Ÿçš„è¥é€ å‡ºåœºæ™¯çš„çœŸå®æ„Ÿä¸æ°›å›´æ„Ÿï¼Œè°ä¸å–œæ¬¢å…‰æºè¾¹ä¸Šè¿˜æœ‰ä¸€å°åœˆå…‰æ™•å‘¢ï¼Œå¦‚æœä»€ä¹ˆé«˜äº®çš„ç‰©ä½“éƒ½èƒ½å½±å“ä½“ç§¯é›¾çš„è¯ï¼Œæ˜¯ä¸æ˜¯å°±ä¸å¤ªéœ€è¦bloomæ•ˆæœäº†å‘¢ã€‚æˆ‘å®é™…åœ°åœ¨ç”Ÿæ´»ä¸­è§‚å¯Ÿäº†ä¸€ä¸‹ï¼Œå‘ç°äººçœ¼æ‰€çœ‹åˆ°çš„å…‰æ™•çš„æ•ˆæœï¼Œæ˜¯å…‰çº¿è¿›å…¥çœ¼ç›ä¹‹åäº§ç”Ÿçš„ï¼Œä¹Ÿå°±æ˜¯è¯´bloomå’Œä½“ç§¯é›¾ç¡®ç¡®å®å®æ˜¯ä¸¤ç§ä¸åŒçš„æ•ˆæœã€‚</p><h2 id=ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•>ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•>#</a></h2><p>ä½“ç§¯é›¾ä¸€èˆ¬æœ‰ä¸¤ç§æ¸²æŸ“æ–¹æ³•ï¼Œä¸€ç§æ˜¯å•çº¯çš„ä»ç›¸æœºå‡ºå‘å¯¹åœºæ™¯è¿›è¡ŒRay Marchingï¼Œæ¯æ¬¡è¿›è¡Œé‡‡æ ·å’Œæ··åˆã€‚è¿™ç§æ–¹æ³•ä¸»è¦çš„ç¼ºç‚¹æ˜¯Ray Marchingçš„æ¬¡æ•°ä¼šæ¯”è¾ƒé«˜æ‰èƒ½æœ‰è¾ƒå¥½çš„æ¸²æŸ“æ•ˆæœã€‚åœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œå¼€å¯TAAçš„æ—¶å€™ï¼Œ20æ¬¡Ray Marchingå°±èƒ½å¾—åˆ°å¾ˆå¥½çš„ä½“ç§¯é›¾æ•ˆæœäº†ï¼›ä½†æ˜¯ä¸å¼€å¯TAAçš„è¯ï¼Œå¯èƒ½ä¼šéœ€è¦60æ¬¡ç”šè‡³æ›´é«˜çš„Ray Marchingæ‰èƒ½å¾—åˆ°å’ŒTAAç±»ä¼¼çš„æ•ˆæœã€‚åŒæ—¶ï¼ŒRay Marchingä½“ç§¯é›¾åªèƒ½åœ¨åå¤„ç†é˜¶æ®µä½¿ç”¨ï¼Œåœ¨å¤„ç†ä¸å†™æ·±åº¦çš„é€æ˜ç‰©ä½“çš„æ—¶å€™ï¼Œä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚</p><p>å¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€å¼ 3Dçº¹ç†ï¼Œå°†æ•´ä¸ªåœºæ™¯çš„ä½“ç§¯é›¾å‚¨å­˜åœ¨è¿™å¼ 3Dçº¹ç†ä¸­ï¼Œå½“ç»˜åˆ¶ç‰©ä½“çš„æ—¶å€™ä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´åæ ‡é‡‡æ ·è¿™å¼ 3Dçº¹ç†ï¼Œç›´æ¥åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­è®¡ç®—é›¾æ•ˆä¹‹åçš„é¢œè‰²ã€‚è¿™ç§æ–¹æ³•ä½¿ç”¨çš„3Dçº¹ç†ä¼šå ç”¨æ›´å¤šçš„å†…å­˜ï¼Œä½†æ˜¯ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿæ­£ç¡®çš„æ¸²æŸ“æ‰€æœ‰ç‰©ä½“ï¼Œå’Œ60æ¬¡Ray Marchingç›¸æ¯”ï¼Œæ€§èƒ½ä¸Šä¹Ÿè¯´ä¸å®šä¼šæœ‰ä¸€äº›ä¼˜åŠ¿ã€‚</p><p>æœ¬æ–‡çš„ä½“ç§¯é›¾å®ç°ï¼Œå‚è€ƒäº†<a href=https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite>EAçš„å¯’éœœå¼•æ“åœ¨Siggraph 2015å¹´æ—¶çš„æ¼”è®²</a>å’Œ<a href=https://github.com/diharaw/volumetric-lighting>diharawçš„OpenGLçš„ä½“ç§¯é›¾æ•ˆæœ</a>ã€‚å€¼å¾—ä¸€çœ‹çš„è¿˜æœ‰<a href=https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pptx>Bart Wronskiåœ¨Siggraph 2014å¹´çš„æ¼”è®²</a>ï¼Œä»¥åŠä¹‹åçš„<a href=https://advances.realtimerendering.com/s2019/slides_public_release.pptx>è’é‡å¤§é•–å®¢åœ¨Siggraph 2019å¹´çš„è¯¾ç¨‹</a>ã€‚ä½¿ç”¨çš„æ˜¯Unity2019.4.29çš„URPå·¥ç¨‹ã€‚</p><h2 id=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æ–¹æ³•>#</a></h2><ol><li>å°†åœºæ™¯ä¸­çš„éœ€è¦æ¸²æŸ“çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯å‚¨å­˜åˆ°ä¸€å¼ å’Œç›¸æœºçš„è§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†ä¸­ã€‚æŒ‰ç…§å¯’éœœå¼•æ“çš„åšæ³•ï¼Œçº¹ç†å¤§å°ä¸º(åˆ†è¾¨ç‡å®½/8)x(åˆ†è¾¨ç‡é«˜/8)x64ï¼Œè¿™æ ·å°±å’Œå±å¹•å¤§å°çš„2Dçº¹ç†å ç”¨çš„å†…å­˜å¤§å°ä¸€è‡´äº†ï¼Œä½†æˆ‘çœ‹Unityå®˜æ–¹çš„ä½“ç§¯é›¾å·¥ç¨‹ä¸­ï¼Œ3Dçº¹ç†çš„æ·±åº¦ä¸º128ï¼Œå°±ä¹ŸæŠŠè‡ªå·±çš„è®¾ç½®æˆ128äº†ï¼Œçº¹ç†æ·±åº¦è¶Šæ·±ï¼Œä½“ç§¯é›¾çš„ç»†èŠ‚å°±èƒ½è¶Šé«˜ã€‚3Dçº¹ç†çš„å®½é«˜å’Œè§†é”¥ä½“å¯¹é½ï¼Œè¿™å¾ˆå¥½ç†è§£ï¼Œè€Œè¿™å¼ è´´å›¾çš„çºµå‘æ·±åº¦å’Œå®é™…çš„æ·±åº¦è¦æ€ä¹ˆå¯¹é½å‘¢ï¼Ÿæœ€ç®€å•çš„å°±æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œä½†æ˜¯è¿™ä¼šå¯¼è‡´è¿‘å¤„ä½“ç§¯é›¾çš„åˆ†è¾¨ç‡ä¸å¤Ÿï¼›å¦ä¸€ç§æ˜¯å’Œè£å‰ªç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œç»è¿‡ä¸€äº›åˆ†æå¯ä»¥çŸ¥é“è¿™æ¯”ä¹‹å‰çš„æ–¹æ³•æ›´ç³Ÿç³•ï¼›ç›®å‰æˆ‘çœ‹ä¸‹æ¥æœ€å¥½çš„åº”è¯¥æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦æŒ‡æ•°å‹å¯¹åº”ï¼Œè¿™æ ·ç¦»ç›¸æœºè¶Šè¿‘3Dçº¹ç†çš„åƒç´ ä¼šè¶Šå¤šï¼Œè¶Šè¿œåˆ™è¶Šå°‘ã€‚æœ¬æ–‡åªä½¿ç”¨äº†å‡ä¸€çš„é›¾ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ä¸–ç•Œç©ºé—´çš„åæ ‡ã€å™ªæ³¢å’Œä¸€ç³»åˆ—çš„è¿ç®—ï¼Œè®¡ç®—å‡ºæŸä¸€ç‚¹çš„ä½“ç§¯é›¾çš„æµ“åº¦ã€‚</li><li>ä½¿ç”¨ä¸Šé¢çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯è®¡ç®—å‡ºæ•£å°„çš„å€¼<code>Lscat</code>ï¼Œä»ä¸‹é¢çš„å›¾å¯ä»¥çœ‹åˆ°<code>Lscat</code>æ˜¯å¯¹æ‰€æœ‰çš„å…‰æºï¼ˆæœ¬æ–‡åªæœ‰ä¸»å…‰æºï¼‰è®¡ç®—\(f(v, l)Vis(x, l)Li(x, l)\)çš„å’Œï¼Œ\(Vis(x, l)\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å¯è§æ€§ï¼Œå¯ä»¥é€šè¿‡é‡‡æ ·é˜´å½±è´´å›¾æ¥è·å¾—ï¼Œ\(Li(x, l)\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å…‰å¼ºï¼Œå¯ä»¥ç®€å•çš„è®¡ç®—è·å¾—ï¼Œ\(f(v, l)\)ç”¨æ¥è¡¨è¿°åœ¨vçš„æ–¹å‘è§‚å¯Ÿé›¾æ—¶å¾—åˆ°lçš„æ•£å°„é‡ï¼Œä¸€èˆ¬è¢«å«åšPhase Functionï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯Henyey-Greenstein Phase Functionï¼Œå…¶ä¸­å‚æ•°gæ˜¯é›¾çš„å„å‘å¼‚æ€§çš„ç¨‹åº¦ï¼Œè¶Šé è¿‘1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¿æŒä¹‹å‰çš„æ–¹å‘ï¼Œè¶Šé è¿‘0è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶å‡åŒ€çš„æ•£å°„ï¼Œè¶Šé è¿‘-1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¼šè¿›è¡Œåå°„ï¼ˆåœ¨å®é™…çš„å…‰ç…§ä¸­ï¼Œæˆ‘ä»¬ä¼šå»æ‰\(\pi\)è¿™ä¸€é¡¹ï¼Œè¿™æ ·èƒ½å’ŒUnityçš„å…‰ç…§æ¨¡å‹ä¿æŒä¸€è‡´ï¼‰ã€‚æ—¶ç©ºæ··åˆä¹Ÿåœ¨è¿™ä¸€æ­¥å¯ä»¥å®Œæˆã€‚</li></ol><p>$$
\tag{Henyey-Greenstein} p(\theta) = \frac 1 {4\pi} \frac {1 - g^2} {(1 + g^2 - 2g \cos \theta)^{\frac 3 2}}
$$</p><p><img loading=lazy src=../images/VolumetricFogScattering.jpg#center alt="Volumetric Fog Scattering"></p><ol start=3><li>å¯¹3Dçº¹ç†ä»ç›¸æœºè¿‘ç‚¹åˆ°è¿œç‚¹è¿›è¡Œæ··åˆï¼Œè¿™å…¶å®æ˜¯ä¸€ç§Ray Marchingï¼Œä¸è¿‡æ˜¯åœ¨3Dçº¹ç†çš„çº¹ç†ç©ºé—´è¿›è¡ŒRay Marchingï¼Œä¸€æ¬¡å‰è¿›ä¸€ä¸ªåƒç´ ã€‚å½“æ··åˆå½“å‰åƒç´ å’Œä¸Šä¸€ä¸ªåƒç´ æ—¶ï¼Œéœ€è¦è€ƒè™‘ç¬¦åˆç‰©ç†çš„é€å…‰ç‡(transmittance), \(\varepsilon\)æ˜¯ä¸€ä¸ªç”¨äºå½’ä¸€åŒ–çš„å¸¸é‡ï¼Œlæ˜¯ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œcæ˜¯ä»‹è´¨çš„å¸æ”¶ç‡ï¼ˆä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç”¨é›¾çš„å¯†åº¦æ¥è¡¨ç¤ºï¼‰ã€‚å…·ä½“çš„æ··åˆçš„è®¡ç®—å’Œè¯´æ˜å¯ä»¥çœ‹EAå¯’éœœå¼•æ“çš„PPTç¬¬28ã€29é¡µã€‚</li></ol><p>$$
\tag{Beer-Lambert} transmittance = e^{-\varepsilon l c}
$$</p><ol start=4><li>æœ€ç»ˆåœ¨ç»˜åˆ¶ç‰©ä½“æ—¶ï¼Œä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œè½¬æ¢åˆ°3Dçº¹ç†çš„åæ ‡ï¼Œé‡‡æ ·3Dçº¹ç†ï¼Œä½¿ç”¨é€å…‰ç‡ä¹˜ä¸Šç‰©ä½“æœ¬èº«çš„é¢œè‰²ï¼Œå†åŠ ä¸Šé›¾çš„é¢œè‰²ï¼Œå°±å¾—åˆ°äº†æœ€ç»ˆçš„ä½“ç§¯é›¾çš„æ•ˆæœäº†ã€‚</li></ol><h2 id=ç›¸å…³ä»£ç å’Œè¯´æ˜>ç›¸å…³ä»£ç å’Œè¯´æ˜<a hidden class=anchor aria-hidden=true href=#ç›¸å…³ä»£ç å’Œè¯´æ˜>#</a></h2><h3 id=volumetricfogcs>VolumetricFog.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogcs>#</a></h3><p>ç”¨äºGlobal Volumeä¸­æ–¹ä¾¿æ·»åŠ ä½“ç§¯é›¾å’Œæ§åˆ¶å„ç§å‚æ•°ã€‚å€¼å¾—è€ƒè™‘çš„æ˜¯<code>maxTransmittance</code>çš„å€¼ï¼Œå› ä¸ºç›¸æœºè¿œè£å‰ªé¢ä¼šæ¯”è¾ƒè¿œï¼Œå³ä½¿é›¾å¹¶ä¸æ˜¯å¾ˆå¤§ï¼Œåœ¨æœ€è¿œå¤„ä¹Ÿæ€»æ˜¯èƒ½å˜æˆå•ä¸€çš„é¢œè‰²ï¼Œè¿™ä¸ªå€¼ç”¨æ¥é˜²æ­¢è¿™ç§æƒ…å†µï¼Œäººä¸ºåœ°é™åˆ¶äº†æœ€å¤§ä¸é€å…‰ç‡ï¼ˆä½†æ˜¯è¿˜æ˜¯å«maxTransmittanceï¼‰ã€‚<code>fogNear</code>è¿™ä¸ªå‚æ•°å®é™…æ˜¯å½±å“äº†3Dçº¹ç†å’Œç›¸æœºä¹‹é—´çš„è·ç¦»ï¼Œæœ€å¥½è¿˜æ˜¯è®¾ç½®æˆ0ï¼Œä¸ç„¶æ—¶ç©ºæ··åˆæ—¶ä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;Post-processing/Volumetric Fog&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFog</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;æ˜¯å¦å¯ç”¨ä½“ç§¯é›¾&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter enabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;æ•´ä½“æ§åˆ¶ä½“ç§¯é›¾å¼ºåº¦&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾æœ€å¤§çš„é€æ˜ç¨‹åº¦ï¼ˆç”¨äºå’Œå¤©ç©ºæ··åˆï¼‰&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter maxTransmittance = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾çš„é¢œè‰²å€¾å‘ï¼Œç›®å‰å¼ºåº¦ä¸º0.03&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ColorParameter fogTint = <span style=color:#66d9ef>new</span> ColorParameter(Color.white);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿‘çš„è·ç¦»&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter fogNear = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>0.01f</span>, <span style=color:#ae81ff>10f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿œçš„è·ç¦»&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter fogFar = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>100f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1000.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾çš„å¯†åº¦ï¼Œè¶Šå¯†æ•ˆæœè¶Šæ˜æ˜¾&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter density = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>3.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>10.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾å—å…‰çš„å„å‘å¼‚æ€§ç¨‹åº¦&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter phase = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, -<span style=color:#ae81ff>0.9f</span>, <span style=color:#ae81ff>0.9f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive() =&gt; (enabled.<span style=color:#66d9ef>value</span> &amp;&amp; (density.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>) &amp;&amp; (intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible() =&gt; <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=volumetricfogrendererfeaturecs>VolumetricFogRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogrendererfeaturecs>#</a></h3><p>å¹³å¹³å¸¸å¸¸çš„RendererFeatureï¼Œäº‹å®ä¸ŠRenderPassEventåº”è¯¥åœ¨DepthPrePassä¹‹åï¼Œä½†æˆ‘æ²¡æ”¹ç‰©ä½“çš„shaderï¼Œå°±æ”¾åœ¨åå¤„ç†ä¹‹å‰äº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader volumetricFogComputeShader;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> VolumetricFogRenderPass volumetricFogRenderPass;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> VolumetricFogSettings volumetricFogSettings = <span style=color:#66d9ef>new</span> VolumetricFogSettings();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            volumetricFogRenderPass = <span style=color:#66d9ef>new</span> VolumetricFogRenderPass(volumetricFogSettings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (renderingData.cameraData.cameraType == CameraType.Game)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                VolumetricFog volumetricFog = VolumeManager.instance.stack.GetComponent&lt;VolumetricFog&gt;();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (volumetricFog &amp;&amp; volumetricFog.IsActive())
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    volumetricFogRenderPass.Setup(volumetricFog);
</span></span><span style=display:flex><span>                    renderer.EnqueuePass(volumetricFogRenderPass);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=volumetricfogrenderpasscs>VolumetricFogRenderPass.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogrenderpasscs>#</a></h3><p>å¹³å¹³å¸¸å¸¸çš„RenderPassï¼Œå®é™…ä½¿ç”¨çš„æ—¶å€™ï¼Œåªä¼šç”¨åˆ°<code>Froxel Generate Pass</code>å’Œ<code>Scatter Pass</code>ï¼Œ<code>Composite Pass</code>å®Œå…¨å¯ä»¥ç”¨ç‰©ä»¶æœ¬èº«çš„æ¸²æŸ“æ¥ä»£æ›¿ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;Volumetric Fog Pass&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler profilingSampler;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler froxelSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Froxel Generate Pass&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler scatterSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Scatter Pass&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler compositeSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Composite Pass&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepth;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthIden;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepthAttachment;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthAttachmentIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> VolumetricFog volumetricFog;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader volumetricFogComputeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> VolumetricFogRendererFeature.VolumetricFogSettings settings;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTexture[] froxelTextures;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTextureDescriptor cubeDesc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> froxelTextureOneName = <span style=color:#e6db74>&#34;_FroxelBufferOne&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> froxelTextureOneID = Shader.PropertyToID(froxelTextureOneName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle froxelTextureOneHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier froxelTextureOneIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> froxelTextureTwoName = <span style=color:#e6db74>&#34;_FroxelBufferTwo&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> froxelTextureTwoID = Shader.PropertyToID(froxelTextureTwoName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle froxelTextureTwoHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier froxelTextureTwoIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> scatterTextureName = <span style=color:#e6db74>&#34;_ScatterBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> scatterTextureID = Shader.PropertyToID(scatterTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle scatterTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier scatterTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> compositeTextureName = <span style=color:#e6db74>&#34;_CompositeBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> compositeTextureID = Shader.PropertyToID(compositeTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle compositeTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier compositeTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2 colorTextureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2 invColorTextureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector3 froxelTextureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector3 invFroxelTextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4 lastViewProjMatrix;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> flipReadWrite = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> VolumetricFogRenderPass(VolumetricFogRendererFeature.VolumetricFogSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            volumetricFogComputeShader = settings.volumetricFogComputeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cameraColor.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraColorIden = cameraColor.Identifier();
</span></span><span style=display:flex><span>            cameraDepth.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthIden = cameraDepth.Identifier();
</span></span><span style=display:flex><span>            cameraDepthAttachment.Init(<span style=color:#e6db74>&#34;_CameraDepthAttachment&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthAttachmentIden = cameraDepthAttachment.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            froxelTextureOneHandle.Init(froxelTextureOneName);
</span></span><span style=display:flex><span>            froxelTextureOneIden = froxelTextureOneHandle.Identifier();
</span></span><span style=display:flex><span>            froxelTextureTwoHandle.Init(froxelTextureTwoName);
</span></span><span style=display:flex><span>            froxelTextureTwoIden = froxelTextureTwoHandle.Identifier();
</span></span><span style=display:flex><span>            scatterTextureHandle.Init(scatterTextureName);
</span></span><span style=display:flex><span>            scatterTextureIden = scatterTextureHandle.Identifier();
</span></span><span style=display:flex><span>            compositeTextureHandle.Init(compositeTextureName);
</span></span><span style=display:flex><span>            compositeTextureIden = compositeTextureHandle.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            lastViewProjMatrix = Matrix4x4.identity;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(VolumetricFog volumetricFog)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.volumetricFog = volumetricFog;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                array = <span style=color:#66d9ef>new</span> T[size];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
</span></span><span style=display:flex><span>                    array[i] = initialValue;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRenderTexture(<span style=color:#66d9ef>ref</span> RenderTexture rt, RenderTextureDescriptor descriptor, <span style=color:#66d9ef>string</span> RTName)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != descriptor.width || rt.height != descriptor.height))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                RenderTexture.ReleaseTemporary(rt);
</span></span><span style=display:flex><span>                rt = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                RenderTextureDescriptor desc = descriptor;
</span></span><span style=display:flex><span>                desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                rt = RenderTexture.GetTemporary(desc);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//rt = new RenderTexture(desc);</span>
</span></span><span style=display:flex><span>                rt.name = RTName;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture[] froxelTexs, RenderTextureDescriptor descriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            EnsureArray(<span style=color:#66d9ef>ref</span> froxelTexs, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>            EnsureRenderTexture(<span style=color:#66d9ef>ref</span> froxelTexs[<span style=color:#ae81ff>0</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex One&#34;</span>);
</span></span><span style=display:flex><span>            EnsureRenderTexture(<span style=color:#66d9ef>ref</span> froxelTexs[<span style=color:#ae81ff>1</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex Two&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(compositeTextureID, desc);
</span></span><span style=display:flex><span>            colorTextureSize = <span style=color:#66d9ef>new</span> Vector2(desc.width, desc.height);
</span></span><span style=display:flex><span>            invColorTextureSize = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1.0f</span> / desc.width, <span style=color:#ae81ff>1.0f</span> / desc.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> width = desc.width / <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> height = desc.height / <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> volmeDepth = <span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>            cubeDesc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor(
</span></span><span style=display:flex><span>                    width, height,
</span></span><span style=display:flex><span>                    Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat,
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            cubeDesc.volumeDepth = volmeDepth;
</span></span><span style=display:flex><span>            cubeDesc.dimension = TextureDimension.Tex3D;
</span></span><span style=display:flex><span>            cubeDesc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            froxelTextureSize = <span style=color:#66d9ef>new</span> Vector3(width, height, volmeDepth);
</span></span><span style=display:flex><span>            invFroxelTextureSize = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>1.0f</span> / (width-<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>1.0f</span> / (height-<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>1.0f</span> / (volmeDepth-<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(scatterTextureID, cubeDesc);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateFroxel(CommandBuffer cmd, CameraData camData, RenderTargetIdentifier depthid,
</span></span><span style=display:flex><span>            RenderTexture froxelReadid, RenderTexture froxelWriteid,
</span></span><span style=display:flex><span>            ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> froxelKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;FroxelMain&#34;</span>);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(froxelKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_FroxelTextureSize&#34;</span>, froxelTextureSize);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_ColorTextureSize&#34;</span>, colorTextureSize);
</span></span><span style=display:flex><span>            cmd.SetComputeMatrixParam(computeShader, <span style=color:#e6db74>&#34;_LastViewProj&#34;</span>, lastViewProjMatrix);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Matrix4x4 projMat = camData.GetGPUProjectionMatrix();
</span></span><span style=display:flex><span>            Matrix4x4 viewMat = camData.GetViewMatrix();
</span></span><span style=display:flex><span>            lastViewProjMatrix = projMat * viewMat;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_DepthTexture&#34;</span>, depthid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_FroxelTexture&#34;</span>, froxelReadid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_RW_FroxelTexture&#34;</span>, froxelWriteid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Color fogTint = volumetricFog.fogTint.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>            fogTint.a = <span style=color:#ae81ff>0.03f</span>;
</span></span><span style=display:flex><span>            volumetricFog.fogTint.Override(fogTint);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_FogTint&#34;</span>, volumetricFog.fogTint.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_NearFar&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> Vector4(camData.camera.nearClipPlane, camData.camera.farClipPlane,
</span></span><span style=display:flex><span>                            volumetricFog.fogNear.<span style=color:#66d9ef>value</span>, volumetricFog.fogFar.<span style=color:#66d9ef>value</span>));
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_VolumetricFogParams&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> Vector4(volumetricFog.phase.<span style=color:#66d9ef>value</span>,
</span></span><span style=display:flex><span>                            volumetricFog.density.<span style=color:#66d9ef>value</span>,
</span></span><span style=display:flex><span>                            volumetricFog.intensity.<span style=color:#66d9ef>value</span>,
</span></span><span style=display:flex><span>                            volumetricFog.maxTransmittance.<span style=color:#66d9ef>value</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, froxelKernel,
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.x / x),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.y / y),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.z / z));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ScatterFog(CommandBuffer cmd, RenderTexture froxelid, RenderTargetIdentifier scatterid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> scatterKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;ScatterMain&#34;</span>);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(scatterKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, scatterKernel, <span style=color:#e6db74>&#34;_FroxelTexture&#34;</span>, froxelid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, scatterKernel, <span style=color:#e6db74>&#34;_RW_ScatterTexture&#34;</span>, scatterid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, scatterKernel,
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.x / x),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.y / y),
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CompositeVolumetricFog(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier depthid, RenderTargetIdentifier scatterid, RenderTargetIdentifier compositeid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> compositeKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;CompositeMain&#34;</span>);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(compositeKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_ColorTexture&#34;</span>, colorid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_DepthTexture&#34;</span>, depthid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_ScatterTexture&#34;</span>, scatterid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_RW_CompositeTexture&#34;</span>, compositeid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, compositeKernel,
</span></span><span style=display:flex><span>                Mathf.CeilToInt(colorTextureSize.x / x),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(colorTextureSize.y / y),
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.Blit(compositeid, colorid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            EnsureRT(<span style=color:#66d9ef>ref</span> froxelTextures, cubeDesc);
</span></span><span style=display:flex><span>            RenderTexture froxelReadTex = froxelTextures[flipReadWrite];
</span></span><span style=display:flex><span>            RenderTexture froxelWriteTex = froxelTextures[<span style=color:#ae81ff>1</span> - flipReadWrite];
</span></span><span style=display:flex><span>            flipReadWrite = <span style=color:#ae81ff>1</span> - flipReadWrite;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, froxelSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                GenerateFroxel(cmd, renderingData.cameraData, cameraDepthAttachmentIden, froxelReadTex, froxelWriteTex, volumetricFogComputeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, scatterSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                ScatterFog(cmd, froxelWriteTex, scatterTextureIden, volumetricFogComputeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, compositeSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                CompositeVolumetricFog(cmd, cameraColorIden, cameraDepthAttachmentIden,
</span></span><span style=display:flex><span>                    scatterTextureIden, compositeTextureIden, volumetricFogComputeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
</span></span><span style=display:flex><span>        {        
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(scatterTextureID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(compositeTextureID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=volumetricfogcomputeshadercompute>VolumetricFogComputeShader.compute<a hidden class=anchor aria-hidden=true href=#volumetricfogcomputeshadercompute>#</a></h3><p>é‡å¤´æˆæ¥äº†ï¼Œè¿™ä¸ªCompute Shaderä¸€å…±æœ‰3ä¸ªkernelã€‚ç¬¬ä¸€ä¸ªç”¨æ¥é€šè¿‡é›¾çš„ä¿¡æ¯å’Œé˜´å½±çš„ä¿¡æ¯è®¡ç®—å…‰ç…§å¹¶å‚¨å­˜åˆ°<code>_RW_FroxelTexture</code>ä¸­ï¼ŒåŒæ—¶ä¹Ÿåšäº†è‡ªèº«çš„å’Œå†å²çš„æ··åˆï¼Œä¹Ÿå¯¹TAAåšäº†é€‚é…ã€‚ç¬¬äºŒä¸ªç”¨æ¥åšçº¹ç†ç©ºé—´çš„Ray Marchingï¼Œè®¡ç®—æ•£å°„çš„é¢œè‰²å’Œé€å…‰ç‡ã€‚ç¬¬ä¸‰ä¸ªå…¶å®æ˜¯ä¸€ä¸ªå±å¹•åå¤„ç†çš„æ•ˆæœï¼Œå°†é›¾æ•ˆç”»åˆ°å±å¹•ä¸Šï¼Œå½“åœ¨ç‰©ä»¶shaderä¸­è®¡ç®—é›¾æ•ˆæ—¶ï¼Œå°±ä¸éœ€è¦è¿™ä¸ªkerneläº†ã€‚</p><p><code>GetDepth</code>æ˜¯å°†çº¹ç†çš„zè½¬æ¢åˆ°è§†ç©ºé—´çš„çº¿æ€§æ·±åº¦(Linear Eye Depth)ï¼Œ<code>GetRatio</code>åˆ™æ˜¯ç›¸åï¼ŒæŠŠçº¿æ€§çš„è§†ç©ºé—´çš„æ·±åº¦è½¬æ¢åˆ°çº¹ç†çš„zåæ ‡ï¼Œ NOT_SIMPLIFIEDè¿™ä¸ªå®å¯ä»¥è®©äººæ›´å¥½çš„ç†è§£æŒ‡æ•°å‹åˆ†å¸ƒçš„è®¡ç®—è¿‡ç¨‹ã€‚</p><p>ä¸ºäº†ç®€åŒ–é—®é¢˜ï¼Œè¿™è¾¹åªè€ƒè™‘äº†ä¸»å…‰æºä½¿ç”¨è”çº§é˜´å½±æ—¶çš„ä½“ç§¯é›¾æ•ˆæœï¼Œä¹Ÿæ²¡æœ‰è€ƒè™‘é›†æˆSHæ¥è®¡ç®—å…¨å±€å…‰ç…§å¯¹ä½“ç§¯é›¾çš„å½±å“ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel FroxelMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel ScatterMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel CompositeMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _MAIN_LIGHT_SHADOWS</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _MAIN_LIGHT_SHADOWS_CASCADE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _SHADOWS_SOFT</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _DepthTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ColorTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _FroxelTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ScatterTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_FroxelTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_ScatterTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_CompositeTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_LinearClamp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_PointClamp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _ColorTextureSize;
</span></span><span style=display:flex><span><span style=color:#75715e>//float4 _InvColorTextureSize;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _FroxelTextureSize;
</span></span><span style=display:flex><span><span style=color:#75715e>//float4 _InvFroxelTextureSize;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _StepCount;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _NearFar;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _FogTint;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _VolumetricFogParams;
</span></span><span style=display:flex><span><span style=color:#75715e>// x: cam near, y: cam far, z: fog near, w: fog far</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _Phase _VolumetricFogParams.x</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _Density _VolumetricFogParams.y</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _Intensity _VolumetricFogParams.z</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _MaxTransmittance _VolumetricFogParams.w</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TAAOffsets;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4x4</span> _LastViewProj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> NDCToWorld(<span style=color:#66d9ef>float3</span> ndc)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ndc.xy <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0f</span> <span style=color:#f92672>*</span> ndc.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>    ndc.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>ndc.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> invJitteredVP <span style=color:#f92672>=</span> UNITY_MATRIX_I_VP;<span style=color:#75715e>//mul(UNITY_MATRIX_I_V, _InvJitteredProj);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionWS <span style=color:#f92672>=</span> mul(invJitteredVP, <span style=color:#66d9ef>float4</span>(ndc, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> positionWS.xyz <span style=color:#f92672>/</span> positionWS.w;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> Linear01DepthToRawDepth(<span style=color:#66d9ef>float</span> z, <span style=color:#66d9ef>float4</span> zBufferParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (rcp(z) <span style=color:#f92672>-</span> zBufferParams.y) <span style=color:#f92672>/</span> zBufferParams.x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> LinearEyeToRawDepth(<span style=color:#66d9ef>float</span> depth, <span style=color:#66d9ef>float4</span> zBufferParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> depth <span style=color:#f92672>-</span> zBufferParams.w) <span style=color:#f92672>/</span> zBufferParams.z;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetDepth(<span style=color:#66d9ef>float2</span> camNearFar, <span style=color:#66d9ef>float2</span> vfNearFar, <span style=color:#66d9ef>float</span> ratio)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#if NOT_SIMPLIFIED</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> lerp(valLeft, valRight, ratio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal <span style=color:#f92672>=</span> camNearFar.x <span style=color:#f92672>*</span> exp(val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> depthVal;
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> lerp(valLeft, valRight, ratio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal <span style=color:#f92672>=</span> exp(val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> depthVal;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetRatio(<span style=color:#66d9ef>float2</span> camNearFar, <span style=color:#66d9ef>float2</span> vfNearFar, <span style=color:#66d9ef>float</span> linearDepth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#if NOT_SIMPLIFIED</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> log(linearDepth <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> (val <span style=color:#f92672>-</span> valLeft) <span style=color:#f92672>/</span> (valRight <span style=color:#f92672>-</span> valLeft);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ratio;
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> log(linearDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> (val <span style=color:#f92672>-</span> valLeft) <span style=color:#f92672>/</span> (valRight <span style=color:#f92672>-</span> valLeft);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ratio;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> HGPhaseFunction(<span style=color:#66d9ef>float</span> g, <span style=color:#66d9ef>float</span> cosTheta)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> g2 <span style=color:#f92672>=</span> g <span style=color:#f92672>*</span> g;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> denominator <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>+</span> g2 <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> g <span style=color:#f92672>*</span> cosTheta;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.25</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> g2) <span style=color:#f92672>*</span> rsqrt(denominator <span style=color:#f92672>*</span> denominator <span style=color:#f92672>*</span> denominator);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> GetFogColor(<span style=color:#66d9ef>float3</span> color, <span style=color:#66d9ef>float3</span> lightDir, <span style=color:#66d9ef>float3</span> viewDir, <span style=color:#66d9ef>float</span> g)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> cosVal <span style=color:#f92672>=</span> dot(<span style=color:#f92672>-</span>lightDir, viewDir);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> color <span style=color:#f92672>*</span> HGPhaseFunction(g, cosVal);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> Hash13(<span style=color:#66d9ef>float3</span> p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> frac(p <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1031</span>);
</span></span><span style=display:flex><span>    p <span style=color:#f92672>+=</span> dot(p, p.zyx <span style=color:#f92672>+</span> <span style=color:#ae81ff>31.32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> frac((p.x <span style=color:#f92672>+</span> p.y) <span style=color:#f92672>*</span> p.z);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> FroxelMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> texcoord <span style=color:#f92672>=</span> (id.xy <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>/</span> _FroxelTextureSize.xy;
</span></span><span style=display:flex><span>    texcoord <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> _TAAOffsets.xy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> jitter <span style=color:#f92672>=</span> Hash13(<span style=color:#66d9ef>float3</span>(texcoord, _Time.y <span style=color:#f92672>*</span> id.z));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> (id.z <span style=color:#f92672>+</span> jitter) <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ratio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rawDepth <span style=color:#f92672>=</span> LinearEyeToRawDepth(depthVal, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(texcoord, rawDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionWS <span style=color:#f92672>=</span> NDCToWorld(positionNDC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewDir <span style=color:#f92672>=</span> normalize(GetCameraPositionWS() <span style=color:#f92672>-</span> positionWS); 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> shadowCoord <span style=color:#f92672>=</span> TransformWorldToShadowCoord(positionWS);   
</span></span><span style=display:flex><span>    Light mainLight <span style=color:#f92672>=</span> GetMainLight(shadowCoord);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> lightColor <span style=color:#f92672>=</span> mainLight.color <span style=color:#f92672>*</span> mainLight.shadowAttenuation;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> lightDir <span style=color:#f92672>=</span> mainLight.direction;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> fogColor <span style=color:#f92672>=</span> GetFogColor(lightColor, lightDir, viewDir, _Phase);
</span></span><span style=display:flex><span>    fogColor <span style=color:#f92672>+=</span> _FogTint.rgb <span style=color:#f92672>*</span> _FogTint.a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> density <span style=color:#f92672>=</span> _Density;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> finalFroxel <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(fogColor, density);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reprojection Temporal Filter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ujRatio <span style=color:#f92672>=</span> (id.z <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ujDepthVal <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ujRatio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ujRawDepth <span style=color:#f92672>=</span> LinearEyeToRawDepth(ujDepthVal, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> ujPositionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(texcoord, ujRawDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> ujPositionWS <span style=color:#f92672>=</span> NDCToWorld(ujPositionNDC);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> lastPositionCS <span style=color:#f92672>=</span> mul(_LastViewProj, <span style=color:#66d9ef>float4</span>(ujPositionWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>    lastPositionCS <span style=color:#f92672>/=</span> lastPositionCS.w;
</span></span><span style=display:flex><span>    lastPositionCS.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>lastPositionCS.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> lastNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(lastPositionCS.xy <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>, lastPositionCS.z);
</span></span><span style=display:flex><span>    lastNDC.xy <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> _TAAOffsets.zw;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(all(lastNDC <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0</span>) <span style=color:#f92672>&amp;&amp;</span> all(lastNDC <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1.0f</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> linearEyeDepth <span style=color:#f92672>=</span> LinearEyeDepth(lastNDC.z, _ZBufferParams);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> reprojRatio <span style=color:#f92672>=</span> GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> froxelTex <span style=color:#f92672>=</span> _FroxelTexture.SampleLevel(sampler_LinearClamp, <span style=color:#66d9ef>float3</span>(lastNDC.xy, reprojRatio), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        finalFroxel <span style=color:#f92672>=</span> lerp(finalFroxel, froxelTex, <span style=color:#ae81ff>0.95</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_FroxelTexture[id] <span style=color:#f92672>=</span> finalFroxel;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> SliceThickness(<span style=color:#66d9ef>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratioThis <span style=color:#f92672>=</span> z <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthThis <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ratioThis);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratioNext <span style=color:#f92672>=</span> (z<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthNext <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ratioNext);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> depthNext <span style=color:#f92672>-</span> depthThis;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> AccumScatter(<span style=color:#66d9ef>int</span> z, <span style=color:#66d9ef>float4</span> accum, <span style=color:#66d9ef>float4</span> slice)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    slice.a <span style=color:#f92672>=</span> max(slice.a, <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> thickness <span style=color:#f92672>=</span> SliceThickness(z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> sliceTransmittance <span style=color:#f92672>=</span> exp(<span style=color:#f92672>-</span>slice.a <span style=color:#f92672>*</span> thickness <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.01f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> sliceScattering <span style=color:#f92672>=</span> slice.rgb <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> sliceTransmittance);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> accumScattering <span style=color:#f92672>=</span> accum.rgb <span style=color:#f92672>+</span> sliceScattering <span style=color:#f92672>*</span> accum.a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> accumTransmittance <span style=color:#f92672>=</span> accum.a <span style=color:#f92672>*</span> sliceTransmittance;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(accumScattering, accumTransmittance);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ScatterMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> accum <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> z<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; z<span style=color:#f92672>&lt;</span>_FroxelTextureSize.z; z<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int3</span> coord <span style=color:#f92672>=</span> <span style=color:#66d9ef>int3</span>(id.xy, z);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> slice <span style=color:#f92672>=</span> _FroxelTexture[coord];
</span></span><span style=display:flex><span>        accum <span style=color:#f92672>=</span> AccumScatter(z, accum, slice);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//_RW_ScatterTexture[coord] = slice;</span>
</span></span><span style=display:flex><span>        _RW_ScatterTexture[coord] <span style=color:#f92672>=</span> accum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CompositeMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> texcoord <span style=color:#f92672>=</span> (id.xy <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> rcp(_ColorTextureSize.xy);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> colorTex <span style=color:#f92672>=</span> _ColorTexture.SampleLevel(sampler_PointClamp, texcoord, <span style=color:#ae81ff>0</span>).rgb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthTex <span style=color:#f92672>=</span> _DepthTexture.SampleLevel(sampler_PointClamp, texcoord, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> linearEyeDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthTex, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> froxelTex <span style=color:#f92672>=</span> _ScatterTexture.SampleLevel(sampler_LinearClamp, <span style=color:#66d9ef>float3</span>(texcoord, ratio), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> accumScatter <span style=color:#f92672>=</span> froxelTex.rgb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> accumTrans <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> _MaxTransmittance, froxelTex.a);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> finalColor <span style=color:#f92672>=</span> colorTex <span style=color:#f92672>*</span> accumTrans <span style=color:#f92672>+</span> froxelTex.rgb;
</span></span><span style=display:flex><span>    finalColor <span style=color:#f92672>=</span> lerp(colorTex.rgb, finalColor, _Intensity);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_CompositeTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(finalColor, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>å¥½ä¹…æ²¡æœ‰å†™æ–°çš„åšå®¢å•¦ï¼Œä¹‹å‰ä¸€ç›´åœ¨å­¦c++ï¼Œä¸æ€ä¹ˆæœ‰æ—¶é—´åšæ–°çš„ä¸œè¥¿ã€‚ä½“ç§¯é›¾è¿˜æ˜¯ä¸€ä¸ªè›®é‡è¦çš„æ•ˆæœï¼Œä¹‹å‰åšRay Marchingçš„æ—¶å€™è€æ˜¯æŠŠæ¡ä¸ä½è¯¥æ­¥è¿›å¤šå°‘ï¼Œç”¨äº†æŒ‡æ•°å‹çš„æ­¥è¿›ä¹‹åå°±æ„Ÿè§‰è±ç„¶å¼€æœ—äº†ã€‚TAAå…¶å®ä¹Ÿåšäº†ä¸€ç‰ˆæ–°çš„ï¼Œè¿˜æ²¡æ¥å¾—åŠå†™ï¼ŒGTAOä¹Ÿå­¦äº†ä¸€éï¼Œå°±ä¹‹åå†è¯´å§ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/volumetric-fog/>Volumetric Fog</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-ray-marching/><span class=title>Â« Prev</span><br><span>ä½¿ç”¨Ray Marchingæ¥æ¸²æŸ“ä½“ç§¯é›¾</span>
</a><a class=next href=https://zznewclear13.github.io/posts/get-view-space-normal-from-depth-texture/><span class=title>Next Â»</span><br><span>ä»æ·±åº¦å›¾ä¸­è·å–è§†ç©ºé—´çš„æ³•çº¿</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>