<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用和视锥体对齐的3D纹理来渲染体积雾 | ZZNEWCLEAR13</title>
<meta name=keywords content="Volumetric Fog,Compute Shader"><meta name=description content="使用3D纹理和Compute Shader来渲染体积雾."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5",{anonymize_ip:!1})}</script><meta property="og:title" content="使用和视锥体对齐的3D纹理来渲染体积雾"><meta property="og:description" content="使用3D纹理和Compute Shader来渲染体积雾."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"><meta property="og:image" content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-23T12:00:00+08:00"><meta property="article:modified_time" content="2022-08-23T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg"><meta name=twitter:title content="使用和视锥体对齐的3D纹理来渲染体积雾"><meta name=twitter:description content="使用3D纹理和Compute Shader来渲染体积雾."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用和视锥体对齐的3D纹理来渲染体积雾","item":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用和视锥体对齐的3D纹理来渲染体积雾","name":"使用和视锥体对齐的3D纹理来渲染体积雾","description":"使用3D纹理和Compute Shader来渲染体积雾.","keywords":["Volumetric Fog","Compute Shader"],"articleBody":"为什么要渲染体积雾 因为它就在那里。\n当然了，更重要的是因为体积雾能迅速的营造出场景的真实感与氛围感，谁不喜欢光源边上还有一小圈光晕呢，如果什么高亮的物体都能影响体积雾的话，是不是就不太需要bloom效果了呢。我实际地在生活中观察了一下，发现人眼所看到的光晕的效果，是光线进入眼睛之后产生的，也就是说bloom和体积雾确确实实是两种不同的效果。\n体积雾的渲染方法 体积雾一般有两种渲染方法，一种是单纯的从相机出发对场景进行Ray Marching，每次进行采样和混合。这种方法主要的缺点是Ray Marching的次数会比较高才能有较好的渲染效果。在我的测试中，开启TAA的时候，20次Ray Marching就能得到很好的体积雾效果了；但是不开启TAA的话，可能会需要60次甚至更高的Ray Marching才能得到和TAA类似的效果。同时，Ray Marching体积雾只能在后处理阶段使用，在处理不写深度的透明物体的时候，会有一些瑕疵。\n另一种方法就是使用一张3D纹理，将整个场景的体积雾储存在这张3D纹理中，当绘制物体的时候使用物体的世界空间坐标采样这张3D纹理，直接在片元着色器中计算雾效之后的颜色。这种方法使用的3D纹理会占用更多的内存，但是一定程度上能够正确的渲染所有物体，和60次Ray Marching相比，性能上也说不定会有一些优势。\n本文的体积雾实现，参考了EA的寒霜引擎在Siggraph 2015年时的演讲和diharaw的OpenGL的体积雾效果。值得一看的还有Bart Wronski在Siggraph 2014年的演讲，以及之后的荒野大镖客在Siggraph 2019年的课程。使用的是Unity2019.4.29的URP工程。\n具体的实现方法 将场景中的需要渲染的雾的信息和阴影信息储存到一张和相机的视锥体对齐的3D纹理中。按照寒霜引擎的做法，纹理大小为(分辨率宽/8)x(分辨率高/8)x64，这样就和屏幕大小的2D纹理占用的内存大小一致了，但我看Unity官方的体积雾工程中，3D纹理的深度为128，就也把自己的设置成128了，纹理深度越深，体积雾的细节就能越高。3D纹理的宽高和视锥体对齐，这很好理解，而这张贴图的纵向深度和实际的深度要怎么对齐呢？最简单的就是和视空间的深度线性对应，但是这会导致近处体积雾的分辨率不够；另一种是和裁剪空间的深度线性对应，经过一些分析可以知道这比之前的方法更糟糕；目前我看下来最好的应该是和视空间的深度指数型对应，这样离相机越近3D纹理的像素会越多，越远则越少。本文只使用了均一的雾，但是可以使用世界空间的坐标、噪波和一系列的运算，计算出某一点的体积雾的浓度。 使用上面的雾的信息和阴影信息计算出散射的值Lscat，从下面的图可以看到Lscat是对所有的光源（本文只有主光源）计算\\(f(v, l)Vis(x, l)Li(x, l)\\)的和，\\(Vis(x, l)\\)即为在x点l光的可见性，可以通过采样阴影贴图来获得，\\(Li(x, l)\\)即为在x点l光的光强，可以简单的计算获得，\\(f(v, l)\\)用来表述在v的方向观察雾时得到l的散射量，一般被叫做Phase Function，我们使用的是Henyey-Greenstein Phase Function，其中参数g是雾的各向异性的程度，越靠近1表示光线穿过雾时越保持之前的方向，越靠近0表示光线穿过雾时均匀的散射，越靠近-1表示光线穿过雾时越会进行反射（在实际的光照中，我们会去掉\\(\\pi\\)这一项，这样能和Unity的光照模型保持一致）。时空混合也在这一步可以完成。 $$ \\tag{Henyey-Greenstein} p(\\theta) = \\frac 1 {4\\pi} \\frac {1 - g^2} {(1 + g^2 - 2g \\cos \\theta)^{\\frac 3 2}} $$\n对3D纹理从相机近点到远点进行混合，这其实是一种Ray Marching，不过是在3D纹理的纹理空间进行Ray Marching，一次前进一个像素。当混合当前像素和上一个像素时，需要考虑符合物理的透光率(transmittance), \\(\\varepsilon\\)是一个用于归一化的常量，l是两点之间的距离，c是介质的吸收率（一定程度上可以用雾的密度来表示）。具体的混合的计算和说明可以看EA寒霜引擎的PPT第28、29页。 $$ \\tag{Beer-Lambert} transmittance = e^{-\\varepsilon l c} $$\n最终在绘制物体时，使用物体的世界空间的坐标，转换到3D纹理的坐标，采样3D纹理，使用透光率乘上物体本身的颜色，再加上雾的颜色，就得到了最终的体积雾的效果了。 相关代码和说明 VolumetricFog.cs 用于Global Volume中方便添加体积雾和控制各种参数。值得考虑的是maxTransmittance的值，因为相机远裁剪面会比较远，即使雾并不是很大，在最远处也总是能变成单一的颜色，这个值用来防止这种情况，人为地限制了最大不透光率（但是还是叫maxTransmittance）。fogNear这个参数实际是影响了3D纹理和相机之间的距离，最好还是设置成0，不然时空混合时会有一些瑕疵。\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"Post-processing/Volumetric Fog\")] public class VolumetricFog : VolumeComponent, IPostProcessComponent { [Tooltip(\"是否启用体积雾\")] public BoolParameter enabled = new BoolParameter(false); [Tooltip(\"整体控制体积雾强度\")] public ClampedFloatParameter intensity = new ClampedFloatParameter(1.0f, 0f, 1.0f); [Tooltip(\"体积雾最大的透明程度（用于和天空混合）\")] public ClampedFloatParameter maxTransmittance = new ClampedFloatParameter(1.0f, 0f, 1.0f); [Tooltip(\"体积雾的颜色倾向，目前强度为0.03\")] public ColorParameter fogTint = new ColorParameter(Color.white); [Tooltip(\"体积雾距离相机最近的距离\")] public ClampedFloatParameter fogNear = new ClampedFloatParameter(0.1f, 0.01f, 10f); [Tooltip(\"体积雾距离相机最远的距离\")] public ClampedFloatParameter fogFar = new ClampedFloatParameter(100f, 1.0f, 1000.0f); [Tooltip(\"体积雾的密度，越密效果越明显\")] public ClampedFloatParameter density = new ClampedFloatParameter(3.0f, 0f, 10.0f); [Tooltip(\"体积雾受光的各向异性程度\")] public ClampedFloatParameter phase = new ClampedFloatParameter(0.0f, -0.9f, 0.9f); public bool IsActive() =\u003e (enabled.value \u0026\u0026 (density.value \u003e 0.0f) \u0026\u0026 (intensity.value \u003e 0.0f)); public bool IsTileCompatible() =\u003e false; } } VolumetricFogRendererFeature.cs 平平常常的RendererFeature，事实上RenderPassEvent应该在DepthPrePass之后，但我没改物体的shader，就放在后处理之前了。\nnamespace UnityEngine.Rendering.Universal { public class VolumetricFogRendererFeature : ScriptableRendererFeature { [System.Serializable] public class VolumetricFogSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader volumetricFogComputeShader; } private VolumetricFogRenderPass volumetricFogRenderPass; public VolumetricFogSettings volumetricFogSettings = new VolumetricFogSettings(); public override void Create() { volumetricFogRenderPass = new VolumetricFogRenderPass(volumetricFogSettings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { if (renderingData.cameraData.cameraType == CameraType.Game) { VolumetricFog volumetricFog = VolumeManager.instance.stack.GetComponent(); if (volumetricFog \u0026\u0026 volumetricFog.IsActive()) { volumetricFogRenderPass.Setup(volumetricFog); renderer.EnqueuePass(volumetricFogRenderPass); } } } } } VolumetricFogRenderPass.cs 平平常常的RenderPass，实际使用的时候，只会用到Froxel Generate Pass和Scatter Pass，Composite Pass完全可以用物件本身的渲染来代替。\nnamespace UnityEngine.Rendering.Universal { public class VolumetricFogRenderPass : ScriptableRenderPass { private const string profilerTag = \"Volumetric Fog Pass\"; private ProfilingSampler profilingSampler; private ProfilingSampler froxelSampler = new ProfilingSampler(\"Froxel Generate Pass\"); private ProfilingSampler scatterSampler = new ProfilingSampler(\"Scatter Pass\"); private ProfilingSampler compositeSampler = new ProfilingSampler(\"Composite Pass\"); private RenderTargetHandle cameraColor; private RenderTargetIdentifier cameraColorIden; private RenderTargetHandle cameraDepth; private RenderTargetIdentifier cameraDepthIden; private RenderTargetHandle cameraDepthAttachment; private RenderTargetIdentifier cameraDepthAttachmentIden; private VolumetricFog volumetricFog; private ComputeShader volumetricFogComputeShader; private VolumetricFogRendererFeature.VolumetricFogSettings settings; private RenderTexture[] froxelTextures; private RenderTextureDescriptor cubeDesc; private static readonly string froxelTextureOneName = \"_FroxelBufferOne\"; private static readonly int froxelTextureOneID = Shader.PropertyToID(froxelTextureOneName); private RenderTargetHandle froxelTextureOneHandle; private RenderTargetIdentifier froxelTextureOneIden; private static readonly string froxelTextureTwoName = \"_FroxelBufferTwo\"; private static readonly int froxelTextureTwoID = Shader.PropertyToID(froxelTextureTwoName); private RenderTargetHandle froxelTextureTwoHandle; private RenderTargetIdentifier froxelTextureTwoIden; private static readonly string scatterTextureName = \"_ScatterBuffer\"; private static readonly int scatterTextureID = Shader.PropertyToID(scatterTextureName); private RenderTargetHandle scatterTextureHandle; private RenderTargetIdentifier scatterTextureIden; private static readonly string compositeTextureName = \"_CompositeBuffer\"; private static readonly int compositeTextureID = Shader.PropertyToID(compositeTextureName); private RenderTargetHandle compositeTextureHandle; private RenderTargetIdentifier compositeTextureIden; private Vector2 colorTextureSize; private Vector2 invColorTextureSize; private Vector3 froxelTextureSize; private Vector3 invFroxelTextureSize; private Matrix4x4 lastViewProjMatrix; private int flipReadWrite = 0; public VolumetricFogRenderPass(VolumetricFogRendererFeature.VolumetricFogSettings settings) { this.settings = settings; profilingSampler = new ProfilingSampler(profilerTag); renderPassEvent = settings.renderPassEvent; volumetricFogComputeShader = settings.volumetricFogComputeShader; cameraColor.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColor.Identifier(); cameraDepth.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepth.Identifier(); cameraDepthAttachment.Init(\"_CameraDepthAttachment\"); cameraDepthAttachmentIden = cameraDepthAttachment.Identifier(); froxelTextureOneHandle.Init(froxelTextureOneName); froxelTextureOneIden = froxelTextureOneHandle.Identifier(); froxelTextureTwoHandle.Init(froxelTextureTwoName); froxelTextureTwoIden = froxelTextureTwoHandle.Identifier(); scatterTextureHandle.Init(scatterTextureName); scatterTextureIden = scatterTextureHandle.Identifier(); compositeTextureHandle.Init(compositeTextureName); compositeTextureIden = compositeTextureHandle.Identifier(); lastViewProjMatrix = Matrix4x4.identity; } public void Setup(VolumetricFog volumetricFog) { this.volumetricFog = volumetricFog; } private static void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } private static void EnsureRenderTexture(ref RenderTexture rt, RenderTextureDescriptor descriptor, string RTName) { if (rt != null \u0026\u0026 (rt.width != descriptor.width || rt.height != descriptor.height)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { RenderTextureDescriptor desc = descriptor; desc.depthBufferBits = 0; desc.msaaSamples = 1; rt = RenderTexture.GetTemporary(desc); //rt = new RenderTexture(desc); rt.name = RTName; if (!rt.IsCreated()) rt.Create(); } } public static void EnsureRT(ref RenderTexture[] froxelTexs, RenderTextureDescriptor descriptor) { EnsureArray(ref froxelTexs, 2); EnsureRenderTexture(ref froxelTexs[0], descriptor, \"Froxel Tex One\"); EnsureRenderTexture(ref froxelTexs[1], descriptor, \"Froxel Tex Two\"); } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; cmd.GetTemporaryRT(compositeTextureID, desc); colorTextureSize = new Vector2(desc.width, desc.height); invColorTextureSize = new Vector2(1.0f / desc.width, 1.0f / desc.height); int width = desc.width / 8; int height = desc.height / 8; int volmeDepth = 128; cubeDesc = new RenderTextureDescriptor( width, height, Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat, 0); cubeDesc.volumeDepth = volmeDepth; cubeDesc.dimension = TextureDimension.Tex3D; cubeDesc.enableRandomWrite = true; froxelTextureSize = new Vector3(width, height, volmeDepth); invFroxelTextureSize = new Vector3(1.0f / (width-0), 1.0f / (height-0), 1.0f / (volmeDepth-0)); cmd.GetTemporaryRT(scatterTextureID, cubeDesc); } private void GenerateFroxel(CommandBuffer cmd, CameraData camData, RenderTargetIdentifier depthid, RenderTexture froxelReadid, RenderTexture froxelWriteid, ComputeShader computeShader) { int froxelKernel = computeShader.FindKernel(\"FroxelMain\"); computeShader.GetKernelThreadGroupSizes(froxelKernel, out uint x, out uint y, out uint z); cmd.SetComputeVectorParam(computeShader, \"_FroxelTextureSize\", froxelTextureSize); cmd.SetComputeVectorParam(computeShader, \"_ColorTextureSize\", colorTextureSize); cmd.SetComputeMatrixParam(computeShader, \"_LastViewProj\", lastViewProjMatrix); Matrix4x4 projMat = camData.GetGPUProjectionMatrix(); Matrix4x4 viewMat = camData.GetViewMatrix(); lastViewProjMatrix = projMat * viewMat; cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_DepthTexture\", depthid); cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_FroxelTexture\", froxelReadid); cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_RW_FroxelTexture\", froxelWriteid); Color fogTint = volumetricFog.fogTint.value; fogTint.a = 0.03f; volumetricFog.fogTint.Override(fogTint); cmd.SetComputeVectorParam(computeShader, \"_FogTint\", volumetricFog.fogTint.value); cmd.SetComputeVectorParam(computeShader, \"_NearFar\", new Vector4(camData.camera.nearClipPlane, camData.camera.farClipPlane, volumetricFog.fogNear.value, volumetricFog.fogFar.value)); cmd.SetComputeVectorParam(computeShader, \"_VolumetricFogParams\", new Vector4(volumetricFog.phase.value, volumetricFog.density.value, volumetricFog.intensity.value, volumetricFog.maxTransmittance.value)); cmd.DispatchCompute(computeShader, froxelKernel, Mathf.CeilToInt(froxelTextureSize.x / x), Mathf.CeilToInt(froxelTextureSize.y / y), Mathf.CeilToInt(froxelTextureSize.z / z)); } private void ScatterFog(CommandBuffer cmd, RenderTexture froxelid, RenderTargetIdentifier scatterid, ComputeShader computeShader) { int scatterKernel = computeShader.FindKernel(\"ScatterMain\"); computeShader.GetKernelThreadGroupSizes(scatterKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, scatterKernel, \"_FroxelTexture\", froxelid); cmd.SetComputeTextureParam(computeShader, scatterKernel, \"_RW_ScatterTexture\", scatterid); cmd.DispatchCompute(computeShader, scatterKernel, Mathf.CeilToInt(froxelTextureSize.x / x), Mathf.CeilToInt(froxelTextureSize.y / y), 1); } private void CompositeVolumetricFog(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier depthid, RenderTargetIdentifier scatterid, RenderTargetIdentifier compositeid, ComputeShader computeShader) { int compositeKernel = computeShader.FindKernel(\"CompositeMain\"); computeShader.GetKernelThreadGroupSizes(compositeKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_ColorTexture\", colorid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_DepthTexture\", depthid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_ScatterTexture\", scatterid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_RW_CompositeTexture\", compositeid); cmd.DispatchCompute(computeShader, compositeKernel, Mathf.CeilToInt(colorTextureSize.x / x), Mathf.CeilToInt(colorTextureSize.y / y), 1); cmd.Blit(compositeid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); EnsureRT(ref froxelTextures, cubeDesc); RenderTexture froxelReadTex = froxelTextures[flipReadWrite]; RenderTexture froxelWriteTex = froxelTextures[1 - flipReadWrite]; flipReadWrite = 1 - flipReadWrite; using (new ProfilingScope(cmd, froxelSampler)) { GenerateFroxel(cmd, renderingData.cameraData, cameraDepthAttachmentIden, froxelReadTex, froxelWriteTex, volumetricFogComputeShader); } using (new ProfilingScope(cmd, scatterSampler)) { ScatterFog(cmd, froxelWriteTex, scatterTextureIden, volumetricFogComputeShader); } using (new ProfilingScope(cmd, compositeSampler)) { CompositeVolumetricFog(cmd, cameraColorIden, cameraDepthAttachmentIden, scatterTextureIden, compositeTextureIden, volumetricFogComputeShader); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(scatterTextureID); cmd.ReleaseTemporaryRT(compositeTextureID); } } } VolumetricFogComputeShader.compute 重头戏来了，这个Compute Shader一共有3个kernel。第一个用来通过雾的信息和阴影的信息计算光照并储存到_RW_FroxelTexture中，同时也做了自身的和历史的混合，也对TAA做了适配。第二个用来做纹理空间的Ray Marching，计算散射的颜色和透光率。第三个其实是一个屏幕后处理的效果，将雾效画到屏幕上，当在物件shader中计算雾效时，就不需要这个kernel了。\nGetDepth是将纹理的z转换到视空间的线性深度(Linear Eye Depth)，GetRatio则是相反，把线性的视空间的深度转换到纹理的z坐标， NOT_SIMPLIFIED这个宏可以让人更好的理解指数型分布的计算过程。\n为了简化问题，这边只考虑了主光源使用联级阴影时的体积雾效果，也没有考虑集成SH来计算全局光照对体积雾的影响。\n#pragma kernel FroxelMain #pragma kernel ScatterMain #pragma kernel CompositeMain #define _MAIN_LIGHT_SHADOWS #define _MAIN_LIGHT_SHADOWS_CASCADE #define _SHADOWS_SOFT #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" Texture2D\u003cfloat\u003e _DepthTexture; Texture2D\u003cfloat4\u003e _ColorTexture; Texture3D\u003cfloat4\u003e _FroxelTexture; Texture3D\u003cfloat4\u003e _ScatterTexture; RWTexture3D\u003cfloat4\u003e _RW_FroxelTexture; RWTexture3D\u003cfloat4\u003e _RW_ScatterTexture; RWTexture2D\u003cfloat4\u003e _RW_CompositeTexture; SamplerState sampler_LinearClamp; SamplerState sampler_PointClamp; float4 _ColorTextureSize; //float4 _InvColorTextureSize; float4 _FroxelTextureSize; //float4 _InvFroxelTextureSize; float _StepCount; float4 _NearFar; float4 _FogTint; float4 _VolumetricFogParams; // x: cam near, y: cam far, z: fog near, w: fog far #define _Phase _VolumetricFogParams.x #define _Density _VolumetricFogParams.y #define _Intensity _VolumetricFogParams.z #define _MaxTransmittance _VolumetricFogParams.w float4 _TAAOffsets; float4x4 _LastViewProj; float3 NDCToWorld(float3 ndc) { ndc.xy = 2.0f * ndc.xy - 1.0f; ndc.y = -ndc.y; float4x4 invJitteredVP = UNITY_MATRIX_I_VP;//mul(UNITY_MATRIX_I_V, _InvJitteredProj); float4 positionWS = mul(invJitteredVP, float4(ndc, 1.0f)); return positionWS.xyz / positionWS.w; } float Linear01DepthToRawDepth(float z, float4 zBufferParams) { return (rcp(z) - zBufferParams.y) / zBufferParams.x; } float LinearEyeToRawDepth(float depth, float4 zBufferParams) { return (1.0f / depth - zBufferParams.w) / zBufferParams.z; } float GetDepth(float2 camNearFar, float2 vfNearFar, float ratio) { #if NOT_SIMPLIFIED float valLeft = log(vfNearFar.x / camNearFar.x); float valRight = log(vfNearFar.y / camNearFar.x); float val = lerp(valLeft, valRight, ratio); float depthVal = camNearFar.x * exp(val); return depthVal; #else float valLeft = log(vfNearFar.x); float valRight = log(vfNearFar.y); float val = lerp(valLeft, valRight, ratio); float depthVal = exp(val); return depthVal; #endif } float GetRatio(float2 camNearFar, float2 vfNearFar, float linearDepth) { #if NOT_SIMPLIFIED float valLeft = log(vfNearFar.x / camNearFar.x); float valRight = log(vfNearFar.y / camNearFar.x); float val = log(linearDepth / camNearFar.x); float ratio = (val - valLeft) / (valRight - valLeft); return ratio; #else float valLeft = log(vfNearFar.x); float valRight = log(vfNearFar.y); float val = log(linearDepth); float ratio = (val - valLeft) / (valRight - valLeft); return ratio; #endif } float HGPhaseFunction(float g, float cosTheta) { float g2 = g * g; float denominator = 1.0f + g2 - 2 * g * cosTheta; return 0.25 * (1.0f - g2) * rsqrt(denominator * denominator * denominator); } float3 GetFogColor(float3 color, float3 lightDir, float3 viewDir, float g) { float cosVal = dot(-lightDir, viewDir); return color * HGPhaseFunction(g, cosVal); } float Hash13(float3 p) { p = frac(p * 0.1031); p += dot(p, p.zyx + 31.32); return frac((p.x + p.y) * p.z); } [numthreads(8,8,8)] void FroxelMain (uint3 id : SV_DispatchThreadID) { float2 texcoord = (id.xy + 0.5f) / _FroxelTextureSize.xy; texcoord += 0.5f * _TAAOffsets.xy; float jitter = Hash13(float3(texcoord, _Time.y * id.z)); float ratio = (id.z + jitter) / _FroxelTextureSize.z; float depthVal = GetDepth(_NearFar.xy, _NearFar.zw, ratio); float rawDepth = LinearEyeToRawDepth(depthVal, _ZBufferParams); float3 positionNDC = float3(texcoord, rawDepth); float3 positionWS = NDCToWorld(positionNDC); float3 viewDir = normalize(GetCameraPositionWS() - positionWS); float4 shadowCoord = TransformWorldToShadowCoord(positionWS); Light mainLight = GetMainLight(shadowCoord); float3 lightColor = mainLight.color * mainLight.shadowAttenuation; float3 lightDir = mainLight.direction; float3 fogColor = GetFogColor(lightColor, lightDir, viewDir, _Phase); fogColor += _FogTint.rgb * _FogTint.a; float density = _Density; float4 finalFroxel = float4(fogColor, density); // Reprojection Temporal Filter float ujRatio = (id.z + 0.5) / _FroxelTextureSize.z; float ujDepthVal = GetDepth(_NearFar.xy, _NearFar.zw, ujRatio); float ujRawDepth = LinearEyeToRawDepth(ujDepthVal, _ZBufferParams); float3 ujPositionNDC = float3(texcoord, ujRawDepth); float3 ujPositionWS = NDCToWorld(ujPositionNDC); float4 lastPositionCS = mul(_LastViewProj, float4(ujPositionWS, 1.0f)); lastPositionCS /= lastPositionCS.w; lastPositionCS.y = -lastPositionCS.y; float3 lastNDC = float3(lastPositionCS.xy * 0.5 + 0.5, lastPositionCS.z); lastNDC.xy -= 0.5f * _TAAOffsets.zw; if(all(lastNDC \u003e 0.0) \u0026\u0026 all(lastNDC \u003c 1.0f)) { float linearEyeDepth = LinearEyeDepth(lastNDC.z, _ZBufferParams); float reprojRatio = GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth); float4 froxelTex = _FroxelTexture.SampleLevel(sampler_LinearClamp, float3(lastNDC.xy, reprojRatio), 0); finalFroxel = lerp(finalFroxel, froxelTex, 0.95); } _RW_FroxelTexture[id] = finalFroxel; } float SliceThickness(int z) { float ratioThis = z / _FroxelTextureSize.z; float depthThis = GetDepth(_NearFar.xy, _NearFar.zw, ratioThis); float ratioNext = (z+1.0f) / _FroxelTextureSize.z; float depthNext = GetDepth(_NearFar.xy, _NearFar.zw, ratioNext); return depthNext - depthThis; } float4 AccumScatter(int z, float4 accum, float4 slice) { slice.a = max(slice.a, 1e-5); float thickness = SliceThickness(z); float sliceTransmittance = exp(-slice.a * thickness * 0.01f); float3 sliceScattering = slice.rgb * (1.0f - sliceTransmittance); float3 accumScattering = accum.rgb + sliceScattering * accum.a; float accumTransmittance = accum.a * sliceTransmittance; return float4(accumScattering, accumTransmittance); } [numthreads(16,16,1)] void ScatterMain (uint3 id : SV_DispatchThreadID) { float4 accum = float4(0.0f, 0.0f, 0.0f, 1.0f); for (int z=0; z\u003c_FroxelTextureSize.z; z++) { int3 coord = int3(id.xy, z); float4 slice = _FroxelTexture[coord]; accum = AccumScatter(z, accum, slice); //_RW_ScatterTexture[coord] = slice; _RW_ScatterTexture[coord] = accum; } } [numthreads(16,16,1)] void CompositeMain (uint3 id : SV_DispatchThreadID) { float2 texcoord = (id.xy + 0.5f) * rcp(_ColorTextureSize.xy); float3 colorTex = _ColorTexture.SampleLevel(sampler_PointClamp, texcoord, 0).rgb; float depthTex = _DepthTexture.SampleLevel(sampler_PointClamp, texcoord, 0); float linearEyeDepth = LinearEyeDepth(depthTex, _ZBufferParams); float ratio = GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth); float4 froxelTex = _ScatterTexture.SampleLevel(sampler_LinearClamp, float3(texcoord, ratio), 0); float3 accumScatter = froxelTex.rgb; float accumTrans = max(1.0f - _MaxTransmittance, froxelTex.a); float3 finalColor = colorTex * accumTrans + froxelTex.rgb; finalColor = lerp(colorTex.rgb, finalColor, _Intensity); _RW_CompositeTexture[id.xy] = float4(finalColor, 1.0f); } 后记 好久没有写新的博客啦，之前一直在学c++，不怎么有时间做新的东西。体积雾还是一个蛮重要的效果，之前做Ray Marching的时候老是把握不住该步进多少，用了指数型的步进之后就感觉豁然开朗了。TAA其实也做了一版新的，还没来得及写，GTAO也学了一遍，就之后再说吧。\n","wordCount":"1730","inLanguage":"en","image":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg","datePublished":"2022-08-23T12:00:00+08:00","dateModified":"2022-08-23T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">使用和视锥体对齐的3D纹理来渲染体积雾</h1><div class=post-description>使用3D纹理和Compute Shader来渲染体积雾.</div><div class=post-meta><span title='2022-08-23 12:00:00 +0800 CST'>August 23, 2022</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/create-volumetric-fog-using-view-aligned-3D-texture.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/VolumetricFog.jpg alt="Volumetric Fog Cover"><p>Volumetric Fog Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>使用和视锥体对齐的3D纹理来渲染体积雾</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%b8%b2%e6%9f%93%e4%bd%93%e7%a7%af%e9%9b%be aria-label=为什么要渲染体积雾>为什么要渲染体积雾</a></li><li><a href=#%e4%bd%93%e7%a7%af%e9%9b%be%e7%9a%84%e6%b8%b2%e6%9f%93%e6%96%b9%e6%b3%95 aria-label=体积雾的渲染方法>体积雾的渲染方法</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=具体的实现方法>具体的实现方法</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81%e5%92%8c%e8%af%b4%e6%98%8e aria-label=相关代码和说明>相关代码和说明</a><ul><li><a href=#volumetricfogcs aria-label=VolumetricFog.cs>VolumetricFog.cs</a></li><li><a href=#volumetricfogrendererfeaturecs aria-label=VolumetricFogRendererFeature.cs>VolumetricFogRendererFeature.cs</a></li><li><a href=#volumetricfogrenderpasscs aria-label=VolumetricFogRenderPass.cs>VolumetricFogRenderPass.cs</a></li><li><a href=#volumetricfogcomputeshadercompute aria-label=VolumetricFogComputeShader.compute>VolumetricFogComputeShader.compute</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=为什么要渲染体积雾>为什么要渲染体积雾<a hidden class=anchor aria-hidden=true href=#为什么要渲染体积雾>#</a></h2><p>因为它就在那里。</p><p>当然了，更重要的是因为体积雾能迅速的营造出场景的真实感与氛围感，谁不喜欢光源边上还有一小圈光晕呢，如果什么高亮的物体都能影响体积雾的话，是不是就不太需要bloom效果了呢。我实际地在生活中观察了一下，发现人眼所看到的光晕的效果，是光线进入眼睛之后产生的，也就是说bloom和体积雾确确实实是两种不同的效果。</p><h2 id=体积雾的渲染方法>体积雾的渲染方法<a hidden class=anchor aria-hidden=true href=#体积雾的渲染方法>#</a></h2><p>体积雾一般有两种渲染方法，一种是单纯的从相机出发对场景进行Ray Marching，每次进行采样和混合。这种方法主要的缺点是Ray Marching的次数会比较高才能有较好的渲染效果。在我的测试中，开启TAA的时候，20次Ray Marching就能得到很好的体积雾效果了；但是不开启TAA的话，可能会需要60次甚至更高的Ray Marching才能得到和TAA类似的效果。同时，Ray Marching体积雾只能在后处理阶段使用，在处理不写深度的透明物体的时候，会有一些瑕疵。</p><p>另一种方法就是使用一张3D纹理，将整个场景的体积雾储存在这张3D纹理中，当绘制物体的时候使用物体的世界空间坐标采样这张3D纹理，直接在片元着色器中计算雾效之后的颜色。这种方法使用的3D纹理会占用更多的内存，但是一定程度上能够正确的渲染所有物体，和60次Ray Marching相比，性能上也说不定会有一些优势。</p><p>本文的体积雾实现，参考了<a href=https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite>EA的寒霜引擎在Siggraph 2015年时的演讲</a>和<a href=https://github.com/diharaw/volumetric-lighting>diharaw的OpenGL的体积雾效果</a>。值得一看的还有<a href=https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pptx>Bart Wronski在Siggraph 2014年的演讲</a>，以及之后的<a href=https://advances.realtimerendering.com/s2019/slides_public_release.pptx>荒野大镖客在Siggraph 2019年的课程</a>。使用的是Unity2019.4.29的URP工程。</p><h2 id=具体的实现方法>具体的实现方法<a hidden class=anchor aria-hidden=true href=#具体的实现方法>#</a></h2><ol><li>将场景中的需要渲染的雾的信息和阴影信息储存到一张和相机的视锥体对齐的3D纹理中。按照寒霜引擎的做法，纹理大小为(分辨率宽/8)x(分辨率高/8)x64，这样就和屏幕大小的2D纹理占用的内存大小一致了，但我看Unity官方的体积雾工程中，3D纹理的深度为128，就也把自己的设置成128了，纹理深度越深，体积雾的细节就能越高。3D纹理的宽高和视锥体对齐，这很好理解，而这张贴图的纵向深度和实际的深度要怎么对齐呢？最简单的就是和视空间的深度线性对应，但是这会导致近处体积雾的分辨率不够；另一种是和裁剪空间的深度线性对应，经过一些分析可以知道这比之前的方法更糟糕；目前我看下来最好的应该是和视空间的深度指数型对应，这样离相机越近3D纹理的像素会越多，越远则越少。本文只使用了均一的雾，但是可以使用世界空间的坐标、噪波和一系列的运算，计算出某一点的体积雾的浓度。</li><li>使用上面的雾的信息和阴影信息计算出散射的值<code>Lscat</code>，从下面的图可以看到<code>Lscat</code>是对所有的光源（本文只有主光源）计算\(f(v, l)Vis(x, l)Li(x, l)\)的和，\(Vis(x, l)\)即为在x点l光的可见性，可以通过采样阴影贴图来获得，\(Li(x, l)\)即为在x点l光的光强，可以简单的计算获得，\(f(v, l)\)用来表述在v的方向观察雾时得到l的散射量，一般被叫做Phase Function，我们使用的是Henyey-Greenstein Phase Function，其中参数g是雾的各向异性的程度，越靠近1表示光线穿过雾时越保持之前的方向，越靠近0表示光线穿过雾时均匀的散射，越靠近-1表示光线穿过雾时越会进行反射（在实际的光照中，我们会去掉\(\pi\)这一项，这样能和Unity的光照模型保持一致）。时空混合也在这一步可以完成。</li></ol><p>$$
\tag{Henyey-Greenstein} p(\theta) = \frac 1 {4\pi} \frac {1 - g^2} {(1 + g^2 - 2g \cos \theta)^{\frac 3 2}}
$$</p><p><img loading=lazy src=../images/VolumetricFogScattering.jpg#center alt="Volumetric Fog Scattering"></p><ol start=3><li>对3D纹理从相机近点到远点进行混合，这其实是一种Ray Marching，不过是在3D纹理的纹理空间进行Ray Marching，一次前进一个像素。当混合当前像素和上一个像素时，需要考虑符合物理的透光率(transmittance), \(\varepsilon\)是一个用于归一化的常量，l是两点之间的距离，c是介质的吸收率（一定程度上可以用雾的密度来表示）。具体的混合的计算和说明可以看EA寒霜引擎的PPT第28、29页。</li></ol><p>$$
\tag{Beer-Lambert} transmittance = e^{-\varepsilon l c}
$$</p><ol start=4><li>最终在绘制物体时，使用物体的世界空间的坐标，转换到3D纹理的坐标，采样3D纹理，使用透光率乘上物体本身的颜色，再加上雾的颜色，就得到了最终的体积雾的效果了。</li></ol><h2 id=相关代码和说明>相关代码和说明<a hidden class=anchor aria-hidden=true href=#相关代码和说明>#</a></h2><h3 id=volumetricfogcs>VolumetricFog.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogcs>#</a></h3><p>用于Global Volume中方便添加体积雾和控制各种参数。值得考虑的是<code>maxTransmittance</code>的值，因为相机远裁剪面会比较远，即使雾并不是很大，在最远处也总是能变成单一的颜色，这个值用来防止这种情况，人为地限制了最大不透光率（但是还是叫maxTransmittance）。<code>fogNear</code>这个参数实际是影响了3D纹理和相机之间的距离，最好还是设置成0，不然时空混合时会有一些瑕疵。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;Post-processing/Volumetric Fog&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFog</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;是否启用体积雾&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter enabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;整体控制体积雾强度&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;体积雾最大的透明程度（用于和天空混合）&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter maxTransmittance = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;体积雾的颜色倾向，目前强度为0.03&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ColorParameter fogTint = <span style=color:#66d9ef>new</span> ColorParameter(Color.white);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;体积雾距离相机最近的距离&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter fogNear = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>0.01f</span>, <span style=color:#ae81ff>10f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;体积雾距离相机最远的距离&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter fogFar = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>100f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1000.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;体积雾的密度，越密效果越明显&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter density = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>3.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>10.0f</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [Tooltip(&#34;体积雾受光的各向异性程度&#34;)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter phase = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, -<span style=color:#ae81ff>0.9f</span>, <span style=color:#ae81ff>0.9f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive() =&gt; (enabled.<span style=color:#66d9ef>value</span> &amp;&amp; (density.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>) &amp;&amp; (intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible() =&gt; <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=volumetricfogrendererfeaturecs>VolumetricFogRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogrendererfeaturecs>#</a></h3><p>平平常常的RendererFeature，事实上RenderPassEvent应该在DepthPrePass之后，但我没改物体的shader，就放在后处理之前了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader volumetricFogComputeShader;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> VolumetricFogRenderPass volumetricFogRenderPass;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> VolumetricFogSettings volumetricFogSettings = <span style=color:#66d9ef>new</span> VolumetricFogSettings();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            volumetricFogRenderPass = <span style=color:#66d9ef>new</span> VolumetricFogRenderPass(volumetricFogSettings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (renderingData.cameraData.cameraType == CameraType.Game)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                VolumetricFog volumetricFog = VolumeManager.instance.stack.GetComponent&lt;VolumetricFog&gt;();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (volumetricFog &amp;&amp; volumetricFog.IsActive())
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    volumetricFogRenderPass.Setup(volumetricFog);
</span></span><span style=display:flex><span>                    renderer.EnqueuePass(volumetricFogRenderPass);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=volumetricfogrenderpasscs>VolumetricFogRenderPass.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogrenderpasscs>#</a></h3><p>平平常常的RenderPass，实际使用的时候，只会用到<code>Froxel Generate Pass</code>和<code>Scatter Pass</code>，<code>Composite Pass</code>完全可以用物件本身的渲染来代替。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;Volumetric Fog Pass&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler profilingSampler;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler froxelSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Froxel Generate Pass&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler scatterSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Scatter Pass&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler compositeSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Composite Pass&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepth;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthIden;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepthAttachment;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthAttachmentIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> VolumetricFog volumetricFog;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader volumetricFogComputeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> VolumetricFogRendererFeature.VolumetricFogSettings settings;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTexture[] froxelTextures;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTextureDescriptor cubeDesc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> froxelTextureOneName = <span style=color:#e6db74>&#34;_FroxelBufferOne&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> froxelTextureOneID = Shader.PropertyToID(froxelTextureOneName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle froxelTextureOneHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier froxelTextureOneIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> froxelTextureTwoName = <span style=color:#e6db74>&#34;_FroxelBufferTwo&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> froxelTextureTwoID = Shader.PropertyToID(froxelTextureTwoName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle froxelTextureTwoHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier froxelTextureTwoIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> scatterTextureName = <span style=color:#e6db74>&#34;_ScatterBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> scatterTextureID = Shader.PropertyToID(scatterTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle scatterTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier scatterTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> compositeTextureName = <span style=color:#e6db74>&#34;_CompositeBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> compositeTextureID = Shader.PropertyToID(compositeTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle compositeTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier compositeTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2 colorTextureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2 invColorTextureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector3 froxelTextureSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector3 invFroxelTextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Matrix4x4 lastViewProjMatrix;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> flipReadWrite = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> VolumetricFogRenderPass(VolumetricFogRendererFeature.VolumetricFogSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            volumetricFogComputeShader = settings.volumetricFogComputeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cameraColor.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraColorIden = cameraColor.Identifier();
</span></span><span style=display:flex><span>            cameraDepth.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthIden = cameraDepth.Identifier();
</span></span><span style=display:flex><span>            cameraDepthAttachment.Init(<span style=color:#e6db74>&#34;_CameraDepthAttachment&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthAttachmentIden = cameraDepthAttachment.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            froxelTextureOneHandle.Init(froxelTextureOneName);
</span></span><span style=display:flex><span>            froxelTextureOneIden = froxelTextureOneHandle.Identifier();
</span></span><span style=display:flex><span>            froxelTextureTwoHandle.Init(froxelTextureTwoName);
</span></span><span style=display:flex><span>            froxelTextureTwoIden = froxelTextureTwoHandle.Identifier();
</span></span><span style=display:flex><span>            scatterTextureHandle.Init(scatterTextureName);
</span></span><span style=display:flex><span>            scatterTextureIden = scatterTextureHandle.Identifier();
</span></span><span style=display:flex><span>            compositeTextureHandle.Init(compositeTextureName);
</span></span><span style=display:flex><span>            compositeTextureIden = compositeTextureHandle.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            lastViewProjMatrix = Matrix4x4.identity;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(VolumetricFog volumetricFog)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.volumetricFog = volumetricFog;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                array = <span style=color:#66d9ef>new</span> T[size];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
</span></span><span style=display:flex><span>                    array[i] = initialValue;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRenderTexture(<span style=color:#66d9ef>ref</span> RenderTexture rt, RenderTextureDescriptor descriptor, <span style=color:#66d9ef>string</span> RTName)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != descriptor.width || rt.height != descriptor.height))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                RenderTexture.ReleaseTemporary(rt);
</span></span><span style=display:flex><span>                rt = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                RenderTextureDescriptor desc = descriptor;
</span></span><span style=display:flex><span>                desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                rt = RenderTexture.GetTemporary(desc);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//rt = new RenderTexture(desc);</span>
</span></span><span style=display:flex><span>                rt.name = RTName;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture[] froxelTexs, RenderTextureDescriptor descriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            EnsureArray(<span style=color:#66d9ef>ref</span> froxelTexs, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>            EnsureRenderTexture(<span style=color:#66d9ef>ref</span> froxelTexs[<span style=color:#ae81ff>0</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex One&#34;</span>);
</span></span><span style=display:flex><span>            EnsureRenderTexture(<span style=color:#66d9ef>ref</span> froxelTexs[<span style=color:#ae81ff>1</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex Two&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(compositeTextureID, desc);
</span></span><span style=display:flex><span>            colorTextureSize = <span style=color:#66d9ef>new</span> Vector2(desc.width, desc.height);
</span></span><span style=display:flex><span>            invColorTextureSize = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1.0f</span> / desc.width, <span style=color:#ae81ff>1.0f</span> / desc.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> width = desc.width / <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> height = desc.height / <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> volmeDepth = <span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>            cubeDesc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor(
</span></span><span style=display:flex><span>                    width, height,
</span></span><span style=display:flex><span>                    Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat,
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            cubeDesc.volumeDepth = volmeDepth;
</span></span><span style=display:flex><span>            cubeDesc.dimension = TextureDimension.Tex3D;
</span></span><span style=display:flex><span>            cubeDesc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            froxelTextureSize = <span style=color:#66d9ef>new</span> Vector3(width, height, volmeDepth);
</span></span><span style=display:flex><span>            invFroxelTextureSize = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>1.0f</span> / (width-<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>1.0f</span> / (height-<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>1.0f</span> / (volmeDepth-<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(scatterTextureID, cubeDesc);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateFroxel(CommandBuffer cmd, CameraData camData, RenderTargetIdentifier depthid,
</span></span><span style=display:flex><span>            RenderTexture froxelReadid, RenderTexture froxelWriteid,
</span></span><span style=display:flex><span>            ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> froxelKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;FroxelMain&#34;</span>);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(froxelKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_FroxelTextureSize&#34;</span>, froxelTextureSize);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_ColorTextureSize&#34;</span>, colorTextureSize);
</span></span><span style=display:flex><span>            cmd.SetComputeMatrixParam(computeShader, <span style=color:#e6db74>&#34;_LastViewProj&#34;</span>, lastViewProjMatrix);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Matrix4x4 projMat = camData.GetGPUProjectionMatrix();
</span></span><span style=display:flex><span>            Matrix4x4 viewMat = camData.GetViewMatrix();
</span></span><span style=display:flex><span>            lastViewProjMatrix = projMat * viewMat;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_DepthTexture&#34;</span>, depthid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_FroxelTexture&#34;</span>, froxelReadid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_RW_FroxelTexture&#34;</span>, froxelWriteid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Color fogTint = volumetricFog.fogTint.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>            fogTint.a = <span style=color:#ae81ff>0.03f</span>;
</span></span><span style=display:flex><span>            volumetricFog.fogTint.Override(fogTint);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_FogTint&#34;</span>, volumetricFog.fogTint.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_NearFar&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> Vector4(camData.camera.nearClipPlane, camData.camera.farClipPlane,
</span></span><span style=display:flex><span>                            volumetricFog.fogNear.<span style=color:#66d9ef>value</span>, volumetricFog.fogFar.<span style=color:#66d9ef>value</span>));
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_VolumetricFogParams&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> Vector4(volumetricFog.phase.<span style=color:#66d9ef>value</span>,
</span></span><span style=display:flex><span>                            volumetricFog.density.<span style=color:#66d9ef>value</span>,
</span></span><span style=display:flex><span>                            volumetricFog.intensity.<span style=color:#66d9ef>value</span>,
</span></span><span style=display:flex><span>                            volumetricFog.maxTransmittance.<span style=color:#66d9ef>value</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, froxelKernel,
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.x / x),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.y / y),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.z / z));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ScatterFog(CommandBuffer cmd, RenderTexture froxelid, RenderTargetIdentifier scatterid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> scatterKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;ScatterMain&#34;</span>);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(scatterKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, scatterKernel, <span style=color:#e6db74>&#34;_FroxelTexture&#34;</span>, froxelid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, scatterKernel, <span style=color:#e6db74>&#34;_RW_ScatterTexture&#34;</span>, scatterid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, scatterKernel,
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.x / x),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(froxelTextureSize.y / y),
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CompositeVolumetricFog(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier depthid, RenderTargetIdentifier scatterid, RenderTargetIdentifier compositeid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> compositeKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;CompositeMain&#34;</span>);
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(compositeKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_ColorTexture&#34;</span>, colorid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_DepthTexture&#34;</span>, depthid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_ScatterTexture&#34;</span>, scatterid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_RW_CompositeTexture&#34;</span>, compositeid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, compositeKernel,
</span></span><span style=display:flex><span>                Mathf.CeilToInt(colorTextureSize.x / x),
</span></span><span style=display:flex><span>                Mathf.CeilToInt(colorTextureSize.y / y),
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.Blit(compositeid, colorid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            EnsureRT(<span style=color:#66d9ef>ref</span> froxelTextures, cubeDesc);
</span></span><span style=display:flex><span>            RenderTexture froxelReadTex = froxelTextures[flipReadWrite];
</span></span><span style=display:flex><span>            RenderTexture froxelWriteTex = froxelTextures[<span style=color:#ae81ff>1</span> - flipReadWrite];
</span></span><span style=display:flex><span>            flipReadWrite = <span style=color:#ae81ff>1</span> - flipReadWrite;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, froxelSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                GenerateFroxel(cmd, renderingData.cameraData, cameraDepthAttachmentIden, froxelReadTex, froxelWriteTex, volumetricFogComputeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, scatterSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                ScatterFog(cmd, froxelWriteTex, scatterTextureIden, volumetricFogComputeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, compositeSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                CompositeVolumetricFog(cmd, cameraColorIden, cameraDepthAttachmentIden,
</span></span><span style=display:flex><span>                    scatterTextureIden, compositeTextureIden, volumetricFogComputeShader);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
</span></span><span style=display:flex><span>        {        
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(scatterTextureID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(compositeTextureID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=volumetricfogcomputeshadercompute>VolumetricFogComputeShader.compute<a hidden class=anchor aria-hidden=true href=#volumetricfogcomputeshadercompute>#</a></h3><p>重头戏来了，这个Compute Shader一共有3个kernel。第一个用来通过雾的信息和阴影的信息计算光照并储存到<code>_RW_FroxelTexture</code>中，同时也做了自身的和历史的混合，也对TAA做了适配。第二个用来做纹理空间的Ray Marching，计算散射的颜色和透光率。第三个其实是一个屏幕后处理的效果，将雾效画到屏幕上，当在物件shader中计算雾效时，就不需要这个kernel了。</p><p><code>GetDepth</code>是将纹理的z转换到视空间的线性深度(Linear Eye Depth)，<code>GetRatio</code>则是相反，把线性的视空间的深度转换到纹理的z坐标， NOT_SIMPLIFIED这个宏可以让人更好的理解指数型分布的计算过程。</p><p>为了简化问题，这边只考虑了主光源使用联级阴影时的体积雾效果，也没有考虑集成SH来计算全局光照对体积雾的影响。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel FroxelMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel ScatterMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel CompositeMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _MAIN_LIGHT_SHADOWS</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _MAIN_LIGHT_SHADOWS_CASCADE</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _SHADOWS_SOFT</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _DepthTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ColorTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _FroxelTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ScatterTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_FroxelTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture3D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_ScatterTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_CompositeTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_LinearClamp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_PointClamp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _ColorTextureSize;
</span></span><span style=display:flex><span><span style=color:#75715e>//float4 _InvColorTextureSize;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _FroxelTextureSize;
</span></span><span style=display:flex><span><span style=color:#75715e>//float4 _InvFroxelTextureSize;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _StepCount;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _NearFar;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _FogTint;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _VolumetricFogParams;
</span></span><span style=display:flex><span><span style=color:#75715e>// x: cam near, y: cam far, z: fog near, w: fog far</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _Phase _VolumetricFogParams.x</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _Density _VolumetricFogParams.y</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _Intensity _VolumetricFogParams.z</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _MaxTransmittance _VolumetricFogParams.w</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TAAOffsets;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4x4</span> _LastViewProj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> NDCToWorld(<span style=color:#66d9ef>float3</span> ndc)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ndc.xy <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0f</span> <span style=color:#f92672>*</span> ndc.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>    ndc.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>ndc.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4x4</span> invJitteredVP <span style=color:#f92672>=</span> UNITY_MATRIX_I_VP;<span style=color:#75715e>//mul(UNITY_MATRIX_I_V, _InvJitteredProj);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionWS <span style=color:#f92672>=</span> mul(invJitteredVP, <span style=color:#66d9ef>float4</span>(ndc, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> positionWS.xyz <span style=color:#f92672>/</span> positionWS.w;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> Linear01DepthToRawDepth(<span style=color:#66d9ef>float</span> z, <span style=color:#66d9ef>float4</span> zBufferParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (rcp(z) <span style=color:#f92672>-</span> zBufferParams.y) <span style=color:#f92672>/</span> zBufferParams.x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> LinearEyeToRawDepth(<span style=color:#66d9ef>float</span> depth, <span style=color:#66d9ef>float4</span> zBufferParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> depth <span style=color:#f92672>-</span> zBufferParams.w) <span style=color:#f92672>/</span> zBufferParams.z;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetDepth(<span style=color:#66d9ef>float2</span> camNearFar, <span style=color:#66d9ef>float2</span> vfNearFar, <span style=color:#66d9ef>float</span> ratio)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#if NOT_SIMPLIFIED</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> lerp(valLeft, valRight, ratio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal <span style=color:#f92672>=</span> camNearFar.x <span style=color:#f92672>*</span> exp(val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> depthVal;
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> lerp(valLeft, valRight, ratio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal <span style=color:#f92672>=</span> exp(val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> depthVal;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetRatio(<span style=color:#66d9ef>float2</span> camNearFar, <span style=color:#66d9ef>float2</span> vfNearFar, <span style=color:#66d9ef>float</span> linearDepth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#if NOT_SIMPLIFIED</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> log(linearDepth <span style=color:#f92672>/</span> camNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> (val <span style=color:#f92672>-</span> valLeft) <span style=color:#f92672>/</span> (valRight <span style=color:#f92672>-</span> valLeft);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ratio;
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valLeft <span style=color:#f92672>=</span> log(vfNearFar.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> valRight <span style=color:#f92672>=</span> log(vfNearFar.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> log(linearDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> (val <span style=color:#f92672>-</span> valLeft) <span style=color:#f92672>/</span> (valRight <span style=color:#f92672>-</span> valLeft);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ratio;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> HGPhaseFunction(<span style=color:#66d9ef>float</span> g, <span style=color:#66d9ef>float</span> cosTheta)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> g2 <span style=color:#f92672>=</span> g <span style=color:#f92672>*</span> g;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> denominator <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>+</span> g2 <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> g <span style=color:#f92672>*</span> cosTheta;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.25</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> g2) <span style=color:#f92672>*</span> rsqrt(denominator <span style=color:#f92672>*</span> denominator <span style=color:#f92672>*</span> denominator);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> GetFogColor(<span style=color:#66d9ef>float3</span> color, <span style=color:#66d9ef>float3</span> lightDir, <span style=color:#66d9ef>float3</span> viewDir, <span style=color:#66d9ef>float</span> g)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> cosVal <span style=color:#f92672>=</span> dot(<span style=color:#f92672>-</span>lightDir, viewDir);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> color <span style=color:#f92672>*</span> HGPhaseFunction(g, cosVal);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> Hash13(<span style=color:#66d9ef>float3</span> p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> frac(p <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1031</span>);
</span></span><span style=display:flex><span>    p <span style=color:#f92672>+=</span> dot(p, p.zyx <span style=color:#f92672>+</span> <span style=color:#ae81ff>31.32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> frac((p.x <span style=color:#f92672>+</span> p.y) <span style=color:#f92672>*</span> p.z);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>8</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> FroxelMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> texcoord <span style=color:#f92672>=</span> (id.xy <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>/</span> _FroxelTextureSize.xy;
</span></span><span style=display:flex><span>    texcoord <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> _TAAOffsets.xy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> jitter <span style=color:#f92672>=</span> Hash13(<span style=color:#66d9ef>float3</span>(texcoord, _Time.y <span style=color:#f92672>*</span> id.z));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> (id.z <span style=color:#f92672>+</span> jitter) <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ratio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rawDepth <span style=color:#f92672>=</span> LinearEyeToRawDepth(depthVal, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(texcoord, rawDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionWS <span style=color:#f92672>=</span> NDCToWorld(positionNDC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewDir <span style=color:#f92672>=</span> normalize(GetCameraPositionWS() <span style=color:#f92672>-</span> positionWS); 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> shadowCoord <span style=color:#f92672>=</span> TransformWorldToShadowCoord(positionWS);   
</span></span><span style=display:flex><span>    Light mainLight <span style=color:#f92672>=</span> GetMainLight(shadowCoord);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> lightColor <span style=color:#f92672>=</span> mainLight.color <span style=color:#f92672>*</span> mainLight.shadowAttenuation;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> lightDir <span style=color:#f92672>=</span> mainLight.direction;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> fogColor <span style=color:#f92672>=</span> GetFogColor(lightColor, lightDir, viewDir, _Phase);
</span></span><span style=display:flex><span>    fogColor <span style=color:#f92672>+=</span> _FogTint.rgb <span style=color:#f92672>*</span> _FogTint.a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> density <span style=color:#f92672>=</span> _Density;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> finalFroxel <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(fogColor, density);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reprojection Temporal Filter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ujRatio <span style=color:#f92672>=</span> (id.z <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ujDepthVal <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ujRatio);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ujRawDepth <span style=color:#f92672>=</span> LinearEyeToRawDepth(ujDepthVal, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> ujPositionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(texcoord, ujRawDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> ujPositionWS <span style=color:#f92672>=</span> NDCToWorld(ujPositionNDC);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> lastPositionCS <span style=color:#f92672>=</span> mul(_LastViewProj, <span style=color:#66d9ef>float4</span>(ujPositionWS, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>    lastPositionCS <span style=color:#f92672>/=</span> lastPositionCS.w;
</span></span><span style=display:flex><span>    lastPositionCS.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>lastPositionCS.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> lastNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(lastPositionCS.xy <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>, lastPositionCS.z);
</span></span><span style=display:flex><span>    lastNDC.xy <span style=color:#f92672>-=</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>*</span> _TAAOffsets.zw;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(all(lastNDC <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.0</span>) <span style=color:#f92672>&amp;&amp;</span> all(lastNDC <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1.0f</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> linearEyeDepth <span style=color:#f92672>=</span> LinearEyeDepth(lastNDC.z, _ZBufferParams);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> reprojRatio <span style=color:#f92672>=</span> GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> froxelTex <span style=color:#f92672>=</span> _FroxelTexture.SampleLevel(sampler_LinearClamp, <span style=color:#66d9ef>float3</span>(lastNDC.xy, reprojRatio), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        finalFroxel <span style=color:#f92672>=</span> lerp(finalFroxel, froxelTex, <span style=color:#ae81ff>0.95</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_FroxelTexture[id] <span style=color:#f92672>=</span> finalFroxel;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> SliceThickness(<span style=color:#66d9ef>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratioThis <span style=color:#f92672>=</span> z <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthThis <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ratioThis);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratioNext <span style=color:#f92672>=</span> (z<span style=color:#f92672>+</span><span style=color:#ae81ff>1.0f</span>) <span style=color:#f92672>/</span> _FroxelTextureSize.z;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthNext <span style=color:#f92672>=</span> GetDepth(_NearFar.xy, _NearFar.zw, ratioNext);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> depthNext <span style=color:#f92672>-</span> depthThis;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> AccumScatter(<span style=color:#66d9ef>int</span> z, <span style=color:#66d9ef>float4</span> accum, <span style=color:#66d9ef>float4</span> slice)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    slice.a <span style=color:#f92672>=</span> max(slice.a, <span style=color:#ae81ff>1</span>e<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> thickness <span style=color:#f92672>=</span> SliceThickness(z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> sliceTransmittance <span style=color:#f92672>=</span> exp(<span style=color:#f92672>-</span>slice.a <span style=color:#f92672>*</span> thickness <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.01f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> sliceScattering <span style=color:#f92672>=</span> slice.rgb <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> sliceTransmittance);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> accumScattering <span style=color:#f92672>=</span> accum.rgb <span style=color:#f92672>+</span> sliceScattering <span style=color:#f92672>*</span> accum.a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> accumTransmittance <span style=color:#f92672>=</span> accum.a <span style=color:#f92672>*</span> sliceTransmittance;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float4</span>(accumScattering, accumTransmittance);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ScatterMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> accum <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> z<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; z<span style=color:#f92672>&lt;</span>_FroxelTextureSize.z; z<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int3</span> coord <span style=color:#f92672>=</span> <span style=color:#66d9ef>int3</span>(id.xy, z);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float4</span> slice <span style=color:#f92672>=</span> _FroxelTexture[coord];
</span></span><span style=display:flex><span>        accum <span style=color:#f92672>=</span> AccumScatter(z, accum, slice);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//_RW_ScatterTexture[coord] = slice;</span>
</span></span><span style=display:flex><span>        _RW_ScatterTexture[coord] <span style=color:#f92672>=</span> accum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CompositeMain (<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> texcoord <span style=color:#f92672>=</span> (id.xy <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>) <span style=color:#f92672>*</span> rcp(_ColorTextureSize.xy);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> colorTex <span style=color:#f92672>=</span> _ColorTexture.SampleLevel(sampler_PointClamp, texcoord, <span style=color:#ae81ff>0</span>).rgb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthTex <span style=color:#f92672>=</span> _DepthTexture.SampleLevel(sampler_PointClamp, texcoord, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> linearEyeDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthTex, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> ratio <span style=color:#f92672>=</span> GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> froxelTex <span style=color:#f92672>=</span> _ScatterTexture.SampleLevel(sampler_LinearClamp, <span style=color:#66d9ef>float3</span>(texcoord, ratio), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> accumScatter <span style=color:#f92672>=</span> froxelTex.rgb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> accumTrans <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> _MaxTransmittance, froxelTex.a);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> finalColor <span style=color:#f92672>=</span> colorTex <span style=color:#f92672>*</span> accumTrans <span style=color:#f92672>+</span> froxelTex.rgb;
</span></span><span style=display:flex><span>    finalColor <span style=color:#f92672>=</span> lerp(colorTex.rgb, finalColor, _Intensity);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_CompositeTexture[id.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(finalColor, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>好久没有写新的博客啦，之前一直在学c++，不怎么有时间做新的东西。体积雾还是一个蛮重要的效果，之前做Ray Marching的时候老是把握不住该步进多少，用了指数型的步进之后就感觉豁然开朗了。TAA其实也做了一版新的，还没来得及写，GTAO也学了一遍，就之后再说吧。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/volumetric-fog/>Volumetric Fog</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-ray-marching/><span class=title>« Prev</span><br><span>使用Ray Marching来渲染体积雾</span>
</a><a class=next href=https://zznewclear13.github.io/posts/get-view-space-normal-from-depth-texture/><span class=title>Next »</span><br><span>从深度图中获取视空间的法线</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>