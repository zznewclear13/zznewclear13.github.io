<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾ | ZZNEWCLEAR13</title><meta name=keywords content="Volumetric Fog,Compute Shader"><meta name=description content="ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css integrity=sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js integrity=sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-157509723-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾"><meta property="og:description" content="ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"><meta property="og:image" content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-23T12:00:00+08:00"><meta property="article:modified_time" content="2022-08-23T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg"><meta name=twitter:title content="ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾"><meta name=twitter:description content="ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾","item":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾","name":"ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾","description":"ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾.","keywords":["Volumetric Fog","Compute Shader"],"articleBody":"ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾ å› ä¸ºå®ƒå°±åœ¨é‚£é‡Œã€‚\nå½“ç„¶äº†ï¼Œæ›´é‡è¦çš„æ˜¯å› ä¸ºä½“ç§¯é›¾èƒ½è¿…é€Ÿçš„è¥é€ å‡ºåœºæ™¯çš„çœŸå®æ„Ÿä¸æ°›å›´æ„Ÿï¼Œè°ä¸å–œæ¬¢å…‰æºè¾¹ä¸Šè¿˜æœ‰ä¸€å°åœˆå…‰æ™•å‘¢ï¼Œå¦‚æœä»€ä¹ˆé«˜äº®çš„ç‰©ä½“éƒ½èƒ½å½±å“ä½“ç§¯é›¾çš„è¯ï¼Œæ˜¯ä¸æ˜¯å°±ä¸å¤ªéœ€è¦bloomæ•ˆæœäº†å‘¢ã€‚æˆ‘å®é™…åœ°åœ¨ç”Ÿæ´»ä¸­è§‚å¯Ÿäº†ä¸€ä¸‹ï¼Œå‘ç°äººçœ¼æ‰€çœ‹åˆ°çš„å…‰æ™•çš„æ•ˆæœï¼Œæ˜¯å…‰çº¿è¿›å…¥çœ¼ç›ä¹‹åäº§ç”Ÿçš„ï¼Œä¹Ÿå°±æ˜¯è¯´bloomå’Œä½“ç§¯é›¾ç¡®ç¡®å®å®æ˜¯ä¸¤ç§ä¸åŒçš„æ•ˆæœã€‚\nä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³• ä½“ç§¯é›¾ä¸€èˆ¬æœ‰ä¸¤ç§æ¸²æŸ“æ–¹æ³•ï¼Œä¸€ç§æ˜¯å•çº¯çš„ä»ç›¸æœºå‡ºå‘å¯¹åœºæ™¯è¿›è¡ŒRay Marchingï¼Œæ¯æ¬¡è¿›è¡Œé‡‡æ ·å’Œæ··åˆã€‚è¿™ç§æ–¹æ³•ä¸»è¦çš„ç¼ºç‚¹æ˜¯Ray Marchingçš„æ¬¡æ•°ä¼šæ¯”è¾ƒé«˜æ‰èƒ½æœ‰è¾ƒå¥½çš„æ¸²æŸ“æ•ˆæœã€‚åœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œå¼€å¯TAAçš„æ—¶å€™ï¼Œ20æ¬¡Ray Marchingå°±èƒ½å¾—åˆ°å¾ˆå¥½çš„ä½“ç§¯é›¾æ•ˆæœäº†ï¼›ä½†æ˜¯ä¸å¼€å¯TAAçš„è¯ï¼Œå¯èƒ½ä¼šéœ€è¦60æ¬¡ç”šè‡³æ›´é«˜çš„Ray Marchingæ‰èƒ½å¾—åˆ°å’ŒTAAç±»ä¼¼çš„æ•ˆæœã€‚åŒæ—¶ï¼ŒRay Marchingä½“ç§¯é›¾åªèƒ½åœ¨åå¤„ç†é˜¶æ®µä½¿ç”¨ï¼Œåœ¨å¤„ç†ä¸å†™æ·±åº¦çš„é€æ˜ç‰©ä½“çš„æ—¶å€™ï¼Œä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚\nå¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€å¼ 3Dçº¹ç†ï¼Œå°†æ•´ä¸ªåœºæ™¯çš„ä½“ç§¯é›¾å‚¨å­˜åœ¨è¿™å¼ 3Dçº¹ç†ä¸­ï¼Œå½“ç»˜åˆ¶ç‰©ä½“çš„æ—¶å€™ä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´åæ ‡é‡‡æ ·è¿™å¼ 3Dçº¹ç†ï¼Œç›´æ¥åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­è®¡ç®—é›¾æ•ˆä¹‹åçš„é¢œè‰²ã€‚è¿™ç§æ–¹æ³•ä½¿ç”¨çš„3Dçº¹ç†ä¼šå ç”¨æ›´å¤šçš„å†…å­˜ï¼Œä½†æ˜¯ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿæ­£ç¡®çš„æ¸²æŸ“æ‰€æœ‰ç‰©ä½“ï¼Œå’Œ60æ¬¡Ray Marchingç›¸æ¯”ï¼Œæ€§èƒ½ä¸Šä¹Ÿè¯´ä¸å®šä¼šæœ‰ä¸€äº›ä¼˜åŠ¿ã€‚\næœ¬æ–‡çš„ä½“ç§¯é›¾å®ç°ï¼Œå‚è€ƒäº†EAçš„å¯’éœœå¼•æ“åœ¨Siggraph 2015å¹´æ—¶çš„æ¼”è®²å’Œdiharawçš„OpenGLçš„ä½“ç§¯é›¾æ•ˆæœã€‚å€¼å¾—ä¸€çœ‹çš„è¿˜æœ‰Bart Wronskiåœ¨Siggraph 2014å¹´çš„æ¼”è®²ï¼Œä»¥åŠä¹‹åçš„è’é‡å¤§é•–å®¢åœ¨Siggraph 2019å¹´çš„è¯¾ç¨‹ã€‚ä½¿ç”¨çš„æ˜¯Unity2019.4.29çš„URPå·¥ç¨‹ã€‚\nå…·ä½“çš„å®ç°æ–¹æ³•  å°†åœºæ™¯ä¸­çš„éœ€è¦æ¸²æŸ“çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯å‚¨å­˜åˆ°ä¸€å¼ å’Œç›¸æœºçš„è§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†ä¸­ã€‚æŒ‰ç…§å¯’éœœå¼•æ“çš„åšæ³•ï¼Œçº¹ç†å¤§å°ä¸º(åˆ†è¾¨ç‡å®½/8)x(åˆ†è¾¨ç‡é«˜/8)x64ï¼Œè¿™æ ·å°±å’Œå±å¹•å¤§å°çš„2Dçº¹ç†å ç”¨çš„å†…å­˜å¤§å°ä¸€è‡´äº†ï¼Œä½†æˆ‘çœ‹Unityå®˜æ–¹çš„ä½“ç§¯é›¾å·¥ç¨‹ä¸­ï¼Œ3Dçº¹ç†çš„æ·±åº¦ä¸º128ï¼Œå°±ä¹ŸæŠŠè‡ªå·±çš„è®¾ç½®æˆ128äº†ï¼Œçº¹ç†æ·±åº¦è¶Šæ·±ï¼Œä½“ç§¯é›¾çš„ç»†èŠ‚å°±èƒ½è¶Šé«˜ã€‚3Dçº¹ç†çš„å®½é«˜å’Œè§†é”¥ä½“å¯¹é½ï¼Œè¿™å¾ˆå¥½ç†è§£ï¼Œè€Œè¿™å¼ è´´å›¾çš„çºµå‘æ·±åº¦å’Œå®é™…çš„æ·±åº¦è¦æ€ä¹ˆå¯¹é½å‘¢ï¼Ÿæœ€ç®€å•çš„å°±æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œä½†æ˜¯è¿™ä¼šå¯¼è‡´è¿‘å¤„ä½“ç§¯é›¾çš„åˆ†è¾¨ç‡ä¸å¤Ÿï¼›å¦ä¸€ç§æ˜¯å’Œè£å‰ªç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œç»è¿‡ä¸€äº›åˆ†æå¯ä»¥çŸ¥é“è¿™æ¯”ä¹‹å‰çš„æ–¹æ³•æ›´ç³Ÿç³•ï¼›ç›®å‰æˆ‘çœ‹ä¸‹æ¥æœ€å¥½çš„åº”è¯¥æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦æŒ‡æ•°å‹å¯¹åº”ï¼Œè¿™æ ·ç¦»ç›¸æœºè¶Šè¿‘3Dçº¹ç†çš„åƒç´ ä¼šè¶Šå¤šï¼Œè¶Šè¿œåˆ™è¶Šå°‘ã€‚æœ¬æ–‡åªä½¿ç”¨äº†å‡ä¸€çš„é›¾ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ä¸–ç•Œç©ºé—´çš„åæ ‡ã€å™ªæ³¢å’Œä¸€ç³»åˆ—çš„è¿ç®—ï¼Œè®¡ç®—å‡ºæŸä¸€ç‚¹çš„ä½“ç§¯é›¾çš„æµ“åº¦ã€‚ ä½¿ç”¨ä¸Šé¢çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯è®¡ç®—å‡ºæ•£å°„çš„å€¼Lscatï¼Œä»ä¸‹é¢çš„å›¾å¯ä»¥çœ‹åˆ°Lscatæ˜¯å¯¹æ‰€æœ‰çš„å…‰æºï¼ˆæœ¬æ–‡åªæœ‰ä¸»å…‰æºï¼‰è®¡ç®—\\(f(v, l)Vis(x, l)Li(x, l)\\)çš„å’Œï¼Œ\\(Vis(x, l)\\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å¯è§æ€§ï¼Œå¯ä»¥é€šè¿‡é‡‡æ ·é˜´å½±è´´å›¾æ¥è·å¾—ï¼Œ\\(Li(x, l)\\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å…‰å¼ºï¼Œå¯ä»¥ç®€å•çš„è®¡ç®—è·å¾—ï¼Œ\\(f(v, l)\\)ç”¨æ¥è¡¨è¿°åœ¨vçš„æ–¹å‘è§‚å¯Ÿé›¾æ—¶å¾—åˆ°lçš„æ•£å°„é‡ï¼Œä¸€èˆ¬è¢«å«åšPhase Functionï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯Henyey-Greenstein Phase Functionï¼Œå…¶ä¸­å‚æ•°gæ˜¯é›¾çš„å„å‘å¼‚æ€§çš„ç¨‹åº¦ï¼Œè¶Šé è¿‘1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¿æŒä¹‹å‰çš„æ–¹å‘ï¼Œè¶Šé è¿‘0è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶å‡åŒ€çš„æ•£å°„ï¼Œè¶Šé è¿‘-1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¼šè¿›è¡Œåå°„ï¼ˆåœ¨å®é™…çš„å…‰ç…§ä¸­ï¼Œæˆ‘ä»¬ä¼šå»æ‰\\(\\pi\\)è¿™ä¸€é¡¹ï¼Œè¿™æ ·èƒ½å’ŒUnityçš„å…‰ç…§æ¨¡å‹ä¿æŒä¸€è‡´ï¼‰ã€‚æ—¶ç©ºæ··åˆä¹Ÿåœ¨è¿™ä¸€æ­¥å¯ä»¥å®Œæˆã€‚  $$ \\tag{Henyey-Greenstein} p(\\theta) = \\frac 1 {4\\pi} \\frac {1 - g^2} {(1 + g^2 - 2g \\cos \\theta)^{\\frac 3 2}} $$\nå¯¹3Dçº¹ç†ä»ç›¸æœºè¿‘ç‚¹åˆ°è¿œç‚¹è¿›è¡Œæ··åˆï¼Œè¿™å…¶å®æ˜¯ä¸€ç§Ray Marchingï¼Œä¸è¿‡æ˜¯åœ¨3Dçº¹ç†çš„çº¹ç†ç©ºé—´è¿›è¡ŒRay Marchingï¼Œä¸€æ¬¡å‰è¿›ä¸€ä¸ªåƒç´ ã€‚å½“æ··åˆå½“å‰åƒç´ å’Œä¸Šä¸€ä¸ªåƒç´ æ—¶ï¼Œéœ€è¦è€ƒè™‘ç¬¦åˆç‰©ç†çš„é€å…‰ç‡(transmittance), \\(\\varepsilon\\)æ˜¯ä¸€ä¸ªç”¨äºå½’ä¸€åŒ–çš„å¸¸é‡ï¼Œlæ˜¯ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œcæ˜¯ä»‹è´¨çš„å¸æ”¶ç‡ï¼ˆä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç”¨é›¾çš„å¯†åº¦æ¥è¡¨ç¤ºï¼‰ã€‚å…·ä½“çš„æ··åˆçš„è®¡ç®—å’Œè¯´æ˜å¯ä»¥çœ‹EAå¯’éœœå¼•æ“çš„PPTç¬¬28ã€29é¡µã€‚  $$ \\tag{Beer-Lambert} transmittance = e^{-\\varepsilon l c} $$\næœ€ç»ˆåœ¨ç»˜åˆ¶ç‰©ä½“æ—¶ï¼Œä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œè½¬æ¢åˆ°3Dçº¹ç†çš„åæ ‡ï¼Œé‡‡æ ·3Dçº¹ç†ï¼Œä½¿ç”¨é€å…‰ç‡ä¹˜ä¸Šç‰©ä½“æœ¬èº«çš„é¢œè‰²ï¼Œå†åŠ ä¸Šé›¾çš„é¢œè‰²ï¼Œå°±å¾—åˆ°äº†æœ€ç»ˆçš„ä½“ç§¯é›¾çš„æ•ˆæœäº†ã€‚  ç›¸å…³ä»£ç å’Œè¯´æ˜ VolumetricFog.cs ç”¨äºGlobal Volumeä¸­æ–¹ä¾¿æ·»åŠ ä½“ç§¯é›¾å’Œæ§åˆ¶å„ç§å‚æ•°ã€‚å€¼å¾—è€ƒè™‘çš„æ˜¯maxTransmittanceçš„å€¼ï¼Œå› ä¸ºç›¸æœºè¿œè£å‰ªé¢ä¼šæ¯”è¾ƒè¿œï¼Œå³ä½¿é›¾å¹¶ä¸æ˜¯å¾ˆå¤§ï¼Œåœ¨æœ€è¿œå¤„ä¹Ÿæ€»æ˜¯èƒ½å˜æˆå•ä¸€çš„é¢œè‰²ï¼Œè¿™ä¸ªå€¼ç”¨æ¥é˜²æ­¢è¿™ç§æƒ…å†µï¼Œäººä¸ºåœ°é™åˆ¶äº†æœ€å¤§ä¸é€å…‰ç‡ï¼ˆä½†æ˜¯è¿˜æ˜¯å«maxTransmittanceï¼‰ã€‚fogNearè¿™ä¸ªå‚æ•°å®é™…æ˜¯å½±å“äº†3Dçº¹ç†å’Œç›¸æœºä¹‹é—´çš„è·ç¦»ï¼Œæœ€å¥½è¿˜æ˜¯è®¾ç½®æˆ0ï¼Œä¸ç„¶æ—¶ç©ºæ··åˆæ—¶ä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"Post-processing/Volumetric Fog\")] public class VolumetricFog : VolumeComponent, IPostProcessComponent { [Tooltip(\"æ˜¯å¦å¯ç”¨ä½“ç§¯é›¾\")] public BoolParameter enabled = new BoolParameter(false); [Tooltip(\"æ•´ä½“æ§åˆ¶ä½“ç§¯é›¾å¼ºåº¦\")] public ClampedFloatParameter intensity = new ClampedFloatParameter(1.0f, 0f, 1.0f); [Tooltip(\"ä½“ç§¯é›¾æœ€å¤§çš„é€æ˜ç¨‹åº¦ï¼ˆç”¨äºå’Œå¤©ç©ºæ··åˆï¼‰\")] public ClampedFloatParameter maxTransmittance = new ClampedFloatParameter(1.0f, 0f, 1.0f); [Tooltip(\"ä½“ç§¯é›¾çš„é¢œè‰²å€¾å‘ï¼Œç›®å‰å¼ºåº¦ä¸º0.03\")] public ColorParameter fogTint = new ColorParameter(Color.white); [Tooltip(\"ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿‘çš„è·ç¦»\")] public ClampedFloatParameter fogNear = new ClampedFloatParameter(0.1f, 0.01f, 10f); [Tooltip(\"ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿œçš„è·ç¦»\")] public ClampedFloatParameter fogFar = new ClampedFloatParameter(100f, 1.0f, 1000.0f); [Tooltip(\"ä½“ç§¯é›¾çš„å¯†åº¦ï¼Œè¶Šå¯†æ•ˆæœè¶Šæ˜æ˜¾\")] public ClampedFloatParameter density = new ClampedFloatParameter(3.0f, 0f, 10.0f); [Tooltip(\"ä½“ç§¯é›¾å—å…‰çš„å„å‘å¼‚æ€§ç¨‹åº¦\")] public ClampedFloatParameter phase = new ClampedFloatParameter(0.0f, -0.9f, 0.9f); public bool IsActive() = (enabled.value \u0026\u0026 (density.value  0.0f) \u0026\u0026 (intensity.value  0.0f)); public bool IsTileCompatible() = false; } } VolumetricFogRendererFeature.cs å¹³å¹³å¸¸å¸¸çš„RendererFeatureï¼Œäº‹å®ä¸ŠRenderPassEventåº”è¯¥åœ¨DepthPrePassä¹‹åï¼Œä½†æˆ‘æ²¡æ”¹ç‰©ä½“çš„shaderï¼Œå°±æ”¾åœ¨åå¤„ç†ä¹‹å‰äº†ã€‚\nnamespace UnityEngine.Rendering.Universal { public class VolumetricFogRendererFeature : ScriptableRendererFeature { [System.Serializable] public class VolumetricFogSettings { public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; public ComputeShader volumetricFogComputeShader; } private VolumetricFogRenderPass volumetricFogRenderPass; public VolumetricFogSettings volumetricFogSettings = new VolumetricFogSettings(); public override void Create() { volumetricFogRenderPass = new VolumetricFogRenderPass(volumetricFogSettings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { if (renderingData.cameraData.cameraType == CameraType.Game) { VolumetricFog volumetricFog = VolumeManager.instance.stack.GetComponent(); if (volumetricFog \u0026\u0026 volumetricFog.IsActive()) { volumetricFogRenderPass.Setup(volumetricFog); renderer.EnqueuePass(volumetricFogRenderPass); } } } } } VolumetricFogRenderPass.cs å¹³å¹³å¸¸å¸¸çš„RenderPassï¼Œå®é™…ä½¿ç”¨çš„æ—¶å€™ï¼Œåªä¼šç”¨åˆ°Froxel Generate Passå’ŒScatter Passï¼ŒComposite Passå®Œå…¨å¯ä»¥ç”¨ç‰©ä»¶æœ¬èº«çš„æ¸²æŸ“æ¥ä»£æ›¿ã€‚\nnamespace UnityEngine.Rendering.Universal { public class VolumetricFogRenderPass : ScriptableRenderPass { private const string profilerTag = \"Volumetric Fog Pass\"; private ProfilingSampler profilingSampler; private ProfilingSampler froxelSampler = new ProfilingSampler(\"Froxel Generate Pass\"); private ProfilingSampler scatterSampler = new ProfilingSampler(\"Scatter Pass\"); private ProfilingSampler compositeSampler = new ProfilingSampler(\"Composite Pass\"); private RenderTargetHandle cameraColor; private RenderTargetIdentifier cameraColorIden; private RenderTargetHandle cameraDepth; private RenderTargetIdentifier cameraDepthIden; private RenderTargetHandle cameraDepthAttachment; private RenderTargetIdentifier cameraDepthAttachmentIden; private VolumetricFog volumetricFog; private ComputeShader volumetricFogComputeShader; private VolumetricFogRendererFeature.VolumetricFogSettings settings; private RenderTexture[] froxelTextures; private RenderTextureDescriptor cubeDesc; private static readonly string froxelTextureOneName = \"_FroxelBufferOne\"; private static readonly int froxelTextureOneID = Shader.PropertyToID(froxelTextureOneName); private RenderTargetHandle froxelTextureOneHandle; private RenderTargetIdentifier froxelTextureOneIden; private static readonly string froxelTextureTwoName = \"_FroxelBufferTwo\"; private static readonly int froxelTextureTwoID = Shader.PropertyToID(froxelTextureTwoName); private RenderTargetHandle froxelTextureTwoHandle; private RenderTargetIdentifier froxelTextureTwoIden; private static readonly string scatterTextureName = \"_ScatterBuffer\"; private static readonly int scatterTextureID = Shader.PropertyToID(scatterTextureName); private RenderTargetHandle scatterTextureHandle; private RenderTargetIdentifier scatterTextureIden; private static readonly string compositeTextureName = \"_CompositeBuffer\"; private static readonly int compositeTextureID = Shader.PropertyToID(compositeTextureName); private RenderTargetHandle compositeTextureHandle; private RenderTargetIdentifier compositeTextureIden; private Vector2 colorTextureSize; private Vector2 invColorTextureSize; private Vector3 froxelTextureSize; private Vector3 invFroxelTextureSize; private Matrix4x4 lastViewProjMatrix; private int flipReadWrite = 0; public VolumetricFogRenderPass(VolumetricFogRendererFeature.VolumetricFogSettings settings) { this.settings = settings; profilingSampler = new ProfilingSampler(profilerTag); renderPassEvent = settings.renderPassEvent; volumetricFogComputeShader = settings.volumetricFogComputeShader; cameraColor.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColor.Identifier(); cameraDepth.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepth.Identifier(); cameraDepthAttachment.Init(\"_CameraDepthAttachment\"); cameraDepthAttachmentIden = cameraDepthAttachment.Identifier(); froxelTextureOneHandle.Init(froxelTextureOneName); froxelTextureOneIden = froxelTextureOneHandle.Identifier(); froxelTextureTwoHandle.Init(froxelTextureTwoName); froxelTextureTwoIden = froxelTextureTwoHandle.Identifier(); scatterTextureHandle.Init(scatterTextureName); scatterTextureIden = scatterTextureHandle.Identifier(); compositeTextureHandle.Init(compositeTextureName); compositeTextureIden = compositeTextureHandle.Identifier(); lastViewProjMatrix = Matrix4x4.identity; } public void Setup(VolumetricFog volumetricFog) { this.volumetricFog = volumetricFog; } private static void EnsureArray(ref T[] array, int size, T initialValue = default(T)) { if (array == null || array.Length != size) { array = new T[size]; for (int i = 0; i != size; i++) array[i] = initialValue; } } private static void EnsureRenderTexture(ref RenderTexture rt, RenderTextureDescriptor descriptor, string RTName) { if (rt != null \u0026\u0026 (rt.width != descriptor.width || rt.height != descriptor.height)) { RenderTexture.ReleaseTemporary(rt); rt = null; } if (rt == null) { RenderTextureDescriptor desc = descriptor; desc.depthBufferBits = 0; desc.msaaSamples = 1; rt = RenderTexture.GetTemporary(desc); //rt = new RenderTexture(desc);  rt.name = RTName; if (!rt.IsCreated()) rt.Create(); } } public static void EnsureRT(ref RenderTexture[] froxelTexs, RenderTextureDescriptor descriptor) { EnsureArray(ref froxelTexs, 2); EnsureRenderTexture(ref froxelTexs[0], descriptor, \"Froxel Tex One\"); EnsureRenderTexture(ref froxelTexs[1], descriptor, \"Froxel Tex Two\"); } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; cmd.GetTemporaryRT(compositeTextureID, desc); colorTextureSize = new Vector2(desc.width, desc.height); invColorTextureSize = new Vector2(1.0f / desc.width, 1.0f / desc.height); int width = desc.width / 8; int height = desc.height / 8; int volmeDepth = 128; cubeDesc = new RenderTextureDescriptor( width, height, Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat, 0); cubeDesc.volumeDepth = volmeDepth; cubeDesc.dimension = TextureDimension.Tex3D; cubeDesc.enableRandomWrite = true; froxelTextureSize = new Vector3(width, height, volmeDepth); invFroxelTextureSize = new Vector3(1.0f / (width-0), 1.0f / (height-0), 1.0f / (volmeDepth-0)); cmd.GetTemporaryRT(scatterTextureID, cubeDesc); } private void GenerateFroxel(CommandBuffer cmd, CameraData camData, RenderTargetIdentifier depthid, RenderTexture froxelReadid, RenderTexture froxelWriteid, ComputeShader computeShader) { int froxelKernel = computeShader.FindKernel(\"FroxelMain\"); computeShader.GetKernelThreadGroupSizes(froxelKernel, out uint x, out uint y, out uint z); cmd.SetComputeVectorParam(computeShader, \"_FroxelTextureSize\", froxelTextureSize); cmd.SetComputeVectorParam(computeShader, \"_ColorTextureSize\", colorTextureSize); cmd.SetComputeMatrixParam(computeShader, \"_LastViewProj\", lastViewProjMatrix); Matrix4x4 projMat = camData.GetGPUProjectionMatrix(); Matrix4x4 viewMat = camData.GetViewMatrix(); lastViewProjMatrix = projMat * viewMat; cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_DepthTexture\", depthid); cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_FroxelTexture\", froxelReadid); cmd.SetComputeTextureParam(computeShader, froxelKernel, \"_RW_FroxelTexture\", froxelWriteid); Color fogTint = volumetricFog.fogTint.value; fogTint.a = 0.03f; volumetricFog.fogTint.Override(fogTint); cmd.SetComputeVectorParam(computeShader, \"_FogTint\", volumetricFog.fogTint.value); cmd.SetComputeVectorParam(computeShader, \"_NearFar\", new Vector4(camData.camera.nearClipPlane, camData.camera.farClipPlane, volumetricFog.fogNear.value, volumetricFog.fogFar.value)); cmd.SetComputeVectorParam(computeShader, \"_VolumetricFogParams\", new Vector4(volumetricFog.phase.value, volumetricFog.density.value, volumetricFog.intensity.value, volumetricFog.maxTransmittance.value)); cmd.DispatchCompute(computeShader, froxelKernel, Mathf.CeilToInt(froxelTextureSize.x / x), Mathf.CeilToInt(froxelTextureSize.y / y), Mathf.CeilToInt(froxelTextureSize.z / z)); } private void ScatterFog(CommandBuffer cmd, RenderTexture froxelid, RenderTargetIdentifier scatterid, ComputeShader computeShader) { int scatterKernel = computeShader.FindKernel(\"ScatterMain\"); computeShader.GetKernelThreadGroupSizes(scatterKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, scatterKernel, \"_FroxelTexture\", froxelid); cmd.SetComputeTextureParam(computeShader, scatterKernel, \"_RW_ScatterTexture\", scatterid); cmd.DispatchCompute(computeShader, scatterKernel, Mathf.CeilToInt(froxelTextureSize.x / x), Mathf.CeilToInt(froxelTextureSize.y / y), 1); } private void CompositeVolumetricFog(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier depthid, RenderTargetIdentifier scatterid, RenderTargetIdentifier compositeid, ComputeShader computeShader) { int compositeKernel = computeShader.FindKernel(\"CompositeMain\"); computeShader.GetKernelThreadGroupSizes(compositeKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_ColorTexture\", colorid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_DepthTexture\", depthid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_ScatterTexture\", scatterid); cmd.SetComputeTextureParam(computeShader, compositeKernel, \"_RW_CompositeTexture\", compositeid); cmd.DispatchCompute(computeShader, compositeKernel, Mathf.CeilToInt(colorTextureSize.x / x), Mathf.CeilToInt(colorTextureSize.y / y), 1); cmd.Blit(compositeid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); EnsureRT(ref froxelTextures, cubeDesc); RenderTexture froxelReadTex = froxelTextures[flipReadWrite]; RenderTexture froxelWriteTex = froxelTextures[1 - flipReadWrite]; flipReadWrite = 1 - flipReadWrite; using (new ProfilingScope(cmd, froxelSampler)) { GenerateFroxel(cmd, renderingData.cameraData, cameraDepthAttachmentIden, froxelReadTex, froxelWriteTex, volumetricFogComputeShader); } using (new ProfilingScope(cmd, scatterSampler)) { ScatterFog(cmd, froxelWriteTex, scatterTextureIden, volumetricFogComputeShader); } using (new ProfilingScope(cmd, compositeSampler)) { CompositeVolumetricFog(cmd, cameraColorIden, cameraDepthAttachmentIden, scatterTextureIden, compositeTextureIden, volumetricFogComputeShader); } context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(scatterTextureID); cmd.ReleaseTemporaryRT(compositeTextureID); } } } VolumetricFogComputeShader.compute é‡å¤´æˆæ¥äº†ï¼Œè¿™ä¸ªCompute Shaderä¸€å…±æœ‰3ä¸ªkernelã€‚ç¬¬ä¸€ä¸ªç”¨æ¥é€šè¿‡é›¾çš„ä¿¡æ¯å’Œé˜´å½±çš„ä¿¡æ¯è®¡ç®—å…‰ç…§å¹¶å‚¨å­˜åˆ°_RW_FroxelTextureä¸­ï¼ŒåŒæ—¶ä¹Ÿåšäº†è‡ªèº«çš„å’Œå†å²çš„æ··åˆï¼Œä¹Ÿå¯¹TAAåšäº†é€‚é…ã€‚ç¬¬äºŒä¸ªç”¨æ¥åšçº¹ç†ç©ºé—´çš„Ray Marchingï¼Œè®¡ç®—æ•£å°„çš„é¢œè‰²å’Œé€å…‰ç‡ã€‚ç¬¬ä¸‰ä¸ªå…¶å®æ˜¯ä¸€ä¸ªå±å¹•åå¤„ç†çš„æ•ˆæœï¼Œå°†é›¾æ•ˆç”»åˆ°å±å¹•ä¸Šï¼Œå½“åœ¨ç‰©ä»¶shaderä¸­è®¡ç®—é›¾æ•ˆæ—¶ï¼Œå°±ä¸éœ€è¦è¿™ä¸ªkerneläº†ã€‚\nGetDepthæ˜¯å°†çº¹ç†çš„zè½¬æ¢åˆ°è§†ç©ºé—´çš„çº¿æ€§æ·±åº¦(Linear Eye Depth)ï¼ŒGetRatioåˆ™æ˜¯ç›¸åï¼ŒæŠŠçº¿æ€§çš„è§†ç©ºé—´çš„æ·±åº¦è½¬æ¢åˆ°çº¹ç†çš„zåæ ‡ï¼Œ NOT_SIMPLIFIEDè¿™ä¸ªå®å¯ä»¥è®©äººæ›´å¥½çš„ç†è§£æŒ‡æ•°å‹åˆ†å¸ƒçš„è®¡ç®—è¿‡ç¨‹ã€‚\nä¸ºäº†ç®€åŒ–é—®é¢˜ï¼Œè¿™è¾¹åªè€ƒè™‘äº†ä¸»å…‰æºä½¿ç”¨è”çº§é˜´å½±æ—¶çš„ä½“ç§¯é›¾æ•ˆæœï¼Œä¹Ÿæ²¡æœ‰è€ƒè™‘é›†æˆSHæ¥è®¡ç®—å…¨å±€å…‰ç…§å¯¹ä½“ç§¯é›¾çš„å½±å“ã€‚\n#pragma kernel FroxelMain\r#pragma kernel ScatterMain\r#pragma kernel CompositeMain\r#define _MAIN_LIGHT_SHADOWS\r#define _MAIN_LIGHT_SHADOWS_CASCADE\r#define _SHADOWS_SOFT\r#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\r#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\rTexture2D _DepthTexture;\rTexture2D _ColorTexture;\rTexture3D _FroxelTexture;\rTexture3D _ScatterTexture;\rRWTexture3D _RW_FroxelTexture;\rRWTexture3D _RW_ScatterTexture;\rRWTexture2D _RW_CompositeTexture;\rSamplerState sampler_LinearClamp;\rSamplerState sampler_PointClamp;\rfloat4 _ColorTextureSize;\r//float4 _InvColorTextureSize;\rfloat4 _FroxelTextureSize;\r//float4 _InvFroxelTextureSize;\rfloat _StepCount;\rfloat4 _NearFar;\rfloat4 _FogTint;\rfloat4 _VolumetricFogParams;\r// x: cam near, y: cam far, z: fog near, w: fog far\r#define _Phase _VolumetricFogParams.x\r#define _Density _VolumetricFogParams.y\r#define _Intensity _VolumetricFogParams.z\r#define _MaxTransmittance _VolumetricFogParams.w\rfloat4 _TAAOffsets;\rfloat4x4 _LastViewProj;\rfloat3 NDCToWorld(float3 ndc)\r{\rndc.xy = 2.0f * ndc.xy - 1.0f;\rndc.y = -ndc.y;\rfloat4x4 invJitteredVP = UNITY_MATRIX_I_VP;//mul(UNITY_MATRIX_I_V, _InvJitteredProj);\rfloat4 positionWS = mul(invJitteredVP, float4(ndc, 1.0f));\rreturn positionWS.xyz / positionWS.w;\r}\rfloat Linear01DepthToRawDepth(float z, float4 zBufferParams)\r{\rreturn (rcp(z) - zBufferParams.y) / zBufferParams.x;\r}\rfloat LinearEyeToRawDepth(float depth, float4 zBufferParams)\r{\rreturn (1.0f / depth - zBufferParams.w) / zBufferParams.z;\r}\rfloat GetDepth(float2 camNearFar, float2 vfNearFar, float ratio)\r{\r#if NOT_SIMPLIFIED\rfloat valLeft = log(vfNearFar.x / camNearFar.x);\rfloat valRight = log(vfNearFar.y / camNearFar.x);\rfloat val = lerp(valLeft, valRight, ratio);\rfloat depthVal = camNearFar.x * exp(val);\rreturn depthVal;\r#else\rfloat valLeft = log(vfNearFar.x);\rfloat valRight = log(vfNearFar.y);\rfloat val = lerp(valLeft, valRight, ratio);\rfloat depthVal = exp(val);\rreturn depthVal;\r#endif\r}\rfloat GetRatio(float2 camNearFar, float2 vfNearFar, float linearDepth)\r{\r#if NOT_SIMPLIFIED\rfloat valLeft = log(vfNearFar.x / camNearFar.x);\rfloat valRight = log(vfNearFar.y / camNearFar.x);\rfloat val = log(linearDepth / camNearFar.x);\rfloat ratio = (val - valLeft) / (valRight - valLeft);\rreturn ratio;\r#else\rfloat valLeft = log(vfNearFar.x);\rfloat valRight = log(vfNearFar.y);\rfloat val = log(linearDepth);\rfloat ratio = (val - valLeft) / (valRight - valLeft);\rreturn ratio;\r#endif\r}\rfloat HGPhaseFunction(float g, float cosTheta)\r{\rfloat g2 = g * g;\rfloat denominator = 1.0f + g2 - 2 * g * cosTheta;\rreturn 0.25 * (1.0f - g2) * rsqrt(denominator * denominator * denominator);\r}\rfloat3 GetFogColor(float3 color, float3 lightDir, float3 viewDir, float g)\r{\rfloat cosVal = dot(-lightDir, viewDir);\rreturn color * HGPhaseFunction(g, cosVal);\r}\rfloat Hash13(float3 p)\r{\rp = frac(p * 0.1031);\rp += dot(p, p.zyx + 31.32);\rreturn frac((p.x + p.y) * p.z);\r}\r[numthreads(8,8,8)]\rvoid FroxelMain (uint3 id : SV_DispatchThreadID)\r{\rfloat2 texcoord = (id.xy + 0.5f) / _FroxelTextureSize.xy;\rtexcoord += 0.5f * _TAAOffsets.xy;\rfloat jitter = Hash13(float3(texcoord, _Time.y * id.z));\rfloat ratio = (id.z + jitter) / _FroxelTextureSize.z;\rfloat depthVal = GetDepth(_NearFar.xy, _NearFar.zw, ratio);\rfloat rawDepth = LinearEyeToRawDepth(depthVal, _ZBufferParams);\rfloat3 positionNDC = float3(texcoord, rawDepth);\rfloat3 positionWS = NDCToWorld(positionNDC);\rfloat3 viewDir = normalize(GetCameraPositionWS() - positionWS); float4 shadowCoord = TransformWorldToShadowCoord(positionWS); Light mainLight = GetMainLight(shadowCoord);\rfloat3 lightColor = mainLight.color * mainLight.shadowAttenuation;\rfloat3 lightDir = mainLight.direction;\rfloat3 fogColor = GetFogColor(lightColor, lightDir, viewDir, _Phase);\rfogColor += _FogTint.rgb * _FogTint.a;\rfloat density = _Density;\rfloat4 finalFroxel = float4(fogColor, density);\r// Reprojection Temporal Filter\rfloat ujRatio = (id.z + 0.5) / _FroxelTextureSize.z;\rfloat ujDepthVal = GetDepth(_NearFar.xy, _NearFar.zw, ujRatio);\rfloat ujRawDepth = LinearEyeToRawDepth(ujDepthVal, _ZBufferParams);\rfloat3 ujPositionNDC = float3(texcoord, ujRawDepth);\rfloat3 ujPositionWS = NDCToWorld(ujPositionNDC);\rfloat4 lastPositionCS = mul(_LastViewProj, float4(ujPositionWS, 1.0f));\rlastPositionCS /= lastPositionCS.w;\rlastPositionCS.y = -lastPositionCS.y;\rfloat3 lastNDC = float3(lastPositionCS.xy * 0.5 + 0.5, lastPositionCS.z);\rlastNDC.xy -= 0.5f * _TAAOffsets.zw;\rif(all(lastNDC  0.0) \u0026\u0026 all(lastNDC åè®° å¥½ä¹…æ²¡æœ‰å†™æ–°çš„åšå®¢å•¦ï¼Œä¹‹å‰ä¸€ç›´åœ¨å­¦c++ï¼Œä¸æ€ä¹ˆæœ‰æ—¶é—´åšæ–°çš„ä¸œè¥¿ã€‚ä½“ç§¯é›¾è¿˜æ˜¯ä¸€ä¸ªè›®é‡è¦çš„æ•ˆæœï¼Œä¹‹å‰åšRay Marchingçš„æ—¶å€™è€æ˜¯æŠŠæ¡ä¸ä½è¯¥æ­¥è¿›å¤šå°‘ï¼Œç”¨äº†æŒ‡æ•°å‹çš„æ­¥è¿›ä¹‹åå°±æ„Ÿè§‰è±ç„¶å¼€æœ—äº†ã€‚TAAå…¶å®ä¹Ÿåšäº†ä¸€ç‰ˆæ–°çš„ï¼Œè¿˜æ²¡æ¥å¾—åŠå†™ï¼ŒGTAOä¹Ÿå­¦äº†ä¸€éï¼Œå°±ä¹‹åå†è¯´å§ã€‚\n","wordCount":"1730","inLanguage":"en","image":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/posts/images/VolumetricFog.jpg","datePublished":"2022-08-23T12:00:00+08:00","dateModified":"2022-08-23T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/create-volumetric-fog-using-view-aligned-3d-texture/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾</h1><div class=post-description>ä½¿ç”¨3Dçº¹ç†å’ŒCompute Shaderæ¥æ¸²æŸ“ä½“ç§¯é›¾.</div><div class=post-meta><span title="2022-08-23 12:00:00 +0800 CST">August 23, 2022</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/create-volumetric-fog-using-view-aligned-3D-texture.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/VolumetricFog.jpg alt="Volumetric Fog Cover"><p>Volumetric Fog Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>ä½¿ç”¨å’Œè§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†æ¥æ¸²æŸ“ä½“ç§¯é›¾</div></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%b8%b2%e6%9f%93%e4%bd%93%e7%a7%af%e9%9b%be aria-label=ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾>ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾</a></li><li><a href=#%e4%bd%93%e7%a7%af%e9%9b%be%e7%9a%84%e6%b8%b2%e6%9f%93%e6%96%b9%e6%b3%95 aria-label=ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•>ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81%e5%92%8c%e8%af%b4%e6%98%8e aria-label=ç›¸å…³ä»£ç å’Œè¯´æ˜>ç›¸å…³ä»£ç å’Œè¯´æ˜</a><ul><li><a href=#volumetricfogcs aria-label=VolumetricFog.cs>VolumetricFog.cs</a></li><li><a href=#volumetricfogrendererfeaturecs aria-label=VolumetricFogRendererFeature.cs>VolumetricFogRendererFeature.cs</a></li><li><a href=#volumetricfogrenderpasscs aria-label=VolumetricFogRenderPass.cs>VolumetricFogRenderPass.cs</a></li><li><a href=#volumetricfogcomputeshadercompute aria-label=VolumetricFogComputeShader.compute>VolumetricFogComputeShader.compute</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾>ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾<a hidden class=anchor aria-hidden=true href=#ä¸ºä»€ä¹ˆè¦æ¸²æŸ“ä½“ç§¯é›¾>#</a></h2><p>å› ä¸ºå®ƒå°±åœ¨é‚£é‡Œã€‚</p><p>å½“ç„¶äº†ï¼Œæ›´é‡è¦çš„æ˜¯å› ä¸ºä½“ç§¯é›¾èƒ½è¿…é€Ÿçš„è¥é€ å‡ºåœºæ™¯çš„çœŸå®æ„Ÿä¸æ°›å›´æ„Ÿï¼Œè°ä¸å–œæ¬¢å…‰æºè¾¹ä¸Šè¿˜æœ‰ä¸€å°åœˆå…‰æ™•å‘¢ï¼Œå¦‚æœä»€ä¹ˆé«˜äº®çš„ç‰©ä½“éƒ½èƒ½å½±å“ä½“ç§¯é›¾çš„è¯ï¼Œæ˜¯ä¸æ˜¯å°±ä¸å¤ªéœ€è¦bloomæ•ˆæœäº†å‘¢ã€‚æˆ‘å®é™…åœ°åœ¨ç”Ÿæ´»ä¸­è§‚å¯Ÿäº†ä¸€ä¸‹ï¼Œå‘ç°äººçœ¼æ‰€çœ‹åˆ°çš„å…‰æ™•çš„æ•ˆæœï¼Œæ˜¯å…‰çº¿è¿›å…¥çœ¼ç›ä¹‹åäº§ç”Ÿçš„ï¼Œä¹Ÿå°±æ˜¯è¯´bloomå’Œä½“ç§¯é›¾ç¡®ç¡®å®å®æ˜¯ä¸¤ç§ä¸åŒçš„æ•ˆæœã€‚</p><h2 id=ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•>ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#ä½“ç§¯é›¾çš„æ¸²æŸ“æ–¹æ³•>#</a></h2><p>ä½“ç§¯é›¾ä¸€èˆ¬æœ‰ä¸¤ç§æ¸²æŸ“æ–¹æ³•ï¼Œä¸€ç§æ˜¯å•çº¯çš„ä»ç›¸æœºå‡ºå‘å¯¹åœºæ™¯è¿›è¡ŒRay Marchingï¼Œæ¯æ¬¡è¿›è¡Œé‡‡æ ·å’Œæ··åˆã€‚è¿™ç§æ–¹æ³•ä¸»è¦çš„ç¼ºç‚¹æ˜¯Ray Marchingçš„æ¬¡æ•°ä¼šæ¯”è¾ƒé«˜æ‰èƒ½æœ‰è¾ƒå¥½çš„æ¸²æŸ“æ•ˆæœã€‚åœ¨æˆ‘çš„æµ‹è¯•ä¸­ï¼Œå¼€å¯TAAçš„æ—¶å€™ï¼Œ20æ¬¡Ray Marchingå°±èƒ½å¾—åˆ°å¾ˆå¥½çš„ä½“ç§¯é›¾æ•ˆæœäº†ï¼›ä½†æ˜¯ä¸å¼€å¯TAAçš„è¯ï¼Œå¯èƒ½ä¼šéœ€è¦60æ¬¡ç”šè‡³æ›´é«˜çš„Ray Marchingæ‰èƒ½å¾—åˆ°å’ŒTAAç±»ä¼¼çš„æ•ˆæœã€‚åŒæ—¶ï¼ŒRay Marchingä½“ç§¯é›¾åªèƒ½åœ¨åå¤„ç†é˜¶æ®µä½¿ç”¨ï¼Œåœ¨å¤„ç†ä¸å†™æ·±åº¦çš„é€æ˜ç‰©ä½“çš„æ—¶å€™ï¼Œä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚</p><p>å¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€å¼ 3Dçº¹ç†ï¼Œå°†æ•´ä¸ªåœºæ™¯çš„ä½“ç§¯é›¾å‚¨å­˜åœ¨è¿™å¼ 3Dçº¹ç†ä¸­ï¼Œå½“ç»˜åˆ¶ç‰©ä½“çš„æ—¶å€™ä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´åæ ‡é‡‡æ ·è¿™å¼ 3Dçº¹ç†ï¼Œç›´æ¥åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­è®¡ç®—é›¾æ•ˆä¹‹åçš„é¢œè‰²ã€‚è¿™ç§æ–¹æ³•ä½¿ç”¨çš„3Dçº¹ç†ä¼šå ç”¨æ›´å¤šçš„å†…å­˜ï¼Œä½†æ˜¯ä¸€å®šç¨‹åº¦ä¸Šèƒ½å¤Ÿæ­£ç¡®çš„æ¸²æŸ“æ‰€æœ‰ç‰©ä½“ï¼Œå’Œ60æ¬¡Ray Marchingç›¸æ¯”ï¼Œæ€§èƒ½ä¸Šä¹Ÿè¯´ä¸å®šä¼šæœ‰ä¸€äº›ä¼˜åŠ¿ã€‚</p><p>æœ¬æ–‡çš„ä½“ç§¯é›¾å®ç°ï¼Œå‚è€ƒäº†<a href=https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite>EAçš„å¯’éœœå¼•æ“åœ¨Siggraph 2015å¹´æ—¶çš„æ¼”è®²</a>å’Œ<a href=https://github.com/diharaw/volumetric-lighting>diharawçš„OpenGLçš„ä½“ç§¯é›¾æ•ˆæœ</a>ã€‚å€¼å¾—ä¸€çœ‹çš„è¿˜æœ‰<a href=https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pptx>Bart Wronskiåœ¨Siggraph 2014å¹´çš„æ¼”è®²</a>ï¼Œä»¥åŠä¹‹åçš„<a href=https://advances.realtimerendering.com/s2019/slides_public_release.pptx>è’é‡å¤§é•–å®¢åœ¨Siggraph 2019å¹´çš„è¯¾ç¨‹</a>ã€‚ä½¿ç”¨çš„æ˜¯Unity2019.4.29çš„URPå·¥ç¨‹ã€‚</p><h2 id=å…·ä½“çš„å®ç°æ–¹æ³•>å…·ä½“çš„å®ç°æ–¹æ³•<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„å®ç°æ–¹æ³•>#</a></h2><ol><li>å°†åœºæ™¯ä¸­çš„éœ€è¦æ¸²æŸ“çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯å‚¨å­˜åˆ°ä¸€å¼ å’Œç›¸æœºçš„è§†é”¥ä½“å¯¹é½çš„3Dçº¹ç†ä¸­ã€‚æŒ‰ç…§å¯’éœœå¼•æ“çš„åšæ³•ï¼Œçº¹ç†å¤§å°ä¸º(åˆ†è¾¨ç‡å®½/8)x(åˆ†è¾¨ç‡é«˜/8)x64ï¼Œè¿™æ ·å°±å’Œå±å¹•å¤§å°çš„2Dçº¹ç†å ç”¨çš„å†…å­˜å¤§å°ä¸€è‡´äº†ï¼Œä½†æˆ‘çœ‹Unityå®˜æ–¹çš„ä½“ç§¯é›¾å·¥ç¨‹ä¸­ï¼Œ3Dçº¹ç†çš„æ·±åº¦ä¸º128ï¼Œå°±ä¹ŸæŠŠè‡ªå·±çš„è®¾ç½®æˆ128äº†ï¼Œçº¹ç†æ·±åº¦è¶Šæ·±ï¼Œä½“ç§¯é›¾çš„ç»†èŠ‚å°±èƒ½è¶Šé«˜ã€‚3Dçº¹ç†çš„å®½é«˜å’Œè§†é”¥ä½“å¯¹é½ï¼Œè¿™å¾ˆå¥½ç†è§£ï¼Œè€Œè¿™å¼ è´´å›¾çš„çºµå‘æ·±åº¦å’Œå®é™…çš„æ·±åº¦è¦æ€ä¹ˆå¯¹é½å‘¢ï¼Ÿæœ€ç®€å•çš„å°±æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œä½†æ˜¯è¿™ä¼šå¯¼è‡´è¿‘å¤„ä½“ç§¯é›¾çš„åˆ†è¾¨ç‡ä¸å¤Ÿï¼›å¦ä¸€ç§æ˜¯å’Œè£å‰ªç©ºé—´çš„æ·±åº¦çº¿æ€§å¯¹åº”ï¼Œç»è¿‡ä¸€äº›åˆ†æå¯ä»¥çŸ¥é“è¿™æ¯”ä¹‹å‰çš„æ–¹æ³•æ›´ç³Ÿç³•ï¼›ç›®å‰æˆ‘çœ‹ä¸‹æ¥æœ€å¥½çš„åº”è¯¥æ˜¯å’Œè§†ç©ºé—´çš„æ·±åº¦æŒ‡æ•°å‹å¯¹åº”ï¼Œè¿™æ ·ç¦»ç›¸æœºè¶Šè¿‘3Dçº¹ç†çš„åƒç´ ä¼šè¶Šå¤šï¼Œè¶Šè¿œåˆ™è¶Šå°‘ã€‚æœ¬æ–‡åªä½¿ç”¨äº†å‡ä¸€çš„é›¾ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ä¸–ç•Œç©ºé—´çš„åæ ‡ã€å™ªæ³¢å’Œä¸€ç³»åˆ—çš„è¿ç®—ï¼Œè®¡ç®—å‡ºæŸä¸€ç‚¹çš„ä½“ç§¯é›¾çš„æµ“åº¦ã€‚</li><li>ä½¿ç”¨ä¸Šé¢çš„é›¾çš„ä¿¡æ¯å’Œé˜´å½±ä¿¡æ¯è®¡ç®—å‡ºæ•£å°„çš„å€¼<code>Lscat</code>ï¼Œä»ä¸‹é¢çš„å›¾å¯ä»¥çœ‹åˆ°<code>Lscat</code>æ˜¯å¯¹æ‰€æœ‰çš„å…‰æºï¼ˆæœ¬æ–‡åªæœ‰ä¸»å…‰æºï¼‰è®¡ç®—\(f(v, l)Vis(x, l)Li(x, l)\)çš„å’Œï¼Œ\(Vis(x, l)\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å¯è§æ€§ï¼Œå¯ä»¥é€šè¿‡é‡‡æ ·é˜´å½±è´´å›¾æ¥è·å¾—ï¼Œ\(Li(x, l)\)å³ä¸ºåœ¨xç‚¹lå…‰çš„å…‰å¼ºï¼Œå¯ä»¥ç®€å•çš„è®¡ç®—è·å¾—ï¼Œ\(f(v, l)\)ç”¨æ¥è¡¨è¿°åœ¨vçš„æ–¹å‘è§‚å¯Ÿé›¾æ—¶å¾—åˆ°lçš„æ•£å°„é‡ï¼Œä¸€èˆ¬è¢«å«åšPhase Functionï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯Henyey-Greenstein Phase Functionï¼Œå…¶ä¸­å‚æ•°gæ˜¯é›¾çš„å„å‘å¼‚æ€§çš„ç¨‹åº¦ï¼Œè¶Šé è¿‘1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¿æŒä¹‹å‰çš„æ–¹å‘ï¼Œè¶Šé è¿‘0è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶å‡åŒ€çš„æ•£å°„ï¼Œè¶Šé è¿‘-1è¡¨ç¤ºå…‰çº¿ç©¿è¿‡é›¾æ—¶è¶Šä¼šè¿›è¡Œåå°„ï¼ˆåœ¨å®é™…çš„å…‰ç…§ä¸­ï¼Œæˆ‘ä»¬ä¼šå»æ‰\(\pi\)è¿™ä¸€é¡¹ï¼Œè¿™æ ·èƒ½å’ŒUnityçš„å…‰ç…§æ¨¡å‹ä¿æŒä¸€è‡´ï¼‰ã€‚æ—¶ç©ºæ··åˆä¹Ÿåœ¨è¿™ä¸€æ­¥å¯ä»¥å®Œæˆã€‚</li></ol><p>$$
\tag{Henyey-Greenstein} p(\theta) = \frac 1 {4\pi} \frac {1 - g^2} {(1 + g^2 - 2g \cos \theta)^{\frac 3 2}}
$$</p><p><img loading=lazy src=../images/VolumetricFogScattering.jpg#center alt="Volumetric Fog Scattering"></p><ol start=3><li>å¯¹3Dçº¹ç†ä»ç›¸æœºè¿‘ç‚¹åˆ°è¿œç‚¹è¿›è¡Œæ··åˆï¼Œè¿™å…¶å®æ˜¯ä¸€ç§Ray Marchingï¼Œä¸è¿‡æ˜¯åœ¨3Dçº¹ç†çš„çº¹ç†ç©ºé—´è¿›è¡ŒRay Marchingï¼Œä¸€æ¬¡å‰è¿›ä¸€ä¸ªåƒç´ ã€‚å½“æ··åˆå½“å‰åƒç´ å’Œä¸Šä¸€ä¸ªåƒç´ æ—¶ï¼Œéœ€è¦è€ƒè™‘ç¬¦åˆç‰©ç†çš„é€å…‰ç‡(transmittance), \(\varepsilon\)æ˜¯ä¸€ä¸ªç”¨äºå½’ä¸€åŒ–çš„å¸¸é‡ï¼Œlæ˜¯ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œcæ˜¯ä»‹è´¨çš„å¸æ”¶ç‡ï¼ˆä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç”¨é›¾çš„å¯†åº¦æ¥è¡¨ç¤ºï¼‰ã€‚å…·ä½“çš„æ··åˆçš„è®¡ç®—å’Œè¯´æ˜å¯ä»¥çœ‹EAå¯’éœœå¼•æ“çš„PPTç¬¬28ã€29é¡µã€‚</li></ol><p>$$
\tag{Beer-Lambert} transmittance = e^{-\varepsilon l c}
$$</p><ol start=4><li>æœ€ç»ˆåœ¨ç»˜åˆ¶ç‰©ä½“æ—¶ï¼Œä½¿ç”¨ç‰©ä½“çš„ä¸–ç•Œç©ºé—´çš„åæ ‡ï¼Œè½¬æ¢åˆ°3Dçº¹ç†çš„åæ ‡ï¼Œé‡‡æ ·3Dçº¹ç†ï¼Œä½¿ç”¨é€å…‰ç‡ä¹˜ä¸Šç‰©ä½“æœ¬èº«çš„é¢œè‰²ï¼Œå†åŠ ä¸Šé›¾çš„é¢œè‰²ï¼Œå°±å¾—åˆ°äº†æœ€ç»ˆçš„ä½“ç§¯é›¾çš„æ•ˆæœäº†ã€‚</li></ol><h2 id=ç›¸å…³ä»£ç å’Œè¯´æ˜>ç›¸å…³ä»£ç å’Œè¯´æ˜<a hidden class=anchor aria-hidden=true href=#ç›¸å…³ä»£ç å’Œè¯´æ˜>#</a></h2><h3 id=volumetricfogcs>VolumetricFog.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogcs>#</a></h3><p>ç”¨äºGlobal Volumeä¸­æ–¹ä¾¿æ·»åŠ ä½“ç§¯é›¾å’Œæ§åˆ¶å„ç§å‚æ•°ã€‚å€¼å¾—è€ƒè™‘çš„æ˜¯<code>maxTransmittance</code>çš„å€¼ï¼Œå› ä¸ºç›¸æœºè¿œè£å‰ªé¢ä¼šæ¯”è¾ƒè¿œï¼Œå³ä½¿é›¾å¹¶ä¸æ˜¯å¾ˆå¤§ï¼Œåœ¨æœ€è¿œå¤„ä¹Ÿæ€»æ˜¯èƒ½å˜æˆå•ä¸€çš„é¢œè‰²ï¼Œè¿™ä¸ªå€¼ç”¨æ¥é˜²æ­¢è¿™ç§æƒ…å†µï¼Œäººä¸ºåœ°é™åˆ¶äº†æœ€å¤§ä¸é€å…‰ç‡ï¼ˆä½†æ˜¯è¿˜æ˜¯å«maxTransmittanceï¼‰ã€‚<code>fogNear</code>è¿™ä¸ªå‚æ•°å®é™…æ˜¯å½±å“äº†3Dçº¹ç†å’Œç›¸æœºä¹‹é—´çš„è·ç¦»ï¼Œæœ€å¥½è¿˜æ˜¯è®¾ç½®æˆ0ï¼Œä¸ç„¶æ—¶ç©ºæ··åˆæ—¶ä¼šæœ‰ä¸€äº›ç‘•ç–µã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>using</span> System;

<span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
<span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;Post-processing/Volumetric Fog&#34;)]</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFog</span> : VolumeComponent, IPostProcessComponent
    {
<span style=color:#a6e22e>        [Tooltip(&#34;æ˜¯å¦å¯ç”¨ä½“ç§¯é›¾&#34;)]</span>
        <span style=color:#66d9ef>public</span> BoolParameter enabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
<span style=color:#a6e22e>        [Tooltip(&#34;æ•´ä½“æ§åˆ¶ä½“ç§¯é›¾å¼ºåº¦&#34;)]</span>
        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1.0f</span>);
<span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾æœ€å¤§çš„é€æ˜ç¨‹åº¦ï¼ˆç”¨äºå’Œå¤©ç©ºæ··åˆï¼‰&#34;)]</span>
        <span style=color:#66d9ef>public</span> ClampedFloatParameter maxTransmittance = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>1.0f</span>);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾çš„é¢œè‰²å€¾å‘ï¼Œç›®å‰å¼ºåº¦ä¸º0.03&#34;)]</span>
        <span style=color:#66d9ef>public</span> ColorParameter fogTint = <span style=color:#66d9ef>new</span> ColorParameter(Color.white);
<span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿‘çš„è·ç¦»&#34;)]</span>
        <span style=color:#66d9ef>public</span> ClampedFloatParameter fogNear = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>0.01f</span>, <span style=color:#ae81ff>10f</span>);
<span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾è·ç¦»ç›¸æœºæœ€è¿œçš„è·ç¦»&#34;)]</span>
        <span style=color:#66d9ef>public</span> ClampedFloatParameter fogFar = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>100f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>1000.0f</span>);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾çš„å¯†åº¦ï¼Œè¶Šå¯†æ•ˆæœè¶Šæ˜æ˜¾&#34;)]</span>
        <span style=color:#66d9ef>public</span> ClampedFloatParameter density = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>3.0f</span>, <span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>10.0f</span>);
<span style=color:#a6e22e>        [Tooltip(&#34;ä½“ç§¯é›¾å—å…‰çš„å„å‘å¼‚æ€§ç¨‹åº¦&#34;)]</span>
        <span style=color:#66d9ef>public</span> ClampedFloatParameter phase = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, -<span style=color:#ae81ff>0.9f</span>, <span style=color:#ae81ff>0.9f</span>);

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive() =&gt; (enabled.<span style=color:#66d9ef>value</span> &amp;&amp; (density.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>) &amp;&amp; (intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>));

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible() =&gt; <span style=color:#66d9ef>false</span>;
    }
}
</code></pre></div><h3 id=volumetricfogrendererfeaturecs>VolumetricFogRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogrendererfeaturecs>#</a></h3><p>å¹³å¹³å¸¸å¸¸çš„RendererFeatureï¼Œäº‹å®ä¸ŠRenderPassEventåº”è¯¥åœ¨DepthPrePassä¹‹åï¼Œä½†æˆ‘æ²¡æ”¹ç‰©ä½“çš„shaderï¼Œå°±æ”¾åœ¨åå¤„ç†ä¹‹å‰äº†ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogRendererFeature</span> : ScriptableRendererFeature
    {
<span style=color:#a6e22e>        [System.Serializable]</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogSettings</span>
        {
            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
            <span style=color:#66d9ef>public</span> ComputeShader volumetricFogComputeShader;
        }

        <span style=color:#66d9ef>private</span> VolumetricFogRenderPass volumetricFogRenderPass;
        <span style=color:#66d9ef>public</span> VolumetricFogSettings volumetricFogSettings = <span style=color:#66d9ef>new</span> VolumetricFogSettings();

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
        {
            volumetricFogRenderPass = <span style=color:#66d9ef>new</span> VolumetricFogRenderPass(volumetricFogSettings);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            <span style=color:#66d9ef>if</span> (renderingData.cameraData.cameraType == CameraType.Game)
            {
                VolumetricFog volumetricFog = VolumeManager.instance.stack.GetComponent&lt;VolumetricFog&gt;();
                <span style=color:#66d9ef>if</span> (volumetricFog &amp;&amp; volumetricFog.IsActive())
                {
                    volumetricFogRenderPass.Setup(volumetricFog);
                    renderer.EnqueuePass(volumetricFogRenderPass);
                }
            }
        }
    }
}
</code></pre></div><h3 id=volumetricfogrenderpasscs>VolumetricFogRenderPass.cs<a hidden class=anchor aria-hidden=true href=#volumetricfogrenderpasscs>#</a></h3><p>å¹³å¹³å¸¸å¸¸çš„RenderPassï¼Œå®é™…ä½¿ç”¨çš„æ—¶å€™ï¼Œåªä¼šç”¨åˆ°<code>Froxel Generate Pass</code>å’Œ<code>Scatter Pass</code>ï¼Œ<code>Composite Pass</code>å®Œå…¨å¯ä»¥ç”¨ç‰©ä»¶æœ¬èº«çš„æ¸²æŸ“æ¥ä»£æ›¿ã€‚</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
{
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolumetricFogRenderPass</span> : ScriptableRenderPass
    {
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;Volumetric Fog Pass&#34;</span>;
        <span style=color:#66d9ef>private</span> ProfilingSampler profilingSampler;
        <span style=color:#66d9ef>private</span> ProfilingSampler froxelSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Froxel Generate Pass&#34;</span>);
        <span style=color:#66d9ef>private</span> ProfilingSampler scatterSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Scatter Pass&#34;</span>);
        <span style=color:#66d9ef>private</span> ProfilingSampler compositeSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Composite Pass&#34;</span>);

        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraColor;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;
        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepth;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthIden;
        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepthAttachment;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthAttachmentIden;

        <span style=color:#66d9ef>private</span> VolumetricFog volumetricFog;
        <span style=color:#66d9ef>private</span> ComputeShader volumetricFogComputeShader;
        <span style=color:#66d9ef>private</span> VolumetricFogRendererFeature.VolumetricFogSettings settings;

        <span style=color:#66d9ef>private</span> RenderTexture[] froxelTextures;
        <span style=color:#66d9ef>private</span> RenderTextureDescriptor cubeDesc;

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> froxelTextureOneName = <span style=color:#e6db74>&#34;_FroxelBufferOne&#34;</span>;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> froxelTextureOneID = Shader.PropertyToID(froxelTextureOneName);
        <span style=color:#66d9ef>private</span> RenderTargetHandle froxelTextureOneHandle;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier froxelTextureOneIden;

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> froxelTextureTwoName = <span style=color:#e6db74>&#34;_FroxelBufferTwo&#34;</span>;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> froxelTextureTwoID = Shader.PropertyToID(froxelTextureTwoName);
        <span style=color:#66d9ef>private</span> RenderTargetHandle froxelTextureTwoHandle;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier froxelTextureTwoIden;

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> scatterTextureName = <span style=color:#e6db74>&#34;_ScatterBuffer&#34;</span>;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> scatterTextureID = Shader.PropertyToID(scatterTextureName);
        <span style=color:#66d9ef>private</span> RenderTargetHandle scatterTextureHandle;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier scatterTextureIden;

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> compositeTextureName = <span style=color:#e6db74>&#34;_CompositeBuffer&#34;</span>;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> compositeTextureID = Shader.PropertyToID(compositeTextureName);
        <span style=color:#66d9ef>private</span> RenderTargetHandle compositeTextureHandle;
        <span style=color:#66d9ef>private</span> RenderTargetIdentifier compositeTextureIden;

        <span style=color:#66d9ef>private</span> Vector2 colorTextureSize;
        <span style=color:#66d9ef>private</span> Vector2 invColorTextureSize;
        <span style=color:#66d9ef>private</span> Vector3 froxelTextureSize;
        <span style=color:#66d9ef>private</span> Vector3 invFroxelTextureSize;

        <span style=color:#66d9ef>private</span> Matrix4x4 lastViewProjMatrix;
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> flipReadWrite = <span style=color:#ae81ff>0</span>;

        <span style=color:#66d9ef>public</span> VolumetricFogRenderPass(VolumetricFogRendererFeature.VolumetricFogSettings settings)
        {
            <span style=color:#66d9ef>this</span>.settings = settings;
            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
            renderPassEvent = settings.renderPassEvent;
            volumetricFogComputeShader = settings.volumetricFogComputeShader;

            cameraColor.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
            cameraColorIden = cameraColor.Identifier();
            cameraDepth.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
            cameraDepthIden = cameraDepth.Identifier();
            cameraDepthAttachment.Init(<span style=color:#e6db74>&#34;_CameraDepthAttachment&#34;</span>);
            cameraDepthAttachmentIden = cameraDepthAttachment.Identifier();

            froxelTextureOneHandle.Init(froxelTextureOneName);
            froxelTextureOneIden = froxelTextureOneHandle.Identifier();
            froxelTextureTwoHandle.Init(froxelTextureTwoName);
            froxelTextureTwoIden = froxelTextureTwoHandle.Identifier();
            scatterTextureHandle.Init(scatterTextureName);
            scatterTextureIden = scatterTextureHandle.Identifier();
            compositeTextureHandle.Init(compositeTextureName);
            compositeTextureIden = compositeTextureHandle.Identifier();

            lastViewProjMatrix = Matrix4x4.identity;
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(VolumetricFog volumetricFog)
        {
            <span style=color:#66d9ef>this</span>.volumetricFog = volumetricFog;
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureArray&lt;T&gt;(<span style=color:#66d9ef>ref</span> T[] array, <span style=color:#66d9ef>int</span> size, T initialValue = <span style=color:#66d9ef>default</span>(T))
        {
            <span style=color:#66d9ef>if</span> (array == <span style=color:#66d9ef>null</span> || array.Length != size)
            {
                array = <span style=color:#66d9ef>new</span> T[size];
                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i != size; i++)
                    array[i] = initialValue;
            }
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRenderTexture(<span style=color:#66d9ef>ref</span> RenderTexture rt, RenderTextureDescriptor descriptor, <span style=color:#66d9ef>string</span> RTName)
        {
            <span style=color:#66d9ef>if</span> (rt != <span style=color:#66d9ef>null</span> &amp;&amp; (rt.width != descriptor.width || rt.height != descriptor.height))
            {
                RenderTexture.ReleaseTemporary(rt);
                rt = <span style=color:#66d9ef>null</span>;
            }

            <span style=color:#66d9ef>if</span> (rt == <span style=color:#66d9ef>null</span>)
            {
                RenderTextureDescriptor desc = descriptor;
                desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
                desc.msaaSamples = <span style=color:#ae81ff>1</span>;
                rt = RenderTexture.GetTemporary(desc);
                <span style=color:#75715e>//rt = new RenderTexture(desc);
</span><span style=color:#75715e></span>                rt.name = RTName;
                <span style=color:#66d9ef>if</span> (!rt.IsCreated()) rt.Create();
            }
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> EnsureRT(<span style=color:#66d9ef>ref</span> RenderTexture[] froxelTexs, RenderTextureDescriptor descriptor)
        {
            EnsureArray(<span style=color:#66d9ef>ref</span> froxelTexs, <span style=color:#ae81ff>2</span>);
            EnsureRenderTexture(<span style=color:#66d9ef>ref</span> froxelTexs[<span style=color:#ae81ff>0</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex One&#34;</span>);
            EnsureRenderTexture(<span style=color:#66d9ef>ref</span> froxelTexs[<span style=color:#ae81ff>1</span>], descriptor, <span style=color:#e6db74>&#34;Froxel Tex Two&#34;</span>);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            RenderTextureDescriptor desc = cameraTextureDescriptor;
            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
            cmd.GetTemporaryRT(compositeTextureID, desc);
            colorTextureSize = <span style=color:#66d9ef>new</span> Vector2(desc.width, desc.height);
            invColorTextureSize = <span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>1.0f</span> / desc.width, <span style=color:#ae81ff>1.0f</span> / desc.height);

            <span style=color:#66d9ef>int</span> width = desc.width / <span style=color:#ae81ff>8</span>;
            <span style=color:#66d9ef>int</span> height = desc.height / <span style=color:#ae81ff>8</span>;
            <span style=color:#66d9ef>int</span> volmeDepth = <span style=color:#ae81ff>128</span>;
            cubeDesc = <span style=color:#66d9ef>new</span> RenderTextureDescriptor(
                    width, height,
                    Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat,
                    <span style=color:#ae81ff>0</span>);
            cubeDesc.volumeDepth = volmeDepth;
            cubeDesc.dimension = TextureDimension.Tex3D;
            cubeDesc.enableRandomWrite = <span style=color:#66d9ef>true</span>;

            froxelTextureSize = <span style=color:#66d9ef>new</span> Vector3(width, height, volmeDepth);
            invFroxelTextureSize = <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>1.0f</span> / (width-<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>1.0f</span> / (height-<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>1.0f</span> / (volmeDepth-<span style=color:#ae81ff>0</span>));

            cmd.GetTemporaryRT(scatterTextureID, cubeDesc);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GenerateFroxel(CommandBuffer cmd, CameraData camData, RenderTargetIdentifier depthid,
            RenderTexture froxelReadid, RenderTexture froxelWriteid,
            ComputeShader computeShader)
        {
            <span style=color:#66d9ef>int</span> froxelKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;FroxelMain&#34;</span>);
            computeShader.GetKernelThreadGroupSizes(froxelKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_FroxelTextureSize&#34;</span>, froxelTextureSize);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_ColorTextureSize&#34;</span>, colorTextureSize);
            cmd.SetComputeMatrixParam(computeShader, <span style=color:#e6db74>&#34;_LastViewProj&#34;</span>, lastViewProjMatrix);

            Matrix4x4 projMat = camData.GetGPUProjectionMatrix();
            Matrix4x4 viewMat = camData.GetViewMatrix();
            lastViewProjMatrix = projMat * viewMat;
            
            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_DepthTexture&#34;</span>, depthid);
            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_FroxelTexture&#34;</span>, froxelReadid);
            cmd.SetComputeTextureParam(computeShader, froxelKernel, <span style=color:#e6db74>&#34;_RW_FroxelTexture&#34;</span>, froxelWriteid);

            Color fogTint = volumetricFog.fogTint.<span style=color:#66d9ef>value</span>;
            fogTint.a = <span style=color:#ae81ff>0.03f</span>;
            volumetricFog.fogTint.Override(fogTint);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_FogTint&#34;</span>, volumetricFog.fogTint.<span style=color:#66d9ef>value</span>);
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_NearFar&#34;</span>,
                <span style=color:#66d9ef>new</span> Vector4(camData.camera.nearClipPlane, camData.camera.farClipPlane,
                            volumetricFog.fogNear.<span style=color:#66d9ef>value</span>, volumetricFog.fogFar.<span style=color:#66d9ef>value</span>));
            cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_VolumetricFogParams&#34;</span>,
                <span style=color:#66d9ef>new</span> Vector4(volumetricFog.phase.<span style=color:#66d9ef>value</span>,
                            volumetricFog.density.<span style=color:#66d9ef>value</span>,
                            volumetricFog.intensity.<span style=color:#66d9ef>value</span>,
                            volumetricFog.maxTransmittance.<span style=color:#66d9ef>value</span>));

            cmd.DispatchCompute(computeShader, froxelKernel,
                Mathf.CeilToInt(froxelTextureSize.x / x),
                Mathf.CeilToInt(froxelTextureSize.y / y),
                Mathf.CeilToInt(froxelTextureSize.z / z));
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ScatterFog(CommandBuffer cmd, RenderTexture froxelid, RenderTargetIdentifier scatterid, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>int</span> scatterKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;ScatterMain&#34;</span>);
            computeShader.GetKernelThreadGroupSizes(scatterKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);

            cmd.SetComputeTextureParam(computeShader, scatterKernel, <span style=color:#e6db74>&#34;_FroxelTexture&#34;</span>, froxelid);
            cmd.SetComputeTextureParam(computeShader, scatterKernel, <span style=color:#e6db74>&#34;_RW_ScatterTexture&#34;</span>, scatterid);

            cmd.DispatchCompute(computeShader, scatterKernel,
                Mathf.CeilToInt(froxelTextureSize.x / x),
                Mathf.CeilToInt(froxelTextureSize.y / y),
                <span style=color:#ae81ff>1</span>);
        }

        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CompositeVolumetricFog(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier depthid, RenderTargetIdentifier scatterid, RenderTargetIdentifier compositeid, ComputeShader computeShader)
        {
            <span style=color:#66d9ef>int</span> compositeKernel = computeShader.FindKernel(<span style=color:#e6db74>&#34;CompositeMain&#34;</span>);
            computeShader.GetKernelThreadGroupSizes(compositeKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);

            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_ColorTexture&#34;</span>, colorid);
            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_DepthTexture&#34;</span>, depthid);
            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_ScatterTexture&#34;</span>, scatterid);
            cmd.SetComputeTextureParam(computeShader, compositeKernel, <span style=color:#e6db74>&#34;_RW_CompositeTexture&#34;</span>, compositeid);

            cmd.DispatchCompute(computeShader, compositeKernel,
                Mathf.CeilToInt(colorTextureSize.x / x),
                Mathf.CeilToInt(colorTextureSize.y / y),
                <span style=color:#ae81ff>1</span>);

            cmd.Blit(compositeid, colorid);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
        {
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            EnsureRT(<span style=color:#66d9ef>ref</span> froxelTextures, cubeDesc);
            RenderTexture froxelReadTex = froxelTextures[flipReadWrite];
            RenderTexture froxelWriteTex = froxelTextures[<span style=color:#ae81ff>1</span> - flipReadWrite];
            flipReadWrite = <span style=color:#ae81ff>1</span> - flipReadWrite;

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, froxelSampler))
            {
                GenerateFroxel(cmd, renderingData.cameraData, cameraDepthAttachmentIden, froxelReadTex, froxelWriteTex, volumetricFogComputeShader);
            }

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, scatterSampler))
            {
                ScatterFog(cmd, froxelWriteTex, scatterTextureIden, volumetricFogComputeShader);
            }

            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, compositeSampler))
            {
                CompositeVolumetricFog(cmd, cameraColorIden, cameraDepthAttachmentIden,
                    scatterTextureIden, compositeTextureIden, volumetricFogComputeShader);
            }

            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();
            CommandBufferPool.Release(cmd);
        }

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
        {        
            cmd.ReleaseTemporaryRT(scatterTextureID);
            cmd.ReleaseTemporaryRT(compositeTextureID);
        }
    }
}
</code></pre></div><h3 id=volumetricfogcomputeshadercompute>VolumetricFogComputeShader.compute<a hidden class=anchor aria-hidden=true href=#volumetricfogcomputeshadercompute>#</a></h3><p>é‡å¤´æˆæ¥äº†ï¼Œè¿™ä¸ªCompute Shaderä¸€å…±æœ‰3ä¸ªkernelã€‚ç¬¬ä¸€ä¸ªç”¨æ¥é€šè¿‡é›¾çš„ä¿¡æ¯å’Œé˜´å½±çš„ä¿¡æ¯è®¡ç®—å…‰ç…§å¹¶å‚¨å­˜åˆ°<code>_RW_FroxelTexture</code>ä¸­ï¼ŒåŒæ—¶ä¹Ÿåšäº†è‡ªèº«çš„å’Œå†å²çš„æ··åˆï¼Œä¹Ÿå¯¹TAAåšäº†é€‚é…ã€‚ç¬¬äºŒä¸ªç”¨æ¥åšçº¹ç†ç©ºé—´çš„Ray Marchingï¼Œè®¡ç®—æ•£å°„çš„é¢œè‰²å’Œé€å…‰ç‡ã€‚ç¬¬ä¸‰ä¸ªå…¶å®æ˜¯ä¸€ä¸ªå±å¹•åå¤„ç†çš„æ•ˆæœï¼Œå°†é›¾æ•ˆç”»åˆ°å±å¹•ä¸Šï¼Œå½“åœ¨ç‰©ä»¶shaderä¸­è®¡ç®—é›¾æ•ˆæ—¶ï¼Œå°±ä¸éœ€è¦è¿™ä¸ªkerneläº†ã€‚</p><p><code>GetDepth</code>æ˜¯å°†çº¹ç†çš„zè½¬æ¢åˆ°è§†ç©ºé—´çš„çº¿æ€§æ·±åº¦(Linear Eye Depth)ï¼Œ<code>GetRatio</code>åˆ™æ˜¯ç›¸åï¼ŒæŠŠçº¿æ€§çš„è§†ç©ºé—´çš„æ·±åº¦è½¬æ¢åˆ°çº¹ç†çš„zåæ ‡ï¼Œ NOT_SIMPLIFIEDè¿™ä¸ªå®å¯ä»¥è®©äººæ›´å¥½çš„ç†è§£æŒ‡æ•°å‹åˆ†å¸ƒçš„è®¡ç®—è¿‡ç¨‹ã€‚</p><p>ä¸ºäº†ç®€åŒ–é—®é¢˜ï¼Œè¿™è¾¹åªè€ƒè™‘äº†ä¸»å…‰æºä½¿ç”¨è”çº§é˜´å½±æ—¶çš„ä½“ç§¯é›¾æ•ˆæœï¼Œä¹Ÿæ²¡æœ‰è€ƒè™‘é›†æˆSHæ¥è®¡ç®—å…¨å±€å…‰ç…§å¯¹ä½“ç§¯é›¾çš„å½±å“ã€‚</p><pre><code class=language-HLSL data-lang=HLSL>#pragma kernel FroxelMain
#pragma kernel ScatterMain
#pragma kernel CompositeMain

#define _MAIN_LIGHT_SHADOWS
#define _MAIN_LIGHT_SHADOWS_CASCADE
#define _SHADOWS_SOFT

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;

Texture2D&lt;float&gt; _DepthTexture;
Texture2D&lt;float4&gt; _ColorTexture;
Texture3D&lt;float4&gt; _FroxelTexture;
Texture3D&lt;float4&gt; _ScatterTexture;

RWTexture3D&lt;float4&gt; _RW_FroxelTexture;
RWTexture3D&lt;float4&gt; _RW_ScatterTexture;
RWTexture2D&lt;float4&gt; _RW_CompositeTexture;

SamplerState sampler_LinearClamp;
SamplerState sampler_PointClamp;

float4 _ColorTextureSize;
//float4 _InvColorTextureSize;
float4 _FroxelTextureSize;
//float4 _InvFroxelTextureSize;

float _StepCount;
float4 _NearFar;
float4 _FogTint;
float4 _VolumetricFogParams;
// x: cam near, y: cam far, z: fog near, w: fog far

#define _Phase _VolumetricFogParams.x
#define _Density _VolumetricFogParams.y
#define _Intensity _VolumetricFogParams.z
#define _MaxTransmittance _VolumetricFogParams.w

float4 _TAAOffsets;
float4x4 _LastViewProj;

float3 NDCToWorld(float3 ndc)
{
    ndc.xy = 2.0f * ndc.xy - 1.0f;
    ndc.y = -ndc.y;
    float4x4 invJitteredVP = UNITY_MATRIX_I_VP;//mul(UNITY_MATRIX_I_V, _InvJitteredProj);
    float4 positionWS = mul(invJitteredVP, float4(ndc, 1.0f));
    return positionWS.xyz / positionWS.w;
}

float Linear01DepthToRawDepth(float z, float4 zBufferParams)
{
    return (rcp(z) - zBufferParams.y) / zBufferParams.x;
}

float LinearEyeToRawDepth(float depth, float4 zBufferParams)
{
    return (1.0f / depth - zBufferParams.w) / zBufferParams.z;
}

float GetDepth(float2 camNearFar, float2 vfNearFar, float ratio)
{
#if NOT_SIMPLIFIED
    float valLeft = log(vfNearFar.x / camNearFar.x);
    float valRight = log(vfNearFar.y / camNearFar.x);
    float val = lerp(valLeft, valRight, ratio);
    float depthVal = camNearFar.x * exp(val);
    return depthVal;
#else
    float valLeft = log(vfNearFar.x);
    float valRight = log(vfNearFar.y);
    float val = lerp(valLeft, valRight, ratio);
    float depthVal = exp(val);
    return depthVal;
#endif
}

float GetRatio(float2 camNearFar, float2 vfNearFar, float linearDepth)
{
#if NOT_SIMPLIFIED
    float valLeft = log(vfNearFar.x / camNearFar.x);
    float valRight = log(vfNearFar.y / camNearFar.x);

    float val = log(linearDepth / camNearFar.x);
    float ratio = (val - valLeft) / (valRight - valLeft);
    return ratio;
#else
    float valLeft = log(vfNearFar.x);
    float valRight = log(vfNearFar.y);

    float val = log(linearDepth);
    float ratio = (val - valLeft) / (valRight - valLeft);
    return ratio;
#endif
}

float HGPhaseFunction(float g, float cosTheta)
{
    float g2 = g * g;
    float denominator = 1.0f + g2 - 2 * g * cosTheta;
    return 0.25 * (1.0f - g2) * rsqrt(denominator * denominator * denominator);
}

float3 GetFogColor(float3 color, float3 lightDir, float3 viewDir, float g)
{
    float cosVal = dot(-lightDir, viewDir);
    return color * HGPhaseFunction(g, cosVal);
}

float Hash13(float3 p)
{
    p = frac(p * 0.1031);
    p += dot(p, p.zyx + 31.32);
    return frac((p.x + p.y) * p.z);
}

[numthreads(8,8,8)]
void FroxelMain (uint3 id : SV_DispatchThreadID)
{
    float2 texcoord = (id.xy + 0.5f) / _FroxelTextureSize.xy;
    texcoord += 0.5f * _TAAOffsets.xy;
    float jitter = Hash13(float3(texcoord, _Time.y * id.z));
    float ratio = (id.z + jitter) / _FroxelTextureSize.z;
    float depthVal = GetDepth(_NearFar.xy, _NearFar.zw, ratio);
    float rawDepth = LinearEyeToRawDepth(depthVal, _ZBufferParams);
    float3 positionNDC = float3(texcoord, rawDepth);
    float3 positionWS = NDCToWorld(positionNDC);

    float3 viewDir = normalize(GetCameraPositionWS() - positionWS); 
    float4 shadowCoord = TransformWorldToShadowCoord(positionWS);   
    Light mainLight = GetMainLight(shadowCoord);
    float3 lightColor = mainLight.color * mainLight.shadowAttenuation;
    float3 lightDir = mainLight.direction;
    
    float3 fogColor = GetFogColor(lightColor, lightDir, viewDir, _Phase);
    fogColor += _FogTint.rgb * _FogTint.a;
    float density = _Density;

    float4 finalFroxel = float4(fogColor, density);

    // Reprojection Temporal Filter
    float ujRatio = (id.z + 0.5) / _FroxelTextureSize.z;
    float ujDepthVal = GetDepth(_NearFar.xy, _NearFar.zw, ujRatio);
    float ujRawDepth = LinearEyeToRawDepth(ujDepthVal, _ZBufferParams);
    float3 ujPositionNDC = float3(texcoord, ujRawDepth);
    float3 ujPositionWS = NDCToWorld(ujPositionNDC);
    float4 lastPositionCS = mul(_LastViewProj, float4(ujPositionWS, 1.0f));
    lastPositionCS /= lastPositionCS.w;
    lastPositionCS.y = -lastPositionCS.y;
    float3 lastNDC = float3(lastPositionCS.xy * 0.5 + 0.5, lastPositionCS.z);
    lastNDC.xy -= 0.5f * _TAAOffsets.zw;

    if(all(lastNDC &gt; 0.0) &amp;&amp; all(lastNDC &lt; 1.0f))
    {
        float linearEyeDepth = LinearEyeDepth(lastNDC.z, _ZBufferParams);
        float reprojRatio = GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth);
        float4 froxelTex = _FroxelTexture.SampleLevel(sampler_LinearClamp, float3(lastNDC.xy, reprojRatio), 0);
        finalFroxel = lerp(finalFroxel, froxelTex, 0.95);
    }

    _RW_FroxelTexture[id] = finalFroxel;
}

float SliceThickness(int z)
{
    float ratioThis = z / _FroxelTextureSize.z;
    float depthThis = GetDepth(_NearFar.xy, _NearFar.zw, ratioThis);

    float ratioNext = (z+1.0f) / _FroxelTextureSize.z;
    float depthNext = GetDepth(_NearFar.xy, _NearFar.zw, ratioNext);

    return depthNext - depthThis;
}

float4 AccumScatter(int z, float4 accum, float4 slice)
{
    slice.a = max(slice.a, 1e-5);
    float thickness = SliceThickness(z);

    float sliceTransmittance = exp(-slice.a * thickness * 0.01f);
    float3 sliceScattering = slice.rgb * (1.0f - sliceTransmittance);

    float3 accumScattering = accum.rgb + sliceScattering * accum.a;
    float accumTransmittance = accum.a * sliceTransmittance;
    return float4(accumScattering, accumTransmittance);
}

[numthreads(16,16,1)]
void ScatterMain (uint3 id : SV_DispatchThreadID)
{
    float4 accum = float4(0.0f, 0.0f, 0.0f, 1.0f);

    for (int z=0; z&lt;_FroxelTextureSize.z; z++)
    {
        int3 coord = int3(id.xy, z);
        float4 slice = _FroxelTexture[coord];
        accum = AccumScatter(z, accum, slice);
        //_RW_ScatterTexture[coord] = slice;
        _RW_ScatterTexture[coord] = accum;
    }
}

[numthreads(16,16,1)]
void CompositeMain (uint3 id : SV_DispatchThreadID)
{  
    float2 texcoord = (id.xy + 0.5f) * rcp(_ColorTextureSize.xy);
    float3 colorTex = _ColorTexture.SampleLevel(sampler_PointClamp, texcoord, 0).rgb;
    float depthTex = _DepthTexture.SampleLevel(sampler_PointClamp, texcoord, 0);

    float linearEyeDepth = LinearEyeDepth(depthTex, _ZBufferParams);
    float ratio = GetRatio(_NearFar.xy, _NearFar.zw, linearEyeDepth);

    float4 froxelTex = _ScatterTexture.SampleLevel(sampler_LinearClamp, float3(texcoord, ratio), 0);
    
    float3 accumScatter = froxelTex.rgb;
    float accumTrans = max(1.0f - _MaxTransmittance, froxelTex.a);
    float3 finalColor = colorTex * accumTrans + froxelTex.rgb;
    finalColor = lerp(colorTex.rgb, finalColor, _Intensity);

    _RW_CompositeTexture[id.xy] = float4(finalColor, 1.0f);
}
</code></pre><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>å¥½ä¹…æ²¡æœ‰å†™æ–°çš„åšå®¢å•¦ï¼Œä¹‹å‰ä¸€ç›´åœ¨å­¦c++ï¼Œä¸æ€ä¹ˆæœ‰æ—¶é—´åšæ–°çš„ä¸œè¥¿ã€‚ä½“ç§¯é›¾è¿˜æ˜¯ä¸€ä¸ªè›®é‡è¦çš„æ•ˆæœï¼Œä¹‹å‰åšRay Marchingçš„æ—¶å€™è€æ˜¯æŠŠæ¡ä¸ä½è¯¥æ­¥è¿›å¤šå°‘ï¼Œç”¨äº†æŒ‡æ•°å‹çš„æ­¥è¿›ä¹‹åå°±æ„Ÿè§‰è±ç„¶å¼€æœ—äº†ã€‚TAAå…¶å®ä¹Ÿåšäº†ä¸€ç‰ˆæ–°çš„ï¼Œè¿˜æ²¡æ¥å¾—åŠå†™ï¼ŒGTAOä¹Ÿå­¦äº†ä¸€éï¼Œå°±ä¹‹åå†è¯´å§ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/volumetric-fog/>Volumetric Fog</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-ray-marching/><span class=title>Â« Prev</span><br><span>ä½¿ç”¨Ray Marchingæ¥æ¸²æŸ“ä½“ç§¯é›¾</span></a>
<a class=next href=https://zznewclear13.github.io/posts/get-view-space-normal-from-depth-texture/><span class=title>Next Â»</span><br><span>ä»æ·±åº¦å›¾ä¸­è·å–è§†ç©ºé—´çš„æ³•çº¿</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>