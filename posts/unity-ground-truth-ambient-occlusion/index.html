<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO | ZZNEWCLEAR13</title>
<meta name=keywords content="Ground Truth Ambient Occlusion,Compute Shader,Screen Space"><meta name=description content="ä½¿ç”¨GroupSharedMemoryåŠ é€ŸGTAOçš„è®¡ç®—."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-JZ0FQH1VK5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JZ0FQH1VK5")}</script><meta property="og:title" content="Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO"><meta property="og:description" content="ä½¿ç”¨GroupSharedMemoryåŠ é€ŸGTAOçš„è®¡ç®—."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/"><meta property="og:image" content="https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/posts/images/GTAO.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-02T12:00:00+08:00"><meta property="article:modified_time" content="2022-12-02T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/posts/images/GTAO.jpg"><meta name=twitter:title content="Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO"><meta name=twitter:description content="ä½¿ç”¨GroupSharedMemoryåŠ é€ŸGTAOçš„è®¡ç®—."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO","item":"https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO","name":"Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO","description":"ä½¿ç”¨GroupSharedMemoryåŠ é€ŸGTAOçš„è®¡ç®—.","keywords":["Ground Truth Ambient Occlusion","Compute Shader","Screen Space"],"articleBody":"ç¯å¢ƒå…‰é®è”½ ç¯å¢ƒå…‰é®è”½ï¼Œåœ¨å¾ˆä¹…å¾ˆä¹…ä»¥å‰ç©åˆºå®¢ä¿¡æ¡çš„æ—¶å€™å°±çœ‹åˆ°è¿‡è¿™ä¸ªè¯è¯­ï¼Œä½†æ˜¯å¹¶ä¸æ‡‚ä»€ä¹ˆæ„æ€ï¼Œæœ¬ç€ç”»è´¨æ‹‰æ»¡çš„åŸåˆ™æ€»æ˜¯ä¼šå‹¾é€‰è¿™ä¸ªé€‰é¡¹ã€‚åæ¥æ‰çŸ¥é“ç¯å¢ƒå…‰é®è”½ç¿»è¯‘è‡ªAmbient Occlusionï¼ˆè¿˜çœŸæ˜¯ç›´ç™½çš„ç¿»è¯‘ï¼‰ï¼Œç”¨æ¥è¡¨ç°è§’è½é‡Œé˜´æš—çš„æ•ˆæœã€‚\nç¯å¢ƒå…‰é®è”½ä½œç”¨åœ¨å…‰çº¿è®¡ç®—çš„é—´æ¥å…‰ç…§çš„é˜¶æ®µï¼Œç”±äºå…‰æ …åŒ–æ¸²æŸ“çš„å±€é™æ€§ï¼Œé—´æ¥å…‰ç…§å¾€å¾€åˆ†ä¸ºæ¼«åå°„é—´æ¥å…‰ç…§å’Œé«˜å…‰é—´æ¥å…‰ç…§ï¼Œå› æ­¤ç¯å¢ƒå…‰é®è”½ä¹Ÿåˆ†æ¼«åå°„å’Œé«˜å…‰ä¸¤ç§ï¼Œè¿™é‡Œæš‚æ—¶åªè®¨è®ºä½œç”¨äºæ¼«åå°„é—´æ¥å…‰ç…§çš„æ¼«åå°„ç¯å¢ƒå…‰é®è”½ã€‚è€Œåˆç”±äºå‰å‘æ¸²æŸ“çš„å±€é™æ€§ï¼Œå±å¹•ç©ºé—´çš„ç¯å¢ƒå…‰é®è”½ä¸åˆ†å·®åˆ«åœ°ä½œç”¨äºç›´æ¥å…‰ç…§å’Œé—´æ¥å…‰ç…§ï¼Œå› æ­¤å…¶å¼ºåº¦è¿˜éœ€è¦ç‰¹åˆ«åœ°ç•™æ„ã€‚\nGround Truth Ambient Occlusionæ˜¯Jorge Jimenezåœ¨ä»–çš„æ–‡ç« Practical Real-Time Strategies for Accurate Indirect Occlusionä¸­ä»‹ç»çš„ä¸€ç§åœ¨ä¸»æœºä¸Šèƒ½å¤Ÿç¬¦åˆäº‹å®ç¯å¢ƒå…‰é®è”½æ•ˆæœçš„ä¸€ç§å±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½çš„ç®—æ³•ã€‚æˆ‘è®¤ä¸ºè¿™ä¸ªç®—æ³•ç›¸è¾ƒäºå…¶ä»–çš„ç¯å¢ƒå…‰é®è”½çš„ç®—æ³•æœ€å¤§çš„ä¼˜ç‚¹æ˜¯ï¼Œæš—éƒ¨å¤Ÿæš—ï¼Œåœ¨å¾ˆçª„çš„ç¼éš™ä¸­èƒ½å¤Ÿå¾ˆé»‘å¾ˆé»‘ï¼Œè¿™æ˜¯åˆ«çš„ç®—æ³•åšä¸åˆ°çš„ã€‚\næœ¬æ–‡æå¤§åœ°å‚è€ƒäº†è‹±ç‰¹å°”çš„XeGTAOå¼€æºä»£ç ã€‚\nå…·ä½“çš„æ“ä½œ è¿™ç¯‡æ–‡ç« ç€é‡è¦è®²çš„æ˜¯ä½¿ç”¨Compute Shaderæ¥åŠ é€Ÿè®¡ç®—çš„æ“ä½œæ–¹å¼ï¼Œå› æ­¤ä¸ä¼šå…·ä½“æ¶‰åŠåˆ°GTAOç®—æ³•æœ¬èº«ï¼Œæ„Ÿå…´è¶£çš„è¯å¯ä»¥å»SIGGRAPH 2016 Courseä¸Šé˜…è¯»GTAOçš„pptã€‚\nGTAOçš„è®¡ç®—éœ€è¦è§†ç©ºé—´æ³•çº¿å’Œæ·±åº¦ä¸¤ä¸ªæ•°æ®ï¼Œå¦‚æœæ˜¯å»¶è¿Ÿç®¡çº¿çš„è¯èƒ½è½»æ˜“å¾—æ‹¿åˆ°æ‰€æœ‰æ•°æ®ï¼Œä½†å¯¹äºå‰å‘æ¸²æŸ“æ¥è¯´ï¼Œéœ€è¦ä»æ·±åº¦æ•°æ®è¿˜åŸå‡ºè§†ç©ºé—´æ³•çº¿ã€‚æ­£å¥½æˆ‘ä¹‹å‰çš„æ–‡ç« ä»‹ç»äº†ä¸€äº›ä»æ·±åº¦å›¾è®¡ç®—è§†ç©ºé—´æ³•çº¿çš„æ–¹æ³•ã€‚ä½†åœ¨åŸæœ‰æ–‡ç« çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬è¿˜èƒ½ä½¿ç”¨Group Shared Memoryå¯¹é‡‡æ ·æ•°è¿›è¡Œä¸€ç³»åˆ—çš„ä¼˜åŒ–ã€‚\nç”±äºGTAOç›¸å¯¹æ¥è¯´ç®—æ˜¯æ¯”è¾ƒä½é¢‘çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä½¿ç”¨ä¸‹é‡‡æ ·çš„æ–¹å¼åªç”¨åŠåˆ†è¾¨ç‡ç”šè‡³æ˜¯æ›´ä½çš„åˆ†è¾¨ç‡æ¥è®¡ç®—GTAOã€‚è¿™é‡Œä½¿ç”¨çš„æ–¹æ³•æ˜¯å¯¹NxNå¤§å°çš„åŒºåŸŸï¼Œæ¯ä¸€å¸§åªå–ä¸€ä¸ªé‡‡æ ·ç‚¹ï¼Œæœ€åé€šè¿‡TAAæ¥è¿›è¡Œæ··åˆã€‚\nGTAOæœ¬èº«çš„é‡‡æ ·æ•°ä¹Ÿèƒ½ä½¿ç”¨æ—¶ç©ºå™ªå£°æ¥ç”Ÿæˆè¾ƒå°‘çš„é‡‡æ ·ç‚¹ï¼Œæœ€åé€šè¿‡TAAæ¥è¿›è¡Œæ··åˆã€‚ä½†æ˜¯å®é™…ä½¿ç”¨ä¸­å‘ç°ï¼Œå¦‚æœä½¿ç”¨è¾ƒå¤šçš„æ—¶é—´æ··åˆï¼Œå½“åœºæ™¯ä¸­çš„ç‰©ä½“å‘ç”Ÿç§»åŠ¨ä¹‹åï¼Œä¼šéœ²å‡ºä¸€éƒ¨åˆ†ç™½è‰²çš„ç”»é¢ï¼Œå’Œè¾ƒæ·±çš„AOæœ‰æ¯”è¾ƒæ˜æ˜¾çš„å¯¹æ¯”ï¼Œå› æ­¤è€ƒè™‘å°½é‡å¤šåœ°ä½¿ç”¨ç©ºé—´çš„æ··åˆã€‚\nå¾—ç›ŠäºGroup Shared Memoryï¼Œå¯ä»¥åœ¨éå¸¸å¤§çš„èŒƒå›´å†…è¿›è¡Œç©ºé—´çš„æ··åˆï¼Œè¿™é‡Œä½¿ç”¨é«˜æ–¯æ¨¡ç³Šçš„æ–¹å¼è¿›è¡Œæ··åˆï¼Œèƒ½å¤Ÿå°½é‡ä¿æŒæš—éƒ¨è¾ƒæš—çš„é¢œè‰²ã€‚å¦‚æœç›´æ¥å¯¹æ‰€æœ‰çš„é‡‡æ ·è¿›è¡Œå¹³å‡çš„è¯ï¼Œä¼šå¯¼è‡´æš—éƒ¨å˜å¾—å¾ˆäº®ï¼Œå¤±å»äº†GTAOæœ€å‡ºä¼—çš„ä¼˜ç‚¹ã€‚å¯¹æ°´å¹³å’Œç«–ç›´æ–¹å‘åšä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šçš„è¯ï¼Œç”±äºæœ¬èº«è¿˜ä¼šæ ¹æ®æ·±åº¦å’Œæ³•çº¿ç®—å‡ºé¢å¤–çš„å‡ ä½•ä¸Šçš„æƒé‡ï¼Œåœ¨ä¸‹é‡‡æ ·ç¨‹åº¦è¾ƒå¤§çš„æ—¶å€™ä¼šäº§ç”Ÿæ¯”è¾ƒæ˜æ˜¾çš„ç‘•ç–µï¼Œå¯ä»¥ç”¨å…¨åˆ†è¾¨ç‡çš„æ·±åº¦å›¾å’Œæ³•çº¿æ¥è§£å†³ï¼Œä½†è¿™ä¼šå¸¦æ¥é¢å¤–çš„é‡‡æ ·ã€‚\nåœ¨é«˜æ–¯æ¨¡ç³Šçš„é˜¶æ®µï¼Œç”±äºæ¨¡ç³Šæ˜¯ä½œç”¨åœ¨ä½åˆ†è¾¨ç‡çš„å›¾åƒä¸Šçš„ï¼Œåœ¨æˆ‘ä»¬çš„ä¸Šé‡‡æ ·çš„æ“ä½œä¸­ï¼Œè¿˜éœ€è¦æ ¹æ®ä¸Šé‡‡æ ·çš„ä½ç½®è¿›è¡ŒåŒçº¿æ€§æ’å€¼ï¼ˆå®é™…ä¸Šåªè¦ä¸€ä¸ªæ–¹å‘çº¿æ€§æ’å€¼å°±å¥½äº†ï¼‰ã€‚\nRender Textureçš„ç²¾åº¦ä¸Šï¼ŒGTAOæœ€åçš„å€¼å¯ä»¥ç”¨8ä½é€šé“æ¥å‚¨å­˜ï¼Œå¦‚æœä¸éœ€è¦é¢å¤–çš„è§†ç©ºé—´æ³•çº¿çš„è¯ï¼Œå¯ä»¥æŠŠGTAOå€¼å’Œ24ä½çš„æ·±åº¦ä¸€èµ·å­˜åˆ°RGBA32çš„RTä¸­ã€‚è¿™é‡Œå°±å·æ‡’ä½¿ç”¨R16G16B16A16_SFloatæ¥å‚¨å­˜äº†ã€‚\nå¦‚æ­¤ä¸€æ¥æ•´ä¸ªè·¯çº¿å›¾å°±æ¯”è¾ƒæ¸…æ™°äº†\nä¸‹é‡‡æ ·æ·±åº¦å›¾è·å–æ·±åº¦æ•°æ® ä½¿ç”¨æ·±åº¦å›¾è®¡ç®—è§†ç©ºé—´çš„æ³•çº¿ï¼Œæˆ–è€…ä»G Bufferç›´æ¥è·å–æ³•çº¿æ•°æ® ä½¿ç”¨æ·±åº¦å›¾å’Œæ³•çº¿è®¡ç®—GTAOçš„å€¼ æ¨ªå‘ä¸Šé‡‡æ ·ï¼Œè®¡ç®—æ°´å¹³é«˜æ–¯æ¨¡ç³Šåçš„GTAOçš„å€¼ çºµå‘ä¸Šé‡‡æ ·ï¼Œè®¡ç®—å‚ç›´é«˜æ–¯æ¨¡ç³Šåçš„GTAOçš„å€¼ ç›¸å…³ä»£ç å’Œè¯´æ˜ GTAOComputeShader.compute é‡ä¸­ä¹‹é‡å°±æ˜¯Compute Shaderäº†ã€‚åˆ†äº†å››ä¸ªKernelï¼šç¬¬ä¸€ä¸ªè®¡ç®—GTAOçš„å€¼ï¼ŒåŒæ—¶è¿˜å‚¨å­˜äº†æ·±åº¦å›¾å’Œæ³•çº¿ï¼ˆé™¤äº†ç›´æ¥å‚¨å­˜æ³•çº¿çš„ä¸¤ä¸ªåˆ†é‡ï¼Œä¹Ÿå¯ä»¥Encodeæˆå…«é¢ä½“æ¥å‚¨å­˜ï¼‰ï¼›ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªåˆ†åˆ«æ˜¯æ°´å¹³å’Œç«–ç›´æ–¹å‘çš„æ¨¡ç³Šï¼›æœ€åä¸€ä¸ªç”¨æ¥å¯è§†åŒ–ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥ä¸ç”¨è¿™ä¸ªã€‚\nå’ŒXeGTAOä¸åŒçš„æ˜¯ï¼Œæˆ‘å¢åŠ äº†ä¸€ä¸ªUSE_AVERAGE_COSçš„å®ï¼Œæ­£å¸¸æ˜¯åœ¨æ¯ä¸€ä¸ªSliceä¸­é€‰æ‹©æœ€å¤§çš„coså€¼ï¼Œä½†æ˜¯è€ƒè™‘åˆ°åœºæ™¯ä¸­æœ‰æ …æ ¼è¿™æ ·çš„ç‰©ä½“ï¼Œåœ¨æ—¶ç©ºæ··åˆç¨‹åº¦ä¸æ˜¯å¾ˆå¤§çš„æ—¶å€™ï¼Œå¯ä»¥è®¡ç®—cosçš„å¹³å‡å€¼æ¥é™ä½æ …æ ¼å¯¹GTAOçš„å½±å“ï¼ˆä¹Ÿå°±æ˜¯å‡å¼±äº†å™ªå£°ï¼‰ï¼Œè¿™ä¸ªå®å®Œå…¨å¯ä»¥ä¸ç”¨å¼€å¯ã€‚\næœ¬æ–‡ä¸ºäº†å°½é‡å¤šçš„ä½¿ç”¨ç©ºé—´æ··åˆï¼ˆäº¦å³ä¸ä½¿ç”¨æ—¶é—´æ··åˆï¼‰ï¼Œåœ¨XeGTAOçš„æ—¶ç©ºå¹³å‡å™ªæ³¢ä¸­é™åˆ¶äº†æ—¶é—´çš„å‚æ•°ä¸º13ï¼Œè¿™æ ·GTAOå°±ä¸ä¼šéšç€æ—¶é—´è€Œå˜åŒ–äº†ï¼Œå®é™…ä¸Šå¯ä»¥ä¼ å…¥_FrameIndexå……åˆ†åˆ©ç”¨æ—¶ç©ºå™ªæ³¢çš„ä¼˜åŠ¿ã€‚\nä¸»è¦æ˜¯ç”¨groupIndexæ¥å‚¨å­˜å’Œè¯»å–Group Shared Memoryï¼Œæ¯ä¸ªç‚¹è‡³å¤šé‡‡æ ·ä¸¤æ¬¡ã€‚è®¡ç®—æ³•çº¿æ—¶ä¼šé‡‡æ ·5x5çš„åŒºåŸŸï¼Œå› æ­¤NORMAL_FROM_DEPTH_PIXEL_RANGEçš„å€¼æ˜¯2ï¼›è®¡ç®—æ¨¡ç³Šæ—¶æ—¢æœ‰é«˜æ–¯æ¨¡ç³Šçš„é‡‡æ ·ï¼Œè¿˜æœ‰åç»­æ‰‹åŠ¨çº¿æ€§æ’å€¼çš„é‡‡æ ·ï¼Œæ‰€ä»¥CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZEä¼šæœ‰ä¸¤è€…ä¹‹å’Œã€‚çº¿æ€§æ’å€¼è¿˜éœ€è¦æ³¨æ„subpixelBiaså¯¹çº¿æ€§æ’å€¼çš„æƒé‡äº§ç”Ÿçš„å½±å“ã€‚\næœ¬æ–‡ä½¿ç”¨äº†å®½åº¦ä¸º29çš„é«˜æ–¯æ ¸ï¼Œå¯ä»¥åœ¨demofoxçš„ç½‘ç«™ä¸Šè½»æ¾çš„è®¡ç®—å¾ˆå¤§çš„é«˜æ–¯æ ¸ã€‚\nå¯èƒ½ä¼šæœ‰æŠ¥å¯„å­˜å™¨ä½¿ç”¨æ•°é‡è¶…è¿‡é™åˆ¶çš„é—®é¢˜ï¼Œæ„Ÿè§‰æ˜¯const arrayå’Œå¾ªç¯å¯¼è‡´çš„ï¼Œä¸è¿‡reimportä¹‹åå°±ä¸ä¼šæŠ¥è¿™ä¸ªè­¦å‘Šäº†ã€‚\n#pragma kernel GTAOMain #pragma kernel BlurHorizontalMain #pragma kernel BlurVerticalMain #pragma kernel VisualizeMain #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" Texture2D\u003cfloat4\u003e _ColorTexture; Texture2D\u003cfloat\u003e _DepthTexture; Texture2D\u003cfloat4\u003e _GTAOTexture; RWTexture2D\u003cfloat4\u003e _RW_NormalTexture; RWTexture2D\u003cfloat4\u003e _RW_GTAOTexture; RWTexture2D\u003cfloat4\u003e _RW_BlurTexture; RWTexture2D\u003cfloat4\u003e _RW_VisualizeTexture; SamplerState sampler_LinearClamp; SamplerState sampler_PointClamp; //region Parameters uint _FrameIndex; uint _DownsamplingFactor; float _Intensity; float _SampleRadius; float _DistributionPower; float _FalloffRange; float2 _HeightFogFalloff; float4 _TextureSize; float4 _TAAOffsets; //endregion //region Pre-defined Marcos #define SQRT2_2 0.70710678118 #define USE_AVERAGE_COS 0 #define SLICE_COUNT 4 #define STEPS_PER_SLICE 3 #define GTAO_THREAD_GROUP_SIZE_X 32 #define GTAO_THREAD_GROUP_SIZE_Y 32 #define BLUR_THREAD_GROUP_SIZE 64 // For normal calculation, can be deleted if we calculate normal in mrt. const static int NORMAL_FROM_DEPTH_PIXEL_RANGE = 2; const static int CACHED_DEPTH_FOR_NORMAL_OFFSET = (GTAO_THREAD_GROUP_SIZE_X + 2*NORMAL_FROM_DEPTH_PIXEL_RANGE); const static int CACHED_DEPTH_FOR_NORMAL_SIZE = CACHED_DEPTH_FOR_NORMAL_OFFSET * (GTAO_THREAD_GROUP_SIZE_Y + 2*NORMAL_FROM_DEPTH_PIXEL_RANGE); // For blur const static int BILINEAR_RADIUS = 1; const static int BLUR_RADIUS = 14; // [-14, +14] for 29 tap gaussian blur const static int CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE = BLUR_THREAD_GROUP_SIZE + 2*(BILINEAR_RADIUS+BLUR_RADIUS); const static int CACHED_AO_FOR_BILINEAR_SIZE = BLUR_THREAD_GROUP_SIZE+2*BILINEAR_RADIUS; //endregion //region Group Shared Memory Help Functions // For normal calculation groupshared float depthForNormal[CACHED_DEPTH_FOR_NORMAL_SIZE]; void SetDepthForNormal(float depth, int index) {depthForNormal[index]=depth;} float GetDepthForNormal(int2 threadPos) {return depthForNormal[threadPos.x+NORMAL_FROM_DEPTH_PIXEL_RANGE+(threadPos.y+NORMAL_FROM_DEPTH_PIXEL_RANGE)*CACHED_DEPTH_FOR_NORMAL_OFFSET];} void CacheDepthForNormal(int2 groupCacheStartPos, uint cacheIndex, int2 subpixelBias) { int2 threadPos = int2(cacheIndex % CACHED_DEPTH_FOR_NORMAL_OFFSET, cacheIndex / CACHED_DEPTH_FOR_NORMAL_OFFSET); int2 texturePos = (groupCacheStartPos + threadPos) * _DownsamplingFactor + subpixelBias; float depth = _DepthTexture.Load(uint3(texturePos, 0)); SetDepthForNormal(depth, cacheIndex); } groupshared float4 aoNormalDepthForBlur[CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE]; void SetAONormalDepthForBlur(float4 aoNormalDepth, int index) {aoNormalDepthForBlur[index]=aoNormalDepth;} float4 GetAONormalDepthForBlur(int threadPos) {return aoNormalDepthForBlur[threadPos+BLUR_RADIUS+BILINEAR_RADIUS];} void CacheAONormalDepthForBlur(int2 groupCacheStartPos, uint cacheIndex, uint vertical) { int2 threadPos = int2(0, 0); threadPos[vertical] = cacheIndex; int2 texturePos = groupCacheStartPos + threadPos; int2 threshold; if(vertical == 0) { threshold = _TextureSize.xy/_DownsamplingFactor - 1; } else { threshold = int2(_TextureSize.x, _TextureSize.y / _DownsamplingFactor) - 1; } texturePos = clamp(texturePos, 0, threshold); float4 aoNormalDepth = _GTAOTexture.Load(uint3(texturePos, 0)); SetAONormalDepthForBlur(aoNormalDepth, cacheIndex); } groupshared float aoForBilinear[CACHED_AO_FOR_BILINEAR_SIZE]; void SetAOForBilinear(float ao, int index) {aoForBilinear[index]=ao;} float GetAOForBilinear(int threadPos) {return aoForBilinear[threadPos.x+BILINEAR_RADIUS];} //endregion //region Space Transformation Help Functions float3 GetViewSpacePositionFromLinearDepth(float2 uv, float linearDepth) { #if UNITY_UV_STARTS_AT_TOP uv.y = 1.0 - uv.y; #endif float2 uvNDC = uv * 2.0 - 1.0; return float3(uvNDC * linearDepth * rcp(UNITY_MATRIX_P._m00_m11), -linearDepth); } float3 GetViewSpacePosition(float2 uv, float depth) { #if UNITY_MATRIX_I_P_SUPPORTED #if UNITY_UV_STARTS_AT_TOP uv.y = 1.0 - uv.y; #endif float3 positionNDC = float3(uv * 2.0 - 1.0, depth); float4 positionVS = mul(UNITY_MATRIX_I_P, float4(positionNDC, 1.0)); positionVS /= positionVS.w; return positionVS.xyz; #else float linearDepth = LinearEyeDepth(depth, _ZBufferParams); return GetViewSpacePositionFromLinearDepth(uv, linearDepth); #endif } float4 LinearEyeDepthFloat4(float4 depthTBLR, float4 zBufferParams) { return rcp(depthTBLR * zBufferParams.z + zBufferParams.w); } //endregion //region GTAO Help Functions //https://github.com/GameTechDev/XeGTAO/blob/master/Source/Rendering/Shaders/XeGTAO.h //-UNITY_MATRIX_P._m11 = rcp(tan(fovy / 2)) float GetScreenSpaceRadius(float linearDepth) { return _SampleRadius * _TextureSize.y * (-UNITY_MATRIX_P._m11) / (2 * linearDepth); } float GetLengthToPixelRatio(float linearDepth) { return _TextureSize.y * (-UNITY_MATRIX_P._m11) / (2 * linearDepth); } // From https://www.shadertoy.com/view/3tB3z3 - except we're using R2 here #define XE_HILBERT_LEVEL 6U #define XE_HILBERT_WIDTH ( (1U \u003c\u003c XE_HILBERT_LEVEL) ) uint HilbertIndex( uint posX, uint posY ) { uint index = 0U; for( uint curLevel = XE_HILBERT_WIDTH/2U; curLevel \u003e 0U; curLevel /= 2U ) { uint regionX = ( posX \u0026 curLevel ) \u003e 0U; uint regionY = ( posY \u0026 curLevel ) \u003e 0U; index += curLevel * curLevel * ( (3U * regionX) ^ regionY); if( regionY == 0U ) { if( regionX == 1U ) { posX = uint( (XE_HILBERT_WIDTH - 1U) ) - posX; posY = uint( (XE_HILBERT_WIDTH - 1U) ) - posY; } uint temp = posX; posX = posY; posY = temp; } } return index; } float2 SpatioTemporalNoise(uint2 pixCoord, uint temporalIndex) { uint index = HilbertIndex(pixCoord.x, pixCoord.y); index += 288*(temporalIndex%64); // why 288? tried out a few and that's the best so far (with XE_HILBERT_LEVEL 6U) - but there's probably better :) // R2 sequence - see http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/ return frac( 0.5 + index * float2(0.75487766624669276005, 0.5698402909980532659114)); } //endregion //region Blur Help Functions float GetWeight(float4 center, float4 samplePoint) { float4 centerAndSampleXY = float4(center.yz, samplePoint.yz) * 2.0f - 1.0f; float3 centerVS = float3(centerAndSampleXY.xy, sqrt(max(0.0f, 1.0f - dot(centerAndSampleXY.xy, centerAndSampleXY.xy)))); float3 sampleVS = float3(centerAndSampleXY.zw, sqrt(max(0.0f, 1.0f - dot(centerAndSampleXY.zw, centerAndSampleXY.zw)))); float normalWeight = saturate(dot(centerVS, sampleVS)); float depthWeight = 1.0f - saturate(abs(center.w - samplePoint.w) * 100.0f); return normalWeight * depthWeight; } void CacheGaussianBlur(uint cacheAOIndex, uint vertical) { int cacheAOThreadPos = cacheAOIndex - BILINEAR_RADIUS; float4 aoNormalDepthC = GetAONormalDepthForBlur(cacheAOThreadPos); float aoSum = 0.0f; float weightSum = 0.0f; float4 aoNormalDepth; float weight; // http://demofox.org/gauss.html const float weights[] = { 0.0002,\t0.0005,\t0.0011,\t0.0023,\t0.0044,\t0.0080,\t0.0136,\t0.0217,\t0.0325,\t0.0457,\t0.0605,\t0.0752,\t0.0879,\t0.0965,\t0.0995,\t0.0965,\t0.0879,\t0.0752,\t0.0605,\t0.0457,\t0.0325,\t0.0217,\t0.0136,\t0.0080,\t0.0044,\t0.0023,\t0.0011,\t0.0005,\t0.0002 }; [unroll(2*BLUR_RADIUS+1)] for (int i = -BLUR_RADIUS; i \u003c= BLUR_RADIUS; ++i) { aoNormalDepth = GetAONormalDepthForBlur(cacheAOThreadPos + i); weight = GetWeight(aoNormalDepthC, aoNormalDepth) * weights[i + BLUR_RADIUS]; aoSum += aoNormalDepth.r * weight; weightSum += weight; } float avgAO = aoSum / weightSum; SetAOForBilinear(avgAO, cacheAOIndex); } //endregion [numthreads(GTAO_THREAD_GROUP_SIZE_X,GTAO_THREAD_GROUP_SIZE_Y,1)] void GTAOMain(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { uint sqrDownSamplingFactor = _DownsamplingFactor * _DownsamplingFactor; int subpixelIndex = _FrameIndex % sqrDownSamplingFactor; int2 subpixelBias = int2(subpixelIndex % _DownsamplingFactor, subpixelIndex / _DownsamplingFactor); int2 pixelCoord = dispatchThreadID.xy * _DownsamplingFactor + subpixelBias; float2 uv = (pixelCoord + 0.5) * _TextureSize.zw; int2 groupCacheStartPos = groupID.xy * int2(GTAO_THREAD_GROUP_SIZE_X, GTAO_THREAD_GROUP_SIZE_Y) - NORMAL_FROM_DEPTH_PIXEL_RANGE; //region Cache Normal int cacheIndex = groupIndex * 2; if(cacheIndex \u003c CACHED_DEPTH_FOR_NORMAL_SIZE-1) { CacheDepthForNormal(groupCacheStartPos, cacheIndex, subpixelBias); CacheDepthForNormal(groupCacheStartPos, cacheIndex + 1, subpixelBias); } GroupMemoryBarrierWithGroupSync(); //endregion uint loadCacheIndex = groupIndex; int2 threadPos = int2(loadCacheIndex % GTAO_THREAD_GROUP_SIZE_X, loadCacheIndex / GTAO_THREAD_GROUP_SIZE_X); //region Calculate Normal From Depth float depthC = GetDepthForNormal(threadPos ); float depthT = GetDepthForNormal(threadPos + int2( 0, 1)); float depthB = GetDepthForNormal(threadPos + int2( 0, -1)); float depthL = GetDepthForNormal(threadPos + int2(-1, 0)); float depthR = GetDepthForNormal(threadPos + int2( 1, 0)); float depthT2 = GetDepthForNormal(threadPos + int2( 0, 2)); float depthB2 = GetDepthForNormal(threadPos + int2( 0, -2)); float depthL2 = GetDepthForNormal(threadPos + int2(-2, 0)); float depthR2 = GetDepthForNormal(threadPos + int2( 2, 0)); // fp16 depth should use this to prevent contour lines due to loss of depth precision. // linearDepth *= 0.99920; // This is for fp32 depth. // linearDepth *= 0.99999; float linearDepth = LinearEyeDepth(depthC, _ZBufferParams) * 0.99999; float4 linearDepths = LinearEyeDepthFloat4(float4(depthT, depthB, depthL, depthR), _ZBufferParams) * 0.99999; float2 center = pixelCoord + 0.5f; float3 viewPosC = GetViewSpacePositionFromLinearDepth(center * _TextureSize.zw, linearDepth); float3 viewPosT = GetViewSpacePositionFromLinearDepth((center + float2( 0, 1) * _DownsamplingFactor) * _TextureSize.zw, linearDepths.x); float3 viewPosB = GetViewSpacePositionFromLinearDepth((center + float2( 0, -1) * _DownsamplingFactor) * _TextureSize.zw, linearDepths.y); float3 viewPosL = GetViewSpacePositionFromLinearDepth((center + float2(-1, 0) * _DownsamplingFactor) * _TextureSize.zw, linearDepths.z); float3 viewPosR = GetViewSpacePositionFromLinearDepth((center + float2( 1, 0) * _DownsamplingFactor) * _TextureSize.zw, linearDepths.w); float3 t = normalize(viewPosT - viewPosC); float3 b = normalize(viewPosC - viewPosB); float3 l = normalize(viewPosC - viewPosL); float3 r = normalize(viewPosR - viewPosC); float4 H = float4(depthL, depthR, depthL2, depthR2); float4 V = float4(depthB, depthT, depthB2, depthT2); float2 he = abs((2 * H.xy - H.zw) - depthC); float2 ve = abs((2 * V.xy - V.zw) - depthC); float3 hDeriv = he.x \u003c he.y ? l : r; float3 vDeriv = ve.x \u003c ve.y ? b : t; float3 normalVS = normalize(cross(hDeriv, vDeriv)); //endregion //region Calculate GTAO From Depth and Normal float2 localNoise = SpatioTemporalNoise(dispatchThreadID.xy, 13); float3 pixCenterPos = viewPosC; float3 viewVec = normalize(-pixCenterPos); float effectRadius = _SampleRadius; float sampleDistributionPower = _DistributionPower; float falloffRange = effectRadius * _FalloffRange; float falloffFrom = effectRadius - falloffRange; float falloffMul = -rcp(falloffRange); float falloffAdd = 1.0 - falloffFrom * falloffMul; float visibility = 0.0; { float noiseSlice = localNoise.x; float noiseSample = localNoise.y; float pixelTooCloseThreshold = 1.3;//Some basic bias preventing sampling current pixel float lengthToPixelRatio = GetLengthToPixelRatio(linearDepth); float screenSpaceRadius = effectRadius * lengthToPixelRatio; //fade GTAO if screenSpaceRadius is too small visibility += saturate((10 - screenSpaceRadius) / 200); float minS = pixelTooCloseThreshold / screenSpaceRadius; //2 * SLICE_COUNT * STEPS_PER_SLICE samples //Almost exactly \"Algorithm 1\" in //https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf [unroll(SLICE_COUNT)] for (int slice = 0; slice \u003c SLICE_COUNT; slice++) { float phi = (slice + noiseSlice) * PI / SLICE_COUNT; float sinPhi, cosPhi; sincos(phi, sinPhi, cosPhi); float2 omega = float2(cosPhi, sinPhi); omega *= screenSpaceRadius; float3 directionVec = float3(cosPhi, sinPhi, 0.0); float3 orthoDirectionVec = directionVec - (dot(directionVec, viewVec) * viewVec); float3 axisVec = normalize(cross(orthoDirectionVec, viewVec)); float3 projectedNormalVec = normalVS - axisVec * dot(normalVS, axisVec); float signNormal = sign(dot(orthoDirectionVec, projectedNormalVec)); float projectedNormalVecLength = length(projectedNormalVec); float cosNorm = saturate(dot(projectedNormalVec, viewVec) / projectedNormalVecLength); float n = signNormal * acos(cosNorm); float lowHorizonCos0 = cos(n + HALF_PI); float lowHorizonCos1 = cos(n - HALF_PI); //Minor improvement float horizonCos0 = lowHorizonCos0; float horizonCos1 = lowHorizonCos1; #if USE_AVERAGE_COS float baseCos0 = 0.0; float baseCos1 = 0.0; #endif [unroll] for (float step = 0; step \u003c STEPS_PER_SLICE; step++) { float stepBaseNoise = (slice + step * STEPS_PER_SLICE) * 0.6180339887498948482; float stepNoise = frac(noiseSample + stepBaseNoise); float s = (step + stepNoise) / STEPS_PER_SLICE; s = pow(s, sampleDistributionPower); s += minS; float2 sampleOffset = s * omega; //In pixel coord; float sampleOffsetLength = length(sampleOffset); sampleOffset = round(sampleOffset) * _TextureSize.zw; //To UV coord float2 sampleScreenPos0 = uv + sampleOffset; float sampleLinearDepth0 = LinearEyeDepth(_DepthTexture.SampleLevel(sampler_PointClamp, sampleScreenPos0, 0), _ZBufferParams); float3 samplePos0 = GetViewSpacePositionFromLinearDepth(sampleScreenPos0, sampleLinearDepth0); float2 sampleScreenPos1 = uv - sampleOffset; float sampleLinearDepth1 = LinearEyeDepth(_DepthTexture.SampleLevel(sampler_PointClamp, sampleScreenPos1, 0), _ZBufferParams); float3 samplePos1 = GetViewSpacePositionFromLinearDepth(sampleScreenPos1, sampleLinearDepth1); float3 sampleDelta0 = samplePos0 - pixCenterPos; float3 sampleDelta1 = samplePos1 - pixCenterPos; float sampleDist0 = length(sampleDelta0); float sampleDist1 = length(sampleDelta1); //Normalize float3 sampleHorizonVec0 = sampleDelta0 / sampleDist0; float3 sampleHorizonVec1 = sampleDelta1 / sampleDist1; float weight0 = saturate(sampleDist0 * falloffMul + falloffAdd); float weight1 = saturate(sampleDist1 * falloffMul + falloffAdd); //sample horizon cos float shc0 = dot(sampleHorizonVec0, viewVec); float shc1 = dot(sampleHorizonVec1, viewVec); shc0 = lerp(lowHorizonCos0, shc0, weight0); shc1 = lerp(lowHorizonCos1, shc1, weight1); #if USE_AVERAGE_COS baseCos0 += shc0; baseCos1 += shc1; #else horizonCos0 = max(horizonCos0, shc0); horizonCos1 = max(horizonCos1, shc1); #endif } #if USE_AVERAGE_COS baseCos0 /= STEPS_PER_SLICE; baseCos1 /= STEPS_PER_SLICE; horizonCos0 = max(baseCos0, horizonCos0); horizonCos1 = max(baseCos1, horizonCos1); #endif float h0 = acos(horizonCos0); float h1 = -acos(horizonCos1); h0 = n + clamp(h0 - n, -HALF_PI, HALF_PI); h1 = n + clamp(h1 - n, -HALF_PI, HALF_PI); float val0 = (cosNorm + 2 * h0 * sin(n) - cos(2 * h0 - n)) / 4; float val1 = (cosNorm + 2 * h1 * sin(n) - cos(2 * h1 - n)) / 4; visibility += projectedNormalVecLength * (val0 + val1); } visibility /= SLICE_COUNT; visibility = max(0.03, visibility); } float outputColor = visibility; #if USE_AVERAGE_COS outputColor /= HALF_PI; #endif //endregion _RW_GTAOTexture[dispatchThreadID.xy] = float4(outputColor, normalVS.xy * 0.5f + 0.5f, depthC); } [numthreads(BLUR_THREAD_GROUP_SIZE,1,1)] void BlurHorizontalMain(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { uint sqrDownSamplingFactor = _DownsamplingFactor * _DownsamplingFactor; int subpixelIndex = _FrameIndex % sqrDownSamplingFactor; int2 subpixelBias = int2(subpixelIndex % _DownsamplingFactor, subpixelIndex / _DownsamplingFactor); int2 pixelCoord = int2(dispatchThreadID.x / _DownsamplingFactor, dispatchThreadID.y); int2 thisSubpixelBias = int2(dispatchThreadID.x % _DownsamplingFactor, 0); //region Cache AO Normal Depth int2 groupCacheStartPos = groupID.xy * int2(BLUR_THREAD_GROUP_SIZE, 1) / int2(_DownsamplingFactor, 1) - int2(BLUR_RADIUS+BILINEAR_RADIUS, 0); int cacheIndex = groupIndex * 2; if(cacheIndex \u003c int(CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE-1)) { CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex, 0); CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex + 1, 0); } GroupMemoryBarrierWithGroupSync(); //endregion float4 thisAONormalDepth = GetAONormalDepthForBlur(groupIndex / _DownsamplingFactor); //region Blur AO int cacheAOIndex = groupIndex * 2; if(cacheAOIndex \u003c CACHED_AO_FOR_BILINEAR_SIZE-1) { CacheGaussianBlur(cacheAOIndex, 0); CacheGaussianBlur(cacheAOIndex + 1, 0); } GroupMemoryBarrierWithGroupSync(); //endregion //region Bilinear Sampling uint loadIndex = groupIndex; int threadPos = loadIndex / _DownsamplingFactor; float2 signVal = sign(thisSubpixelBias - subpixelBias); float thisAO = GetAOForBilinear(threadPos); float leftAO = GetAOForBilinear(threadPos + signVal.x); float2 lerpVal = abs(thisSubpixelBias - subpixelBias) / (float)_DownsamplingFactor; float finalAO = lerp(thisAO, leftAO, lerpVal.x); //endregion _RW_BlurTexture[dispatchThreadID.xy] = float4(finalAO, thisAONormalDepth.yzw); } [numthreads(1,BLUR_THREAD_GROUP_SIZE,1)] void BlurVerticalMain(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { uint sqrDownSamplingFactor = _DownsamplingFactor * _DownsamplingFactor; int subpixelIndex = _FrameIndex % sqrDownSamplingFactor; int2 subpixelBias = int2(subpixelIndex % _DownsamplingFactor, subpixelIndex / _DownsamplingFactor); int2 pixelCoord = dispatchThreadID.xy / _DownsamplingFactor; int2 thisSubpixelBias = dispatchThreadID.xy % _DownsamplingFactor; //region Cache AO Normal Depth int2 groupCacheStartPos = groupID.xy * int2(1, BLUR_THREAD_GROUP_SIZE) / int2(1, _DownsamplingFactor) - int2(0, BLUR_RADIUS+BILINEAR_RADIUS); int cacheIndex = groupIndex * 2; if(cacheIndex \u003c int(CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE-1)) { CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex, 1); CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex + 1, 1); } GroupMemoryBarrierWithGroupSync(); //endregion //region Blur AO int cacheAOIndex = groupIndex * 2; if(cacheAOIndex \u003c CACHED_AO_FOR_BILINEAR_SIZE-1) { CacheGaussianBlur(cacheAOIndex, 1); CacheGaussianBlur(cacheAOIndex + 1, 1); } GroupMemoryBarrierWithGroupSync(); //endregion //region Bilinear Sampling uint loadIndex = groupIndex; int threadPos = loadIndex / _DownsamplingFactor; float2 signVal = sign(thisSubpixelBias - subpixelBias); float thisAO = GetAOForBilinear(threadPos); float topAO = GetAOForBilinear(threadPos + signVal.y); float2 lerpVal = abs(thisSubpixelBias - subpixelBias) / (float)_DownsamplingFactor; float finalAO = lerp(thisAO, topAO, lerpVal.y); //endregion _RW_BlurTexture[dispatchThreadID.xy] = finalAO; } [numthreads(GTAO_THREAD_GROUP_SIZE_X,GTAO_THREAD_GROUP_SIZE_Y,1)] void VisualizeMain(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex, uint3 dispatchThreadID : SV_DispatchThreadID) { float gtaoVal = _GTAOTexture.Load(uint3(dispatchThreadID.xy, 0)).r; float4 colorTexture = _ColorTexture.Load(uint3(dispatchThreadID.xy, 0)); float3 finalColor = colorTexture.rgb * lerp(1.0f, gtaoVal, _Intensity); _RW_VisualizeTexture[dispatchThreadID.xy] = float4(finalColor, 1.0f); } GroundTruthAmbientOcclusion.cs ç”¨äºæ§åˆ¶GTAOçš„å„ç§å‚æ•°ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚\nusing System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenu(\"SSAO/GTAO\")] public class GroundTruthAmbientOcclusion : VolumeComponent, IPostProcessComponent { public ClampedIntParameter downsamplingFactor = new ClampedIntParameter(2, 1, 4); public ClampedFloatParameter intensity = new ClampedFloatParameter(0.0f, 0.0f, 1.0f); public ClampedFloatParameter radius = new ClampedFloatParameter(1.0f, 0.01f, 5.0f); public ClampedFloatParameter distributionPower = new ClampedFloatParameter(2.0f, 1.0f, 5.0f); public ClampedFloatParameter falloffRange = new ClampedFloatParameter(0.1f, 0.01f, 1.0f); public bool IsActive() { return active \u0026\u0026 intensity.value \u003e 0.0f; } public bool IsTileCompatible() { return false; } } } GTAORendererFeature.cs ä¹Ÿæ²¡å•¥å¥½è¯´çš„ï¼Œå¾ˆæ™®é€šçš„RendererFeatureã€‚\nnamespace UnityEngine.Rendering.Universal { public class GTAORendererFeature : ScriptableRendererFeature { [System.Serializable] public class GTAOSettings { public bool isEnabled; public RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingOpaques; public ComputeShader gtaoComputeShader; } public GTAOSettings settings = new GTAOSettings(); private GTAORenderPass gtaoRenderPass; public override void Create() { gtaoRenderPass = new GTAORenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { GroundTruthAmbientOcclusion gtao = VolumeManager.instance.stack.GetComponent(); if (gtao != null \u0026\u0026 gtao.IsActive()) { gtaoRenderPass.Setup(gtao); renderer.EnqueuePass(gtaoRenderPass); } } } } GTAORenderPass.cs ä¸»è¦å€¼å¾—æ³¨æ„çš„æ˜¯å›¾åƒåˆ†è¾¨ç‡çš„å¤§å°ï¼Œè·å–åŠåˆ†è¾¨ç‡çš„å¤§å°æ—¶ï¼Œè¦è®°å¾—ä½¿ç”¨Ceilæ¥è·å–æ›´å¤§çš„å›¾ç‰‡ã€‚ç„¶åæ¯ä¸€ä¸ªé˜¶æ®µä½¿ç”¨çš„Dispatchæ•°ç›®ä¹Ÿä¸å°½ç›¸åŒï¼Œä¸»è¦æ˜¯ä¸Šé‡‡æ ·çš„é˜¶æ®µèŠ±æ ·æ¯”è¾ƒå¤šã€‚\nnamespace UnityEngine.Rendering.Universal { public class GTAORenderPass : ScriptableRenderPass { private const string profilerTag = \"Ground Truth Ambient Occlusion\"; private const string gtaoKernelName = \"GTAOMain\"; private const string blurHorizontalKernelName = \"BlurHorizontalMain\"; private const string blurVerticalKernelName = \"BlurVerticalMain\"; private const string visualizeKernelName = \"VisualizeMain\"; private ProfilingSampler profilingSampler; private ProfilingSampler gtaoSampler = new ProfilingSampler(\"GTAO Pass\"); private ProfilingSampler blurSampler = new ProfilingSampler(\"Blur Pass\"); private ProfilingSampler visualizeSampler = new ProfilingSampler(\"Visualize Pass\"); private RenderTargetHandle cameraColor; private RenderTargetIdentifier cameraColorIden; private RenderTargetHandle cameraDepth; private RenderTargetIdentifier cameraDepthIden; private RenderTargetHandle cameraDepthAttachment; private RenderTargetIdentifier cameraDepthAttachmentIden; private static readonly string gtaoTextureName = \"_GTAOBuffer\"; private static readonly int gtaoTextureID = Shader.PropertyToID(gtaoTextureName); private RenderTargetHandle gtaoTextureHandle; private RenderTargetIdentifier gtaoTextureIden; private static readonly string horizontalBlurTextureName = \"_HorizontalBlurBuffer\"; private static readonly int horizontalBlurTextureID = Shader.PropertyToID(horizontalBlurTextureName); private RenderTargetHandle horizontalBlurTextureHandle; private RenderTargetIdentifier horizontalBlurTextureIden; private static readonly string vericalBlurTextureName = \"_VerticalBlurBuffer\"; private static readonly int vericalBlurTextureID = Shader.PropertyToID(vericalBlurTextureName); private RenderTargetHandle vericalBlurTextureHandle; private RenderTargetIdentifier vericalBlurTextureIden; private static readonly string visualizeTextureName = \"_VisualizeBuffer\"; private static readonly int visualizeTextureID = Shader.PropertyToID(visualizeTextureName); private RenderTargetHandle visualizeTextureHandle; private RenderTargetIdentifier visualizeTextureIden; private GroundTruthAmbientOcclusion groundTruthAmbientOcclusion; private ComputeShader gtaoComputeShader; private GTAORendererFeature.GTAOSettings settings; private int downsamplingFactor; private Vector2Int fullRes; private Vector2Int downsampleRes; private int frameIndex; static readonly int _GTAOFrameIndexID = Shader.PropertyToID(\"_FrameIndex\"); static readonly int _GTAODownsamplingFactorID = Shader.PropertyToID(\"_DownsamplingFactor\"); static readonly int _GTAOIntensityID = Shader.PropertyToID(\"_Intensity\"); static readonly int _GTAOSampleRadiusID = Shader.PropertyToID(\"_SampleRadius\"); static readonly int _GTAODistributionPowerID = Shader.PropertyToID(\"_DistributionPower\"); static readonly int _GTAOFalloffRangeID = Shader.PropertyToID(\"_FalloffRange\"); static readonly int _GTAOTextureSizeID = Shader.PropertyToID(\"_TextureSize\"); static readonly int _GTAOColorTextureID = Shader.PropertyToID(\"_ColorTexture\"); static readonly int _GTAODepthTextureID = Shader.PropertyToID(\"_DepthTexture\"); static readonly int _GTAOTextureID = Shader.PropertyToID(\"_GTAOTexture\"); static readonly int _GTAORWTextureID = Shader.PropertyToID(\"_RW_GTAOTexture\"); static readonly int _GTAORWBlurTextureID = Shader.PropertyToID(\"_RW_BlurTexture\"); static readonly int _GTAORWVisualizeTextureID = Shader.PropertyToID(\"_RW_VisualizeTexture\"); public GTAORenderPass(GTAORendererFeature.GTAOSettings settings) { this.settings = settings; profilingSampler = new ProfilingSampler(profilerTag); renderPassEvent = settings.renderPassEvent; gtaoComputeShader = settings.gtaoComputeShader; cameraColor.Init(\"_CameraColorTexture\"); cameraColorIden = cameraColor.Identifier(); cameraDepth.Init(\"_CameraDepthTexture\"); cameraDepthIden = cameraDepth.Identifier(); cameraDepthAttachment.Init(\"_CameraDepthAttachment\"); cameraDepthAttachmentIden = cameraDepthAttachment.Identifier(); gtaoTextureHandle.Init(gtaoTextureName); gtaoTextureIden = gtaoTextureHandle.Identifier(); horizontalBlurTextureHandle.Init(horizontalBlurTextureName); horizontalBlurTextureIden = horizontalBlurTextureHandle.Identifier(); vericalBlurTextureHandle.Init(vericalBlurTextureName); vericalBlurTextureIden = vericalBlurTextureHandle.Identifier(); visualizeTextureHandle.Init(visualizeTextureName); visualizeTextureIden = visualizeTextureHandle.Identifier(); frameIndex = 0; } public void Setup(GroundTruthAmbientOcclusion groundTruthAmbientOcclusion) { this.groundTruthAmbientOcclusion = groundTruthAmbientOcclusion; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { RenderTextureDescriptor desc = cameraTextureDescriptor; desc.enableRandomWrite = true; desc.depthBufferBits = 0; desc.msaaSamples = 1; desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat; downsamplingFactor = groundTruthAmbientOcclusion.downsamplingFactor.value; fullRes = new Vector2Int(desc.width, desc.height); downsampleRes = new Vector2Int(Mathf.CeilToInt((float)desc.width / downsamplingFactor), Mathf.CeilToInt((float)desc.height / downsamplingFactor)); cmd.GetTemporaryRT(visualizeTextureID, desc); cmd.GetTemporaryRT(vericalBlurTextureID, desc); desc.height = downsampleRes.y; cmd.GetTemporaryRT(horizontalBlurTextureID, desc); desc.width = downsampleRes.x; cmd.GetTemporaryRT(gtaoTextureID, desc); } private void DoGTAOCalculation(CommandBuffer cmd, RenderTargetIdentifier depthid, RenderTargetIdentifier gtaoid, ComputeShader computeShader) { if (!computeShader.HasKernel(gtaoKernelName)) return; int gtaoKernel = computeShader.FindKernel(gtaoKernelName); computeShader.GetKernelThreadGroupSizes(gtaoKernel, out uint x, out uint y, out uint z); cmd.SetComputeIntParam(computeShader, _GTAOFrameIndexID, frameIndex); cmd.SetComputeIntParam(computeShader, _GTAODownsamplingFactorID, downsamplingFactor); cmd.SetComputeVectorParam(computeShader, _GTAOTextureSizeID, new Vector4(fullRes.x, fullRes.y, 1.0f / fullRes.x, 1.0f / fullRes.y)); cmd.SetComputeFloatParam(computeShader, _GTAOSampleRadiusID, groundTruthAmbientOcclusion.radius.value); cmd.SetComputeFloatParam(computeShader, _GTAODistributionPowerID, groundTruthAmbientOcclusion.distributionPower.value); cmd.SetComputeFloatParam(computeShader, _GTAOFalloffRangeID, groundTruthAmbientOcclusion.falloffRange.value); cmd.SetComputeTextureParam(computeShader, gtaoKernel, _GTAODepthTextureID, depthid); cmd.SetComputeTextureParam(computeShader, gtaoKernel, _GTAORWTextureID, gtaoid); cmd.DispatchCompute(computeShader, gtaoKernel, Mathf.CeilToInt((float)downsampleRes.x / x), Mathf.CeilToInt((float)downsampleRes.y / y), 1); } private void DoBlur(CommandBuffer cmd, RenderTargetIdentifier gtaoid, RenderTargetIdentifier horizontalid, RenderTargetIdentifier verticalid, ComputeShader computeShader) { if (!computeShader.HasKernel(blurHorizontalKernelName) || !computeShader.HasKernel(blurVerticalKernelName)) return; int horizontalKernel = computeShader.FindKernel(blurHorizontalKernelName); int verticalKernel = computeShader.FindKernel(blurVerticalKernelName); uint x, y, z; computeShader.GetKernelThreadGroupSizes(horizontalKernel, out x, out y, out z); cmd.SetComputeTextureParam(computeShader, horizontalKernel, _GTAOTextureID, gtaoid); cmd.SetComputeTextureParam(computeShader, horizontalKernel, _GTAORWBlurTextureID, horizontalid); cmd.DispatchCompute(computeShader, horizontalKernel, Mathf.CeilToInt((float)fullRes.x / x), Mathf.CeilToInt((float)downsampleRes.y / y), 1); computeShader.GetKernelThreadGroupSizes(verticalKernel, out x, out y, out z); cmd.SetComputeTextureParam(computeShader, verticalKernel, _GTAOTextureID, horizontalid); cmd.SetComputeTextureParam(computeShader, verticalKernel, _GTAORWBlurTextureID, verticalid); cmd.DispatchCompute(computeShader, verticalKernel, Mathf.CeilToInt((float)fullRes.x / x), Mathf.CeilToInt((float)fullRes.y / y), 1); } private void DoVisualization(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier verticalid, RenderTargetIdentifier visualizeid, ComputeShader computeShader) { if (!computeShader.HasKernel(visualizeKernelName)) return; int visualzieKernel = computeShader.FindKernel(visualizeKernelName); cmd.SetComputeFloatParam(computeShader, _GTAOIntensityID, groundTruthAmbientOcclusion.intensity.value); computeShader.GetKernelThreadGroupSizes(visualzieKernel, out uint x, out uint y, out uint z); cmd.SetComputeTextureParam(computeShader, visualzieKernel, _GTAOColorTextureID, colorid); cmd.SetComputeTextureParam(computeShader, visualzieKernel, _GTAOTextureID, verticalid); cmd.SetComputeTextureParam(computeShader, visualzieKernel, _GTAORWVisualizeTextureID, visualizeid); cmd.DispatchCompute(computeShader, visualzieKernel, Mathf.CeilToInt((float)fullRes.x / x), Mathf.CeilToInt((float)fullRes.y / y), 1); cmd.Blit(visualizeid, colorid); } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = CommandBufferPool.Get(profilerTag); context.ExecuteCommandBuffer(cmd); cmd.Clear(); using (new ProfilingScope(cmd, profilingSampler)) { using (new ProfilingScope(cmd, gtaoSampler)) { if(renderingData.cameraData.isSceneViewCamera) { DoGTAOCalculation(cmd, cameraDepthIden, gtaoTextureIden, gtaoComputeShader); } else { DoGTAOCalculation(cmd, cameraDepthAttachmentIden, gtaoTextureIden, gtaoComputeShader); } } using (new ProfilingScope(cmd, blurSampler)) { DoBlur(cmd, gtaoTextureIden, horizontalBlurTextureIden, vericalBlurTextureIden, gtaoComputeShader); } using (new ProfilingScope(cmd, visualizeSampler)) { DoVisualization(cmd, cameraColorIden, vericalBlurTextureIden, visualizeTextureIden, gtaoComputeShader); } } frameIndex=(++frameIndex)%60; context.ExecuteCommandBuffer(cmd); cmd.Clear(); CommandBufferPool.Release(cmd); } public override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(gtaoTextureID); cmd.ReleaseTemporaryRT(horizontalBlurTextureID); cmd.ReleaseTemporaryRT(vericalBlurTextureID); cmd.ReleaseTemporaryRT(visualizeTextureID); } } } åè®° åˆéš”äº†å¾ˆä¹…ï¼Œæ€»ç®—é€¼ç€è‡ªå·±æŠŠè¿™ç¯‡æ–‡ç« å†™å®Œäº†ï¼Œä¹Ÿé€¼ç€è‡ªå·±å¼ºè¡Œç”¨Group Shared Memoryæ¥åšå„ç§é‡‡æ ·çš„ä¼˜åŒ–ã€‚å†™å‡ºæ¥çš„ä»£ç æœç„¶å¾ˆå“äººä¹Ÿåº”è¯¥æ²¡äººèƒ½çœ‹å¾—æ‡‚å§ï¼ˆå½“ç„¶æ›´å¯èƒ½æ˜¯æ²¡äººä¼šçœ‹ï¼‰ã€‚\n","wordCount":"2929","inLanguage":"en","image":"https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/posts/images/GTAO.jpg","datePublished":"2022-12-02T12:00:00+08:00","dateModified":"2022-12-02T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/unity-ground-truth-ambient-occlusion/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=è¿›è¡Œæ—¶><span>è¿›è¡Œæ—¶</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=åˆ†ç±»><span>åˆ†ç±»</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=å‹æƒ…é“¾æ¥><span>å‹æƒ…é“¾æ¥</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="ğŸ” (Alt + /)" accesskey=/><span>ğŸ”</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO</h1><div class=post-description>ä½¿ç”¨GroupSharedMemoryåŠ é€ŸGTAOçš„è®¡ç®—.</div><div class=post-meta><span title='2022-12-02 12:00:00 +0800 CST'>December 2, 2022</span>&nbsp;Â·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/unity-ground-truth-ambient-occlusion.md rel="noopener noreferrer" target=_blank>ç¼–è¾‘</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/GTAO.jpg alt="Ground Truth Ambient Occlusion Cover"><p>Ground Truth Ambient Occlusion Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Unityä½¿ç”¨ComputeShaderè®¡ç®—GTAO</div></summary><div class=inner><ul><li><a href=#%e7%8e%af%e5%a2%83%e5%85%89%e9%81%ae%e8%94%bd aria-label=ç¯å¢ƒå…‰é®è”½>ç¯å¢ƒå…‰é®è”½</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=å…·ä½“çš„æ“ä½œ>å…·ä½“çš„æ“ä½œ</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81%e5%92%8c%e8%af%b4%e6%98%8e aria-label=ç›¸å…³ä»£ç å’Œè¯´æ˜>ç›¸å…³ä»£ç å’Œè¯´æ˜</a><ul><li><a href=#gtaocomputeshadercompute aria-label=GTAOComputeShader.compute>GTAOComputeShader.compute</a></li><li><a href=#groundtruthambientocclusioncs aria-label=GroundTruthAmbientOcclusion.cs>GroundTruthAmbientOcclusion.cs</a></li><li><a href=#gtaorendererfeaturecs aria-label=GTAORendererFeature.cs>GTAORendererFeature.cs</a></li><li><a href=#gtaorenderpasscs aria-label=GTAORenderPass.cs>GTAORenderPass.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=åè®°>åè®°</a></li></ul></div></details></div><div class=post-content><h2 id=ç¯å¢ƒå…‰é®è”½>ç¯å¢ƒå…‰é®è”½<a hidden class=anchor aria-hidden=true href=#ç¯å¢ƒå…‰é®è”½>#</a></h2><p>ç¯å¢ƒå…‰é®è”½ï¼Œåœ¨å¾ˆä¹…å¾ˆä¹…ä»¥å‰ç©åˆºå®¢ä¿¡æ¡çš„æ—¶å€™å°±çœ‹åˆ°è¿‡è¿™ä¸ªè¯è¯­ï¼Œä½†æ˜¯å¹¶ä¸æ‡‚ä»€ä¹ˆæ„æ€ï¼Œæœ¬ç€ç”»è´¨æ‹‰æ»¡çš„åŸåˆ™æ€»æ˜¯ä¼šå‹¾é€‰è¿™ä¸ªé€‰é¡¹ã€‚åæ¥æ‰çŸ¥é“ç¯å¢ƒå…‰é®è”½ç¿»è¯‘è‡ªAmbient Occlusionï¼ˆè¿˜çœŸæ˜¯ç›´ç™½çš„ç¿»è¯‘ï¼‰ï¼Œç”¨æ¥è¡¨ç°è§’è½é‡Œé˜´æš—çš„æ•ˆæœã€‚</p><p>ç¯å¢ƒå…‰é®è”½ä½œç”¨åœ¨å…‰çº¿è®¡ç®—çš„é—´æ¥å…‰ç…§çš„é˜¶æ®µï¼Œç”±äºå…‰æ …åŒ–æ¸²æŸ“çš„å±€é™æ€§ï¼Œé—´æ¥å…‰ç…§å¾€å¾€åˆ†ä¸ºæ¼«åå°„é—´æ¥å…‰ç…§å’Œé«˜å…‰é—´æ¥å…‰ç…§ï¼Œå› æ­¤ç¯å¢ƒå…‰é®è”½ä¹Ÿåˆ†æ¼«åå°„å’Œé«˜å…‰ä¸¤ç§ï¼Œè¿™é‡Œæš‚æ—¶åªè®¨è®ºä½œç”¨äºæ¼«åå°„é—´æ¥å…‰ç…§çš„æ¼«åå°„ç¯å¢ƒå…‰é®è”½ã€‚è€Œåˆç”±äºå‰å‘æ¸²æŸ“çš„å±€é™æ€§ï¼Œå±å¹•ç©ºé—´çš„ç¯å¢ƒå…‰é®è”½ä¸åˆ†å·®åˆ«åœ°ä½œç”¨äºç›´æ¥å…‰ç…§å’Œé—´æ¥å…‰ç…§ï¼Œå› æ­¤å…¶å¼ºåº¦è¿˜éœ€è¦ç‰¹åˆ«åœ°ç•™æ„ã€‚</p><p>Ground Truth Ambient Occlusionæ˜¯Jorge Jimenezåœ¨ä»–çš„æ–‡ç« <a href=https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf>Practical Real-Time Strategies for Accurate Indirect Occlusion</a>ä¸­ä»‹ç»çš„ä¸€ç§åœ¨ä¸»æœºä¸Šèƒ½å¤Ÿç¬¦åˆäº‹å®ç¯å¢ƒå…‰é®è”½æ•ˆæœçš„ä¸€ç§å±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½çš„ç®—æ³•ã€‚æˆ‘è®¤ä¸ºè¿™ä¸ªç®—æ³•ç›¸è¾ƒäºå…¶ä»–çš„ç¯å¢ƒå…‰é®è”½çš„ç®—æ³•æœ€å¤§çš„ä¼˜ç‚¹æ˜¯ï¼Œæš—éƒ¨å¤Ÿæš—ï¼Œåœ¨å¾ˆçª„çš„ç¼éš™ä¸­èƒ½å¤Ÿå¾ˆé»‘å¾ˆé»‘ï¼Œè¿™æ˜¯åˆ«çš„ç®—æ³•åšä¸åˆ°çš„ã€‚</p><p>æœ¬æ–‡æå¤§åœ°å‚è€ƒäº†è‹±ç‰¹å°”çš„<a href=https://github.com/GameTechDev/XeGTAO>XeGTAO</a>å¼€æºä»£ç ã€‚</p><h2 id=å…·ä½“çš„æ“ä½œ>å…·ä½“çš„æ“ä½œ<a hidden class=anchor aria-hidden=true href=#å…·ä½“çš„æ“ä½œ>#</a></h2><p>è¿™ç¯‡æ–‡ç« ç€é‡è¦è®²çš„æ˜¯ä½¿ç”¨Compute Shaderæ¥åŠ é€Ÿè®¡ç®—çš„æ“ä½œæ–¹å¼ï¼Œå› æ­¤ä¸ä¼šå…·ä½“æ¶‰åŠåˆ°GTAOç®—æ³•æœ¬èº«ï¼Œæ„Ÿå…´è¶£çš„è¯å¯ä»¥å»<a href=https://blog.selfshadow.com/publications/s2016-shading-course/>SIGGRAPH 2016 Course</a>ä¸Šé˜…è¯»GTAOçš„pptã€‚</p><p>GTAOçš„è®¡ç®—éœ€è¦è§†ç©ºé—´æ³•çº¿å’Œæ·±åº¦ä¸¤ä¸ªæ•°æ®ï¼Œå¦‚æœæ˜¯å»¶è¿Ÿç®¡çº¿çš„è¯èƒ½è½»æ˜“å¾—æ‹¿åˆ°æ‰€æœ‰æ•°æ®ï¼Œä½†å¯¹äºå‰å‘æ¸²æŸ“æ¥è¯´ï¼Œéœ€è¦ä»æ·±åº¦æ•°æ®è¿˜åŸå‡ºè§†ç©ºé—´æ³•çº¿ã€‚æ­£å¥½æˆ‘ä¹‹å‰çš„<a href=https://zznewclear13.github.io/posts/get-view-space-normal-from-depth-texture/>æ–‡ç« </a>ä»‹ç»äº†ä¸€äº›ä»æ·±åº¦å›¾è®¡ç®—è§†ç©ºé—´æ³•çº¿çš„æ–¹æ³•ã€‚ä½†åœ¨åŸæœ‰æ–‡ç« çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬è¿˜èƒ½ä½¿ç”¨Group Shared Memoryå¯¹é‡‡æ ·æ•°è¿›è¡Œä¸€ç³»åˆ—çš„ä¼˜åŒ–ã€‚</p><p>ç”±äºGTAOç›¸å¯¹æ¥è¯´ç®—æ˜¯æ¯”è¾ƒä½é¢‘çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä½¿ç”¨ä¸‹é‡‡æ ·çš„æ–¹å¼åªç”¨åŠåˆ†è¾¨ç‡ç”šè‡³æ˜¯æ›´ä½çš„åˆ†è¾¨ç‡æ¥è®¡ç®—GTAOã€‚è¿™é‡Œä½¿ç”¨çš„æ–¹æ³•æ˜¯å¯¹NxNå¤§å°çš„åŒºåŸŸï¼Œæ¯ä¸€å¸§åªå–ä¸€ä¸ªé‡‡æ ·ç‚¹ï¼Œæœ€åé€šè¿‡TAAæ¥è¿›è¡Œæ··åˆã€‚</p><p>GTAOæœ¬èº«çš„é‡‡æ ·æ•°ä¹Ÿèƒ½ä½¿ç”¨æ—¶ç©ºå™ªå£°æ¥ç”Ÿæˆè¾ƒå°‘çš„é‡‡æ ·ç‚¹ï¼Œæœ€åé€šè¿‡TAAæ¥è¿›è¡Œæ··åˆã€‚ä½†æ˜¯å®é™…ä½¿ç”¨ä¸­å‘ç°ï¼Œå¦‚æœä½¿ç”¨è¾ƒå¤šçš„æ—¶é—´æ··åˆï¼Œå½“åœºæ™¯ä¸­çš„ç‰©ä½“å‘ç”Ÿç§»åŠ¨ä¹‹åï¼Œä¼šéœ²å‡ºä¸€éƒ¨åˆ†ç™½è‰²çš„ç”»é¢ï¼Œå’Œè¾ƒæ·±çš„AOæœ‰æ¯”è¾ƒæ˜æ˜¾çš„å¯¹æ¯”ï¼Œå› æ­¤è€ƒè™‘å°½é‡å¤šåœ°ä½¿ç”¨ç©ºé—´çš„æ··åˆã€‚</p><p>å¾—ç›ŠäºGroup Shared Memoryï¼Œå¯ä»¥åœ¨éå¸¸å¤§çš„èŒƒå›´å†…è¿›è¡Œç©ºé—´çš„æ··åˆï¼Œè¿™é‡Œä½¿ç”¨é«˜æ–¯æ¨¡ç³Šçš„æ–¹å¼è¿›è¡Œæ··åˆï¼Œèƒ½å¤Ÿå°½é‡ä¿æŒæš—éƒ¨è¾ƒæš—çš„é¢œè‰²ã€‚å¦‚æœç›´æ¥å¯¹æ‰€æœ‰çš„é‡‡æ ·è¿›è¡Œå¹³å‡çš„è¯ï¼Œä¼šå¯¼è‡´æš—éƒ¨å˜å¾—å¾ˆäº®ï¼Œå¤±å»äº†GTAOæœ€å‡ºä¼—çš„ä¼˜ç‚¹ã€‚å¯¹æ°´å¹³å’Œç«–ç›´æ–¹å‘åšä¸¤æ¬¡é«˜æ–¯æ¨¡ç³Šçš„è¯ï¼Œç”±äºæœ¬èº«è¿˜ä¼šæ ¹æ®æ·±åº¦å’Œæ³•çº¿ç®—å‡ºé¢å¤–çš„å‡ ä½•ä¸Šçš„æƒé‡ï¼Œåœ¨ä¸‹é‡‡æ ·ç¨‹åº¦è¾ƒå¤§çš„æ—¶å€™ä¼šäº§ç”Ÿæ¯”è¾ƒæ˜æ˜¾çš„ç‘•ç–µï¼Œå¯ä»¥ç”¨å…¨åˆ†è¾¨ç‡çš„æ·±åº¦å›¾å’Œæ³•çº¿æ¥è§£å†³ï¼Œä½†è¿™ä¼šå¸¦æ¥é¢å¤–çš„é‡‡æ ·ã€‚</p><p>åœ¨é«˜æ–¯æ¨¡ç³Šçš„é˜¶æ®µï¼Œç”±äºæ¨¡ç³Šæ˜¯ä½œç”¨åœ¨ä½åˆ†è¾¨ç‡çš„å›¾åƒä¸Šçš„ï¼Œåœ¨æˆ‘ä»¬çš„ä¸Šé‡‡æ ·çš„æ“ä½œä¸­ï¼Œè¿˜éœ€è¦æ ¹æ®ä¸Šé‡‡æ ·çš„ä½ç½®è¿›è¡ŒåŒçº¿æ€§æ’å€¼ï¼ˆå®é™…ä¸Šåªè¦ä¸€ä¸ªæ–¹å‘çº¿æ€§æ’å€¼å°±å¥½äº†ï¼‰ã€‚</p><p>Render Textureçš„ç²¾åº¦ä¸Šï¼ŒGTAOæœ€åçš„å€¼å¯ä»¥ç”¨8ä½é€šé“æ¥å‚¨å­˜ï¼Œå¦‚æœä¸éœ€è¦é¢å¤–çš„è§†ç©ºé—´æ³•çº¿çš„è¯ï¼Œå¯ä»¥æŠŠGTAOå€¼å’Œ24ä½çš„æ·±åº¦ä¸€èµ·å­˜åˆ°RGBA32çš„RTä¸­ã€‚è¿™é‡Œå°±å·æ‡’ä½¿ç”¨R16G16B16A16_SFloatæ¥å‚¨å­˜äº†ã€‚</p><p>å¦‚æ­¤ä¸€æ¥æ•´ä¸ªè·¯çº¿å›¾å°±æ¯”è¾ƒæ¸…æ™°äº†</p><ol><li>ä¸‹é‡‡æ ·æ·±åº¦å›¾è·å–æ·±åº¦æ•°æ®</li><li>ä½¿ç”¨æ·±åº¦å›¾è®¡ç®—è§†ç©ºé—´çš„æ³•çº¿ï¼Œæˆ–è€…ä»G Bufferç›´æ¥è·å–æ³•çº¿æ•°æ®</li><li>ä½¿ç”¨æ·±åº¦å›¾å’Œæ³•çº¿è®¡ç®—GTAOçš„å€¼</li><li>æ¨ªå‘ä¸Šé‡‡æ ·ï¼Œè®¡ç®—æ°´å¹³é«˜æ–¯æ¨¡ç³Šåçš„GTAOçš„å€¼</li><li>çºµå‘ä¸Šé‡‡æ ·ï¼Œè®¡ç®—å‚ç›´é«˜æ–¯æ¨¡ç³Šåçš„GTAOçš„å€¼</li></ol><h2 id=ç›¸å…³ä»£ç å’Œè¯´æ˜>ç›¸å…³ä»£ç å’Œè¯´æ˜<a hidden class=anchor aria-hidden=true href=#ç›¸å…³ä»£ç å’Œè¯´æ˜>#</a></h2><h3 id=gtaocomputeshadercompute>GTAOComputeShader.compute<a hidden class=anchor aria-hidden=true href=#gtaocomputeshadercompute>#</a></h3><p>é‡ä¸­ä¹‹é‡å°±æ˜¯Compute Shaderäº†ã€‚åˆ†äº†å››ä¸ªKernelï¼šç¬¬ä¸€ä¸ªè®¡ç®—GTAOçš„å€¼ï¼ŒåŒæ—¶è¿˜å‚¨å­˜äº†æ·±åº¦å›¾å’Œæ³•çº¿ï¼ˆé™¤äº†ç›´æ¥å‚¨å­˜æ³•çº¿çš„ä¸¤ä¸ªåˆ†é‡ï¼Œä¹Ÿå¯ä»¥Encodeæˆå…«é¢ä½“æ¥å‚¨å­˜ï¼‰ï¼›ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªåˆ†åˆ«æ˜¯æ°´å¹³å’Œç«–ç›´æ–¹å‘çš„æ¨¡ç³Šï¼›æœ€åä¸€ä¸ªç”¨æ¥å¯è§†åŒ–ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥ä¸ç”¨è¿™ä¸ªã€‚</p><p>å’ŒXeGTAOä¸åŒçš„æ˜¯ï¼Œæˆ‘å¢åŠ äº†ä¸€ä¸ª<code>USE_AVERAGE_COS</code>çš„å®ï¼Œæ­£å¸¸æ˜¯åœ¨æ¯ä¸€ä¸ªSliceä¸­é€‰æ‹©æœ€å¤§çš„coså€¼ï¼Œä½†æ˜¯è€ƒè™‘åˆ°åœºæ™¯ä¸­æœ‰æ …æ ¼è¿™æ ·çš„ç‰©ä½“ï¼Œåœ¨æ—¶ç©ºæ··åˆç¨‹åº¦ä¸æ˜¯å¾ˆå¤§çš„æ—¶å€™ï¼Œå¯ä»¥è®¡ç®—cosçš„å¹³å‡å€¼æ¥é™ä½æ …æ ¼å¯¹GTAOçš„å½±å“ï¼ˆä¹Ÿå°±æ˜¯å‡å¼±äº†å™ªå£°ï¼‰ï¼Œè¿™ä¸ªå®å®Œå…¨å¯ä»¥ä¸ç”¨å¼€å¯ã€‚</p><p>æœ¬æ–‡ä¸ºäº†å°½é‡å¤šçš„ä½¿ç”¨ç©ºé—´æ··åˆï¼ˆäº¦å³ä¸ä½¿ç”¨æ—¶é—´æ··åˆï¼‰ï¼Œåœ¨XeGTAOçš„æ—¶ç©ºå¹³å‡å™ªæ³¢ä¸­é™åˆ¶äº†æ—¶é—´çš„å‚æ•°ä¸º13ï¼Œè¿™æ ·GTAOå°±ä¸ä¼šéšç€æ—¶é—´è€Œå˜åŒ–äº†ï¼Œå®é™…ä¸Šå¯ä»¥ä¼ å…¥<code>_FrameIndex</code>å……åˆ†åˆ©ç”¨æ—¶ç©ºå™ªæ³¢çš„ä¼˜åŠ¿ã€‚</p><p>ä¸»è¦æ˜¯ç”¨<code>groupIndex</code>æ¥å‚¨å­˜å’Œè¯»å–Group Shared Memoryï¼Œæ¯ä¸ªç‚¹è‡³å¤šé‡‡æ ·ä¸¤æ¬¡ã€‚è®¡ç®—æ³•çº¿æ—¶ä¼šé‡‡æ ·5x5çš„åŒºåŸŸï¼Œå› æ­¤<code>NORMAL_FROM_DEPTH_PIXEL_RANGE</code>çš„å€¼æ˜¯2ï¼›è®¡ç®—æ¨¡ç³Šæ—¶æ—¢æœ‰é«˜æ–¯æ¨¡ç³Šçš„é‡‡æ ·ï¼Œè¿˜æœ‰åç»­æ‰‹åŠ¨çº¿æ€§æ’å€¼çš„é‡‡æ ·ï¼Œæ‰€ä»¥<code>CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE</code>ä¼šæœ‰ä¸¤è€…ä¹‹å’Œã€‚çº¿æ€§æ’å€¼è¿˜éœ€è¦æ³¨æ„<code>subpixelBias</code>å¯¹çº¿æ€§æ’å€¼çš„æƒé‡äº§ç”Ÿçš„å½±å“ã€‚</p><p>æœ¬æ–‡ä½¿ç”¨äº†å®½åº¦ä¸º29çš„é«˜æ–¯æ ¸ï¼Œå¯ä»¥åœ¨<a href=http://demofox.org/gauss.html>demofoxçš„ç½‘ç«™</a>ä¸Šè½»æ¾çš„è®¡ç®—å¾ˆå¤§çš„é«˜æ–¯æ ¸ã€‚</p><p>å¯èƒ½ä¼šæœ‰æŠ¥å¯„å­˜å™¨ä½¿ç”¨æ•°é‡è¶…è¿‡é™åˆ¶çš„é—®é¢˜ï¼Œæ„Ÿè§‰æ˜¯const arrayå’Œå¾ªç¯å¯¼è‡´çš„ï¼Œä¸è¿‡reimportä¹‹åå°±ä¸ä¼šæŠ¥è¿™ä¸ªè­¦å‘Šäº†ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel GTAOMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel BlurHorizontalMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel BlurVerticalMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel VisualizeMain</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ColorTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _DepthTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _GTAOTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_NormalTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_GTAOTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_BlurTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_VisualizeTexture;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_LinearClamp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SamplerState</span> sampler_PointClamp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//region Parameters</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint</span> _FrameIndex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint</span> _DownsamplingFactor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _Intensity;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _SampleRadius;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _DistributionPower;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _FalloffRange;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> _HeightFogFalloff;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TAAOffsets;
</span></span><span style=display:flex><span><span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//region Pre-defined Marcos</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define SQRT2_2                 0.70710678118</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define USE_AVERAGE_COS                 0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define SLICE_COUNT                     4</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define STEPS_PER_SLICE                 3</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GTAO_THREAD_GROUP_SIZE_X        32</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GTAO_THREAD_GROUP_SIZE_Y        32</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BLUR_THREAD_GROUP_SIZE          64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For normal calculation, can be deleted if we calculate normal in mrt.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> NORMAL_FROM_DEPTH_PIXEL_RANGE <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> CACHED_DEPTH_FOR_NORMAL_OFFSET <span style=color:#f92672>=</span> (GTAO_THREAD_GROUP_SIZE_X <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>NORMAL_FROM_DEPTH_PIXEL_RANGE);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> CACHED_DEPTH_FOR_NORMAL_SIZE <span style=color:#f92672>=</span> CACHED_DEPTH_FOR_NORMAL_OFFSET <span style=color:#f92672>*</span> (GTAO_THREAD_GROUP_SIZE_Y <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>NORMAL_FROM_DEPTH_PIXEL_RANGE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For blur</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> BILINEAR_RADIUS <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> BLUR_RADIUS <span style=color:#f92672>=</span> <span style=color:#ae81ff>14</span>; <span style=color:#75715e>// [-14, +14] for 29 tap gaussian blur</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE <span style=color:#f92672>=</span> BLUR_THREAD_GROUP_SIZE <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>(BILINEAR_RADIUS<span style=color:#f92672>+</span>BLUR_RADIUS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> CACHED_AO_FOR_BILINEAR_SIZE <span style=color:#f92672>=</span> BLUR_THREAD_GROUP_SIZE<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>BILINEAR_RADIUS;
</span></span><span style=display:flex><span><span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//region Group Shared Memory Help Functions</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For normal calculation</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> <span style=color:#66d9ef>float</span> depthForNormal[CACHED_DEPTH_FOR_NORMAL_SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetDepthForNormal(<span style=color:#66d9ef>float</span> depth, <span style=color:#66d9ef>int</span> index) {depthForNormal[index]<span style=color:#f92672>=</span>depth;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetDepthForNormal(<span style=color:#66d9ef>int2</span> threadPos) {<span style=color:#66d9ef>return</span> depthForNormal[threadPos.x<span style=color:#f92672>+</span>NORMAL_FROM_DEPTH_PIXEL_RANGE<span style=color:#f92672>+</span>(threadPos.y<span style=color:#f92672>+</span>NORMAL_FROM_DEPTH_PIXEL_RANGE)<span style=color:#f92672>*</span>CACHED_DEPTH_FOR_NORMAL_OFFSET];}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CacheDepthForNormal(<span style=color:#66d9ef>int2</span> groupCacheStartPos, <span style=color:#66d9ef>uint</span> cacheIndex, <span style=color:#66d9ef>int2</span> subpixelBias)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> threadPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(cacheIndex <span style=color:#f92672>%</span> CACHED_DEPTH_FOR_NORMAL_OFFSET, cacheIndex <span style=color:#f92672>/</span> CACHED_DEPTH_FOR_NORMAL_OFFSET);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> texturePos <span style=color:#f92672>=</span> (groupCacheStartPos <span style=color:#f92672>+</span> threadPos) <span style=color:#f92672>*</span> _DownsamplingFactor <span style=color:#f92672>+</span> subpixelBias;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depth <span style=color:#f92672>=</span> _DepthTexture.Load(<span style=color:#66d9ef>uint3</span>(texturePos, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    SetDepthForNormal(depth, cacheIndex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> <span style=color:#66d9ef>float4</span> aoNormalDepthForBlur[CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetAONormalDepthForBlur(<span style=color:#66d9ef>float4</span> aoNormalDepth, <span style=color:#66d9ef>int</span> index) {aoNormalDepthForBlur[index]<span style=color:#f92672>=</span>aoNormalDepth;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> GetAONormalDepthForBlur(<span style=color:#66d9ef>int</span> threadPos) {<span style=color:#66d9ef>return</span> aoNormalDepthForBlur[threadPos<span style=color:#f92672>+</span>BLUR_RADIUS<span style=color:#f92672>+</span>BILINEAR_RADIUS];}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CacheAONormalDepthForBlur(<span style=color:#66d9ef>int2</span> groupCacheStartPos, <span style=color:#66d9ef>uint</span> cacheIndex, <span style=color:#66d9ef>uint</span> vertical)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> threadPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    threadPos[vertical] <span style=color:#f92672>=</span> cacheIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> texturePos <span style=color:#f92672>=</span> groupCacheStartPos <span style=color:#f92672>+</span> threadPos;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> threshold;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(vertical <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threshold <span style=color:#f92672>=</span> _TextureSize.xy<span style=color:#f92672>/</span>_DownsamplingFactor <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threshold <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(_TextureSize.x, _TextureSize.y <span style=color:#f92672>/</span> _DownsamplingFactor) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    texturePos <span style=color:#f92672>=</span> clamp(texturePos, <span style=color:#ae81ff>0</span>, threshold);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> aoNormalDepth <span style=color:#f92672>=</span> _GTAOTexture.Load(<span style=color:#66d9ef>uint3</span>(texturePos, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    SetAONormalDepthForBlur(aoNormalDepth, cacheIndex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> <span style=color:#66d9ef>float</span> aoForBilinear[CACHED_AO_FOR_BILINEAR_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetAOForBilinear(<span style=color:#66d9ef>float</span> ao, <span style=color:#66d9ef>int</span> index) {aoForBilinear[index]<span style=color:#f92672>=</span>ao;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetAOForBilinear(<span style=color:#66d9ef>int</span> threadPos) {<span style=color:#66d9ef>return</span> aoForBilinear[threadPos.x<span style=color:#f92672>+</span>BILINEAR_RADIUS];}
</span></span><span style=display:flex><span><span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//region Space Transformation Help Functions</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> GetViewSpacePositionFromLinearDepth(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float</span> linearDepth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#if UNITY_UV_STARTS_AT_TOP</span>
</span></span><span style=display:flex><span>    uv.y <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> uv.y;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> uvNDC <span style=color:#f92672>=</span> uv <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>float3</span>(uvNDC <span style=color:#f92672>*</span> linearDepth <span style=color:#f92672>*</span> rcp(UNITY_MATRIX_P._m00_m11), <span style=color:#f92672>-</span>linearDepth);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> GetViewSpacePosition(<span style=color:#66d9ef>float2</span> uv, <span style=color:#66d9ef>float</span> depth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#if UNITY_MATRIX_I_P_SUPPORTED</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if UNITY_UV_STARTS_AT_TOP</span>
</span></span><span style=display:flex><span>    uv.y <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> uv.y;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(uv <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0</span>, depth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionVS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_I_P, <span style=color:#66d9ef>float4</span>(positionNDC, <span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>    positionVS <span style=color:#f92672>/=</span> positionVS.w;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> positionVS.xyz;
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depth, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> GetViewSpacePositionFromLinearDepth(uv, linearDepth);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> LinearEyeDepthFloat4(<span style=color:#66d9ef>float4</span> depthTBLR, <span style=color:#66d9ef>float4</span> zBufferParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rcp(depthTBLR <span style=color:#f92672>*</span> zBufferParams.z <span style=color:#f92672>+</span> zBufferParams.w);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//region GTAO Help Functions</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//https://github.com/GameTechDev/XeGTAO/blob/master/Source/Rendering/Shaders/XeGTAO.h</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//-UNITY_MATRIX_P._m11 = rcp(tan(fovy / 2))</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetScreenSpaceRadius(<span style=color:#66d9ef>float</span> linearDepth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _SampleRadius <span style=color:#f92672>*</span> _TextureSize.y <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span>UNITY_MATRIX_P._m11) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> linearDepth);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetLengthToPixelRatio(<span style=color:#66d9ef>float</span> linearDepth)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _TextureSize.y <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span>UNITY_MATRIX_P._m11) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> linearDepth);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// From https://www.shadertoy.com/view/3tB3z3 - except we&#39;re using R2 here</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define XE_HILBERT_LEVEL    6U</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define XE_HILBERT_WIDTH    ( (1U &lt;&lt; XE_HILBERT_LEVEL) )</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint</span> HilbertIndex( <span style=color:#66d9ef>uint</span> posX, <span style=color:#66d9ef>uint</span> posY )
</span></span><span style=display:flex><span>{   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>U;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>( <span style=color:#66d9ef>uint</span> curLevel <span style=color:#f92672>=</span> XE_HILBERT_WIDTH<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>U; curLevel <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>U; curLevel <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>U )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> regionX <span style=color:#f92672>=</span> ( posX <span style=color:#f92672>&amp;</span> curLevel ) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>U;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> regionY <span style=color:#f92672>=</span> ( posY <span style=color:#f92672>&amp;</span> curLevel ) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>U;
</span></span><span style=display:flex><span>        index <span style=color:#f92672>+=</span> curLevel <span style=color:#f92672>*</span> curLevel <span style=color:#f92672>*</span> ( (<span style=color:#ae81ff>3</span>U <span style=color:#f92672>*</span> regionX) <span style=color:#f92672>^</span> regionY);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>( regionY <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>U )
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>( regionX <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>U )
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                posX <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint</span>( (XE_HILBERT_WIDTH <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>U) ) <span style=color:#f92672>-</span> posX;
</span></span><span style=display:flex><span>                posY <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint</span>( (XE_HILBERT_WIDTH <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>U) ) <span style=color:#f92672>-</span> posY;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>uint</span> temp <span style=color:#f92672>=</span> posX;
</span></span><span style=display:flex><span>            posX <span style=color:#f92672>=</span> posY;
</span></span><span style=display:flex><span>            posY <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> index;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> SpatioTemporalNoise(<span style=color:#66d9ef>uint2</span> pixCoord, <span style=color:#66d9ef>uint</span> temporalIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> index <span style=color:#f92672>=</span> HilbertIndex(pixCoord.x, pixCoord.y);
</span></span><span style=display:flex><span>    index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>288</span><span style=color:#f92672>*</span>(temporalIndex<span style=color:#f92672>%</span><span style=color:#ae81ff>64</span>); <span style=color:#75715e>// why 288? tried out a few and that&#39;s the best so far (with XE_HILBERT_LEVEL 6U) - but there&#39;s probably better :)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// R2 sequence - see http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> frac( <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>+</span> index <span style=color:#f92672>*</span> <span style=color:#66d9ef>float2</span>(<span style=color:#ae81ff>0.75487766624669276005</span>, <span style=color:#ae81ff>0.5698402909980532659114</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//region Blur Help Functions</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> GetWeight(<span style=color:#66d9ef>float4</span> center, <span style=color:#66d9ef>float4</span> samplePoint)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> centerAndSampleXY <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(center.yz, samplePoint.yz) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0f</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> centerVS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(centerAndSampleXY.xy, sqrt(max(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> dot(centerAndSampleXY.xy, centerAndSampleXY.xy))));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> sampleVS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(centerAndSampleXY.zw, sqrt(max(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> dot(centerAndSampleXY.zw, centerAndSampleXY.zw))));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> normalWeight <span style=color:#f92672>=</span> saturate(dot(centerVS, sampleVS));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthWeight <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>-</span> saturate(abs(center.w <span style=color:#f92672>-</span> samplePoint.w) <span style=color:#f92672>*</span> <span style=color:#ae81ff>100.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> normalWeight <span style=color:#f92672>*</span> depthWeight;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CacheGaussianBlur(<span style=color:#66d9ef>uint</span> cacheAOIndex, <span style=color:#66d9ef>uint</span> vertical)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheAOThreadPos <span style=color:#f92672>=</span> cacheAOIndex <span style=color:#f92672>-</span> BILINEAR_RADIUS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> aoNormalDepthC <span style=color:#f92672>=</span> GetAONormalDepthForBlur(cacheAOThreadPos);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> aoSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> weightSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> aoNormalDepth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> weight;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// http://demofox.org/gauss.html</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> weights[] <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0.0002</span>,	<span style=color:#ae81ff>0.0005</span>,	<span style=color:#ae81ff>0.0011</span>,	<span style=color:#ae81ff>0.0023</span>,	<span style=color:#ae81ff>0.0044</span>,	<span style=color:#ae81ff>0.0080</span>,	<span style=color:#ae81ff>0.0136</span>,	<span style=color:#ae81ff>0.0217</span>,	<span style=color:#ae81ff>0.0325</span>,	<span style=color:#ae81ff>0.0457</span>,	<span style=color:#ae81ff>0.0605</span>,	<span style=color:#ae81ff>0.0752</span>,	<span style=color:#ae81ff>0.0879</span>,	<span style=color:#ae81ff>0.0965</span>,	<span style=color:#ae81ff>0.0995</span>,	<span style=color:#ae81ff>0.0965</span>,	<span style=color:#ae81ff>0.0879</span>,	<span style=color:#ae81ff>0.0752</span>,	<span style=color:#ae81ff>0.0605</span>,	<span style=color:#ae81ff>0.0457</span>,	<span style=color:#ae81ff>0.0325</span>,	<span style=color:#ae81ff>0.0217</span>,	<span style=color:#ae81ff>0.0136</span>,	<span style=color:#ae81ff>0.0080</span>,	<span style=color:#ae81ff>0.0044</span>,	<span style=color:#ae81ff>0.0023</span>,	<span style=color:#ae81ff>0.0011</span>,	<span style=color:#ae81ff>0.0005</span>,	<span style=color:#ae81ff>0.0002</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [<span style=color:#a6e22e>unroll</span>(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>BLUR_RADIUS<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>BLUR_RADIUS; i <span style=color:#f92672>&lt;=</span> BLUR_RADIUS; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        aoNormalDepth <span style=color:#f92672>=</span> GetAONormalDepthForBlur(cacheAOThreadPos <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        weight <span style=color:#f92672>=</span> GetWeight(aoNormalDepthC, aoNormalDepth) <span style=color:#f92672>*</span> weights[i <span style=color:#f92672>+</span> BLUR_RADIUS];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        aoSum <span style=color:#f92672>+=</span> aoNormalDepth.r <span style=color:#f92672>*</span> weight;
</span></span><span style=display:flex><span>        weightSum <span style=color:#f92672>+=</span> weight;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> avgAO <span style=color:#f92672>=</span> aoSum <span style=color:#f92672>/</span> weightSum;
</span></span><span style=display:flex><span>    SetAOForBilinear(avgAO, cacheAOIndex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(GTAO_THREAD_GROUP_SIZE_X,GTAO_THREAD_GROUP_SIZE_Y,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GTAOMain(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> sqrDownSamplingFactor <span style=color:#f92672>=</span> _DownsamplingFactor <span style=color:#f92672>*</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> subpixelIndex <span style=color:#f92672>=</span> _FrameIndex <span style=color:#f92672>%</span> sqrDownSamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> subpixelBias <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(subpixelIndex <span style=color:#f92672>%</span> _DownsamplingFactor, subpixelIndex <span style=color:#f92672>/</span> _DownsamplingFactor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> pixelCoord <span style=color:#f92672>=</span> dispatchThreadID.xy <span style=color:#f92672>*</span> _DownsamplingFactor <span style=color:#f92672>+</span> subpixelBias;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> uv <span style=color:#f92672>=</span> (pixelCoord <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#f92672>*</span> _TextureSize.zw;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> groupCacheStartPos <span style=color:#f92672>=</span> groupID.xy <span style=color:#f92672>*</span> <span style=color:#66d9ef>int2</span>(GTAO_THREAD_GROUP_SIZE_X, GTAO_THREAD_GROUP_SIZE_Y) <span style=color:#f92672>-</span> NORMAL_FROM_DEPTH_PIXEL_RANGE;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Cache Normal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(cacheIndex <span style=color:#f92672>&lt;</span> CACHED_DEPTH_FOR_NORMAL_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheDepthForNormal(groupCacheStartPos, cacheIndex, subpixelBias);
</span></span><span style=display:flex><span>        CacheDepthForNormal(groupCacheStartPos, cacheIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, subpixelBias);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> loadCacheIndex <span style=color:#f92672>=</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> threadPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(loadCacheIndex <span style=color:#f92672>%</span> GTAO_THREAD_GROUP_SIZE_X, loadCacheIndex <span style=color:#f92672>/</span> GTAO_THREAD_GROUP_SIZE_X);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Calculate Normal From Depth</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthC    <span style=color:#f92672>=</span> GetDepthForNormal(threadPos               );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthT    <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>( <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthB    <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>( <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthL    <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthR    <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>( <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthT2   <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>( <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthB2   <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>( <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthL2   <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>,  <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthR2   <span style=color:#f92672>=</span> GetDepthForNormal(threadPos <span style=color:#f92672>+</span> <span style=color:#66d9ef>int2</span>( <span style=color:#ae81ff>2</span>,  <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// fp16 depth should use this to prevent contour lines due to loss of depth precision.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linearDepth *= 0.99920;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is for fp32 depth.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linearDepth *= 0.99999;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthC, _ZBufferParams) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.99999</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> linearDepths <span style=color:#f92672>=</span> LinearEyeDepthFloat4(<span style=color:#66d9ef>float4</span>(depthT, depthB, depthL, depthR), _ZBufferParams) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.99999</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> center <span style=color:#f92672>=</span> pixelCoord <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewPosC <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth(center <span style=color:#f92672>*</span> _TextureSize.zw, linearDepth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewPosT <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth((center <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>( <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> _DownsamplingFactor) <span style=color:#f92672>*</span> _TextureSize.zw, linearDepths.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewPosB <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth((center <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>( <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> _DownsamplingFactor) <span style=color:#f92672>*</span> _TextureSize.zw, linearDepths.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewPosL <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth((center <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>) <span style=color:#f92672>*</span> _DownsamplingFactor) <span style=color:#f92672>*</span> _TextureSize.zw, linearDepths.z);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewPosR <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth((center <span style=color:#f92672>+</span> <span style=color:#66d9ef>float2</span>( <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>) <span style=color:#f92672>*</span> _DownsamplingFactor) <span style=color:#f92672>*</span> _TextureSize.zw, linearDepths.w);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> t <span style=color:#f92672>=</span> normalize(viewPosT <span style=color:#f92672>-</span> viewPosC);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> b <span style=color:#f92672>=</span> normalize(viewPosC <span style=color:#f92672>-</span> viewPosB);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> l <span style=color:#f92672>=</span> normalize(viewPosC <span style=color:#f92672>-</span> viewPosL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> r <span style=color:#f92672>=</span> normalize(viewPosR <span style=color:#f92672>-</span> viewPosC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> H <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(depthL, depthR, depthL2, depthR2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> V <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(depthB, depthT, depthB2, depthT2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> he <span style=color:#f92672>=</span> abs((<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> H.xy <span style=color:#f92672>-</span> H.zw) <span style=color:#f92672>-</span> depthC);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> ve <span style=color:#f92672>=</span> abs((<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> V.xy <span style=color:#f92672>-</span> V.zw) <span style=color:#f92672>-</span> depthC);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> hDeriv <span style=color:#f92672>=</span> he.x <span style=color:#f92672>&lt;</span> he.y <span style=color:#f92672>?</span> l <span style=color:#f92672>:</span> r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> vDeriv <span style=color:#f92672>=</span> ve.x <span style=color:#f92672>&lt;</span> ve.y <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> t;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> normalVS <span style=color:#f92672>=</span> normalize(cross(hDeriv, vDeriv));
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Calculate GTAO From Depth and Normal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> localNoise <span style=color:#f92672>=</span> SpatioTemporalNoise(dispatchThreadID.xy, <span style=color:#ae81ff>13</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> pixCenterPos <span style=color:#f92672>=</span> viewPosC;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> viewVec <span style=color:#f92672>=</span> normalize(<span style=color:#f92672>-</span>pixCenterPos);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> effectRadius <span style=color:#f92672>=</span> _SampleRadius;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> sampleDistributionPower <span style=color:#f92672>=</span> _DistributionPower;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> falloffRange <span style=color:#f92672>=</span> effectRadius <span style=color:#f92672>*</span> _FalloffRange;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> falloffFrom <span style=color:#f92672>=</span> effectRadius <span style=color:#f92672>-</span> falloffRange;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> falloffMul <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>rcp(falloffRange);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> falloffAdd <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> falloffFrom <span style=color:#f92672>*</span> falloffMul;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> visibility <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> noiseSlice <span style=color:#f92672>=</span> localNoise.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> noiseSample <span style=color:#f92672>=</span> localNoise.y;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> pixelTooCloseThreshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.3</span>;<span style=color:#75715e>//Some basic bias preventing sampling current pixel</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> lengthToPixelRatio <span style=color:#f92672>=</span> GetLengthToPixelRatio(linearDepth);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> screenSpaceRadius <span style=color:#f92672>=</span> effectRadius <span style=color:#f92672>*</span> lengthToPixelRatio;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//fade GTAO if screenSpaceRadius is too small</span>
</span></span><span style=display:flex><span>        visibility <span style=color:#f92672>+=</span> saturate((<span style=color:#ae81ff>10</span> <span style=color:#f92672>-</span> screenSpaceRadius) <span style=color:#f92672>/</span> <span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> minS <span style=color:#f92672>=</span> pixelTooCloseThreshold <span style=color:#f92672>/</span> screenSpaceRadius;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>//2 * SLICE_COUNT * STEPS_PER_SLICE samples</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Almost exactly &#34;Algorithm 1&#34; in</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf</span>
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>unroll</span>(SLICE_COUNT)]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> slice <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; slice <span style=color:#f92672>&lt;</span> SLICE_COUNT; slice<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> phi <span style=color:#f92672>=</span> (slice <span style=color:#f92672>+</span> noiseSlice) <span style=color:#f92672>*</span> PI <span style=color:#f92672>/</span> SLICE_COUNT;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> sinPhi, cosPhi;
</span></span><span style=display:flex><span>            sincos(phi, sinPhi, cosPhi);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float2</span> omega <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(cosPhi, sinPhi);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            omega <span style=color:#f92672>*=</span> screenSpaceRadius;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> directionVec <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(cosPhi, sinPhi, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> orthoDirectionVec <span style=color:#f92672>=</span> directionVec <span style=color:#f92672>-</span> (dot(directionVec, viewVec) <span style=color:#f92672>*</span> viewVec);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> axisVec <span style=color:#f92672>=</span> normalize(cross(orthoDirectionVec, viewVec));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float3</span> projectedNormalVec <span style=color:#f92672>=</span> normalVS <span style=color:#f92672>-</span> axisVec <span style=color:#f92672>*</span> dot(normalVS, axisVec);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> signNormal <span style=color:#f92672>=</span> sign(dot(orthoDirectionVec, projectedNormalVec));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> projectedNormalVecLength <span style=color:#f92672>=</span> length(projectedNormalVec);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> cosNorm <span style=color:#f92672>=</span> saturate(dot(projectedNormalVec, viewVec) <span style=color:#f92672>/</span> projectedNormalVecLength);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> n <span style=color:#f92672>=</span> signNormal <span style=color:#f92672>*</span> acos(cosNorm);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> lowHorizonCos0 <span style=color:#f92672>=</span> cos(n <span style=color:#f92672>+</span> HALF_PI);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> lowHorizonCos1 <span style=color:#f92672>=</span> cos(n <span style=color:#f92672>-</span> HALF_PI);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//Minor improvement</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> horizonCos0 <span style=color:#f92672>=</span> lowHorizonCos0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> horizonCos1 <span style=color:#f92672>=</span> lowHorizonCos1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if USE_AVERAGE_COS</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> baseCos0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> baseCos1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            [<span style=color:#a6e22e>unroll</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>float</span> step <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; step <span style=color:#f92672>&lt;</span> STEPS_PER_SLICE; step<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> stepBaseNoise <span style=color:#f92672>=</span> (slice <span style=color:#f92672>+</span> step <span style=color:#f92672>*</span> STEPS_PER_SLICE) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.6180339887498948482</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> stepNoise <span style=color:#f92672>=</span> frac(noiseSample <span style=color:#f92672>+</span> stepBaseNoise);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> s <span style=color:#f92672>=</span> (step <span style=color:#f92672>+</span> stepNoise) <span style=color:#f92672>/</span> STEPS_PER_SLICE;
</span></span><span style=display:flex><span>                s <span style=color:#f92672>=</span> pow(s, sampleDistributionPower);
</span></span><span style=display:flex><span>                s <span style=color:#f92672>+=</span> minS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> sampleOffset <span style=color:#f92672>=</span> s <span style=color:#f92672>*</span> omega; <span style=color:#75715e>//In pixel coord;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleOffsetLength <span style=color:#f92672>=</span> length(sampleOffset);
</span></span><span style=display:flex><span>                sampleOffset <span style=color:#f92672>=</span> round(sampleOffset) <span style=color:#f92672>*</span> _TextureSize.zw; <span style=color:#75715e>//To UV coord</span>
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> sampleScreenPos0 <span style=color:#f92672>=</span> uv <span style=color:#f92672>+</span> sampleOffset;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleLinearDepth0 <span style=color:#f92672>=</span> LinearEyeDepth(_DepthTexture.SampleLevel(sampler_PointClamp, sampleScreenPos0, <span style=color:#ae81ff>0</span>), _ZBufferParams);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> samplePos0 <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth(sampleScreenPos0, sampleLinearDepth0);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float2</span> sampleScreenPos1 <span style=color:#f92672>=</span> uv <span style=color:#f92672>-</span> sampleOffset;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleLinearDepth1 <span style=color:#f92672>=</span> LinearEyeDepth(_DepthTexture.SampleLevel(sampler_PointClamp, sampleScreenPos1, <span style=color:#ae81ff>0</span>), _ZBufferParams);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> samplePos1 <span style=color:#f92672>=</span> GetViewSpacePositionFromLinearDepth(sampleScreenPos1, sampleLinearDepth1);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> sampleDelta0 <span style=color:#f92672>=</span> samplePos0 <span style=color:#f92672>-</span> pixCenterPos;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> sampleDelta1 <span style=color:#f92672>=</span> samplePos1 <span style=color:#f92672>-</span> pixCenterPos;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleDist0 <span style=color:#f92672>=</span> length(sampleDelta0);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> sampleDist1 <span style=color:#f92672>=</span> length(sampleDelta1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//Normalize</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> sampleHorizonVec0 <span style=color:#f92672>=</span> sampleDelta0 <span style=color:#f92672>/</span> sampleDist0;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float3</span> sampleHorizonVec1 <span style=color:#f92672>=</span> sampleDelta1 <span style=color:#f92672>/</span> sampleDist1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> weight0 <span style=color:#f92672>=</span> saturate(sampleDist0 <span style=color:#f92672>*</span> falloffMul <span style=color:#f92672>+</span> falloffAdd);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> weight1 <span style=color:#f92672>=</span> saturate(sampleDist1 <span style=color:#f92672>*</span> falloffMul <span style=color:#f92672>+</span> falloffAdd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//sample horizon cos</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> shc0 <span style=color:#f92672>=</span> dot(sampleHorizonVec0, viewVec);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>float</span> shc1 <span style=color:#f92672>=</span> dot(sampleHorizonVec1, viewVec);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                shc0 <span style=color:#f92672>=</span> lerp(lowHorizonCos0, shc0, weight0);
</span></span><span style=display:flex><span>                shc1 <span style=color:#f92672>=</span> lerp(lowHorizonCos1, shc1, weight1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if USE_AVERAGE_COS</span>
</span></span><span style=display:flex><span>                baseCos0 <span style=color:#f92672>+=</span> shc0;
</span></span><span style=display:flex><span>                baseCos1 <span style=color:#f92672>+=</span> shc1;
</span></span><span style=display:flex><span><span style=color:#75715e>#else</span>
</span></span><span style=display:flex><span>                horizonCos0 <span style=color:#f92672>=</span> max(horizonCos0, shc0);
</span></span><span style=display:flex><span>                horizonCos1 <span style=color:#f92672>=</span> max(horizonCos1, shc1);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if USE_AVERAGE_COS</span>
</span></span><span style=display:flex><span>            baseCos0 <span style=color:#f92672>/=</span> STEPS_PER_SLICE;
</span></span><span style=display:flex><span>            baseCos1 <span style=color:#f92672>/=</span> STEPS_PER_SLICE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            horizonCos0 <span style=color:#f92672>=</span> max(baseCos0, horizonCos0);
</span></span><span style=display:flex><span>            horizonCos1 <span style=color:#f92672>=</span> max(baseCos1, horizonCos1);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> h0 <span style=color:#f92672>=</span> acos(horizonCos0);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> h1 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>acos(horizonCos1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            h0 <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> clamp(h0 <span style=color:#f92672>-</span> n, <span style=color:#f92672>-</span>HALF_PI, HALF_PI);
</span></span><span style=display:flex><span>            h1 <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> clamp(h1 <span style=color:#f92672>-</span> n, <span style=color:#f92672>-</span>HALF_PI, HALF_PI);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> val0 <span style=color:#f92672>=</span> (cosNorm <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> h0 <span style=color:#f92672>*</span> sin(n) <span style=color:#f92672>-</span> cos(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> h0 <span style=color:#f92672>-</span> n)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> val1 <span style=color:#f92672>=</span> (cosNorm <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> h1 <span style=color:#f92672>*</span> sin(n) <span style=color:#f92672>-</span> cos(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> h1 <span style=color:#f92672>-</span> n)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>            visibility <span style=color:#f92672>+=</span> projectedNormalVecLength <span style=color:#f92672>*</span> (val0 <span style=color:#f92672>+</span> val1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        visibility <span style=color:#f92672>/=</span> SLICE_COUNT;
</span></span><span style=display:flex><span>        visibility <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0.03</span>, visibility);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> outputColor <span style=color:#f92672>=</span> visibility;
</span></span><span style=display:flex><span><span style=color:#75715e>#if USE_AVERAGE_COS</span>
</span></span><span style=display:flex><span>    outputColor <span style=color:#f92672>/=</span> HALF_PI;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_GTAOTexture[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(outputColor, normalVS.xy <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>, depthC);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(BLUR_THREAD_GROUP_SIZE,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> BlurHorizontalMain(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> sqrDownSamplingFactor <span style=color:#f92672>=</span> _DownsamplingFactor <span style=color:#f92672>*</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> subpixelIndex <span style=color:#f92672>=</span> _FrameIndex <span style=color:#f92672>%</span> sqrDownSamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> subpixelBias <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(subpixelIndex <span style=color:#f92672>%</span> _DownsamplingFactor, subpixelIndex <span style=color:#f92672>/</span> _DownsamplingFactor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> pixelCoord <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(dispatchThreadID.x <span style=color:#f92672>/</span> _DownsamplingFactor, dispatchThreadID.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> thisSubpixelBias <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(dispatchThreadID.x <span style=color:#f92672>%</span> _DownsamplingFactor, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Cache AO Normal Depth</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> groupCacheStartPos <span style=color:#f92672>=</span> groupID.xy <span style=color:#f92672>*</span> <span style=color:#66d9ef>int2</span>(BLUR_THREAD_GROUP_SIZE, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#66d9ef>int2</span>(_DownsamplingFactor, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> <span style=color:#66d9ef>int2</span>(BLUR_RADIUS<span style=color:#f92672>+</span>BILINEAR_RADIUS, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(cacheIndex <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span>(CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> thisAONormalDepth <span style=color:#f92672>=</span> GetAONormalDepthForBlur(groupIndex  <span style=color:#f92672>/</span> _DownsamplingFactor);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Blur AO</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheAOIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(cacheAOIndex <span style=color:#f92672>&lt;</span> CACHED_AO_FOR_BILINEAR_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheGaussianBlur(cacheAOIndex, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        CacheGaussianBlur(cacheAOIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Bilinear Sampling</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> loadIndex <span style=color:#f92672>=</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> threadPos <span style=color:#f92672>=</span> loadIndex <span style=color:#f92672>/</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> signVal <span style=color:#f92672>=</span> sign(thisSubpixelBias <span style=color:#f92672>-</span> subpixelBias);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> thisAO    <span style=color:#f92672>=</span> GetAOForBilinear(threadPos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> leftAO    <span style=color:#f92672>=</span> GetAOForBilinear(threadPos <span style=color:#f92672>+</span> signVal.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> lerpVal <span style=color:#f92672>=</span> abs(thisSubpixelBias <span style=color:#f92672>-</span> subpixelBias) <span style=color:#f92672>/</span> (<span style=color:#66d9ef>float</span>)_DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> finalAO <span style=color:#f92672>=</span> lerp(thisAO, leftAO, lerpVal.x);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_BlurTexture[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(finalAO, thisAONormalDepth.yzw);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>1</span>,BLUR_THREAD_GROUP_SIZE,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> BlurVerticalMain(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> sqrDownSamplingFactor <span style=color:#f92672>=</span> _DownsamplingFactor <span style=color:#f92672>*</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> subpixelIndex <span style=color:#f92672>=</span> _FrameIndex <span style=color:#f92672>%</span> sqrDownSamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> subpixelBias <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(subpixelIndex <span style=color:#f92672>%</span> _DownsamplingFactor, subpixelIndex <span style=color:#f92672>/</span> _DownsamplingFactor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> pixelCoord <span style=color:#f92672>=</span> dispatchThreadID.xy <span style=color:#f92672>/</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> thisSubpixelBias <span style=color:#f92672>=</span> dispatchThreadID.xy <span style=color:#f92672>%</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Cache AO Normal Depth</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> groupCacheStartPos <span style=color:#f92672>=</span> groupID.xy <span style=color:#f92672>*</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span>, BLUR_THREAD_GROUP_SIZE) <span style=color:#f92672>/</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>1</span>, _DownsamplingFactor) <span style=color:#f92672>-</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, BLUR_RADIUS<span style=color:#f92672>+</span>BILINEAR_RADIUS);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(cacheIndex <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span>(CACHED_AO_NORMAL_DEPTH_FOR_BLUR_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        CacheAONormalDepthForBlur(groupCacheStartPos, cacheIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Blur AO</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cacheAOIndex <span style=color:#f92672>=</span> groupIndex <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(cacheAOIndex <span style=color:#f92672>&lt;</span> CACHED_AO_FOR_BILINEAR_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CacheGaussianBlur(cacheAOIndex, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        CacheGaussianBlur(cacheAOIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//region Bilinear Sampling</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint</span> loadIndex <span style=color:#f92672>=</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> threadPos <span style=color:#f92672>=</span> loadIndex <span style=color:#f92672>/</span> _DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> signVal <span style=color:#f92672>=</span> sign(thisSubpixelBias <span style=color:#f92672>-</span> subpixelBias);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> thisAO    <span style=color:#f92672>=</span> GetAOForBilinear(threadPos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> topAO    <span style=color:#f92672>=</span> GetAOForBilinear(threadPos <span style=color:#f92672>+</span> signVal.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> lerpVal <span style=color:#f92672>=</span> abs(thisSubpixelBias <span style=color:#f92672>-</span> subpixelBias) <span style=color:#f92672>/</span> (<span style=color:#66d9ef>float</span>)_DownsamplingFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> finalAO <span style=color:#f92672>=</span> lerp(thisAO, topAO, lerpVal.y); 
</span></span><span style=display:flex><span>    <span style=color:#75715e>//endregion</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _RW_BlurTexture[dispatchThreadID.xy] <span style=color:#f92672>=</span> finalAO;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(GTAO_THREAD_GROUP_SIZE_X,GTAO_THREAD_GROUP_SIZE_Y,<span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> VisualizeMain(<span style=color:#66d9ef>uint3</span> groupID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> groupThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupThreadID</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint</span> groupIndex <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_GroupIndex</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint3</span> dispatchThreadID <span style=color:#f92672>:</span> <span style=color:#a6e22e>SV_DispatchThreadID</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> gtaoVal <span style=color:#f92672>=</span> _GTAOTexture.Load(<span style=color:#66d9ef>uint3</span>(dispatchThreadID.xy, <span style=color:#ae81ff>0</span>)).r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> colorTexture <span style=color:#f92672>=</span> _ColorTexture.Load(<span style=color:#66d9ef>uint3</span>(dispatchThreadID.xy, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> finalColor <span style=color:#f92672>=</span> colorTexture.rgb <span style=color:#f92672>*</span> lerp(<span style=color:#ae81ff>1.0f</span>, gtaoVal, _Intensity);
</span></span><span style=display:flex><span>    _RW_VisualizeTexture[dispatchThreadID.xy] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(finalColor, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=groundtruthambientocclusioncs>GroundTruthAmbientOcclusion.cs<a hidden class=anchor aria-hidden=true href=#groundtruthambientocclusioncs>#</a></h3><p>ç”¨äºæ§åˆ¶GTAOçš„å„ç§å‚æ•°ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenu(&#34;SSAO/GTAO&#34;)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GroundTruthAmbientOcclusion</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedIntParameter downsamplingFactor = <span style=color:#66d9ef>new</span> ClampedIntParameter(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter intensity = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter radius = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.01f</span>, <span style=color:#ae81ff>5.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter distributionPower = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>2.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>5.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ClampedFloatParameter falloffRange = <span style=color:#66d9ef>new</span> ClampedFloatParameter(<span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>0.01f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> active &amp;&amp; intensity.<span style=color:#66d9ef>value</span> &gt; <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gtaorendererfeaturecs>GTAORendererFeature.cs<a hidden class=anchor aria-hidden=true href=#gtaorendererfeaturecs>#</a></h3><p>ä¹Ÿæ²¡å•¥å¥½è¯´çš„ï¼Œå¾ˆæ™®é€šçš„RendererFeatureã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GTAORendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>        [System.Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GTAOSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> isEnabled;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader gtaoComputeShader;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GTAOSettings settings = <span style=color:#66d9ef>new</span> GTAOSettings();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GTAORenderPass gtaoRenderPass;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            gtaoRenderPass = <span style=color:#66d9ef>new</span> GTAORenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            GroundTruthAmbientOcclusion gtao = VolumeManager.instance.stack.GetComponent&lt;GroundTruthAmbientOcclusion&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (gtao != <span style=color:#66d9ef>null</span> &amp;&amp; gtao.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                gtaoRenderPass.Setup(gtao);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(gtaoRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=gtaorenderpasscs>GTAORenderPass.cs<a hidden class=anchor aria-hidden=true href=#gtaorenderpasscs>#</a></h3><p>ä¸»è¦å€¼å¾—æ³¨æ„çš„æ˜¯å›¾åƒåˆ†è¾¨ç‡çš„å¤§å°ï¼Œè·å–åŠåˆ†è¾¨ç‡çš„å¤§å°æ—¶ï¼Œè¦è®°å¾—ä½¿ç”¨Ceilæ¥è·å–æ›´å¤§çš„å›¾ç‰‡ã€‚ç„¶åæ¯ä¸€ä¸ªé˜¶æ®µä½¿ç”¨çš„Dispatchæ•°ç›®ä¹Ÿä¸å°½ç›¸åŒï¼Œä¸»è¦æ˜¯ä¸Šé‡‡æ ·çš„é˜¶æ®µèŠ±æ ·æ¯”è¾ƒå¤šã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GTAORenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> profilerTag = <span style=color:#e6db74>&#34;Ground Truth Ambient Occlusion&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> gtaoKernelName = <span style=color:#e6db74>&#34;GTAOMain&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> blurHorizontalKernelName = <span style=color:#e6db74>&#34;BlurHorizontalMain&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> blurVerticalKernelName = <span style=color:#e6db74>&#34;BlurVerticalMain&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> visualizeKernelName = <span style=color:#e6db74>&#34;VisualizeMain&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler profilingSampler;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler gtaoSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;GTAO Pass&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler blurSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Blur Pass&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ProfilingSampler visualizeSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(<span style=color:#e6db74>&#34;Visualize Pass&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraColor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraColorIden;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepth;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthIden;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle cameraDepthAttachment;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier cameraDepthAttachmentIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> gtaoTextureName = <span style=color:#e6db74>&#34;_GTAOBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> gtaoTextureID = Shader.PropertyToID(gtaoTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle gtaoTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier gtaoTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> horizontalBlurTextureName = <span style=color:#e6db74>&#34;_HorizontalBlurBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> horizontalBlurTextureID = Shader.PropertyToID(horizontalBlurTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle horizontalBlurTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier horizontalBlurTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> vericalBlurTextureName = <span style=color:#e6db74>&#34;_VerticalBlurBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> vericalBlurTextureID = Shader.PropertyToID(vericalBlurTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle vericalBlurTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier vericalBlurTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> visualizeTextureName = <span style=color:#e6db74>&#34;_VisualizeBuffer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> visualizeTextureID = Shader.PropertyToID(visualizeTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetHandle visualizeTextureHandle;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RenderTargetIdentifier visualizeTextureIden;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GroundTruthAmbientOcclusion groundTruthAmbientOcclusion;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader gtaoComputeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> GTAORendererFeature.GTAOSettings settings;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> downsamplingFactor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int fullRes;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int downsampleRes;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> frameIndex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOFrameIndexID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_FrameIndex&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAODownsamplingFactorID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_DownsamplingFactor&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOIntensityID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_Intensity&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOSampleRadiusID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_SampleRadius&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAODistributionPowerID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_DistributionPower&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOFalloffRangeID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_FalloffRange&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOTextureSizeID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_TextureSize&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOColorTextureID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_ColorTexture&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAODepthTextureID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_DepthTexture&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAOTextureID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_GTAOTexture&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAORWTextureID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_GTAOTexture&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAORWBlurTextureID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_BlurTexture&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> _GTAORWVisualizeTextureID = Shader.PropertyToID(<span style=color:#e6db74>&#34;_RW_VisualizeTexture&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> GTAORenderPass(GTAORendererFeature.GTAOSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(profilerTag);
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            gtaoComputeShader = settings.gtaoComputeShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cameraColor.Init(<span style=color:#e6db74>&#34;_CameraColorTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraColorIden = cameraColor.Identifier();
</span></span><span style=display:flex><span>            cameraDepth.Init(<span style=color:#e6db74>&#34;_CameraDepthTexture&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthIden = cameraDepth.Identifier();
</span></span><span style=display:flex><span>            cameraDepthAttachment.Init(<span style=color:#e6db74>&#34;_CameraDepthAttachment&#34;</span>);
</span></span><span style=display:flex><span>            cameraDepthAttachmentIden = cameraDepthAttachment.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            gtaoTextureHandle.Init(gtaoTextureName);
</span></span><span style=display:flex><span>            gtaoTextureIden = gtaoTextureHandle.Identifier();
</span></span><span style=display:flex><span>            horizontalBlurTextureHandle.Init(horizontalBlurTextureName);
</span></span><span style=display:flex><span>            horizontalBlurTextureIden = horizontalBlurTextureHandle.Identifier();
</span></span><span style=display:flex><span>            vericalBlurTextureHandle.Init(vericalBlurTextureName);
</span></span><span style=display:flex><span>            vericalBlurTextureIden = vericalBlurTextureHandle.Identifier();
</span></span><span style=display:flex><span>            visualizeTextureHandle.Init(visualizeTextureName);
</span></span><span style=display:flex><span>            visualizeTextureIden = visualizeTextureHandle.Identifier();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            frameIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(GroundTruthAmbientOcclusion groundTruthAmbientOcclusion)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.groundTruthAmbientOcclusion = groundTruthAmbientOcclusion;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = cameraTextureDescriptor;
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            downsamplingFactor = groundTruthAmbientOcclusion.downsamplingFactor.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>            fullRes = <span style=color:#66d9ef>new</span> Vector2Int(desc.width, desc.height);
</span></span><span style=display:flex><span>            downsampleRes = <span style=color:#66d9ef>new</span> Vector2Int(Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)desc.width / downsamplingFactor), Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)desc.height / downsamplingFactor));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(visualizeTextureID, desc);
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(vericalBlurTextureID, desc);
</span></span><span style=display:flex><span>            desc.height = downsampleRes.y;
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(horizontalBlurTextureID, desc);
</span></span><span style=display:flex><span>            desc.width = downsampleRes.x;
</span></span><span style=display:flex><span>            cmd.GetTemporaryRT(gtaoTextureID, desc);      
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoGTAOCalculation(CommandBuffer cmd, RenderTargetIdentifier depthid, RenderTargetIdentifier gtaoid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader.HasKernel(gtaoKernelName)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> gtaoKernel = computeShader.FindKernel(gtaoKernelName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(gtaoKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeIntParam(computeShader, _GTAOFrameIndexID, frameIndex);
</span></span><span style=display:flex><span>            cmd.SetComputeIntParam(computeShader, _GTAODownsamplingFactorID, downsamplingFactor);
</span></span><span style=display:flex><span>            cmd.SetComputeVectorParam(computeShader, _GTAOTextureSizeID, <span style=color:#66d9ef>new</span> Vector4(fullRes.x, fullRes.y, <span style=color:#ae81ff>1.0f</span> / fullRes.x, <span style=color:#ae81ff>1.0f</span> / fullRes.y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.SetComputeFloatParam(computeShader, _GTAOSampleRadiusID, groundTruthAmbientOcclusion.radius.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            cmd.SetComputeFloatParam(computeShader, _GTAODistributionPowerID, groundTruthAmbientOcclusion.distributionPower.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>            cmd.SetComputeFloatParam(computeShader, _GTAOFalloffRangeID, groundTruthAmbientOcclusion.falloffRange.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, gtaoKernel, _GTAODepthTextureID, depthid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, gtaoKernel, _GTAORWTextureID, gtaoid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, gtaoKernel,
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)downsampleRes.x / x),
</span></span><span style=display:flex><span>                    Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)downsampleRes.y / y),
</span></span><span style=display:flex><span>                    <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoBlur(CommandBuffer cmd, RenderTargetIdentifier gtaoid, RenderTargetIdentifier horizontalid, RenderTargetIdentifier verticalid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader.HasKernel(blurHorizontalKernelName) || !computeShader.HasKernel(blurVerticalKernelName)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> horizontalKernel = computeShader.FindKernel(blurHorizontalKernelName);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> verticalKernel = computeShader.FindKernel(blurVerticalKernelName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>uint</span> x, y, z;
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(horizontalKernel, <span style=color:#66d9ef>out</span> x, <span style=color:#66d9ef>out</span> y, <span style=color:#66d9ef>out</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, horizontalKernel, _GTAOTextureID, gtaoid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, horizontalKernel, _GTAORWBlurTextureID, horizontalid);
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, horizontalKernel,
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)fullRes.x / x),
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)downsampleRes.y / y),
</span></span><span style=display:flex><span>                                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(verticalKernel, <span style=color:#66d9ef>out</span> x, <span style=color:#66d9ef>out</span> y, <span style=color:#66d9ef>out</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, verticalKernel, _GTAOTextureID, horizontalid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, verticalKernel, _GTAORWBlurTextureID, verticalid);
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, verticalKernel,
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)fullRes.x / x),
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)fullRes.y / y),
</span></span><span style=display:flex><span>                                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> DoVisualization(CommandBuffer cmd, RenderTargetIdentifier colorid, RenderTargetIdentifier verticalid, RenderTargetIdentifier visualizeid, ComputeShader computeShader)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!computeShader.HasKernel(visualizeKernelName)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> visualzieKernel = computeShader.FindKernel(visualizeKernelName);
</span></span><span style=display:flex><span>            cmd.SetComputeFloatParam(computeShader, _GTAOIntensityID, groundTruthAmbientOcclusion.intensity.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            computeShader.GetKernelThreadGroupSizes(visualzieKernel, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, visualzieKernel, _GTAOColorTextureID, colorid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, visualzieKernel, _GTAOTextureID, verticalid);
</span></span><span style=display:flex><span>            cmd.SetComputeTextureParam(computeShader, visualzieKernel, _GTAORWVisualizeTextureID, visualizeid);
</span></span><span style=display:flex><span>            cmd.DispatchCompute(computeShader, visualzieKernel,
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)fullRes.x / x),
</span></span><span style=display:flex><span>                                Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)fullRes.y / y),
</span></span><span style=display:flex><span>                                <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cmd.Blit(visualizeid, colorid);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, gtaoSampler))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(renderingData.cameraData.isSceneViewCamera)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        DoGTAOCalculation(cmd, cameraDepthIden, gtaoTextureIden, gtaoComputeShader);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        DoGTAOCalculation(cmd, cameraDepthAttachmentIden, gtaoTextureIden, gtaoComputeShader);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, blurSampler))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    DoBlur(cmd, gtaoTextureIden, horizontalBlurTextureIden, vericalBlurTextureIden, gtaoComputeShader);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, visualizeSampler))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    DoVisualization(cmd, cameraColorIden, vericalBlurTextureIden, visualizeTextureIden, gtaoComputeShader);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            frameIndex=(++frameIndex)%<span style=color:#ae81ff>60</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            context.ExecuteCommandBuffer(cmd);
</span></span><span style=display:flex><span>            cmd.Clear();
</span></span><span style=display:flex><span>            CommandBufferPool.Release(cmd);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> FrameCleanup(CommandBuffer cmd)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(gtaoTextureID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(horizontalBlurTextureID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(vericalBlurTextureID);
</span></span><span style=display:flex><span>            cmd.ReleaseTemporaryRT(visualizeTextureID);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=åè®°>åè®°<a hidden class=anchor aria-hidden=true href=#åè®°>#</a></h2><p>åˆéš”äº†å¾ˆä¹…ï¼Œæ€»ç®—é€¼ç€è‡ªå·±æŠŠè¿™ç¯‡æ–‡ç« å†™å®Œäº†ï¼Œä¹Ÿé€¼ç€è‡ªå·±å¼ºè¡Œç”¨Group Shared Memoryæ¥åšå„ç§é‡‡æ ·çš„ä¼˜åŒ–ã€‚å†™å‡ºæ¥çš„ä»£ç æœç„¶å¾ˆå“äººä¹Ÿåº”è¯¥æ²¡äººèƒ½çœ‹å¾—æ‡‚å§ï¼ˆå½“ç„¶æ›´å¯èƒ½æ˜¯æ²¡äººä¼šçœ‹ï¼‰ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/ground-truth-ambient-occlusion/>Ground Truth Ambient Occlusion</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li><li><a href=https://zznewclear13.github.io/tags/screen-space/>Screen Space</a></li></ul><nav class=paginav><a class=prev href=https://zznewclear13.github.io/posts/mimic-oxygen-not-includeds-tile-rendering/><span class=title>Â« Prev</span><br><span>æ¨¡ä»¿ç¼ºæ°§çš„ç“¦ç‰‡æ¸²æŸ“æ–¹æ³•</span>
</a><a class=next href=https://zznewclear13.github.io/posts/create-volumetric-fog-using-ray-marching/><span class=title>Next Â»</span><br><span>ä½¿ç”¨Ray Marchingæ¥æ¸²æŸ“ä½“ç§¯é›¾</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>