<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用Compute Shader计算屏幕空间接触阴影 | ZZNEWCLEAR13</title>
<meta name=keywords content="Contact Shadow,Screen Space,Compute Shader"><meta name=description content="通过径向分派Compute Shader，使用Group Shared Memory缓存深度值."><meta name=author content="zznewclear13"><link rel=canonical href=https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zznewclear13.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zznewclear13.github.io/favicon.ico><link rel=apple-touch-icon href=https://zznewclear13.github.io/favicon.ico><link rel=mask-icon href=https://zznewclear13.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157509723-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="使用Compute Shader计算屏幕空间接触阴影"><meta property="og:description" content="通过径向分派Compute Shader，使用Group Shared Memory缓存深度值."><meta property="og:type" content="article"><meta property="og:url" content="https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/"><meta property="og:image" content="https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/posts/images/ScreenSpaceContactShadow.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-20T12:00:00+08:00"><meta property="article:modified_time" content="2024-04-20T12:00:00+08:00"><meta property="og:site_name" content="ZZNEWCLEAR13"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/posts/images/ScreenSpaceContactShadow.png"><meta name=twitter:title content="使用Compute Shader计算屏幕空间接触阴影"><meta name=twitter:description content="通过径向分派Compute Shader，使用Group Shared Memory缓存深度值."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zznewclear13.github.io/posts/"},{"@type":"ListItem","position":2,"name":"使用Compute Shader计算屏幕空间接触阴影","item":"https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用Compute Shader计算屏幕空间接触阴影","name":"使用Compute Shader计算屏幕空间接触阴影","description":"通过径向分派Compute Shader，使用Group Shared Memory缓存深度值.","keywords":["Contact Shadow","Screen Space","Compute Shader"],"articleBody":"屏幕空间接触阴影 屏幕空间接触阴影是用来解决普通的阴影贴图精度不够的问题而提出来的一种通过深度图在屏幕空间计算阴影的方法。索尼的Bend Studio的Graham Aldridge在Sigraph 2023的索尼创作者大会上，介绍了往日不再（Days Gone）中计算屏幕空间接触阴影的方式，这里可以找到演示文稿和参考代码。\n本篇文章相当于是Radial Dispatch系列的第三篇文章了，与上一篇文章一样，这篇文章是基于径向分派Compute Shader中相关算法的实际应用，具体的缓存方式也可以参考上一篇文章使用Group Shared Memory加速径向模糊，这里就不再赘述了。实际上我发现了这样计算接触阴影的一个缺陷，就是不太好计算软阴影了，由于缓存的限制，随机采样只能在一个很小的范围内分布，基本上用不上了。由于使用的是屏幕空间的深度图的信息，加上厚度检测之后很容易出现漏面的问题，封面中的瑕疵也有一部分是来自于我的Relax Cone Step Mapping本身深度值的瑕疵，屏幕上半部分的阴影就好很多。这就当作是一个Proof of Concept吧，之后有机会的话再回来优化优化。\n本文使用的是Unity 2022.3.21f1，URP版本是14.0.10。\n具体的代码 ContactShadowComputeShader.compute 核心的代码来自于前一篇文章径向分派Compute Shader。前一篇文章在循环中是通过统一步长进行采样的，会采样到四个像素中间因此需要双线性插值，这次我们固定水平或者竖直方向的步长为一个像素，这样我们只需要在一个方向上进行线性插值了。由于深度和颜色信息是两种不同的信息，我们仅对距离很近的深度进行线性插值，对于距离较远的两个深度值，我们使用离采样点最近像素的深度值。至于如何判断深度远近，我使用了和屏幕空间反射中相同的_ThicknessParams，默认物体的厚度为linearSampleDepth * _Thickness.y + _Thickness.x。\n#pragma kernel ContactShadowPoint #pragma kernel ClearMain // #pragma warning(disable: 3556) #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\" #define THREAD_COUNT 128 Texture2D\u003cfloat4\u003e _ColorTex; Texture2D\u003cfloat\u003e _CameraDepthTexture; RWTexture2D\u003cfloat4\u003e _RW_TargetTex; float3 _LightPosWS; float4 _LightPosCS; float2 _LightPosSS; float2 _ThicknessParams; float4 _TextureSize; float _LightRange; float _Debug; struct DispatchParams { int2 offset; int count; int stride; int xMajor; }; StructuredBuffer\u003cDispatchParams\u003e _DispatchData; int GetDispatchType(int index, out int dispatchIndex, out DispatchParams dispatchParams) { for (int i=0; i\u003c8; ++i) { dispatchParams = _DispatchData[i]; dispatchIndex = dispatchParams.count - 1 - index; if (dispatchIndex \u003e= 0) return i; } return 0; } int2 GetDispatchDirection(int dispatchType, out int2 iLightPosOffset) { dispatchType /= 2; int xDir = dispatchType / 2; int yDir = dispatchType % 2; int2 dir = int2(xDir, yDir); iLightPosOffset = dir - 1; return dir * 2 - 1; } int2 GetDispatchOffset(int dispatchType, int dispatchIndex, DispatchParams dispatchParams, out int groupIndex) { groupIndex = 0; int2 dispatchOffset = int2(0, 0); int offsetType = dispatchType % 2; int colIndexOffset = max(dispatchParams.offset.x,dispatchParams.offset.y)/THREAD_COUNT; int2 indexOffset = dispatchParams.xMajor==1?dispatchParams.offset:dispatchParams.offset.yx; int stride = dispatchParams.stride; int colIndex = dispatchIndex / stride; int rowIndex = dispatchIndex - colIndex * stride; if (offsetType == 0) { int offsetedColIndex = colIndex + colIndexOffset; int tempIndex = rowIndex + indexOffset.y - (offsetedColIndex + 1) * THREAD_COUNT; if (tempIndex \u003e= 0) { dispatchOffset = int2(tempIndex + indexOffset.x, dispatchParams.stride - (colIndex + colIndexOffset + 1) * THREAD_COUNT + indexOffset.x + indexOffset.y); groupIndex = tempIndex; } else { dispatchOffset = int2((offsetedColIndex + 1) * THREAD_COUNT - 1, rowIndex + indexOffset.y); groupIndex = rowIndex; } } else { int minOffsetX = max(dispatchParams.stride + indexOffset.y, (colIndexOffset + 1) * THREAD_COUNT); dispatchOffset = int2(minOffsetX + colIndex * THREAD_COUNT - 1, rowIndex + indexOffset.y); groupIndex = rowIndex; } if (dispatchParams.xMajor == 0) dispatchOffset.xy = dispatchOffset.yx; return dispatchOffset; } void GetIndexedOffset(int index, float2 absDir, bool xMajor, out int2 offset1, out int2 offset2, out int2 offset3) { if (!xMajor) { absDir = absDir.yx; } float val = float(index) * absDir.y / absDir.x; float floorVal = floor(val); float fracVal = frac(val); if (fracVal \u003c= 0.5f) { offset1 = int2(index, floorVal - 1.0f); offset2 = int2(index, floorVal); offset3 = int2(index, floorVal + 1.0f); } else { offset1 = int2(index, floorVal); offset2 = int2(index, floorVal + 1.0f); offset3 = int2(index, floorVal + 2.0f); } if (!xMajor) { offset1 = offset1.yx; offset2 = offset2.yx; offset3 = offset3.yx; } } float LoadDepthTexture(int2 coord) { // coord.y = int(_TextureSize.y) - 1 - coord.y; coord = clamp(coord, int2(0, 0), int2(_TextureSize.xy - 1.0f)); return _CameraDepthTexture.Load(uint3(coord, 0)); } struct DepthData { float depth; float linearDepth; }; groupshared DepthData cachedDepth[THREAD_COUNT * 6]; void SetCachedDepth(DepthData depthData, int2 threadPos) {cachedDepth[threadPos.x+threadPos.y*THREAD_COUNT]=depthData;} DepthData GetCachedDepth(int2 threadPos) {return cachedDepth[threadPos.x+threadPos.y*THREAD_COUNT*2];} void CacheDepth(int2 groupStartSS, float2 lightPosSS, int cacheIndex) { float2 toLight = lightPosSS - (groupStartSS + 0.5f); float2 absDir = abs(toLight); int2 signDir = int2(sign(toLight)); bool xMajor = absDir.x \u003e= absDir.y; float depthVal1, depthVal2, depthVal3; DepthData depthData1, depthData2, depthData3; int2 offset1, offset2, offset3; { GetIndexedOffset(cacheIndex, absDir, xMajor, offset1, offset2, offset3); depthVal1 = LoadDepthTexture(groupStartSS + offset1 * signDir); depthVal2 = LoadDepthTexture(groupStartSS + offset2 * signDir); depthVal3 = LoadDepthTexture(groupStartSS + offset3 * signDir); depthData1.depth = depthVal1; depthData1.linearDepth = LinearEyeDepth(depthVal1, _ZBufferParams); depthData2.depth = depthVal2; depthData2.linearDepth = LinearEyeDepth(depthVal2, _ZBufferParams); depthData3.depth = depthVal3; depthData3.linearDepth = LinearEyeDepth(depthVal3, _ZBufferParams); SetCachedDepth(depthData1, int2(cacheIndex, 0)); SetCachedDepth(depthData2, int2(cacheIndex, 2)); SetCachedDepth(depthData3, int2(cacheIndex, 4)); } { int extIndex = cacheIndex + THREAD_COUNT; GetIndexedOffset(extIndex, absDir, xMajor, offset1, offset2, offset3); depthVal1 = LoadDepthTexture(groupStartSS + offset1 * signDir); depthVal2 = LoadDepthTexture(groupStartSS + offset2 * signDir); depthVal3 = LoadDepthTexture(groupStartSS + offset3 * signDir); depthData1.depth = depthVal1; depthData1.linearDepth = LinearEyeDepth(depthVal1, _ZBufferParams); depthData2.depth = depthVal2; depthData2.linearDepth = LinearEyeDepth(depthVal2, _ZBufferParams); depthData3.depth = depthVal3; depthData3.linearDepth = LinearEyeDepth(depthVal3, _ZBufferParams); SetCachedDepth(depthData1, int2(cacheIndex, 1)); SetCachedDepth(depthData2, int2(cacheIndex, 3)); SetCachedDepth(depthData3, int2(cacheIndex, 5)); } } [numthreads(1, THREAD_COUNT, 1)] void ContactShadowPoint(uint3 id : SV_DISPATCHTHREADID) { float2 lightPosSS = _LightPosSS; int2 iLightPosSS = int2(floor(lightPosSS + 0.5f)); int dispatchIndex; DispatchParams dispatchParams; int dispatchType = GetDispatchType(id.x, dispatchIndex, dispatchParams); int2 iLightPosOffset; int2 dispatchDirection = GetDispatchDirection(dispatchType, iLightPosOffset); int groupIndex; int2 dispatchOffset = GetDispatchOffset(dispatchType, dispatchIndex, dispatchParams, groupIndex); int2 iGroupStartSS = iLightPosSS + iLightPosOffset + dispatchDirection * dispatchOffset; CacheDepth(iGroupStartSS, lightPosSS, id.y); GroupMemoryBarrierWithGroupSync(); float2 toLight = lightPosSS - (float2(iGroupStartSS) + 0.5f); float2 absDir = abs(toLight); int2 signDir = sign(toLight); bool xMajor = absDir.x \u003e= absDir.y; float2 absNDir = normalize(absDir); float absToLightStepRatio = xMajor ? absDir.y / absDir.x : absDir.x / absDir.y; int baseOffsetY = int(float(id.y) * absToLightStepRatio + 0.5f); int2 iOffset = xMajor ? int2(id.y, baseOffsetY) : int2(baseOffsetY, id.y); int2 iPosSS = iGroupStartSS + iOffset * signDir; if (any(iPosSS \u003c int2(0, 0)) || any(iPosSS \u003e= int2(_TextureSize.xy))) return; float2 posSS = float2(iPosSS) + 0.5f; float2 toPosSS = posSS - lightPosSS; float2 absToPos = abs(toPosSS); float absToPosStepRatio = xMajor ? absToPos.y / absToPos.x : absToPos.x / absToPos.y; int yIntersect = int(float(id.y) * absToPosStepRatio + 0.5f); int yVal = baseOffsetY; if (yIntersect != yVal) return; float lenToPosSS = xMajor ? absToPos.x : absToPos.y; DepthData thisDepth = GetCachedDepth(int2(id.y, 1)); float lightLinearDepth = LinearEyeDepth(_LightPosCS.z / _LightPosCS.w, _ZBufferParams); float shadow = 1.0f; float3 positionNDC = float3(posSS*_TextureSize.zw*2.0f-1.0f, thisDepth.depth); positionNDC.y = -positionNDC.y; float4 positionWS = mul(UNITY_MATRIX_I_VP, float4(positionNDC, 1.0f)); positionWS.xyz /= positionWS.w; float lenToLightWS = length(positionWS.xyz - _LightPosWS); if (lenToLightWS \u003e _LightRange) { _RW_TargetTex[iPosSS] = float4(0.0f, 0.0f, 0.0f, 1.0f); return; } for (int i=1; i\u003cTHREAD_COUNT; ++i) { if (i\u003e=lenToPosSS) break; float baseOffsetY0 = (i + id.y) * absToLightStepRatio; int iBaseStartY0 = int(floor(baseOffsetY0)) + (frac(baseOffsetY0)\u003c=0.5f ? -1 : 0); float offsetY0 = i * absToPosStepRatio + baseOffsetY; int offsetStartY0 = int(floor(offsetY0)); int sampleIndex0 = offsetStartY0 - iBaseStartY0; DepthData depthData0 = GetCachedDepth(int2(id.y + i, sampleIndex0)); DepthData depthData1 = GetCachedDepth(int2(id.y + i, sampleIndex0 + 1)); float weightY0 = frac(offsetY0); if (abs(depthData0.linearDepth-depthData1.linearDepth) \u003e(min(depthData0.linearDepth, depthData1.linearDepth) * _ThicknessParams.y + _ThicknessParams.x)) { weightY0 = step(0.5f, weightY0); } float interpolatedLinearDepth = 1.0f / lerp(1.0f/depthData0.linearDepth, 1.0f/depthData1.linearDepth, weightY0); float estimatedDepth = 1.0f / lerp(1.0f/thisDepth.linearDepth, 1.0f/lightLinearDepth, clamp(i/lenToPosSS, 0.0f, 1.0f)); if (estimatedDepth\u003einterpolatedLinearDepth \u0026\u0026 ((estimatedDepth-interpolatedLinearDepth)\u003cinterpolatedLinearDepth*_ThicknessParams.y+_ThicknessParams.x)) { shadow = 0.0f; break; } } float3 color = shadow; _RW_TargetTex[iPosSS] = float4(color, 1.0f); } [numthreads(8, 8, 1)] void ClearMain(uint3 id : SV_DISPATCHTHREADID) { _RW_TargetTex[id.xy] = 0.0f; } ContactShadowRenderPass.cs 和上一篇文章如出一辙，看上去只是把Radial Blur替换成了Contact Shadow，把center替换成了light。这里我们只考虑了点光源的接触阴影，平行光较为简单，所有点的采样方向都是同一个方向，聚光灯和点光源实际上是一样的。\nusing Unity.Mathematics; namespace UnityEngine.Rendering.Universal { public class ContactShadowRenderPass : ScriptableRenderPass { public static Light lightSource; private static readonly string passName = \"Contact Shadow Render Pass\"; private ScriptableRenderer renderer; private ContactShadowRendererFeature.ContactShadowSettings settings; private ContactShadow contactShadow; private ComputeShader computeShader; private Vector2Int textureSize; private static readonly string contactShadowTextureName = \"_ContactShadowTexture\"; private static readonly int contactShadowTextureID = Shader.PropertyToID(contactShadowTextureName); private RTHandle contactShadowTextureHandle; private ComputeBuffer computeBuffer; private static readonly int THREAD_COUNT = 128; private static readonly int DISPATCH_DATA_COUNT = 8; private static readonly int DISPATCH_DATA_STRIDE = 5; private static readonly int DISPATCH_DATA_SIZE = DISPATCH_DATA_COUNT * DISPATCH_DATA_STRIDE; private int[] dispatchData = new int[DISPATCH_DATA_SIZE]; public ContactShadowRenderPass(ContactShadowRendererFeature.ContactShadowSettings settings) { this.settings = settings; computeShader = settings.computeShader; renderPassEvent = settings.renderPassEvent; profilingSampler = new ProfilingSampler(passName); } public void Setup(ScriptableRenderer renderer, ContactShadow contactShadow) { this.renderer = renderer; this.contactShadow = contactShadow; } private void EnsureComputeBuffer(int count, int stride) { if (computeBuffer == null || computeBuffer.count != count || computeBuffer.stride != stride) { if (computeBuffer != null) { computeBuffer.Release(); } computeBuffer = new ComputeBuffer(count, stride, ComputeBufferType.Structured); } } public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData) { EnsureComputeBuffer(DISPATCH_DATA_COUNT, DISPATCH_DATA_STRIDE * 4); RenderTextureDescriptor desc = renderingData.cameraData.cameraTargetDescriptor; textureSize = new Vector2Int(desc.width, desc.height); desc.enableRandomWrite = true; desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat; desc.depthBufferBits = 0; desc.msaaSamples = 1; desc.useMipMap = false; RenderingUtils.ReAllocateIfNeeded(ref contactShadowTextureHandle, desc, FilterMode.Point, TextureWrapMode.Clamp, false, 1, 0, contactShadowTextureName); ; } private Vector4 GetTextureSizeParameter(Vector2Int textureSize) { return new Vector4(textureSize.x, textureSize.y, 1.0f / textureSize.x, 1.0f / textureSize.y); } private struct DispatchParams { public int2 offset; public int count; public int stride; public int xMajor; public DispatchParams(int2 offset, int count, int stride, int xMajor) { this.offset = offset; this.count = count; this.stride = stride; this.xMajor = xMajor; } } private void GetDispatchParams(int2 coord, int2 offset, out DispatchParams dp1, out DispatchParams dp2) { int colIndexOffset = math.max(offset.x, offset.y) / THREAD_COUNT; int yIndexOffset; int minVal, maxVal, xMajor; if (coord.x \u003e= coord.y) { minVal = coord.y; maxVal = coord.x; yIndexOffset = offset.y; xMajor = 1; } else { minVal = coord.x; maxVal = coord.y; yIndexOffset = offset.x; xMajor = 0; } int stride1 = math.max(0, (minVal + colIndexOffset + 1) * THREAD_COUNT - 1 - offset.x - offset.y); int count1 = stride1 * math.max(0, minVal - colIndexOffset); int stride2 = math.max(0, (minVal + 1) * THREAD_COUNT - yIndexOffset); int count2 = stride2 * math.max(0, maxVal - math.max(minVal, colIndexOffset)); dp1 = new DispatchParams(offset, count1, stride1, xMajor); dp2 = new DispatchParams(offset, count2, stride2, xMajor); } private void GetDispatchList(int2 iCenterPosSS, int2 textureSize, out DispatchParams[] dispatchList) { int2 offsetLB = math.max(0, iCenterPosSS - textureSize); int2 offsetRT = math.max(0, new int2(0, 0) - iCenterPosSS); int2 coordLB = (iCenterPosSS + THREAD_COUNT - 1) / THREAD_COUNT; int2 coordRT = (textureSize - iCenterPosSS + THREAD_COUNT - 1) / THREAD_COUNT; int2 coordRB = new int2(coordRT.x, coordLB.y); int2 coordLT = new int2(coordLB.x, coordRT.y); int2 offsetRB = new int2(offsetRT.x, offsetLB.y); int2 offsetLT = new int2(offsetLB.x, offsetRT.y); GetDispatchParams(coordLB, offsetLB, out DispatchParams dpLB1, out DispatchParams dpLB2); GetDispatchParams(coordLT, offsetLT, out DispatchParams dpLT1, out DispatchParams dpLT2); GetDispatchParams(coordRB, offsetRB, out DispatchParams dpRB1, out DispatchParams dpRB2); GetDispatchParams(coordRT, offsetRT, out DispatchParams dpRT1, out DispatchParams dpRT2); dispatchList = new DispatchParams[] { dpLB1, dpLB2, dpLT1, dpLT2, dpRB1, dpRB2, dpRT1, dpRT2 }; } private int SetDispatchData(DispatchParams[] dispatchList) { if (dispatchList.Length != 8) return 0; int totalCount = 0; for (int i = 0; i \u003c 8; ++i) { var param = dispatchList[i]; totalCount += param.count; dispatchData[5 * i + 0] = param.offset.x; dispatchData[5 * i + 1] = param.offset.y; dispatchData[5 * i + 2] = totalCount; dispatchData[5 * i + 3] = param.stride; dispatchData[5 * i + 4] = param.xMajor; } computeBuffer.SetData(dispatchData); return totalCount; } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { CommandBuffer cmd = renderingData.commandBuffer; UniversalRenderer universalRenderer = renderer as UniversalRenderer; if (universalRenderer == null || computeShader == null || lightSource == null || lightSource.type != LightType.Point) return; using (new ProfilingScope(cmd, profilingSampler)) { float4 lightPosWS = new float4(lightSource.transform.position, 1.0f); float4x4 viewMat = renderingData.cameraData.GetViewMatrix(); float4x4 projMat = renderingData.cameraData.GetGPUProjectionMatrix(); float4x4 vpMat = math.mul(projMat, viewMat); float4 lightPosCS = math.mul(vpMat, lightPosWS); float3 lightPosNDC = lightPosCS.xyz / lightPosCS.w; lightPosNDC.y = -lightPosNDC.y; float2 lightPosSS = (lightPosNDC.xy * 0.5f + 0.5f) * new float2(textureSize.x, textureSize.y); int2 iLightPosSS = new int2(math.floor(lightPosSS + 0.5f)); int2 ts = new int2(textureSize.x, textureSize.y); GetDispatchList(iLightPosSS, ts, out DispatchParams[] dispatchList); int totalDispatchCount = SetDispatchData(dispatchList); var backBuffer = universalRenderer.m_ColorBufferSystem.GetBackBuffer(cmd); // int clearID = computeShader.FindKernel(\"ClearMain\"); // cmd.SetComputeTextureParam(computeShader, clearID, \"_RW_TargetTex\", contactShadowTextureHandle); // computeShader.GetKernelThreadGroupSizes(clearID, out uint x1, out uint y1, out uint z1); // cmd.DispatchCompute(computeShader, clearID, // Mathf.CeilToInt((float)textureSize.x / x1), // Mathf.CeilToInt((float)textureSize.y / y1), // 1); int kernelID = computeShader.FindKernel(\"ContactShadowPoint\"); cmd.SetComputeTextureParam(computeShader, kernelID, \"_ColorTex\", backBuffer); cmd.SetComputeTextureParam(computeShader, kernelID, \"_RW_TargetTex\", contactShadowTextureHandle); cmd.SetComputeVectorParam(computeShader, \"_LightPosWS\", lightPosWS); cmd.SetComputeVectorParam(computeShader, \"_LightPosCS\", lightPosCS); cmd.SetComputeVectorParam(computeShader, \"_LightPosSS\", new float4(lightPosSS, 0.0f, 0.0f)); cmd.SetComputeVectorParam(computeShader, \"_ThicknessParams\", contactShadow.thicknessParams.value); cmd.SetComputeVectorParam(computeShader, \"_TextureSize\", GetTextureSizeParameter(textureSize)); cmd.SetComputeFloatParam(computeShader, \"_LightRange\", lightSource.range); cmd.SetComputeFloatParam(computeShader, \"_Debug\", contactShadow.debug.value); cmd.SetComputeBufferParam(computeShader, kernelID, \"_DispatchData\", computeBuffer); computeShader.GetKernelThreadGroupSizes(kernelID, out uint x, out uint y, out uint z); cmd.DispatchCompute(computeShader, kernelID, Mathf.CeilToInt((float)totalDispatchCount / x), 1, 1); cmd.Blit(contactShadowTextureHandle, backBuffer); } } public void Dispose() { contactShadowTextureHandle?.Release(); if (computeBuffer != null) { computeBuffer.Release(); computeBuffer = null; } } } } ContactShadowRendererFeature.cs using System; namespace UnityEngine.Rendering.Universal { public class ContactShadowRendererFeature : ScriptableRendererFeature { [Serializable] public class ContactShadowSettings { public ComputeShader computeShader; public RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing; } public ContactShadowSettings settings = new ContactShadowSettings(); private ContactShadowRenderPass contactShadowRenderPass; public override void Create() { contactShadowRenderPass = new ContactShadowRenderPass(settings); } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { ContactShadow cs = VolumeManager.instance.stack.GetComponent(); if (cs.IsActive()) { contactShadowRenderPass.Setup(renderer, cs); renderer.EnqueuePass(contactShadowRenderPass); } } protected override void Dispose(bool disposing) { contactShadowRenderPass?.Dispose(); base.Dispose(disposing); } } } ContactShadow.cs using System; namespace UnityEngine.Rendering.Universal { [Serializable, VolumeComponentMenuForRenderPipeline(\"Post-processing/Contact Shadow\", typeof(UniversalRenderPipeline))] public sealed class ContactShadow : VolumeComponent, IPostProcessComponent { public BoolParameter isEnabled = new BoolParameter(false); public Vector2Parameter thicknessParams = new Vector2Parameter(new Vector2(0.1f, 0.02f)); public FloatParameter debug = new FloatParameter(0.0f); public bool IsActive() { return isEnabled.value; } public bool IsTileCompatible() =\u003e false; } } ScreenSpaceContactShadowLightSource.cs using UnityEngine; [ExecuteAlways] [RequireComponent(typeof(Light))] public class ScreenSpaceContactShadowLightSource : MonoBehaviour { public static ScreenSpaceContactShadowLightSource Instance { get; private set; } private void OnEnable() { if (Instance == null) { Instance = this; UnityEngine.Rendering.Universal.ContactShadowRenderPass.lightSource = GetComponent(); } else { Debug.LogError(\"Only one instance of ScreenSpaceContactShadowLightSource is allowed to exist at the same time.\"); enabled = false; } } private void OnDisable() { if (Instance == this) { Instance = null; } } private void OnDestroy() { if (Instance == this ) { Instance = null; } } } 后记 摸了两周，但也没摸，但是确实有点没有动力了。Radial Dispatch系列估计到这里就告一段落了，这个屏幕空间接触阴影没有我之前想象中的效果那么好，之后会在草场、云、海洋、Radiance Cascade GI中间选一个来做吧，不过估计要很久了。本来封面是想放一个点光源在视差映射贴图上的接触阴影和平行光在远处山上森林的接触阴影的，不过有点懒得整了。2024虽然糟透了，但也还有一丝丝的好消息吧。\n","wordCount":"2017","inLanguage":"en","image":"https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/posts/images/ScreenSpaceContactShadow.png","datePublished":"2024-04-20T12:00:00+08:00","dateModified":"2024-04-20T12:00:00+08:00","author":{"@type":"Person","name":"zznewclear13"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zznewclear13.github.io/posts/calculate-screen-space-contact-shadow-using-compute-shader/"},"publisher":{"@type":"Organization","name":"ZZNEWCLEAR13","logo":{"@type":"ImageObject","url":"https://zznewclear13.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zznewclear13.github.io/ accesskey=h title="ZZNEWCLEAR13 (Alt + H)"><img src=https://zznewclear13.github.io/apple-touch-icon.png alt aria-label=logo height=35>ZZNEWCLEAR13</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zznewclear13.github.io/now/ title=进行时><span>进行时</span></a></li><li><a href=https://zznewclear13.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zznewclear13.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zznewclear13.github.io/links/ title=友情链接><span>友情链接</span></a></li><li><a href=https://zznewclear13.github.io/search/ title="🔎 (Alt + /)" accesskey=/><span>🔎</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zznewclear13.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zznewclear13.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">使用Compute Shader计算屏幕空间接触阴影</h1><div class=post-description>通过径向分派Compute Shader，使用Group Shared Memory缓存深度值.</div><div class=post-meta><span title='2024-04-20 12:00:00 +0800 CST'>April 20, 2024</span>&nbsp;·&nbsp;zznewclear13&nbsp;|&nbsp;<a href=https://github.com/zznewclear13/zznewclear13.com/blob/main/content/posts/calculate-screen-space-contact-shadow-using-compute-shader.md rel="noopener noreferrer" target=_blank>编辑</a></div></header><figure class=entry-cover><img loading=eager src=https://zznewclear13.github.io/posts/images/ScreenSpaceContactShadow.png alt="Screen Space Contact Shadow Cover"><p>Screen Space Contact Shadow Example</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>使用Compute Shader计算屏幕空间接触阴影</div></summary><div class=inner><ul><li><a href=#%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4%e6%8e%a5%e8%a7%a6%e9%98%b4%e5%bd%b1 aria-label=屏幕空间接触阴影>屏幕空间接触阴影</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=具体的代码>具体的代码</a><ul><li><a href=#contactshadowcomputeshadercompute aria-label=ContactShadowComputeShader.compute>ContactShadowComputeShader.compute</a></li><li><a href=#contactshadowrenderpasscs aria-label=ContactShadowRenderPass.cs>ContactShadowRenderPass.cs</a></li><li><a href=#contactshadowrendererfeaturecs aria-label=ContactShadowRendererFeature.cs>ContactShadowRendererFeature.cs</a></li><li><a href=#contactshadowcs aria-label=ContactShadow.cs>ContactShadow.cs</a></li><li><a href=#screenspacecontactshadowlightsourcecs aria-label=ScreenSpaceContactShadowLightSource.cs>ScreenSpaceContactShadowLightSource.cs</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><h2 id=屏幕空间接触阴影>屏幕空间接触阴影<a hidden class=anchor aria-hidden=true href=#屏幕空间接触阴影>#</a></h2><p>屏幕空间接触阴影是用来解决普通的阴影贴图精度不够的问题而提出来的一种通过深度图在屏幕空间计算阴影的方法。索尼的Bend Studio的Graham Aldridge在Sigraph 2023的索尼创作者大会上，介绍了往日不再（Days Gone）中计算屏幕空间接触阴影的方式，<a href=https://www.bendstudio.com/blog/inside-bend-screen-space-shadows/>这里</a>可以找到演示文稿和参考代码。</p><p>本篇文章相当于是Radial Dispatch系列的第三篇文章了，与上一篇文章一样，这篇文章是基于<a href=/posts/dispatch-compute-shader-in-a-radial-way/>径向分派Compute Shader</a>中相关算法的实际应用，具体的缓存方式也可以参考上一篇文章<a href=/posts/accelerate-radial-blur-using-group-shared-memory/>使用Group Shared Memory加速径向模糊</a>，这里就不再赘述了。实际上我发现了这样计算接触阴影的一个缺陷，就是不太好计算软阴影了，由于缓存的限制，随机采样只能在一个很小的范围内分布，基本上用不上了。由于使用的是屏幕空间的深度图的信息，加上厚度检测之后很容易出现漏面的问题，封面中的瑕疵也有一部分是来自于我的Relax Cone Step Mapping本身深度值的瑕疵，屏幕上半部分的阴影就好很多。这就当作是一个Proof of Concept吧，之后有机会的话再回来优化优化。</p><p>本文使用的是Unity 2022.3.21f1，URP版本是14.0.10。</p><h2 id=具体的代码>具体的代码<a hidden class=anchor aria-hidden=true href=#具体的代码>#</a></h2><h3 id=contactshadowcomputeshadercompute>ContactShadowComputeShader.compute<a hidden class=anchor aria-hidden=true href=#contactshadowcomputeshadercompute>#</a></h3><p>核心的代码来自于前一篇文章<a href=/posts/dispatch-compute-shader-in-a-radial-way/>径向分派Compute Shader</a>。前一篇文章在循环中是通过统一步长进行采样的，会采样到四个像素中间因此需要双线性插值，这次我们固定水平或者竖直方向的步长为一个像素，这样我们只需要在一个方向上进行线性插值了。由于深度和颜色信息是两种不同的信息，我们仅对距离很近的深度进行线性插值，对于距离较远的两个深度值，我们使用离采样点最近像素的深度值。至于如何判断深度远近，我使用了和<a href=/posts/screen-space-reflection/>屏幕空间反射</a>中相同的<code>_ThicknessParams</code>，默认物体的厚度为<code>linearSampleDepth * _Thickness.y + _Thickness.x</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HLSL data-lang=HLSL><span style=display:flex><span><span style=color:#75715e>#pragma kernel ContactShadowPoint</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma kernel ClearMain</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// #pragma warning(disable: 3556)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include &#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define THREAD_COUNT 128</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _ColorTex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>Texture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> _CameraDepthTexture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>RWTexture2D</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float4</span><span style=color:#f92672>&gt;</span> _RW_TargetTex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float3</span> _LightPosWS;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _LightPosCS;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> _LightPosSS;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float2</span> _ThicknessParams;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float4</span> _TextureSize;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _LightRange;
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> _Debug;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> DispatchParams
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> xMajor;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>StructuredBuffer</span><span style=color:#f92672>&lt;</span>DispatchParams<span style=color:#f92672>&gt;</span> _DispatchData;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> GetDispatchType(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> dispatchIndex, <span style=color:#66d9ef>out</span> DispatchParams dispatchParams)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        dispatchParams <span style=color:#f92672>=</span> _DispatchData[i];
</span></span><span style=display:flex><span>        dispatchIndex <span style=color:#f92672>=</span> dispatchParams.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> index;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dispatchIndex <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int2</span> GetDispatchDirection(<span style=color:#66d9ef>int</span> dispatchType, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> iLightPosOffset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    dispatchType <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> xDir <span style=color:#f92672>=</span> dispatchType <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yDir <span style=color:#f92672>=</span> dispatchType <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dir <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(xDir, yDir);
</span></span><span style=display:flex><span>    iLightPosOffset <span style=color:#f92672>=</span> dir <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dir <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int2</span> GetDispatchOffset(<span style=color:#66d9ef>int</span> dispatchType, <span style=color:#66d9ef>int</span> dispatchIndex, DispatchParams dispatchParams, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int</span> groupIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    groupIndex <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> offsetType <span style=color:#f92672>=</span> dispatchType <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> colIndexOffset <span style=color:#f92672>=</span> max(dispatchParams.offset.x,dispatchParams.offset.y)<span style=color:#f92672>/</span>THREAD_COUNT;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> indexOffset <span style=color:#f92672>=</span> dispatchParams.xMajor<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span><span style=color:#f92672>?</span>dispatchParams.offset<span style=color:#f92672>:</span>dispatchParams.offset.yx;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stride <span style=color:#f92672>=</span> dispatchParams.stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> colIndex <span style=color:#f92672>=</span> dispatchIndex <span style=color:#f92672>/</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> rowIndex <span style=color:#f92672>=</span> dispatchIndex <span style=color:#f92672>-</span> colIndex <span style=color:#f92672>*</span> stride;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offsetType <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {         
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> offsetedColIndex <span style=color:#f92672>=</span> colIndex <span style=color:#f92672>+</span> colIndexOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> tempIndex <span style=color:#f92672>=</span> rowIndex <span style=color:#f92672>+</span> indexOffset.y <span style=color:#f92672>-</span> (offsetedColIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tempIndex <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(tempIndex <span style=color:#f92672>+</span> indexOffset.x, dispatchParams.stride <span style=color:#f92672>-</span> (colIndex <span style=color:#f92672>+</span> colIndexOffset <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT <span style=color:#f92672>+</span> indexOffset.x <span style=color:#f92672>+</span> indexOffset.y);
</span></span><span style=display:flex><span>            groupIndex <span style=color:#f92672>=</span> tempIndex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>((offsetedColIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, rowIndex <span style=color:#f92672>+</span> indexOffset.y);
</span></span><span style=display:flex><span>            groupIndex <span style=color:#f92672>=</span> rowIndex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> minOffsetX <span style=color:#f92672>=</span> max(dispatchParams.stride <span style=color:#f92672>+</span> indexOffset.y, (colIndexOffset <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> THREAD_COUNT);
</span></span><span style=display:flex><span>        dispatchOffset <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(minOffsetX <span style=color:#f92672>+</span> colIndex <span style=color:#f92672>*</span> THREAD_COUNT <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, rowIndex <span style=color:#f92672>+</span> indexOffset.y);
</span></span><span style=display:flex><span>        groupIndex <span style=color:#f92672>=</span> rowIndex;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dispatchParams.xMajor <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) dispatchOffset.xy <span style=color:#f92672>=</span> dispatchOffset.yx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dispatchOffset;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> GetIndexedOffset(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>float2</span> absDir, <span style=color:#66d9ef>bool</span> xMajor,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> offset1, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> offset2, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>int2</span> offset3)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>xMajor)   
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        absDir <span style=color:#f92672>=</span> absDir.yx;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> val <span style=color:#f92672>=</span> <span style=color:#66d9ef>float</span>(index) <span style=color:#f92672>*</span> absDir.y <span style=color:#f92672>/</span> absDir.x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> floorVal <span style=color:#f92672>=</span> floor(val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> fracVal <span style=color:#f92672>=</span> frac(val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fracVal <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0.5f</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        offset1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(index, floorVal <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        offset2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(index, floorVal);
</span></span><span style=display:flex><span>        offset3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(index, floorVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        offset1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(index, floorVal);
</span></span><span style=display:flex><span>        offset2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(index, floorVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        offset3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(index, floorVal <span style=color:#f92672>+</span> <span style=color:#ae81ff>2.0f</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>xMajor) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        offset1 <span style=color:#f92672>=</span> offset1.yx;
</span></span><span style=display:flex><span>        offset2 <span style=color:#f92672>=</span> offset2.yx;
</span></span><span style=display:flex><span>        offset3 <span style=color:#f92672>=</span> offset3.yx;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> LoadDepthTexture(<span style=color:#66d9ef>int2</span> coord)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// coord.y = int(_TextureSize.y) - 1 - coord.y;</span>
</span></span><span style=display:flex><span>    coord <span style=color:#f92672>=</span> clamp(coord, <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#66d9ef>int2</span>(_TextureSize.xy <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _CameraDepthTexture.Load(<span style=color:#66d9ef>uint3</span>(coord, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> DepthData
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> linearDepth;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>groupshared</span> DepthData cachedDepth[THREAD_COUNT <span style=color:#f92672>*</span> <span style=color:#ae81ff>6</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SetCachedDepth(DepthData depthData, <span style=color:#66d9ef>int2</span> threadPos) {cachedDepth[threadPos.x<span style=color:#f92672>+</span>threadPos.y<span style=color:#f92672>*</span>THREAD_COUNT]<span style=color:#f92672>=</span>depthData;}
</span></span><span style=display:flex><span>DepthData GetCachedDepth(<span style=color:#66d9ef>int2</span> threadPos) {<span style=color:#66d9ef>return</span> cachedDepth[threadPos.x<span style=color:#f92672>+</span>threadPos.y<span style=color:#f92672>*</span>THREAD_COUNT<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>];}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> CacheDepth(<span style=color:#66d9ef>int2</span> groupStartSS, <span style=color:#66d9ef>float2</span> lightPosSS, <span style=color:#66d9ef>int</span> cacheIndex)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> toLight <span style=color:#f92672>=</span> lightPosSS <span style=color:#f92672>-</span> (groupStartSS <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absDir <span style=color:#f92672>=</span> abs(toLight);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> signDir <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(sign(toLight));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> xMajor <span style=color:#f92672>=</span> absDir.x <span style=color:#f92672>&gt;=</span> absDir.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> depthVal1, depthVal2, depthVal3;
</span></span><span style=display:flex><span>    DepthData depthData1, depthData2, depthData3;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> offset1, offset2, offset3;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        GetIndexedOffset(cacheIndex, absDir, xMajor, offset1, offset2, offset3);
</span></span><span style=display:flex><span>        depthVal1 <span style=color:#f92672>=</span> LoadDepthTexture(groupStartSS <span style=color:#f92672>+</span> offset1 <span style=color:#f92672>*</span> signDir);
</span></span><span style=display:flex><span>        depthVal2 <span style=color:#f92672>=</span> LoadDepthTexture(groupStartSS <span style=color:#f92672>+</span> offset2 <span style=color:#f92672>*</span> signDir);
</span></span><span style=display:flex><span>        depthVal3 <span style=color:#f92672>=</span> LoadDepthTexture(groupStartSS <span style=color:#f92672>+</span> offset3 <span style=color:#f92672>*</span> signDir);
</span></span><span style=display:flex><span>        depthData1.depth <span style=color:#f92672>=</span> depthVal1;
</span></span><span style=display:flex><span>        depthData1.linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthVal1, _ZBufferParams);
</span></span><span style=display:flex><span>        depthData2.depth <span style=color:#f92672>=</span> depthVal2;
</span></span><span style=display:flex><span>        depthData2.linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthVal2, _ZBufferParams);
</span></span><span style=display:flex><span>        depthData3.depth <span style=color:#f92672>=</span> depthVal3;
</span></span><span style=display:flex><span>        depthData3.linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthVal3, _ZBufferParams);
</span></span><span style=display:flex><span>        SetCachedDepth(depthData1, <span style=color:#66d9ef>int2</span>(cacheIndex, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        SetCachedDepth(depthData2, <span style=color:#66d9ef>int2</span>(cacheIndex, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        SetCachedDepth(depthData3, <span style=color:#66d9ef>int2</span>(cacheIndex, <span style=color:#ae81ff>4</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> extIndex <span style=color:#f92672>=</span> cacheIndex <span style=color:#f92672>+</span> THREAD_COUNT;
</span></span><span style=display:flex><span>        GetIndexedOffset(extIndex, absDir, xMajor, offset1, offset2, offset3);
</span></span><span style=display:flex><span>        depthVal1 <span style=color:#f92672>=</span> LoadDepthTexture(groupStartSS <span style=color:#f92672>+</span> offset1 <span style=color:#f92672>*</span> signDir);
</span></span><span style=display:flex><span>        depthVal2 <span style=color:#f92672>=</span> LoadDepthTexture(groupStartSS <span style=color:#f92672>+</span> offset2 <span style=color:#f92672>*</span> signDir);
</span></span><span style=display:flex><span>        depthVal3 <span style=color:#f92672>=</span> LoadDepthTexture(groupStartSS <span style=color:#f92672>+</span> offset3 <span style=color:#f92672>*</span> signDir);
</span></span><span style=display:flex><span>        depthData1.depth <span style=color:#f92672>=</span> depthVal1;
</span></span><span style=display:flex><span>        depthData1.linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthVal1, _ZBufferParams);
</span></span><span style=display:flex><span>        depthData2.depth <span style=color:#f92672>=</span> depthVal2;
</span></span><span style=display:flex><span>        depthData2.linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthVal2, _ZBufferParams);
</span></span><span style=display:flex><span>        depthData3.depth <span style=color:#f92672>=</span> depthVal3;
</span></span><span style=display:flex><span>        depthData3.linearDepth <span style=color:#f92672>=</span> LinearEyeDepth(depthVal3, _ZBufferParams);
</span></span><span style=display:flex><span>        SetCachedDepth(depthData1, <span style=color:#66d9ef>int2</span>(cacheIndex, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        SetCachedDepth(depthData2, <span style=color:#66d9ef>int2</span>(cacheIndex, <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>        SetCachedDepth(depthData3, <span style=color:#66d9ef>int2</span>(cacheIndex, <span style=color:#ae81ff>5</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>1</span>, THREAD_COUNT, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ContactShadowPoint(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> SV_DISPATCHTHREADID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> lightPosSS <span style=color:#f92672>=</span> _LightPosSS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iLightPosSS <span style=color:#f92672>=</span> <span style=color:#66d9ef>int2</span>(floor(lightPosSS <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dispatchIndex;
</span></span><span style=display:flex><span>    DispatchParams dispatchParams;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dispatchType <span style=color:#f92672>=</span> GetDispatchType(id.x, dispatchIndex, dispatchParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iLightPosOffset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dispatchDirection <span style=color:#f92672>=</span> GetDispatchDirection(dispatchType, iLightPosOffset);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> groupIndex;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> dispatchOffset <span style=color:#f92672>=</span> GetDispatchOffset(dispatchType, dispatchIndex, dispatchParams, groupIndex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iGroupStartSS <span style=color:#f92672>=</span> iLightPosSS <span style=color:#f92672>+</span> iLightPosOffset <span style=color:#f92672>+</span> dispatchDirection <span style=color:#f92672>*</span> dispatchOffset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CacheDepth(iGroupStartSS, lightPosSS, id.y);
</span></span><span style=display:flex><span>    GroupMemoryBarrierWithGroupSync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> toLight <span style=color:#f92672>=</span> lightPosSS <span style=color:#f92672>-</span> (<span style=color:#66d9ef>float2</span>(iGroupStartSS) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absDir <span style=color:#f92672>=</span> abs(toLight);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> signDir <span style=color:#f92672>=</span> sign(toLight);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> xMajor <span style=color:#f92672>=</span> absDir.x <span style=color:#f92672>&gt;=</span> absDir.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absNDir <span style=color:#f92672>=</span> normalize(absDir);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> absToLightStepRatio <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span>  absDir.y <span style=color:#f92672>/</span> absDir.x <span style=color:#f92672>:</span>  absDir.x <span style=color:#f92672>/</span> absDir.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> baseOffsetY <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#66d9ef>float</span>(id.y) <span style=color:#f92672>*</span> absToLightStepRatio <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iOffset <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span> <span style=color:#66d9ef>int2</span>(id.y, baseOffsetY) <span style=color:#f92672>:</span> <span style=color:#66d9ef>int2</span>(baseOffsetY, id.y);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int2</span> iPosSS <span style=color:#f92672>=</span> iGroupStartSS <span style=color:#f92672>+</span> iOffset <span style=color:#f92672>*</span> signDir;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (any(iPosSS <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int2</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>||</span> any(iPosSS <span style=color:#f92672>&gt;=</span> <span style=color:#66d9ef>int2</span>(_TextureSize.xy))) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> posSS <span style=color:#f92672>=</span> <span style=color:#66d9ef>float2</span>(iPosSS) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> toPosSS <span style=color:#f92672>=</span> posSS <span style=color:#f92672>-</span> lightPosSS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float2</span> absToPos <span style=color:#f92672>=</span> abs(toPosSS);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> absToPosStepRatio <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span> absToPos.y <span style=color:#f92672>/</span> absToPos.x <span style=color:#f92672>:</span>  absToPos.x <span style=color:#f92672>/</span> absToPos.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yIntersect <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#66d9ef>float</span>(id.y) <span style=color:#f92672>*</span> absToPosStepRatio <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yVal <span style=color:#f92672>=</span> baseOffsetY;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (yIntersect <span style=color:#f92672>!=</span> yVal) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> lenToPosSS <span style=color:#f92672>=</span> xMajor <span style=color:#f92672>?</span> absToPos.x <span style=color:#f92672>:</span> absToPos.y;
</span></span><span style=display:flex><span>    DepthData thisDepth <span style=color:#f92672>=</span> GetCachedDepth(<span style=color:#66d9ef>int2</span>(id.y, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> lightLinearDepth <span style=color:#f92672>=</span> LinearEyeDepth(_LightPosCS.z <span style=color:#f92672>/</span> _LightPosCS.w, _ZBufferParams);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> shadow <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> positionNDC <span style=color:#f92672>=</span> <span style=color:#66d9ef>float3</span>(posSS<span style=color:#f92672>*</span>_TextureSize.zw<span style=color:#f92672>*</span><span style=color:#ae81ff>2.0f</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1.0f</span>, thisDepth.depth);
</span></span><span style=display:flex><span>    positionNDC.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>positionNDC.y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float4</span> positionWS <span style=color:#f92672>=</span> mul(UNITY_MATRIX_I_VP, <span style=color:#66d9ef>float4</span>(positionNDC, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>    positionWS.xyz <span style=color:#f92672>/=</span> positionWS.w;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> lenToLightWS <span style=color:#f92672>=</span> length(positionWS.xyz <span style=color:#f92672>-</span> _LightPosWS);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (lenToLightWS <span style=color:#f92672>&gt;</span> _LightRange)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _RW_TargetTex[iPosSS] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;</span>THREAD_COUNT; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i<span style=color:#f92672>&gt;=</span>lenToPosSS) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> baseOffsetY0 <span style=color:#f92672>=</span> (i <span style=color:#f92672>+</span> id.y) <span style=color:#f92672>*</span> absToLightStepRatio;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> iBaseStartY0 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(floor(baseOffsetY0)) <span style=color:#f92672>+</span> (frac(baseOffsetY0)<span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>0.5f</span> <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> offsetY0 <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> absToPosStepRatio <span style=color:#f92672>+</span> baseOffsetY;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> offsetStartY0 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(floor(offsetY0));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> sampleIndex0 <span style=color:#f92672>=</span> offsetStartY0 <span style=color:#f92672>-</span> iBaseStartY0;
</span></span><span style=display:flex><span>        DepthData depthData0 <span style=color:#f92672>=</span> GetCachedDepth(<span style=color:#66d9ef>int2</span>(id.y <span style=color:#f92672>+</span> i, sampleIndex0));
</span></span><span style=display:flex><span>        DepthData depthData1 <span style=color:#f92672>=</span> GetCachedDepth(<span style=color:#66d9ef>int2</span>(id.y <span style=color:#f92672>+</span> i, sampleIndex0 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> weightY0 <span style=color:#f92672>=</span> frac(offsetY0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (abs(depthData0.linearDepth<span style=color:#f92672>-</span>depthData1.linearDepth)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&gt;</span>(min(depthData0.linearDepth, depthData1.linearDepth) <span style=color:#f92672>*</span> _ThicknessParams.y <span style=color:#f92672>+</span> _ThicknessParams.x))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            weightY0 <span style=color:#f92672>=</span> step(<span style=color:#ae81ff>0.5f</span>, weightY0);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> interpolatedLinearDepth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> lerp(<span style=color:#ae81ff>1.0f</span><span style=color:#f92672>/</span>depthData0.linearDepth, <span style=color:#ae81ff>1.0f</span><span style=color:#f92672>/</span>depthData1.linearDepth, weightY0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> estimatedDepth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0f</span> <span style=color:#f92672>/</span> lerp(<span style=color:#ae81ff>1.0f</span><span style=color:#f92672>/</span>thisDepth.linearDepth, <span style=color:#ae81ff>1.0f</span><span style=color:#f92672>/</span>lightLinearDepth, clamp(i<span style=color:#f92672>/</span>lenToPosSS, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (estimatedDepth<span style=color:#f92672>&gt;</span>interpolatedLinearDepth <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            ((estimatedDepth<span style=color:#f92672>-</span>interpolatedLinearDepth)<span style=color:#f92672>&lt;</span>interpolatedLinearDepth<span style=color:#f92672>*</span>_ThicknessParams.y<span style=color:#f92672>+</span>_ThicknessParams.x))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            shadow <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float3</span> color <span style=color:#f92672>=</span> shadow;
</span></span><span style=display:flex><span>    _RW_TargetTex[iPosSS] <span style=color:#f92672>=</span> <span style=color:#66d9ef>float4</span>(color, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>numthreads</span>(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ClearMain(<span style=color:#66d9ef>uint3</span> id <span style=color:#f92672>:</span> SV_DISPATCHTHREADID)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _RW_TargetTex[id.xy] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=contactshadowrenderpasscs>ContactShadowRenderPass.cs<a hidden class=anchor aria-hidden=true href=#contactshadowrenderpasscs>#</a></h3><p>和上一篇文章如出一辙，看上去只是把Radial Blur替换成了Contact Shadow，把center替换成了light。这里我们只考虑了点光源的接触阴影，平行光较为简单，所有点的采样方向都是同一个方向，聚光灯和点光源实际上是一样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Mathematics;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ContactShadowRenderPass</span> : ScriptableRenderPass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Light lightSource;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> passName = <span style=color:#e6db74>&#34;Contact Shadow Render Pass&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ScriptableRenderer renderer;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ContactShadowRendererFeature.ContactShadowSettings settings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ContactShadow contactShadow;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector2Int textureSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> contactShadowTextureName = <span style=color:#e6db74>&#34;_ContactShadowTexture&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> contactShadowTextureID = Shader.PropertyToID(contactShadowTextureName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> RTHandle contactShadowTextureHandle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ComputeBuffer computeBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> THREAD_COUNT = <span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> DISPATCH_DATA_COUNT = <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> DISPATCH_DATA_STRIDE = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> DISPATCH_DATA_SIZE = DISPATCH_DATA_COUNT * DISPATCH_DATA_STRIDE;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span>[] dispatchData = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[DISPATCH_DATA_SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ContactShadowRenderPass(ContactShadowRendererFeature.ContactShadowSettings settings)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.settings = settings;
</span></span><span style=display:flex><span>            computeShader = settings.computeShader;
</span></span><span style=display:flex><span>            renderPassEvent = settings.renderPassEvent;
</span></span><span style=display:flex><span>            profilingSampler = <span style=color:#66d9ef>new</span> ProfilingSampler(passName);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Setup(ScriptableRenderer renderer, ContactShadow contactShadow)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.renderer = renderer;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.contactShadow = contactShadow;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> EnsureComputeBuffer(<span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (computeBuffer == <span style=color:#66d9ef>null</span> || computeBuffer.count != count || computeBuffer.stride != stride)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    computeBuffer.Release();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>new</span> ComputeBuffer(count, stride, ComputeBufferType.Structured);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnCameraSetup(CommandBuffer cmd, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            EnsureComputeBuffer(DISPATCH_DATA_COUNT, DISPATCH_DATA_STRIDE * <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            RenderTextureDescriptor desc = renderingData.cameraData.cameraTargetDescriptor;
</span></span><span style=display:flex><span>            textureSize = <span style=color:#66d9ef>new</span> Vector2Int(desc.width, desc.height);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            desc.enableRandomWrite = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            desc.graphicsFormat = Experimental.Rendering.GraphicsFormat.R16G16B16A16_SFloat;
</span></span><span style=display:flex><span>            desc.depthBufferBits = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            desc.msaaSamples = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            desc.useMipMap = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            RenderingUtils.ReAllocateIfNeeded(<span style=color:#66d9ef>ref</span> contactShadowTextureHandle, desc, FilterMode.Point, TextureWrapMode.Clamp, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, contactShadowTextureName); ;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Vector4 GetTextureSizeParameter(Vector2Int textureSize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Vector4(textureSize.x, textureSize.y, <span style=color:#ae81ff>1.0f</span> / textureSize.x, <span style=color:#ae81ff>1.0f</span> / textureSize.y);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DispatchParams</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> int2 offset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> stride;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> xMajor;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> DispatchParams(int2 offset, <span style=color:#66d9ef>int</span> count, <span style=color:#66d9ef>int</span> stride, <span style=color:#66d9ef>int</span> xMajor)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.offset = offset; <span style=color:#66d9ef>this</span>.count = count; <span style=color:#66d9ef>this</span>.stride = stride; <span style=color:#66d9ef>this</span>.xMajor = xMajor;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GetDispatchParams(int2 coord, int2 offset, <span style=color:#66d9ef>out</span> DispatchParams dp1, <span style=color:#66d9ef>out</span> DispatchParams dp2)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> colIndexOffset = math.max(offset.x, offset.y) / THREAD_COUNT;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> yIndexOffset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> minVal, maxVal, xMajor;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (coord.x &gt;= coord.y)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                minVal = coord.y;
</span></span><span style=display:flex><span>                maxVal = coord.x;
</span></span><span style=display:flex><span>                yIndexOffset = offset.y;
</span></span><span style=display:flex><span>                xMajor = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                minVal = coord.x;
</span></span><span style=display:flex><span>                maxVal = coord.y;
</span></span><span style=display:flex><span>                yIndexOffset = offset.x;
</span></span><span style=display:flex><span>                xMajor = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> stride1 = math.max(<span style=color:#ae81ff>0</span>, (minVal + colIndexOffset + <span style=color:#ae81ff>1</span>) * THREAD_COUNT - <span style=color:#ae81ff>1</span> - offset.x - offset.y);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count1 = stride1 * math.max(<span style=color:#ae81ff>0</span>, minVal - colIndexOffset);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> stride2 = math.max(<span style=color:#ae81ff>0</span>, (minVal + <span style=color:#ae81ff>1</span>) * THREAD_COUNT - yIndexOffset);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> count2 = stride2 * math.max(<span style=color:#ae81ff>0</span>, maxVal - math.max(minVal, colIndexOffset));
</span></span><span style=display:flex><span>            dp1 = <span style=color:#66d9ef>new</span> DispatchParams(offset, count1, stride1, xMajor);
</span></span><span style=display:flex><span>            dp2 = <span style=color:#66d9ef>new</span> DispatchParams(offset, count2, stride2, xMajor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> GetDispatchList(int2 iCenterPosSS, int2 textureSize, <span style=color:#66d9ef>out</span> DispatchParams[] dispatchList)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            int2 offsetLB = math.max(<span style=color:#ae81ff>0</span>, iCenterPosSS - textureSize);
</span></span><span style=display:flex><span>            int2 offsetRT = math.max(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>new</span> int2(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) - iCenterPosSS);
</span></span><span style=display:flex><span>            int2 coordLB = (iCenterPosSS + THREAD_COUNT - <span style=color:#ae81ff>1</span>) / THREAD_COUNT;
</span></span><span style=display:flex><span>            int2 coordRT = (textureSize - iCenterPosSS + THREAD_COUNT - <span style=color:#ae81ff>1</span>) / THREAD_COUNT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            int2 coordRB = <span style=color:#66d9ef>new</span> int2(coordRT.x, coordLB.y);
</span></span><span style=display:flex><span>            int2 coordLT = <span style=color:#66d9ef>new</span> int2(coordLB.x, coordRT.y);
</span></span><span style=display:flex><span>            int2 offsetRB = <span style=color:#66d9ef>new</span> int2(offsetRT.x, offsetLB.y);
</span></span><span style=display:flex><span>            int2 offsetLT = <span style=color:#66d9ef>new</span> int2(offsetLB.x, offsetRT.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            GetDispatchParams(coordLB, offsetLB, <span style=color:#66d9ef>out</span> DispatchParams dpLB1, <span style=color:#66d9ef>out</span> DispatchParams dpLB2);
</span></span><span style=display:flex><span>            GetDispatchParams(coordLT, offsetLT, <span style=color:#66d9ef>out</span> DispatchParams dpLT1, <span style=color:#66d9ef>out</span> DispatchParams dpLT2);
</span></span><span style=display:flex><span>            GetDispatchParams(coordRB, offsetRB, <span style=color:#66d9ef>out</span> DispatchParams dpRB1, <span style=color:#66d9ef>out</span> DispatchParams dpRB2);
</span></span><span style=display:flex><span>            GetDispatchParams(coordRT, offsetRT, <span style=color:#66d9ef>out</span> DispatchParams dpRT1, <span style=color:#66d9ef>out</span> DispatchParams dpRT2);
</span></span><span style=display:flex><span>            dispatchList = <span style=color:#66d9ef>new</span> DispatchParams[] { dpLB1, dpLB2, dpLT1, dpLT2, dpRB1, dpRB2, dpRT1, dpRT2 };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> SetDispatchData(DispatchParams[] dispatchList)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (dispatchList.Length != <span style=color:#ae81ff>8</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> totalCount = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>8</span>; ++i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> param = dispatchList[i];
</span></span><span style=display:flex><span>                totalCount += param.count;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>0</span>] = param.offset.x;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>1</span>] = param.offset.y;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>2</span>] = totalCount;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>3</span>] = param.stride;
</span></span><span style=display:flex><span>                dispatchData[<span style=color:#ae81ff>5</span> * i + <span style=color:#ae81ff>4</span>] = param.xMajor;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            computeBuffer.SetData(dispatchData);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> totalCount;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(ScriptableRenderContext context, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            CommandBuffer cmd = renderingData.commandBuffer;
</span></span><span style=display:flex><span>            UniversalRenderer universalRenderer = renderer <span style=color:#66d9ef>as</span> UniversalRenderer;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (universalRenderer == <span style=color:#66d9ef>null</span> || computeShader == <span style=color:#66d9ef>null</span> || lightSource == <span style=color:#66d9ef>null</span> || lightSource.type != LightType.Point) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>new</span> ProfilingScope(cmd, profilingSampler))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                float4 lightPosWS = <span style=color:#66d9ef>new</span> float4(lightSource.transform.position, <span style=color:#ae81ff>1.0f</span>);
</span></span><span style=display:flex><span>                float4x4 viewMat = renderingData.cameraData.GetViewMatrix();
</span></span><span style=display:flex><span>                float4x4 projMat = renderingData.cameraData.GetGPUProjectionMatrix();
</span></span><span style=display:flex><span>                float4x4 vpMat = math.mul(projMat, viewMat);
</span></span><span style=display:flex><span>                float4 lightPosCS = math.mul(vpMat, lightPosWS);
</span></span><span style=display:flex><span>                float3 lightPosNDC = lightPosCS.xyz / lightPosCS.w;
</span></span><span style=display:flex><span>                lightPosNDC.y = -lightPosNDC.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                float2 lightPosSS = (lightPosNDC.xy * <span style=color:#ae81ff>0.5f</span> + <span style=color:#ae81ff>0.5f</span>) * <span style=color:#66d9ef>new</span> float2(textureSize.x, textureSize.y);
</span></span><span style=display:flex><span>                int2 iLightPosSS = <span style=color:#66d9ef>new</span> int2(math.floor(lightPosSS + <span style=color:#ae81ff>0.5f</span>));
</span></span><span style=display:flex><span>                int2 ts = <span style=color:#66d9ef>new</span> int2(textureSize.x, textureSize.y);
</span></span><span style=display:flex><span>                GetDispatchList(iLightPosSS, ts, <span style=color:#66d9ef>out</span> DispatchParams[] dispatchList);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> totalDispatchCount = SetDispatchData(dispatchList);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> backBuffer = universalRenderer.m_ColorBufferSystem.GetBackBuffer(cmd);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// int clearID = computeShader.FindKernel(&#34;ClearMain&#34;);</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// cmd.SetComputeTextureParam(computeShader, clearID, &#34;_RW_TargetTex&#34;, contactShadowTextureHandle);</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// computeShader.GetKernelThreadGroupSizes(clearID, out uint x1, out uint y1, out uint z1);</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// cmd.DispatchCompute(computeShader, clearID,</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//                     Mathf.CeilToInt((float)textureSize.x / x1),</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//                     Mathf.CeilToInt((float)textureSize.y / y1),</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//                     1);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> kernelID = computeShader.FindKernel(<span style=color:#e6db74>&#34;ContactShadowPoint&#34;</span>);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_ColorTex&#34;</span>, backBuffer);
</span></span><span style=display:flex><span>                cmd.SetComputeTextureParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_RW_TargetTex&#34;</span>, contactShadowTextureHandle);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_LightPosWS&#34;</span>, lightPosWS);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_LightPosCS&#34;</span>, lightPosCS);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_LightPosSS&#34;</span>, <span style=color:#66d9ef>new</span> float4(lightPosSS, <span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>0.0f</span>));
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_ThicknessParams&#34;</span>, contactShadow.thicknessParams.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>                cmd.SetComputeVectorParam(computeShader, <span style=color:#e6db74>&#34;_TextureSize&#34;</span>, GetTextureSizeParameter(textureSize));
</span></span><span style=display:flex><span>                cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_LightRange&#34;</span>, lightSource.range);
</span></span><span style=display:flex><span>                cmd.SetComputeFloatParam(computeShader, <span style=color:#e6db74>&#34;_Debug&#34;</span>, contactShadow.debug.<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>                cmd.SetComputeBufferParam(computeShader, kernelID, <span style=color:#e6db74>&#34;_DispatchData&#34;</span>, computeBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                computeShader.GetKernelThreadGroupSizes(kernelID, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> x, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> y, <span style=color:#66d9ef>out</span> <span style=color:#66d9ef>uint</span> z);
</span></span><span style=display:flex><span>                cmd.DispatchCompute(computeShader, kernelID,
</span></span><span style=display:flex><span>                                     Mathf.CeilToInt((<span style=color:#66d9ef>float</span>)totalDispatchCount / x),
</span></span><span style=display:flex><span>                                     <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                                     <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                cmd.Blit(contactShadowTextureHandle, backBuffer);
</span></span><span style=display:flex><span>            }         
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            contactShadowTextureHandle?.Release();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (computeBuffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                computeBuffer.Release();
</span></span><span style=display:flex><span>                computeBuffer = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=contactshadowrendererfeaturecs>ContactShadowRendererFeature.cs<a hidden class=anchor aria-hidden=true href=#contactshadowrendererfeaturecs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ContactShadowRendererFeature</span> : ScriptableRendererFeature
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [Serializable]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ContactShadowSettings</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> ComputeShader computeShader;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> RenderPassEvent renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ContactShadowSettings settings = <span style=color:#66d9ef>new</span> ContactShadowSettings();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ContactShadowRenderPass contactShadowRenderPass;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Create()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            contactShadowRenderPass = <span style=color:#66d9ef>new</span> ContactShadowRenderPass(settings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> AddRenderPasses(ScriptableRenderer renderer, <span style=color:#66d9ef>ref</span> RenderingData renderingData)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            ContactShadow cs = VolumeManager.instance.stack.GetComponent&lt;ContactShadow&gt;();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cs.IsActive())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                contactShadowRenderPass.Setup(renderer, cs);
</span></span><span style=display:flex><span>                renderer.EnqueuePass(contactShadowRenderPass);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> disposing)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            contactShadowRenderPass?.Dispose();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>base</span>.Dispose(disposing);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=contactshadowcs>ContactShadow.cs<a hidden class=anchor aria-hidden=true href=#contactshadowcs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UnityEngine.Rendering.Universal
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Serializable, VolumeComponentMenuForRenderPipeline(&#34;Post-processing/Contact Shadow&#34;, typeof(UniversalRenderPipeline))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ContactShadow</span> : VolumeComponent, IPostProcessComponent
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BoolParameter isEnabled = <span style=color:#66d9ef>new</span> BoolParameter(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Vector2Parameter thicknessParams = <span style=color:#66d9ef>new</span> Vector2Parameter(<span style=color:#66d9ef>new</span> Vector2(<span style=color:#ae81ff>0.1f</span>, <span style=color:#ae81ff>0.02f</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> FloatParameter debug = <span style=color:#66d9ef>new</span> FloatParameter(<span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsActive()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> isEnabled.<span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsTileCompatible() =&gt; <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=screenspacecontactshadowlightsourcecs>ScreenSpaceContactShadowLightSource.cs<a hidden class=anchor aria-hidden=true href=#screenspacecontactshadowlightsourcecs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[ExecuteAlways]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[RequireComponent(typeof(Light))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ScreenSpaceContactShadowLightSource</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ScreenSpaceContactShadowLightSource Instance { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Instance = <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>            UnityEngine.Rendering.Universal.ContactShadowRenderPass.lightSource = GetComponent&lt;Light&gt;();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.LogError(<span style=color:#e6db74>&#34;Only one instance of ScreenSpaceContactShadowLightSource is allowed to exist at the same time.&#34;</span>);
</span></span><span style=display:flex><span>            enabled = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDisable()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance == <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Instance = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Instance == <span style=color:#66d9ef>this</span> )
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Instance = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>摸了两周，但也没摸，但是确实有点没有动力了。Radial Dispatch系列估计到这里就告一段落了，这个屏幕空间接触阴影没有我之前想象中的效果那么好，之后会在草场、云、海洋、Radiance Cascade GI中间选一个来做吧，不过估计要很久了。本来封面是想放一个点光源在视差映射贴图上的接触阴影和平行光在远处山上森林的接触阴影的，不过有点懒得整了。2024虽然糟透了，但也还有一丝丝的好消息吧。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zznewclear13.github.io/tags/contact-shadow/>Contact Shadow</a></li><li><a href=https://zznewclear13.github.io/tags/screen-space/>Screen Space</a></li><li><a href=https://zznewclear13.github.io/tags/compute-shader/>Compute Shader</a></li></ul><nav class=paginav><a class=next href=https://zznewclear13.github.io/posts/accelerate-radial-blur-using-group-shared-memory/><span class=title>Next »</span><br><span>使用Group Shared Memory加速径向模糊</span></a></nav></footer><div id=comments></div><script>let currentHugoTheme=window.localStorage.getItem("pref-theme");function loadComment(){const t=document.getElementById("comments");let n=currentHugoTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","zznewclear13/zznewclear13.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",n),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),t.innerHTML="",t.appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentHugoTheme&&(currentHugoTheme=e,loadComment())}</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://zznewclear13.github.io/>ZZNEWCLEAR13</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>